var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Final_project_template","ref":false,"files":[{"name":"Final_project_template.c","type":"source","group":"model","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Final_project_template.c\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Final_project_template.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Final_project_template_private.h\"\r\n#include <string.h>\r\n#include <math.h>\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Named constants for Chart: '<S29>/Chart' */\r\n#define IN_Manual                      ((uint8_T)1U)\r\n#define IN_PosCtrl                     ((uint8_T)2U)\r\n#define IN_VelCtrl                     ((uint8_T)3U)\r\n\r\n/* Block signals (default storage) */\r\nB rtB;\r\n\r\n/* Block states (default storage) */\r\nDW rtDW;\r\n\r\n/* Previous zero-crossings (trigger) states */\r\nPrevZCX rtPrevZCX;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nstatic void rate_monotonic_scheduler(void);\r\nflexcan_state_t canCom0_State;\r\nflexcan_msgbuff_t canCom0_recvBuff16;\r\nflexcan_msgbuff_t canCom0_recvBuff17;\r\nflexcan_msgbuff_t canCom0_recvBuff12;\r\nflexcan_msgbuff_t canCom0_recvBuff13;\r\nflexcan_msgbuff_t canCom0_recvBuff2;\r\nflexcan_msgbuff_t canCom0_recvBuff3;\r\nflexcan_msgbuff_t canCom0_recvBuff14;\r\nflexcan_msgbuff_t canCom0_recvBuff15;\r\nflexcan_msgbuff_t canCom0_recvBuff4;\r\nflexcan_msgbuff_t canCom0_recvBuff5;\r\nflexcan_msgbuff_t canCom0_recvBuff6;\r\nflexcan_msgbuff_t canCom0_recvBuff7;\r\nflexcan_msgbuff_t canCom0_recvBuff8;\r\nflexcan_msgbuff_t canCom0_recvBuff9;\r\nflexcan_msgbuff_t canCom0_recvBuff10;\r\nflexcan_msgbuff_t canCom0_recvBuff11;\r\n\r\n/*\r\n * Set which subrates need to run this base step (base rate always runs).\r\n * This function must be called prior to calling the model step function\r\n * in order to remember which rates need to run this base step.  The\r\n * buffering of events allows for overlapping preemption.\r\n */\r\nvoid Final_project_template_SetEventsForThisBaseStep(boolean_T *eventFlags)\r\n{\r\n  /* Task runs when its counter is zero, computed via rtmStepTask macro */\r\n  eventFlags[1] = ((boolean_T)rtmStepTask(rtM, 1));\r\n  eventFlags[2] = ((boolean_T)rtmStepTask(rtM, 2));\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate\r\n *         and rate transition flags for tasks that exchange data.\r\n *         The function assumes rate-monotonic multitasking scheduler.\r\n *         The function must be called at model base rate so that\r\n *         the generated code self-manages all its subrates and rate\r\n *         transition flags.\r\n */\r\nstatic void rate_monotonic_scheduler(void)\r\n{\r\n  /* To ensure a deterministic data transfer between two rates,\r\n   * data is transferred at the priority of a fast task and the frequency\r\n   * of the slow task.  The following flags indicate when the data transfer\r\n   * happens.  That is, a rate interaction flag is set true when both rates\r\n   * will run, and false otherwise.\r\n   */\r\n\r\n  /* tid 0 shares data with slower tid rate: 2 */\r\n  rtM->Timing.RateInteraction.TID0_2 = (rtM->Timing.TaskCounters.TID[2] == 0);\r\n\r\n  /* tid 1 shares data with slower tid rate: 2 */\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    rtM->Timing.RateInteraction.TID1_2 = (rtM->Timing.TaskCounters.TID[2] == 0);\r\n  }\r\n\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (rtM->Timing.TaskCounters.TID[1])++;\r\n  if ((rtM->Timing.TaskCounters.TID[1]) > 19) {/* Sample time: [0.01s, 0.0s] */\r\n    rtM->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n\r\n  (rtM->Timing.TaskCounters.TID[2])++;\r\n  if ((rtM->Timing.TaskCounters.TID[2]) > 99) {/* Sample time: [0.05s, 0.0s] */\r\n    rtM->Timing.TaskCounters.TID[2] = 0;\r\n  }\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S7>/Switch Case Action Subsystem2'\r\n *    '<S8>/Switch Case Action Subsystem2'\r\n *    '<S9>/Switch Case Action Subsystem2'\r\n *    '<S10>/Switch Case Action Subsystem2'\r\n *    '<S11>/Switch Case Action Subsystem2'\r\n *    '<S12>/Switch Case Action Subsystem2'\r\n */\r\nvoid SwitchCaseActionSubsystem2(const uint8_T rtu_sn[8], real32_T *rty_s,\r\n  real32_T *rty_n)\r\n{\r\n  /* S-Function (slrealtimebytepacking): '<S13>/Byte Unpacking ' */\r\n\r\n  /* Byte Unpacking: <S13>/Byte Unpacking  */\r\n  (void)memcpy((uint8_T*)rty_s, (uint8_T*)&rtu_sn[0] + 0, 4);\r\n  (void)memcpy((uint8_T*)rty_n, (uint8_T*)&rtu_sn[0] + 4, 4);\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S7>/Switch Case Action Subsystem3'\r\n *    '<S8>/Switch Case Action Subsystem3'\r\n *    '<S9>/Switch Case Action Subsystem3'\r\n *    '<S10>/Switch Case Action Subsystem3'\r\n *    '<S11>/Switch Case Action Subsystem3'\r\n *    '<S12>/Switch Case Action Subsystem3'\r\n */\r\nvoid SwitchCaseActionSubsystem3(const uint8_T rtu_psius[8], real32_T *rty_psi,\r\n  real32_T *rty_us)\r\n{\r\n  /* S-Function (slrealtimebytepacking): '<S14>/Byte Unpacking ' */\r\n\r\n  /* Byte Unpacking: <S14>/Byte Unpacking  */\r\n  (void)memcpy((uint8_T*)rty_psi, (uint8_T*)&rtu_psius[0] + 0, 4);\r\n  (void)memcpy((uint8_T*)rty_us, (uint8_T*)&rtu_psius[0] + 4, 4);\r\n}\r\n\r\n/* Model step function for TID0 */\r\nvoid Final_project_template_step0(void) /* Sample time: [0.0005s, 0.0s] */\r\n{\r\n  {                                    /* Sample time: [0.0005s, 0.0s] */\r\n    rate_monotonic_scheduler();\r\n  }\r\n\r\n  /* RateTransition: '<S4>/RT' */\r\n  if (rtM->Timing.RateInteraction.TID0_2) {\r\n    /* RateTransition: '<S4>/RT' */\r\n    rtB.RT_k = rtDW.RT_Buffer0;\r\n\r\n    /* RateTransition: '<S4>/RT1' */\r\n    memcpy(&rtB.RT1[0], &rtDW.RT1_Buffer0[0], 90U * sizeof(uint8_T));\r\n  }\r\n\r\n  /* End of RateTransition: '<S4>/RT' */\r\n\r\n  /* S-Function (fcgen): '<S4>/Function-Call Generator2' incorporates:\r\n   *  SubSystem: '<S4>/UART Iteration'\r\n   */\r\n  /* Outputs for Resettable SubSystem: '<S73>/Resettable Subsystem' incorporates:\r\n   *  ResetPort: '<S74>/Reset'\r\n   */\r\n  if (((rtPrevZCX.ResettableSubsystem_Reset_ZCE == POS_ZCSIG) != (int32_T)\r\n       rtB.RT_k) && (rtPrevZCX.ResettableSubsystem_Reset_ZCE !=\r\n                     UNINITIALIZED_ZCSIG)) {\r\n    /* InitializeConditions for Delay: '<S74>/Delay' */\r\n    rtDW.Delay_DSTATE = 0.0;\r\n  }\r\n\r\n  rtPrevZCX.ResettableSubsystem_Reset_ZCE = rtB.RT_k;\r\n\r\n  /* Sum: '<S74>/Sum' incorporates:\r\n   *  Constant: '<S74>/Constant'\r\n   *  Delay: '<S74>/Delay'\r\n   */\r\n  rtDW.Delay_DSTATE++;\r\n\r\n  /* End of Outputs for SubSystem: '<S73>/Resettable Subsystem' */\r\n\r\n  /* MultiPortSwitch: '<S73>/Index Vector' incorporates:\r\n   *  Delay: '<S74>/Delay'\r\n   */\r\n  rtB.IndexVector = rtB.RT1[(int32_T)rtDW.Delay_DSTATE - 1];\r\n\r\n  /* S-Function (lpuart_s32k_transmit): '<S73>/LPUART_Transmit' */\r\n  {\r\n    LPUART_DRV_SendData(1, &rtB.IndexVector, 1);\r\n  }\r\n\r\n  /* End of Outputs for S-Function (fcgen): '<S4>/Function-Call Generator2' */\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive' */\r\n  FLEXCAN_DRV_Receive(0, 16, &canCom0_recvBuff16);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive1' */\r\n  FLEXCAN_DRV_Receive(0, 17, &canCom0_recvBuff17);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive10' */\r\n  FLEXCAN_DRV_Receive(0, 12, &canCom0_recvBuff12);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive11' */\r\n  FLEXCAN_DRV_Receive(0, 13, &canCom0_recvBuff13);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive12' */\r\n  FLEXCAN_DRV_Receive(0, 2, &canCom0_recvBuff2);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive13' */\r\n  FLEXCAN_DRV_Receive(0, 3, &canCom0_recvBuff3);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive14' */\r\n  FLEXCAN_DRV_Receive(0, 14, &canCom0_recvBuff14);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive15' */\r\n  FLEXCAN_DRV_Receive(0, 15, &canCom0_recvBuff15);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive2' */\r\n  FLEXCAN_DRV_Receive(0, 4, &canCom0_recvBuff4);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive3' */\r\n  FLEXCAN_DRV_Receive(0, 5, &canCom0_recvBuff5);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive4' */\r\n  FLEXCAN_DRV_Receive(0, 6, &canCom0_recvBuff6);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive5' */\r\n  FLEXCAN_DRV_Receive(0, 7, &canCom0_recvBuff7);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive6' */\r\n  FLEXCAN_DRV_Receive(0, 8, &canCom0_recvBuff8);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive7' */\r\n  FLEXCAN_DRV_Receive(0, 9, &canCom0_recvBuff9);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive8' */\r\n  FLEXCAN_DRV_Receive(0, 10, &canCom0_recvBuff10);\r\n\r\n  /* S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive9' */\r\n  FLEXCAN_DRV_Receive(0, 11, &canCom0_recvBuff11);\r\n\r\n  /* S-Function (ftm_s32k_pwm_config): '<S3>/FTM_PWM_Config' incorporates:\r\n   *  Constant: '<S3>/Constant'\r\n   *  Constant: '<S3>/Constant1'\r\n   */\r\n  {\r\n    uint16_t dutyA = FTM_MAX_DUTY_CYCLE * 0.5F;\r\n    FTM_DRV_UpdatePwmChannel(FTM_PWM3, 0U, FTM_PWM_UPDATE_IN_DUTY_CYCLE, dutyA,\r\n      0, true);\r\n  }\r\n}\r\n\r\n/* Model step function for TID1 */\r\nvoid Final_project_template_step1(void) /* Sample time: [0.01s, 0.0s] */\r\n{\r\n  /* local block i/o variables */\r\n  real_T rtb_DataTypeConversion;\r\n  real_T rtb_dsdt;\r\n  real32_T rtb_Conversion;\r\n  real32_T rtb_Gain_ie;\r\n  real32_T rtb_Sum1_e;\r\n  uint32_T HighLevelDesign_ELAPS_T;\r\n\r\n  /* End of Outputs for S-Function (fcan_s32k_isr): '<S1>/FCAN_Isr' */\r\n\r\n  /* S-Function (fcgen): '<Root>/Function-Call Top' incorporates:\r\n   *  SubSystem: '<Root>/High Level Design'\r\n   */\r\n  if (rtDW.HighLevelDesign_RESET_ELAPS_T) {\r\n    HighLevelDesign_ELAPS_T = 0U;\r\n  } else {\r\n    HighLevelDesign_ELAPS_T = rtM->Timing.clockTick1 -\r\n      rtDW.HighLevelDesign_PREV_T;\r\n  }\r\n\r\n  rtDW.HighLevelDesign_PREV_T = rtM->Timing.clockTick1;\r\n  rtDW.HighLevelDesign_RESET_ELAPS_T = false;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S26>/Digital_Input' */\r\n\r\n  /* GPIPORTE14 signal update */\r\n  rtB.Digital_Input = (PINS_DRV_ReadPins(PTE) >> 14) & 0x01;\r\n\r\n  /* SignalConversion generated from: '<S2>/s,n,psi,us (Cars 1-6)' */\r\n  rtB.snpsiusCars16[0] = rtB.ByteUnpacking_o1_m;\r\n  rtB.snpsiusCars16[1] = rtB.ByteUnpacking_o2_k;\r\n  rtB.snpsiusCars16[2] = rtB.ByteUnpacking_o1_b;\r\n  rtB.snpsiusCars16[3] = rtB.ByteUnpacking_o2_nz;\r\n  rtB.snpsiusCars16[4] = rtB.ByteUnpacking_o1_o3;\r\n  rtB.snpsiusCars16[5] = rtB.ByteUnpacking_o2_h;\r\n  rtB.snpsiusCars16[6] = rtB.ByteUnpacking_o1_az;\r\n  rtB.snpsiusCars16[7] = rtB.ByteUnpacking_o2_b;\r\n  rtB.snpsiusCars16[8] = rtB.ByteUnpacking_o1_i;\r\n  rtB.snpsiusCars16[9] = rtB.ByteUnpacking_o2_i;\r\n  rtB.snpsiusCars16[10] = rtB.ByteUnpacking_o1_a;\r\n  rtB.snpsiusCars16[11] = rtB.ByteUnpacking_o2_j1;\r\n  rtB.snpsiusCars16[12] = rtB.ByteUnpacking_o1_o0;\r\n  rtB.snpsiusCars16[13] = rtB.ByteUnpacking_o2_p;\r\n  rtB.snpsiusCars16[14] = rtB.ByteUnpacking_o1_c;\r\n  rtB.snpsiusCars16[15] = rtB.ByteUnpacking_o2_c;\r\n  rtB.snpsiusCars16[16] = rtB.ByteUnpacking_o1_o;\r\n  rtB.snpsiusCars16[17] = rtB.ByteUnpacking_o2_j;\r\n  rtB.snpsiusCars16[18] = rtB.ByteUnpacking_o1_f4;\r\n  rtB.snpsiusCars16[19] = rtB.ByteUnpacking_o2_m;\r\n  rtB.snpsiusCars16[20] = rtB.ByteUnpacking_o1_f;\r\n  rtB.snpsiusCars16[21] = rtB.ByteUnpacking_o2_n;\r\n  rtB.snpsiusCars16[22] = rtB.ByteUnpacking_o1;\r\n  rtB.snpsiusCars16[23] = rtB.ByteUnpacking_o2;\r\n\r\n  /* SignalConversion generated from: '<S29>/S-Function Builder' incorporates:\r\n   *  UnitDelay: '<S2>/Unit Delay'\r\n   */\r\n  rtB.TmpSignalConversionAtSFunctionB[0] = rtDW.UnitDelay_DSTATE[0];\r\n  rtB.TmpSignalConversionAtSFunctionB[1] = rtDW.UnitDelay_DSTATE[1];\r\n  rtB.TmpSignalConversionAtSFunctionB[2] = rtDW.UnitDelay_DSTATE[2];\r\n  rtB.TmpSignalConversionAtSFunctionB[3] = rtDW.UnitDelay_DSTATE[3];\r\n  memcpy(&rtB.TmpSignalConversionAtSFunctionB[4], &rtB.snpsiusCars16[0], 24U *\r\n         sizeof(real32_T));\r\n\r\n  /* S-Function (ahead_logic): '<S29>/S-Function Builder' */\r\n  ahead_logic_Outputs_wrapper(&rtB.TmpSignalConversionAtSFunctionB[0],\r\n    &rtB.SFunctionBuilder_o1, &rtB.SFunctionBuilder_o2);\r\n\r\n  /* Chart: '<S29>/Chart' incorporates:\r\n   *  UnitDelay: '<S2>/Unit Delay'\r\n   */\r\n  if (rtDW.is_active_c3_Final_project_temp == 0U) {\r\n    rtDW.is_active_c3_Final_project_temp = 1U;\r\n    rtDW.is_c3_Final_project_template = IN_Manual;\r\n  } else {\r\n    switch (rtDW.is_c3_Final_project_template) {\r\n     case IN_Manual:\r\n      rtb_Gain_ie = rtB.SFunctionBuilder_o1 - rtDW.UnitDelay_DSTATE[0];\r\n      if (rtB.Digital_Input && (rtB.SFunctionBuilder_o2 < rtDW.UnitDelay_DSTATE\r\n           [3]) && (rtb_Gain_ie <= 20.0F)) {\r\n        rtDW.is_c3_Final_project_template = IN_PosCtrl;\r\n      } else if (rtB.Digital_Input && ((rtB.SFunctionBuilder_o2 >\r\n                   rtDW.UnitDelay_DSTATE[3]) || (rtb_Gain_ie > 20.0F) ||\r\n                  ((rtB.SFunctionBuilder_o2 == rtDW.UnitDelay_DSTATE[3]) &&\r\n                   (rtB.SFunctionBuilder_o1 == rtDW.UnitDelay_DSTATE[0])))) {\r\n        rtDW.is_c3_Final_project_template = IN_VelCtrl;\r\n      } else {\r\n        rtB.man = true;\r\n        rtB.vel = false;\r\n        rtB.pos = false;\r\n      }\r\n      break;\r\n\r\n     case IN_PosCtrl:\r\n      if (!rtB.Digital_Input) {\r\n        rtDW.is_c3_Final_project_template = IN_Manual;\r\n      } else if (rtB.Digital_Input && ((rtB.SFunctionBuilder_o2 >\r\n                   rtDW.UnitDelay_DSTATE[3]) || (rtB.SFunctionBuilder_o1 -\r\n                   rtDW.UnitDelay_DSTATE[0] > 20.0F) ||\r\n                  ((rtB.SFunctionBuilder_o2 == rtDW.UnitDelay_DSTATE[3]) &&\r\n                   (rtB.SFunctionBuilder_o1 == rtDW.UnitDelay_DSTATE[0])))) {\r\n        rtDW.is_c3_Final_project_template = IN_VelCtrl;\r\n      } else {\r\n        rtB.man = false;\r\n        rtB.vel = false;\r\n        rtB.pos = true;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_VelCtrl: */\r\n      if (!rtB.Digital_Input) {\r\n        rtDW.is_c3_Final_project_template = IN_Manual;\r\n      } else if (rtB.Digital_Input && (rtB.SFunctionBuilder_o2 <\r\n                  rtDW.UnitDelay_DSTATE[3]) && (rtB.SFunctionBuilder_o1 -\r\n                  rtDW.UnitDelay_DSTATE[0] <= 20.0F)) {\r\n        rtDW.is_c3_Final_project_template = IN_PosCtrl;\r\n      } else {\r\n        rtB.man = false;\r\n        rtB.vel = true;\r\n        rtB.pos = false;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S29>/Chart' */\r\n\r\n  /* S-Function (gpio_s32k_output): '<S25>/Digital_Output' */\r\n\r\n  /* GPOPORTD8 Data Signal Update */\r\n  if (rtB.pos) {\r\n    PINS_DRV_SetPins(PTD, 1UL<<8);\r\n  } else {\r\n    PINS_DRV_ClearPins(PTD, 1UL<<8);\r\n  }\r\n\r\n  /* S-Function (gpio_s32k_output): '<S25>/Digital_Output1' */\r\n\r\n  /* GPOPORTD9 Data Signal Update */\r\n  if (rtB.vel) {\r\n    PINS_DRV_SetPins(PTD, 1UL<<9);\r\n  } else {\r\n    PINS_DRV_ClearPins(PTD, 1UL<<9);\r\n  }\r\n\r\n  /* S-Function (gpio_s32k_output): '<S25>/Digital_Output2' */\r\n\r\n  /* GPOPORTD10 Data Signal Update */\r\n  if (rtB.man) {\r\n    PINS_DRV_SetPins(PTD, 1UL<<10);\r\n  } else {\r\n    PINS_DRV_ClearPins(PTD, 1UL<<10);\r\n  }\r\n\r\n  /* S-Function (adc_s32k_start): '<S37>/ADC_Start' */\r\n  {\r\n    adc_chan_config_t adc0_chan_cfg = {\r\n      .interruptEnable = false,\r\n      .channel = ADC_INPUTCHAN_EXT0\r\n    };\r\n\r\n    /* Initialize channel configuration of ADC0. */\r\n    ADC_DRV_ConfigChan(0, 0, &adc0_chan_cfg);\r\n    uint16_t result;\r\n\r\n    /* Get conversion result of ADC0 */\r\n    ADC_DRV_WaitConvDone(0);\r\n    ADC_DRV_GetChanResult(0, 0, &result);\r\n    rtB.ADC_Start = result;\r\n  }\r\n\r\n  /* Outputs for Enabled SubSystem: '<S25>/Enabled Subsystem' incorporates:\r\n   *  EnablePort: '<S30>/Enable'\r\n   */\r\n  if (rtB.man) {\r\n    /* Merge: '<S25>/Merge' incorporates:\r\n     *  Constant: '<S37>/Constant'\r\n     *  Gain: '<S37>/Gain'\r\n     *  SignalConversion generated from: '<S30>/Throttle'\r\n     *  Sum: '<S37>/Sum'\r\n     */\r\n    rtB.Merge = ((real32_T)rtB.ADC_Start - 512.0F) * 0.75F;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S25>/Enabled Subsystem' */\r\n\r\n  /* Outputs for Enabled SubSystem: '<S25>/Position Ctrl' incorporates:\r\n   *  EnablePort: '<S31>/Enable'\r\n   */\r\n  if (rtB.pos) {\r\n    /* Merge: '<S25>/Merge' incorporates:\r\n     *  Constant: '<S25>/Constant'\r\n     *  Gain: '<S31>/D-gain'\r\n     *  Gain: '<S31>/Feed-forward'\r\n     *  Gain: '<S31>/P-gain'\r\n     *  Sum: '<S31>/Sum1'\r\n     *  Sum: '<S31>/Sum2'\r\n     *  Sum: '<S31>/Sum3'\r\n     *  Sum: '<S31>/Sum4'\r\n     *  Sum: '<S31>/Sum5'\r\n     *  UnitDelay: '<S2>/Unit Delay'\r\n     */\r\n    rtB.Merge = ((20.0F - (rtB.SFunctionBuilder_o1 - rtDW.UnitDelay_DSTATE[0])) *\r\n                 -3000.0F + (rtB.SFunctionBuilder_o2 - rtDW.UnitDelay_DSTATE[3])\r\n                 * 4900.0F) + 100.0F * rtB.SFunctionBuilder_o2;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S25>/Position Ctrl' */\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input' */\r\n\r\n  /* GPIPORTE6 signal update */\r\n  rtB.Digital_Input_g = (PINS_DRV_ReadPins(PTE) >> 6) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input1' */\r\n\r\n  /* GPIPORTE7 signal update */\r\n  rtB.Digital_Input1 = (PINS_DRV_ReadPins(PTE) >> 7) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input2' */\r\n\r\n  /* GPIPORTE8 signal update */\r\n  rtB.Digital_Input2 = (PINS_DRV_ReadPins(PTE) >> 8) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input3' */\r\n\r\n  /* GPIPORTE9 signal update */\r\n  rtB.Digital_Input3 = (PINS_DRV_ReadPins(PTE) >> 9) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input4' */\r\n\r\n  /* GPIPORTE10 signal update */\r\n  rtB.Digital_Input4 = (PINS_DRV_ReadPins(PTE) >> 10) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input5' */\r\n\r\n  /* GPIPORTE11 signal update */\r\n  rtB.Digital_Input5 = (PINS_DRV_ReadPins(PTE) >> 11) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input6' */\r\n\r\n  /* GPIPORTE12 signal update */\r\n  rtB.Digital_Input6 = (PINS_DRV_ReadPins(PTE) >> 12) & 0x01;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S36>/Digital_Input7' */\r\n\r\n  /* GPIPORTE13 signal update */\r\n  rtB.Digital_Input7 = (PINS_DRV_ReadPins(PTE) >> 13) & 0x01;\r\n\r\n  /* Gain: '<S36>/Gain' incorporates:\r\n   *  ArithShift: '<S36>/Shift Arithmetic1'\r\n   *  ArithShift: '<S36>/Shift Arithmetic2'\r\n   *  ArithShift: '<S36>/Shift Arithmetic3'\r\n   *  ArithShift: '<S36>/Shift Arithmetic4'\r\n   *  ArithShift: '<S36>/Shift Arithmetic5'\r\n   *  ArithShift: '<S36>/Shift Arithmetic6'\r\n   *  ArithShift: '<S36>/Shift Arithmetic7'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion1'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion2'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion3'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion4'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion5'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion6'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion7'\r\n   *  DataTypeConversion: '<S36>/Data Type Conversion8'\r\n   *  Sum: '<S36>/Add'\r\n   */\r\n  rtb_Gain_ie = (real32_T)((int32_T)(((((((uint32_T)(rtB.Digital_Input1 << 1) +\r\n    rtB.Digital_Input_g) + (uint32_T)(rtB.Digital_Input2 << 2)) + (uint32_T)\r\n    (rtB.Digital_Input3 << 3)) + (uint32_T)(rtB.Digital_Input4 << 4)) +\r\n    (uint32_T)(rtB.Digital_Input5 << 5)) + (uint32_T)(rtB.Digital_Input6 << 6))\r\n    + (rtB.Digital_Input7 << 7)) * 0.25F;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S25>/Speed Ctrl' incorporates:\r\n   *  EnablePort: '<S32>/Enable'\r\n   */\r\n  if (rtB.vel) {\r\n    /* Sum: '<S32>/Sum1' incorporates:\r\n     *  UnitDelay: '<S2>/Unit Delay'\r\n     */\r\n    rtb_Sum1_e = rtb_Gain_ie - rtDW.UnitDelay_DSTATE[3];\r\n\r\n    /* Merge: '<S25>/Merge' incorporates:\r\n     *  Gain: '<S32>/Gain'\r\n     *  Gain: '<S34>/Gain1'\r\n     *  Sum: '<S32>/Sum'\r\n     *  Sum: '<S34>/Sum'\r\n     *  UnitDelay: '<S35>/Unit Delay'\r\n     */\r\n    rtB.Merge = (5000.0F * rtb_Sum1_e + rtDW.UnitDelay_DSTATE_o) + 100.0F *\r\n      rtb_Gain_ie;\r\n\r\n    /* Sum: '<S35>/Sum' incorporates:\r\n     *  Gain: '<S34>/Gain'\r\n     *  Gain: '<S35>/Gain'\r\n     *  UnitDelay: '<S35>/Unit Delay'\r\n     */\r\n    rtDW.UnitDelay_DSTATE_o += 50.0F * rtb_Sum1_e * 0.01F;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S25>/Speed Ctrl' */\r\n\r\n  /* S-Function (ftm_s32k_quadrature_decoder): '<S38>/Quadrature_Decoder' */\r\n\r\n  /* FTM2: get counter value */\r\n  rtB.Quadrature_Decoder_o2 = FTM_DRV_GetQuadDir(FTM2);\r\n  rtB.Quadrature_Decoder_o4 = FTM_DRV_GetQuadTimerOverflowDir(FTM2);\r\n  rtB.Quadrature_Decoder_o3 = FTM_DRV_HasTimerOverflowed(FTM2);\r\n  rtB.Quadrature_Decoder_o1 = FTM_DRV_GetCounter(FTM2);\r\n  FTM_DRV_ClearTimerOverflow(FTM2);\r\n\r\n  /* Sum: '<S39>/Sum1' incorporates:\r\n   *  DataTypeConversion: '<S39>/Data Type Conversion1'\r\n   *  DataTypeConversion: '<S39>/Data Type Conversion2'\r\n   *  Gain: '<S39>/Gain'\r\n   *  Sum: '<S39>/Sum'\r\n   *  UnitDelay: '<S39>/Unit Delay'\r\n   *  UnitDelay: '<S39>/Unit Delay1'\r\n   */\r\n  rtDW.UnitDelay1_DSTATE += (real32_T)(int16_T)(rtB.Quadrature_Decoder_o1 -\r\n    rtDW.UnitDelay_DSTATE_c) * 0.09F;\r\n\r\n  /* Gain: '<S26>/Gain' incorporates:\r\n   *  Gain: '<S38>/Gain'\r\n   *  UnitDelay: '<S39>/Unit Delay1'\r\n   */\r\n  rtB.Gain = 0.0174532924F * rtDW.UnitDelay1_DSTATE * -0.2F;\r\n\r\n  /* S-Function (gpio_s32k_input): '<S26>/Digital_Input1' */\r\n\r\n  /* GPIPORTE15 signal update */\r\n  rtB.Digital_Input1_b = (PINS_DRV_ReadPins(PTE) >> 15) & 0x01;\r\n\r\n  /* Outputs for Atomic SubSystem: '<S28>/Vehicle Dynamics' */\r\n  /* DiscreteIntegrator: '<S60>/Discrete-Time Integrator' */\r\n  if (rtDW.DiscreteTimeIntegrator_SYSTEM_E != 0) {\r\n    /* DiscreteIntegrator: '<S60>/Discrete-Time Integrator' */\r\n    rtB.DiscreteTimeIntegrator = rtDW.DiscreteTimeIntegrator_DSTATE;\r\n  } else {\r\n    /* DiscreteIntegrator: '<S60>/Discrete-Time Integrator' */\r\n    rtB.DiscreteTimeIntegrator = 0.01F * (real32_T)HighLevelDesign_ELAPS_T\r\n      * rtDW.DiscreteTimeIntegrator_PREV_U + rtDW.DiscreteTimeIntegrator_DSTATE;\r\n  }\r\n\r\n  /* End of DiscreteIntegrator: '<S60>/Discrete-Time Integrator' */\r\n\r\n  /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator2' */\r\n  if (rtDW.DiscreteTimeIntegrator2_SYSTEM_ != 0) {\r\n    /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator2' */\r\n    rtB.DiscreteTimeIntegrator2 = rtDW.DiscreteTimeIntegrator2_DSTATE;\r\n  } else {\r\n    /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator2' */\r\n    rtB.DiscreteTimeIntegrator2 = 0.01F * (real32_T)HighLevelDesign_ELAPS_T\r\n      * rtDW.DiscreteTimeIntegrator2_PREV_U +\r\n      rtDW.DiscreteTimeIntegrator2_DSTATE;\r\n  }\r\n\r\n  /* End of DiscreteIntegrator: '<S62>/Discrete-Time Integrator2' */\r\n\r\n  /* S-Function (model): '<S61>/S-Function Builder' */\r\n  model_Outputs_wrapper(&rtB.DiscreteTimeIntegrator, &rtB.Gain,\r\n                        &rtB.DiscreteTimeIntegrator2, &rtB.SFunctionBuilder_o1_b,\r\n                        &rtB.SFunctionBuilder_o2_i, &rtB.SFunctionBuilder_o3,\r\n                        &rtConstP.pooled6, 1, &rtConstP.pooled6, 1);\r\n\r\n  /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator' */\r\n  if (rtDW.DiscreteTimeIntegrator_SYSTEM_b == 0) {\r\n    /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator' */\r\n    rtDW.DiscreteTimeIntegrator_DSTATE_k += 0.01F * (real32_T)\r\n      HighLevelDesign_ELAPS_T * rtDW.DiscreteTimeIntegrator_PREV_U_d;\r\n  }\r\n\r\n  /* End of DiscreteIntegrator: '<S62>/Discrete-Time Integrator' */\r\n\r\n  /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator1' */\r\n  if (rtDW.DiscreteTimeIntegrator1_SYSTEM_ == 0) {\r\n    /* DiscreteIntegrator: '<S62>/Discrete-Time Integrator1' */\r\n    rtDW.DiscreteTimeIntegrator1_DSTATE += 0.01F * (real32_T)\r\n      HighLevelDesign_ELAPS_T * rtDW.DiscreteTimeIntegrator1_PREV_U;\r\n  }\r\n\r\n  /* End of DiscreteIntegrator: '<S62>/Discrete-Time Integrator1' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S60>/Discrete-Time Integrator' incorporates:\r\n   *  Gain: '<S60>/Gain'\r\n   *  Gain: '<S60>/Gain1'\r\n   *  Sum: '<S60>/Sum'\r\n   */\r\n  rtDW.DiscreteTimeIntegrator_SYSTEM_E = 0U;\r\n  rtDW.DiscreteTimeIntegrator_DSTATE = rtB.DiscreteTimeIntegrator;\r\n  rtDW.DiscreteTimeIntegrator_PREV_U = (rtB.Merge - 100.0F *\r\n    rtB.DiscreteTimeIntegrator) * 0.0005F;\r\n\r\n  /* Update for DiscreteIntegrator: '<S62>/Discrete-Time Integrator2' */\r\n  rtDW.DiscreteTimeIntegrator2_SYSTEM_ = 0U;\r\n  rtDW.DiscreteTimeIntegrator2_DSTATE = rtB.DiscreteTimeIntegrator2;\r\n  rtDW.DiscreteTimeIntegrator2_PREV_U = rtB.SFunctionBuilder_o3;\r\n\r\n  /* Update for DiscreteIntegrator: '<S62>/Discrete-Time Integrator' */\r\n  rtDW.DiscreteTimeIntegrator_SYSTEM_b = 0U;\r\n  rtDW.DiscreteTimeIntegrator_PREV_U_d = rtB.SFunctionBuilder_o1_b;\r\n\r\n  /* Update for DiscreteIntegrator: '<S62>/Discrete-Time Integrator1' */\r\n  rtDW.DiscreteTimeIntegrator1_SYSTEM_ = 0U;\r\n  rtDW.DiscreteTimeIntegrator1_PREV_U = rtB.SFunctionBuilder_o2_i;\r\n\r\n  /* End of Outputs for SubSystem: '<S28>/Vehicle Dynamics' */\r\n\r\n  /* UnitDelay: '<S69>/Unit Delay' */\r\n  rtB.UnitDelay = rtDW.UnitDelay_DSTATE_i;\r\n\r\n  /* S-Function (get_path1): '<S66>/Look up P' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.UnitDelay), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP_o1 = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP_o2 = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP_o1 = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP_o2 = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Sum: '<S66>/Sum' */\r\n  rtb_Gain_ie = rtDW.DiscreteTimeIntegrator_DSTATE_k - rtB.LookupP_o1;\r\n  rtb_Sum1_e = rtDW.DiscreteTimeIntegrator1_DSTATE - rtB.LookupP_o2;\r\n\r\n  /* S-Function (get_rvec1): '<S66>/Look up Right Vector' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.UnitDelay), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector_o1 = fy;\r\n        rtB.LookupRightVector_o2 = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector_o1 = cos(r);\r\n        rtB.LookupRightVector_o2 = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Sum: '<S71>/Sum1' incorporates:\r\n   *  Product: '<S71>/Product'\r\n   */\r\n  rtB.Sum1 = rtb_Gain_ie * rtB.LookupRightVector_o1 + rtb_Sum1_e *\r\n    rtB.LookupRightVector_o2;\r\n\r\n  /* S-Function (get_rvec1): '<S44>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.UnitDelay), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1 = fy;\r\n        rtB.LookupRightVector1_o2 = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1 = cos(r);\r\n        rtB.LookupRightVector1_o2 = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S44>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.UnitDelay), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1 = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2 = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1 = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2 = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S51>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[0]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1_j = fy;\r\n        rtB.LookupRightVector1_o2_m = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1_j = cos(r);\r\n        rtB.LookupRightVector1_o2_m = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S51>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[0]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1_j = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2_m = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1_j = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2_m = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S52>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[4]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1_i = fy;\r\n        rtB.LookupRightVector1_o2_d = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1_i = cos(r);\r\n        rtB.LookupRightVector1_o2_d = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S52>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[4]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1_f = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2_p = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1_f = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2_p = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S53>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[8]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1_a = fy;\r\n        rtB.LookupRightVector1_o2_j = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1_a = cos(r);\r\n        rtB.LookupRightVector1_o2_j = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S53>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[8]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1_jz = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2_pi = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1_jz = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2_pi = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S54>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[12]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1_c = fy;\r\n        rtB.LookupRightVector1_o2_e = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1_c = cos(r);\r\n        rtB.LookupRightVector1_o2_e = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S54>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[12]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1_a = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2_l = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1_a = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2_l = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S55>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[16]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1_iv = fy;\r\n        rtB.LookupRightVector1_o2_f = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1_iv = cos(r);\r\n        rtB.LookupRightVector1_o2_f = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S55>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[16]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1_c = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2_e = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1_c = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2_e = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S56>/Look up Right Vector1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[20]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector1_o1_je = fy;\r\n        rtB.LookupRightVector1_o2_b = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector1_o1_je = cos(r);\r\n        rtB.LookupRightVector1_o2_b = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_path1): '<S56>/Look up P1' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.snpsiusCars16[20]), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* If the path is straight, interpolate between start and stop */\r\n      rtB.LookupP1_o1_g = rs[i].data.straight.start[0] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[0]-rs[i].\r\n        data.straight.start[0]);\r\n      rtB.LookupP1_o2_n = rs[i].data.straight.start[1] +\r\n        (p/rs[i].data.straight.length)*(rs[i].data.straight.stop[1]-rs[i].\r\n        data.straight.start[1]);\r\n      break;\r\n\r\n     case CONST_CURVE:\r\n      rtB.LookupP1_o1_g = rs[i].data.const_curve.center[0] + rs[i].\r\n        data.const_curve.r\r\n        *cos( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      rtB.LookupP1_o2_n = rs[i].data.const_curve.center[1] + rs[i].\r\n        data.const_curve.r\r\n        *sin( (double)(rs[i].data.const_curve.dir)*p/(rs[i].data.const_curve.r)\r\n             + rs[i].data.const_curve.ts );\r\n      break;\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S65>/Look up Right Vector' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.UnitDelay), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector_o1_j = fy;\r\n        rtB.LookupRightVector_o2_f = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector_o1_j = cos(r);\r\n        rtB.LookupRightVector_o2_f = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Sum: '<S64>/Sum1' */\r\n  rtb_Conversion = rtB.DiscreteTimeIntegrator2 + rtB.Gain;\r\n\r\n  /* Product: '<S64>/Product1' incorporates:\r\n   *  Gain: '<S65>/Gain'\r\n   *  Product: '<S64>/Product'\r\n   *  Product: '<S64>/Product2'\r\n   *  Sum: '<S64>/Sum'\r\n   *  Trigonometry: '<S64>/Trigonometric Function'\r\n   *  Trigonometry: '<S64>/Trigonometric Function1'\r\n   */\r\n  rtB.Product1 = (-rtB.LookupRightVector_o2_f * cosf(rtb_Conversion) + sinf\r\n                  (rtb_Conversion) * rtB.LookupRightVector_o1_j) *\r\n    rtB.DiscreteTimeIntegrator;\r\n\r\n  /* S-Function (any2byte): '<S42>/Byte Pack1' */\r\n\r\n  /* Pack: <S42>/Byte Pack1 */\r\n  (void) memcpy(&rtB.BytePack1[0], &rtB.DiscreteTimeIntegrator2,\r\n                4);\r\n  (void) memcpy(&rtB.BytePack1[4], &rtB.Product1,\r\n                4);\r\n\r\n  /* S-Function (fcan_s32k_send): '<S42>/psi,us' incorporates:\r\n   *  Constant: '<S42>/Constant'\r\n   */\r\n  {\r\n    flexcan_data_info_t canCom0_txBuff1 = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = ((uint8_T)8U),\r\n      .fd_enable = false,\r\n      .fd_padding = 0x0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigTxMb(0, 1, &canCom0_txBuff1, 0x56);\r\n    FLEXCAN_DRV_Send(0, 1, &canCom0_txBuff1, 0x56, &rtB.BytePack1[0]);\r\n  }\r\n\r\n  /* S-Function (any2byte): '<S42>/Byte Pack' */\r\n\r\n  /* Pack: <S42>/Byte Pack */\r\n  (void) memcpy(&rtB.BytePack[0], &rtB.UnitDelay,\r\n                4);\r\n  (void) memcpy(&rtB.BytePack[4], &rtB.Sum1,\r\n                4);\r\n\r\n  /* S-Function (fcan_s32k_send): '<S42>/s,n' incorporates:\r\n   *  Constant: '<S42>/Constant1'\r\n   */\r\n  {\r\n    flexcan_data_info_t canCom0_txBuff0 = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = ((uint8_T)8U),\r\n      .fd_enable = false,\r\n      .fd_padding = 0x0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigTxMb(0, 0, &canCom0_txBuff0, 0x55);\r\n    FLEXCAN_DRV_Send(0, 0, &canCom0_txBuff0, 0x55, &rtB.BytePack[0]);\r\n  }\r\n\r\n  /* Sum: '<S57>/Sum' incorporates:\r\n   *  Constant: '<S57>/Constant'\r\n   *  Constant: '<S59>/Constant'\r\n   *  Gain: '<S57>/Gain'\r\n   *  Product: '<S59>/Product'\r\n   *  Sum: '<S27>/Sum1'\r\n   */\r\n  rtB.Saturation = (0.0F - rtB.DiscreteTimeIntegrator * rtB.Gain * -100.0F) *\r\n    0.0003162F + 0.5F;\r\n\r\n  /* Saturate: '<S57>/Saturation' */\r\n  if (rtB.Saturation > 0.76F) {\r\n    /* Sum: '<S57>/Sum' incorporates:\r\n     *  Saturate: '<S57>/Saturation'\r\n     */\r\n    rtB.Saturation = 0.76F;\r\n  } else if (rtB.Saturation < 0.24F) {\r\n    /* Sum: '<S57>/Sum' incorporates:\r\n     *  Saturate: '<S57>/Saturation'\r\n     */\r\n    rtB.Saturation = 0.24F;\r\n  }\r\n\r\n  /* End of Saturate: '<S57>/Saturation' */\r\n\r\n  /* S-Function (ftm_s32k_pwm_config): '<S43>/FTM_PWM_Config' incorporates:\r\n   *  Constant: '<S43>/Constant'\r\n   */\r\n  {\r\n    uint16_t dutyA = FTM_MAX_DUTY_CYCLE * rtB.Saturation;\r\n    FTM_DRV_UpdatePwmChannel(FTM_PWM0, 0U, FTM_PWM_UPDATE_IN_DUTY_CYCLE, dutyA,\r\n      0, true);\r\n  }\r\n\r\n  /* S-Function (get_rvec1): '<S68>/Look up Right Vector' */\r\n  {\r\n    extern struct road_seg_type rs[MAX_RS];\r\n    real_T p, u_alt;\r\n    int i;\r\n\r\n    /* keep u within the range [0, PATH_LENGTH) */\r\n    u_alt = fmod( (rtB.UnitDelay), PATH_LENGTH);\r\n\r\n    /* Find the segment in rs[] that the path distance u_alt lies within */\r\n    for (i=0; i<MAX_RS; i++) {\r\n      if (rs[i].p > u_alt) {\r\n        i--;\r\n        break;\r\n      }\r\n    }\r\n\r\n    /* i is the segment in which u lies; p is the path length from the\r\n     * beginning of segment i to u_alt */\r\n    p = u_alt - rs[i].p;\r\n    switch ( rs[i].type)\r\n    {\r\n     case STRAIGHT:\r\n      /* if path is straight, then the \"right\" vector is normal to\r\n       * the vector that points straight ahead */\r\n      {\r\n        double fx, fy;                 /* unit vector straight ahead */\r\n        double length;                 /* length of vector from start to stop */\r\n        fx = rs[i].data.straight.stop[0] - rs[i].data.straight.start[0];\r\n        fy = rs[i].data.straight.stop[1] - rs[i].data.straight.start[1];\r\n        length = sqrt(fx*fx + fy*fy);\r\n        fx /= length;\r\n        fy /= length;\r\n\r\n        /* <x,y,0> =  <fx,fy,0> x <0,0,1> */\r\n        rtB.LookupRightVector_o1_i = fy;\r\n        rtB.LookupRightVector_o2_fo = -fx;\r\n        break;\r\n      }\r\n\r\n     case CONST_CURVE:\r\n      {\r\n        double r;                      /* right angle */\r\n        if (rs[i].data.const_curve.dir > 0.0) {\r\n          r = p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts;\r\n        } else {\r\n          r = -p/(rs[i].data.const_curve.r) + rs[i].data.const_curve.ts\r\n            + 3.14159265358979;\r\n        }\r\n\r\n        rtB.LookupRightVector_o1_i = cos(r);\r\n        rtB.LookupRightVector_o2_fo = sin(r);\r\n        break;\r\n      }\r\n\r\n     default :\r\n      /* assign no value */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* DataTypeConversion: '<S66>/Data  Type  Conversion' incorporates:\r\n   *  Gain: '<S68>/Gain'\r\n   *  Product: '<S70>/Product'\r\n   *  Sum: '<S70>/Sum1'\r\n   */\r\n  rtb_DataTypeConversion = rtb_Gain_ie * -rtB.LookupRightVector_o2_fo +\r\n    rtb_Sum1_e * rtB.LookupRightVector_o1_i;\r\n\r\n  /* DiscreteStateSpace: '<S66>/Controller' */\r\n  {\r\n    rtb_dsdt = 0.38289225536816662*rtDW.Controller_DSTATE;\r\n    rtb_dsdt += 150.12503472222349*rtb_DataTypeConversion;\r\n  }\r\n\r\n  /* Sum: '<S69>/Sum' incorporates:\r\n   *  DataTypeConversion: '<S67>/Conversion'\r\n   *  Gain: '<S69>/Gain'\r\n   *  UnitDelay: '<S69>/Unit Delay'\r\n   */\r\n  rtDW.UnitDelay_DSTATE_i = 0.01F * (real32_T)rtb_dsdt + rtB.UnitDelay;\r\n\r\n  /* Update for UnitDelay: '<S2>/Unit Delay' */\r\n  rtDW.UnitDelay_DSTATE[0] = rtB.UnitDelay;\r\n  rtDW.UnitDelay_DSTATE[1] = rtB.Sum1;\r\n  rtDW.UnitDelay_DSTATE[2] = rtB.DiscreteTimeIntegrator2;\r\n  rtDW.UnitDelay_DSTATE[3] = rtB.Product1;\r\n\r\n  /* Update for UnitDelay: '<S39>/Unit Delay' */\r\n  rtDW.UnitDelay_DSTATE_c = rtB.Quadrature_Decoder_o1;\r\n\r\n  /* Update for DiscreteStateSpace: '<S66>/Controller' */\r\n  {\r\n    real_T xnew[1];\r\n    xnew[0] = 1.0*rtDW.Controller_DSTATE;\r\n    xnew[0] += 0.65292519369349644*rtb_DataTypeConversion;\r\n    (void) memcpy(&rtDW.Controller_DSTATE, xnew,\r\n                  sizeof(real_T)*1);\r\n  }\r\n\r\n  /* End of Outputs for S-Function (fcgen): '<Root>/Function-Call Top' */\r\n\r\n  /* RateTransition: '<Root>/Rate Transition' incorporates:\r\n   *  Product: '<S44>/Product'\r\n   *  Product: '<S51>/Product'\r\n   *  Product: '<S52>/Product'\r\n   *  Product: '<S53>/Product'\r\n   *  Product: '<S54>/Product'\r\n   *  Product: '<S55>/Product'\r\n   *  Product: '<S56>/Product'\r\n   *  SignalConversion generated from: '<S2>/Serial'\r\n   *  Sum: '<S44>/Sum'\r\n   *  Sum: '<S51>/Sum'\r\n   *  Sum: '<S52>/Sum'\r\n   *  Sum: '<S53>/Sum'\r\n   *  Sum: '<S54>/Sum'\r\n   *  Sum: '<S55>/Sum'\r\n   *  Sum: '<S56>/Sum'\r\n   */\r\n  if (rtM->Timing.RateInteraction.TID1_2) {\r\n    /* S-Function (fcgen): '<Root>/Function-Call Top' incorporates:\r\n     *  SubSystem: '<Root>/High Level Design'\r\n     */\r\n    rtDW.RateTransition_Buffer[0] = rtB.Sum1 * rtB.LookupRightVector1_o1 +\r\n      rtB.LookupP1_o1;\r\n    rtDW.RateTransition_Buffer[1] = rtB.Sum1 * rtB.LookupRightVector1_o2 +\r\n      rtB.LookupP1_o2;\r\n    rtDW.RateTransition_Buffer[2] = rtB.DiscreteTimeIntegrator2;\r\n    rtDW.RateTransition_Buffer[3] = rtB.DiscreteTimeIntegrator;\r\n    rtDW.RateTransition_Buffer[4] = rtB.snpsiusCars16[1] *\r\n      rtB.LookupRightVector1_o1_j + rtB.LookupP1_o1_j;\r\n    rtDW.RateTransition_Buffer[5] = rtB.snpsiusCars16[1] *\r\n      rtB.LookupRightVector1_o2_m + rtB.LookupP1_o2_m;\r\n    rtDW.RateTransition_Buffer[6] = rtB.snpsiusCars16[2];\r\n    rtDW.RateTransition_Buffer[7] = rtB.snpsiusCars16[5] *\r\n      rtB.LookupRightVector1_o1_i + rtB.LookupP1_o1_f;\r\n    rtDW.RateTransition_Buffer[8] = rtB.snpsiusCars16[5] *\r\n      rtB.LookupRightVector1_o2_d + rtB.LookupP1_o2_p;\r\n    rtDW.RateTransition_Buffer[9] = rtB.snpsiusCars16[6];\r\n    rtDW.RateTransition_Buffer[10] = rtB.snpsiusCars16[9] *\r\n      rtB.LookupRightVector1_o1_a + rtB.LookupP1_o1_jz;\r\n    rtDW.RateTransition_Buffer[11] = rtB.snpsiusCars16[9] *\r\n      rtB.LookupRightVector1_o2_j + rtB.LookupP1_o2_pi;\r\n    rtDW.RateTransition_Buffer[12] = rtB.snpsiusCars16[10];\r\n    rtDW.RateTransition_Buffer[13] = rtB.snpsiusCars16[13] *\r\n      rtB.LookupRightVector1_o1_c + rtB.LookupP1_o1_a;\r\n    rtDW.RateTransition_Buffer[14] = rtB.snpsiusCars16[13] *\r\n      rtB.LookupRightVector1_o2_e + rtB.LookupP1_o2_l;\r\n    rtDW.RateTransition_Buffer[15] = rtB.snpsiusCars16[14];\r\n    rtDW.RateTransition_Buffer[16] = rtB.snpsiusCars16[17] *\r\n      rtB.LookupRightVector1_o1_iv + rtB.LookupP1_o1_c;\r\n    rtDW.RateTransition_Buffer[17] = rtB.snpsiusCars16[17] *\r\n      rtB.LookupRightVector1_o2_f + rtB.LookupP1_o2_e;\r\n    rtDW.RateTransition_Buffer[18] = rtB.snpsiusCars16[18];\r\n    rtDW.RateTransition_Buffer[19] = rtB.snpsiusCars16[21] *\r\n      rtB.LookupRightVector1_o1_je + rtB.LookupP1_o1_g;\r\n    rtDW.RateTransition_Buffer[20] = rtB.snpsiusCars16[21] *\r\n      rtB.LookupRightVector1_o2_b + rtB.LookupP1_o2_n;\r\n    rtDW.RateTransition_Buffer[21] = rtB.snpsiusCars16[22];\r\n\r\n    /* End of Outputs for S-Function (fcgen): '<Root>/Function-Call Top' */\r\n  }\r\n\r\n  /* End of RateTransition: '<Root>/Rate Transition' */\r\n\r\n  /* Update absolute time */\r\n  /* The \"clockTick1\" counts the number of times the code of this task has\r\n   * been executed. The resolution of this integer timer is 0.01, which is the step size\r\n   * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n   * application lifespan selected.\r\n   */\r\n  rtM->Timing.clockTick1++;\r\n}\r\n\r\n/* Model step function for TID2 */\r\nvoid Final_project_template_step2(void) /* Sample time: [0.05s, 0.0s] */\r\n{\r\n  /* RateTransition: '<Root>/Rate Transition' */\r\n  memcpy(&rtB.RateTransition[0], &rtDW.RateTransition_Buffer[0], 22U * sizeof\r\n         (real32_T));\r\n\r\n  /* S-Function (fcgen): '<S4>/Function-Call Generator1' incorporates:\r\n   *  SubSystem: '<S4>/Serial'\r\n   */\r\n  /* S-Function (slrealtimebytepacking): '<S72>/Byte Packing ' */\r\n\r\n  /* Byte Packing: <S72>/Byte Packing  */\r\n  (void)memcpy((uint8_T*)&rtB.BytePacking[0] + 0, (uint8_T*)&rtB.RateTransition\r\n               [0], 88);\r\n\r\n  /* Logic: '<S72>/NOT' incorporates:\r\n   *  Delay: '<S72>/Delay'\r\n   */\r\n  rtDW.Delay_DSTATE_j = !rtDW.Delay_DSTATE_j;\r\n\r\n  /* End of Outputs for S-Function (fcgen): '<S4>/Function-Call Generator1' */\r\n\r\n  /* RateTransition: '<S4>/RT' incorporates:\r\n   *  Delay: '<S72>/Delay'\r\n   */\r\n  rtDW.RT_Buffer0 = rtDW.Delay_DSTATE_j;\r\n\r\n  /* S-Function (fcgen): '<S4>/Function-Call Generator1' incorporates:\r\n   *  SubSystem: '<S4>/Serial'\r\n   */\r\n  /* RateTransition: '<S4>/RT1' incorporates:\r\n   *  Constant: '<S72>/Constant2'\r\n   *  Constant: '<S72>/Constant3'\r\n   *  SignalConversion generated from: '<S72>/data_out'\r\n   */\r\n  rtDW.RT1_Buffer0[0] = 115U;\r\n  memcpy(&rtDW.RT1_Buffer0[1], &rtB.BytePacking[0], 88U * sizeof(uint8_T));\r\n  rtDW.RT1_Buffer0[89] = 101U;\r\n\r\n  /* End of Outputs for S-Function (fcgen): '<S4>/Function-Call Generator1' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid Final_project_template_initialize(void)\r\n{\r\n  /* Start for S-Function (fcan_s32k_config): '<Root>/FCAN_Config' */\r\n  {\r\n    const flexcan_user_config_t canCom0_InitConfig = {\r\n      .pe_clock = FLEXCAN_CLK_SOURCE_PERIPH,\r\n      .max_num_mb = 32U,\r\n      .num_id_filters = FLEXCAN_RX_FIFO_ID_FILTERS_8,\r\n      .is_rx_fifo_needed = false,\r\n      .flexcanMode = FLEXCAN_NORMAL_MODE,\r\n\r\n      /* Bitrate: 500U and clock frequency: 80000000U */\r\n      .bitrate = {\r\n        .propSeg = 2U,\r\n        .phaseSeg1 = 3U,\r\n        .phaseSeg2 = 1U,\r\n        .preDivider = 15U,\r\n        .rJumpwidth = 1U\r\n      },\r\n\r\n      /* Bitrate: 2000U and clock frequency: 80000000U for dataPhase */\r\n      .bitrate_cbt = {\r\n        .propSeg = 6U,\r\n        .phaseSeg1 = 6U,\r\n        .phaseSeg2 = 6U,\r\n        .preDivider = 2U,\r\n        .rJumpwidth = 2U\r\n      },\r\n      .fd_enable = false,\r\n      .payload = FLEXCAN_PAYLOAD_SIZE_8,\r\n      .rxFifoDMAChannel = 0U,\r\n      .transfer_type = FLEXCAN_RXFIFO_USING_INTERRUPTS,\r\n    };\r\n\r\n    /* CAN RX pin config */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n    PINS_DRV_SetMuxModeSel(PORTE, 4, PORT_MUX_ALT5);\r\n\r\n    /* CAN TX pin config */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n    PINS_DRV_SetMuxModeSel(PORTE, 5, PORT_MUX_ALT5);\r\n\r\n    /* Enable CAN0 clock */\r\n    PCC_SetClockMode(PCC, PCC_FlexCAN0_CLOCK, true);\r\n    FLEXCAN_DRV_Init(0, &canCom0_State, &canCom0_InitConfig);\r\n  }\r\n\r\n  /* Start for S-Function (lpuart_s32k_config): '<Root>/LPUART_Config' */\r\n  {\r\n    static lpuart_state_t lpuartState;\r\n\r\n    /* Enable clock for PORTC */\r\n    PCC_SetClockMode(PCC, PCC_PORTC_CLOCK, true);\r\n\r\n    /* Configure pin for RX function */\r\n    PINS_SetMuxModeSel(PORTC, 6, PORT_MUX_ALT2);\r\n\r\n    /* Enable clock for PORTC */\r\n    PCC_SetClockMode(PCC, PCC_PORTC_CLOCK, true);\r\n\r\n    /* Configure pin for TX function */\r\n    PINS_SetMuxModeSel(PORTC, 7, PORT_MUX_ALT2);\r\n\r\n    /* Set LPUART clock source */\r\n    PCC_SetPeripheralClockControl(PCC, PCC_LPUART1_CLOCK, true,\r\n      CLK_SRC_FIRC_DIV2, 0, 0);\r\n\r\n    /* Enable LPUART clock */\r\n    PCC_SetClockMode(PCC, PCC_LPUART1_CLOCK, true);\r\n    const lpuart_user_config_t lpuart1_config = {\r\n      .transferType = LPUART_USING_INTERRUPTS,\r\n      .baudRate = 115200U,\r\n      .parityMode = LPUART_PARITY_DISABLED,\r\n      .stopBitCount = LPUART_ONE_STOP_BIT,\r\n      .bitCountPerChar = LPUART_8_BITS_PER_CHAR,\r\n      .rxDMAChannel = 0U,\r\n      .txDMAChannel = 0U,\r\n    };\r\n\r\n    /* Initializes a LPUART instance for operation */\r\n    LPUART_DRV_Init(1, &lpuartState, &lpuart1_config);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 16, &rxInfo, 0x0F);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 16, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive1' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 17, &rxInfo, 0x10);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 17, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive10' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 12, &rxInfo, 0x41);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 12, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive11' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 13, &rxInfo, 0x42);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 13, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive12' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 2, &rxInfo, 0x4b);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 2, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive13' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 3, &rxInfo, 0x4c);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 3, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive14' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 14, &rxInfo, 0x69);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 14, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive15' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 15, &rxInfo, 0x6a);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 15, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive2' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 4, &rxInfo, 0x19);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 4, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive3' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 5, &rxInfo, 0x1a);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 5, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive4' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 6, &rxInfo, 0x23);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 6, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive5' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 7, &rxInfo, 0x24);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 7, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive6' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 8, &rxInfo, 0x2d);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 8, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive7' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 9, &rxInfo, 0x2e);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 9, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive8' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 10, &rxInfo, 0x37);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 10, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (fcan_s32k_receive): '<S5>/FCAN_Receive9' */\r\n  {\r\n    flexcan_msgbuff_id_type_t msg_id_type = FLEXCAN_MSG_ID_STD;\r\n    flexcan_data_info_t rxInfo = {\r\n      .msg_id_type = FLEXCAN_MSG_ID_STD,\r\n      .data_length = 8,\r\n      .fd_enable = false,\r\n      .fd_padding = 0,\r\n      .enable_brs = false,\r\n      .is_remote = false\r\n    };\r\n\r\n    FLEXCAN_DRV_ConfigRxMb(0, 11, &rxInfo, 0x38);\r\n    FLEXCAN_DRV_SetRxMaskType(0, FLEXCAN_RX_MASK_INDIVIDUAL);\r\n    FLEXCAN_DRV_SetRxIndividualMask(0, msg_id_type, 11, 0x0);\r\n  }\r\n\r\n  /* Start for S-Function (ftm_s32k_pwm_config): '<S3>/FTM_PWM_Config' incorporates:\r\n   *  Constant: '<S3>/Constant'\r\n   *  Constant: '<S3>/Constant1'\r\n   */\r\n\r\n  /* Enable clock for PORTB */\r\n  PCC_SetClockMode (PCC, PCC_PORTB_CLOCK, true);\r\n\r\n  /* Pin is configured for FTM function */\r\n  PINS_SetMuxModeSel (PORTB, 8, PORT_MUX_ALT2);\r\n\r\n  /* Set FTM_3 clock source */\r\n  PCC_SetPeripheralClockControl (PCC, FTM3_CLK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n  /* Enable clock for FTM_3 */\r\n  PCC_SetClockMode (PCC, FTM3_CLK, true);\r\n\r\n  /* PWM3 initialization */\r\n  FTM_DRV_Init (FTM_PWM3, &flexTimer_pwm3_InitConfig, &ftmStateStruct3);\r\n  FTM_DRV_InitPwm (FTM_PWM3, &flexTimer_pwm3_PwmConfig);\r\n  FTM_DRV_SetChnTriggerCmd(FTM3, 1, false);\r\n\r\n  /* Start for S-Function (adc_s32k_config): '<Root>/ADC_Config' */\r\n  {\r\n    const adc_converter_config_t adc0_cfg = {\r\n      .clockDivide = ADC_CLK_DIVIDE_1,\r\n      .sampleTime = 1U,\r\n      .resolution = ADC_RESOLUTION_12BIT,\r\n      .inputClock = ADC_CLK_ALT_1,\r\n      .trigger = ADC_TRIGGER_SOFTWARE,\r\n      .pretriggerSel = ADC_PRETRIGGER_SEL_PDB,\r\n      .triggerSel = ADC_TRIGGER_SEL_TRGMUX,\r\n      .dmaEnable = true,\r\n      .voltageRef = ADC_VOLTAGEREF_VREF,\r\n      .continuousConvEnable = false,\r\n      .supplyMonitoringEnable = false\r\n    };\r\n\r\n    const adc_compare_config_t adc0_cmp_cfg = {\r\n      .compareEnable = false,\r\n      .compareGreaterThanEnable = false,\r\n      .compareRangeFuncEnable = false,\r\n      .compVal1 = 0,\r\n      .compVal2 = 0\r\n    };\r\n\r\n    const adc_average_config_t adc0_avrg_cfg = {\r\n      .hwAvgEnable = false,\r\n      .hwAverage = ADC_AVERAGE_4\r\n    };\r\n\r\n    /* Enable ADC0 clock */\r\n    PCC_SetClockMode(PCC, PCC_ADC0_CLOCK, false);\r\n\r\n    /* Set ADC0 clock source */\r\n    PCC_SetPeripheralClockControl(PCC, PCC_ADC0_CLOCK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n    /* Enable ADC0 clock */\r\n    PCC_SetClockMode(PCC, PCC_ADC0_CLOCK, true);\r\n    ADC_DRV_Reset(0);\r\n\r\n    /* Configure ADC0 */\r\n    ADC_DRV_ConfigConverter(0, &adc0_cfg);\r\n    ADC_DRV_SetSwPretrigger(0,ADC_SW_PRETRIGGER_DISABLED);\r\n    ADC_DRV_ConfigHwCompare(0, &adc0_cmp_cfg);\r\n    ADC_DRV_ConfigHwAverage(0, &adc0_avrg_cfg);\r\n\r\n    /* Do calibration before initialize the ADC0. */\r\n    ADC_DRV_AutoCalibration(0);\r\n  }\r\n\r\n  rtPrevZCX.ResettableSubsystem_Reset_ZCE = UNINITIALIZED_ZCSIG;\r\n\r\n  /* SystemInitialize for S-Function (fcan_s32k_isr): '<S1>/FCAN_Isr' */\r\n  FLEXCAN_DRV_InstallEventCallback(0, fcan0_s32k_rx_isr, (void *)0);\r\n\r\n  /* SystemInitialize for S-Function (fcgen): '<Root>/Function-Call Top' incorporates:\r\n   *  SubSystem: '<Root>/High Level Design'\r\n   */\r\n  /* Start for S-Function (gpio_s32k_input): '<S26>/Digital_Input' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin14 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 14,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE14. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin14);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_output): '<S25>/Digital_Output' */\r\n  {\r\n    /* Enable clock for PORTD */\r\n    PCC_SetClockMode(PCC, PCC_PORTD_CLOCK, true);\r\n\r\n    /* Configure the output port init structure. */\r\n    const pin_settings_config_t gpioPORTDPin8 = {\r\n      .base = PORTD,\r\n      .pinPortIdx = 8,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTD,\r\n      .direction = GPIO_OUTPUT_DIRECTION,\r\n      .initValue = 0U\r\n    };\r\n\r\n    /* Initialize GPIPORTD8. */\r\n    PINS_DRV_Init(1, &gpioPORTDPin8);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_output): '<S25>/Digital_Output1' */\r\n  {\r\n    /* Enable clock for PORTD */\r\n    PCC_SetClockMode(PCC, PCC_PORTD_CLOCK, true);\r\n\r\n    /* Configure the output port init structure. */\r\n    const pin_settings_config_t gpioPORTDPin9 = {\r\n      .base = PORTD,\r\n      .pinPortIdx = 9,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTD,\r\n      .direction = GPIO_OUTPUT_DIRECTION,\r\n      .initValue = 0U\r\n    };\r\n\r\n    /* Initialize GPIPORTD9. */\r\n    PINS_DRV_Init(1, &gpioPORTDPin9);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_output): '<S25>/Digital_Output2' */\r\n  {\r\n    /* Enable clock for PORTD */\r\n    PCC_SetClockMode(PCC, PCC_PORTD_CLOCK, true);\r\n\r\n    /* Configure the output port init structure. */\r\n    const pin_settings_config_t gpioPORTDPin10 = {\r\n      .base = PORTD,\r\n      .pinPortIdx = 10,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTD,\r\n      .direction = GPIO_OUTPUT_DIRECTION,\r\n      .initValue = 0U\r\n    };\r\n\r\n    /* Initialize GPIPORTD10. */\r\n    PINS_DRV_Init(1, &gpioPORTDPin10);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin6 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 6,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE6. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin6);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input1' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin7 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 7,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE7. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin7);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input2' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin8 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 8,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE8. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin8);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input3' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin9 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 9,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE9. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin9);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input4' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin10 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 10,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE10. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin10);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input5' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin11 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 11,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE11. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin11);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input6' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin12 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 12,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE12. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin12);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S36>/Digital_Input7' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin13 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 13,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE13. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin13);\r\n  }\r\n\r\n  /* Start for S-Function (ftm_s32k_quadrature_decoder): '<S38>/Quadrature_Decoder' */\r\n  {\r\n    ftm_user_config_t ftm2_qd_InitConfig = {\r\n      {\r\n        true,                          /* Software trigger state */\r\n        false,                         /* Hardware trigger 1 state */\r\n        false,                         /* Hardware trigger 2 state */\r\n        false,                         /* Hardware trigger 3 state */\r\n        false,                         /* Max loading point state */\r\n        false,                         /* Min loading point state */\r\n        FTM_SYSTEM_CLOCK,              /* Update mode for INVCTRL register */\r\n        FTM_SYSTEM_CLOCK,              /* Update mode for SWOCTRL register */\r\n        FTM_SYSTEM_CLOCK,              /* Update mode for OUTMASK register */\r\n        FTM_SYSTEM_CLOCK,              /* Update mode for CNTIN register */\r\n        false,                         /* Automatic clear of the trigger*/\r\n        FTM_UPDATE_NOW,                /* Synchronization point */\r\n      },\r\n      FTM_MODE_QUADRATURE_DECODER,     /* Mode of operation for FTM */\r\n      FTM_CLOCK_DIVID_BY_1,            /* FTM clock prescaler */\r\n      FTM_CLOCK_SOURCE_SYSTEMCLK,      /* FTM clock source */\r\n      FTM_BDM_MODE_00,                 /* FTM debug mode */\r\n      false,                           /* Interrupt state */\r\n      false                            /* Initialization trigger */\r\n    };\r\n\r\n    ftm_quad_decode_config_t ftm2_qd_Params = {\r\n      FTM_QUAD_PHASE_ENCODE,           /* Quadrature decoder mode */\r\n      0,                               /* Initial counter value */\r\n      65535,                           /* Maximum counter value */\r\n\r\n      {\r\n        false,                         /* Filter state */\r\n        0,                             /* Filter value */\r\n        FTM_QUAD_PHASE_NORMAL          /* Phase polarity */\r\n      },\r\n\r\n      {\r\n        false,                         /* Filter state */\r\n        0,                             /* Filter value */\r\n        FTM_QUAD_PHASE_NORMAL          /* Phase polarity */\r\n      }\r\n    };\r\n\r\n    /* Enable clock for PORTA */\r\n    PCC_SetClockMode(PCC, PCC_PORTA_CLOCK, true);\r\n\r\n    /* Pin is configured for FTM function */\r\n    PINS_SetMuxModeSel(PORTA, 13, PORT_MUX_ALT6);\r\n\r\n    /* Enable clock for PORTA */\r\n    PCC_SetClockMode(PCC, PCC_PORTA_CLOCK, true);\r\n\r\n    /* Pin is configured for FTM function */\r\n    PINS_SetMuxModeSel(PORTA, 12, PORT_MUX_ALT6);\r\n\r\n    /* Set FTM_2 clock source */\r\n    PCC_SetPeripheralClockControl (PCC, FTM2_CLK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n    /* Enable clock for FTM_2 */\r\n    PCC_SetClockMode (PCC, FTM2_CLK, true);\r\n\r\n    /* Initialize FTM instance QD decoder*/\r\n    static ftm_state_t ftm2StateStruct;\r\n    FTM_DRV_Init(2, &ftm2_qd_InitConfig, &ftm2StateStruct);\r\n\r\n    /* Start QD decoder*/\r\n    FTM_DRV_QuadDecodeStart(2, &ftm2_qd_Params);\r\n  }\r\n\r\n  /* Start for S-Function (gpio_s32k_input): '<S26>/Digital_Input1' */\r\n  {\r\n    /* Enable clock for PORTE */\r\n    PCC_SetClockMode(PCC, PCC_PORTE_CLOCK, true);\r\n\r\n    /* Configure the input port init structure. */\r\n    const pin_settings_config_t gpioPORTEPin15 = {\r\n      .base = PORTE,\r\n      .pinPortIdx = 15,\r\n      .pullConfig = PORT_INTERNAL_PULL_NOT_ENABLED,\r\n      .passiveFilter = false,\r\n      .driveSelect = PORT_LOW_DRIVE_STRENGTH,\r\n      .mux = PORT_MUX_AS_GPIO,\r\n      .pinLock = false,\r\n      .intConfig = PORT_DMA_INT_DISABLED,\r\n      .clearIntFlag = true,\r\n      .gpioBase = PTE,\r\n      .direction = GPIO_INPUT_DIRECTION,\r\n    };\r\n\r\n    /* Initialize GPIPORTE15. */\r\n    PINS_DRV_Init(1, &gpioPORTEPin15);\r\n  }\r\n\r\n  /* Start for S-Function (ftm_s32k_pwm_config): '<S43>/FTM_PWM_Config' incorporates:\r\n   *  Constant: '<S43>/Constant'\r\n   */\r\n\r\n  /* Enable clock for PORTB */\r\n  PCC_SetClockMode (PCC, PCC_PORTB_CLOCK, true);\r\n\r\n  /* Pin is configured for FTM function */\r\n  PINS_SetMuxModeSel (PORTB, 12, PORT_MUX_ALT2);\r\n\r\n  /* Set FTM_0 clock source */\r\n  PCC_SetPeripheralClockControl (PCC, FTM0_CLK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n  /* Enable clock for FTM_0 */\r\n  PCC_SetClockMode (PCC, FTM0_CLK, true);\r\n\r\n  /* PWM0 initialization */\r\n  FTM_DRV_Init (FTM_PWM0, &flexTimer_pwm0_InitConfig, &ftmStateStruct0);\r\n  FTM_DRV_InitPwm (FTM_PWM0, &flexTimer_pwm0_PwmConfig);\r\n  FTM_DRV_SetChnTriggerCmd(FTM0, 1, false);\r\n\r\n  /* Enable for S-Function (fcgen): '<Root>/Function-Call Top' incorporates:\r\n   *  SubSystem: '<Root>/High Level Design'\r\n   */\r\n  rtDW.HighLevelDesign_RESET_ELAPS_T = true;\r\n\r\n  /* Enable for Atomic SubSystem: '<S28>/Vehicle Dynamics' */\r\n  /* Enable for DiscreteIntegrator: '<S60>/Discrete-Time Integrator' */\r\n  rtDW.DiscreteTimeIntegrator_SYSTEM_E = 1U;\r\n\r\n  /* Enable for DiscreteIntegrator: '<S62>/Discrete-Time Integrator2' */\r\n  rtDW.DiscreteTimeIntegrator2_SYSTEM_ = 1U;\r\n\r\n  /* Enable for DiscreteIntegrator: '<S62>/Discrete-Time Integrator' */\r\n  rtDW.DiscreteTimeIntegrator_SYSTEM_b = 1U;\r\n\r\n  /* Enable for DiscreteIntegrator: '<S62>/Discrete-Time Integrator1' */\r\n  rtDW.DiscreteTimeIntegrator1_SYSTEM_ = 1U;\r\n\r\n  /* End of Enable for SubSystem: '<S28>/Vehicle Dynamics' */\r\n  /* End of Enable for S-Function (fcgen): '<Root>/Function-Call Top' */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid Final_project_template_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Final_project_template.h","type":"header","group":"model","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Final_project_template.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Final_project_template_h_\r\n#define RTW_HEADER_Final_project_template_h_\r\n#ifndef Final_project_template_COMMON_INCLUDES_\r\n#define Final_project_template_COMMON_INCLUDES_\r\n#include <string.h>\r\n#include \"rtwtypes.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"pins_driver.h\"\r\n#include \"adc_driver.h\"\r\n#include \"ftm_qd_driver.h\"\r\n#include \"clock_manager.h\"\r\n#include \"ftm_hw_access.h\"\r\n#include \"pins_port_hw_access.h\"\r\n#include \"flexcan_hw_access.h\"\r\n#include \"ftm_pwm_driver.h\"\r\n#include \"ftm0_pwm_params.h\"\r\n#include \"ftm3_pwm_params.h\"\r\n#include \"lpuart_driver.h\"\r\n#include \"device_registers.h\"\r\n#include \"flexcan_driver.h\"\r\n#include \"lin_lpuart_driver.h\"\r\n#include \"lpuart_hw_access.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"fcan0_s32k_rx_isr.h\"\r\n#endif                             /* Final_project_template_COMMON_INCLUDES_ */\r\n\r\n#include \"Final_project_template_types.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmStepTask\r\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\r\n#endif\r\n\r\n#ifndef rtmTaskCounter\r\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\r\n#endif\r\n\r\n#define Final_project_template_M       (rtM)\r\n\r\n/* user code (top of header file) */\r\n#include <math.h>\r\n\r\n/* Block states (default storage) for system '<S7>/Switch Case Action Subsystem2' */\r\ntypedef struct {\r\n  int_T ByteUnpacking_IWORK[4];        /* '<S13>/Byte Unpacking ' */\r\n} DW_SwitchCaseActionSubsystem2;\r\n\r\n/* Block states (default storage) for system '<S7>/Switch Case Action Subsystem3' */\r\ntypedef struct {\r\n  int_T ByteUnpacking_IWORK[4];        /* '<S14>/Byte Unpacking ' */\r\n} DW_SwitchCaseActionSubsystem3;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  uint32_T FCAN_Isr_o3;                /* '<S1>/FCAN_Isr' */\r\n  uint32_T ADC_Start;                  /* '<S37>/ADC_Start' */\r\n  real32_T RateTransition[22];         /* '<Root>/Rate Transition' */\r\n  real32_T snpsiusCars16[24];          /* '<S2>/s,n,psi,us (Cars 1-6)' */\r\n  real32_T TmpSignalConversionAtSFunctionB[28];\r\n  real32_T SFunctionBuilder_o1;        /* '<S29>/S-Function Builder' */\r\n  real32_T SFunctionBuilder_o2;        /* '<S29>/S-Function Builder' */\r\n  real32_T Merge;                      /* '<S25>/Merge' */\r\n  real32_T Gain;                       /* '<S26>/Gain' */\r\n  real32_T UnitDelay;                  /* '<S69>/Unit Delay' */\r\n  real32_T LookupP_o1;                 /* '<S66>/Look up P' */\r\n  real32_T LookupP_o2;                 /* '<S66>/Look up P' */\r\n  real32_T LookupRightVector_o1;       /* '<S66>/Look up Right Vector' */\r\n  real32_T LookupRightVector_o2;       /* '<S66>/Look up Right Vector' */\r\n  real32_T Sum1;                       /* '<S71>/Sum1' */\r\n  real32_T LookupRightVector1_o1;      /* '<S44>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2;      /* '<S44>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1;                /* '<S44>/Look up P1' */\r\n  real32_T LookupP1_o2;                /* '<S44>/Look up P1' */\r\n  real32_T LookupRightVector1_o1_j;    /* '<S51>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2_m;    /* '<S51>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1_j;              /* '<S51>/Look up P1' */\r\n  real32_T LookupP1_o2_m;              /* '<S51>/Look up P1' */\r\n  real32_T LookupRightVector1_o1_i;    /* '<S52>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2_d;    /* '<S52>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1_f;              /* '<S52>/Look up P1' */\r\n  real32_T LookupP1_o2_p;              /* '<S52>/Look up P1' */\r\n  real32_T LookupRightVector1_o1_a;    /* '<S53>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2_j;    /* '<S53>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1_jz;             /* '<S53>/Look up P1' */\r\n  real32_T LookupP1_o2_pi;             /* '<S53>/Look up P1' */\r\n  real32_T LookupRightVector1_o1_c;    /* '<S54>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2_e;    /* '<S54>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1_a;              /* '<S54>/Look up P1' */\r\n  real32_T LookupP1_o2_l;              /* '<S54>/Look up P1' */\r\n  real32_T LookupRightVector1_o1_iv;   /* '<S55>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2_f;    /* '<S55>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1_c;              /* '<S55>/Look up P1' */\r\n  real32_T LookupP1_o2_e;              /* '<S55>/Look up P1' */\r\n  real32_T LookupRightVector1_o1_je;   /* '<S56>/Look up Right Vector1' */\r\n  real32_T LookupRightVector1_o2_b;    /* '<S56>/Look up Right Vector1' */\r\n  real32_T LookupP1_o1_g;              /* '<S56>/Look up P1' */\r\n  real32_T LookupP1_o2_n;              /* '<S56>/Look up P1' */\r\n  real32_T LookupRightVector_o1_j;     /* '<S65>/Look up Right Vector' */\r\n  real32_T LookupRightVector_o2_f;     /* '<S65>/Look up Right Vector' */\r\n  real32_T Product1;                   /* '<S64>/Product1' */\r\n  real32_T Saturation;                 /* '<S57>/Saturation' */\r\n  real32_T LookupRightVector_o1_i;     /* '<S68>/Look up Right Vector' */\r\n  real32_T LookupRightVector_o2_fo;    /* '<S68>/Look up Right Vector' */\r\n  real32_T DiscreteTimeIntegrator;     /* '<S60>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator2;    /* '<S62>/Discrete-Time Integrator2' */\r\n  real32_T SFunctionBuilder_o1_b;      /* '<S61>/S-Function Builder' */\r\n  real32_T SFunctionBuilder_o2_i;      /* '<S61>/S-Function Builder' */\r\n  real32_T SFunctionBuilder_o3;        /* '<S61>/S-Function Builder' */\r\n  real32_T ByteUnpacking_o1;           /* '<S24>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2;           /* '<S24>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_f;         /* '<S23>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_n;         /* '<S23>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_f4;        /* '<S22>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_m;         /* '<S22>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_o;         /* '<S21>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_j;         /* '<S21>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_c;         /* '<S20>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_c;         /* '<S20>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_o0;        /* '<S19>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_p;         /* '<S19>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_a;         /* '<S18>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_j1;        /* '<S18>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_i;         /* '<S17>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_i;         /* '<S17>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_az;        /* '<S16>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_b;         /* '<S16>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_o3;        /* '<S15>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_h;         /* '<S15>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_b;         /* '<S14>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_nz;        /* '<S14>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o1_m;         /* '<S13>/Byte Unpacking ' */\r\n  real32_T ByteUnpacking_o2_k;         /* '<S13>/Byte Unpacking ' */\r\n  uint16_T FCAN_Isr_o6;                /* '<S1>/FCAN_Isr' */\r\n  uint16_T Quadrature_Decoder_o1;      /* '<S38>/Quadrature_Decoder' */\r\n  uint8_T RT1[90];                     /* '<S4>/RT1' */\r\n  uint8_T FCAN_Isr_o2;                 /* '<S1>/FCAN_Isr' */\r\n  uint8_T FCAN_Isr_o4[8];              /* '<S1>/FCAN_Isr' */\r\n  uint8_T FCAN_Isr_o5;                 /* '<S1>/FCAN_Isr' */\r\n  uint8_T IndexVector;                 /* '<S73>/Index Vector' */\r\n  uint8_T BytePacking[88];             /* '<S72>/Byte Packing ' */\r\n  uint8_T BytePack1[8];                /* '<S42>/Byte Pack1' */\r\n  uint8_T BytePack[8];                 /* '<S42>/Byte Pack' */\r\n  boolean_T RT_k;                      /* '<S4>/RT' */\r\n  boolean_T Digital_Input;             /* '<S26>/Digital_Input' */\r\n  boolean_T Digital_Input_g;           /* '<S36>/Digital_Input' */\r\n  boolean_T Digital_Input1;            /* '<S36>/Digital_Input1' */\r\n  boolean_T Digital_Input2;            /* '<S36>/Digital_Input2' */\r\n  boolean_T Digital_Input3;            /* '<S36>/Digital_Input3' */\r\n  boolean_T Digital_Input4;            /* '<S36>/Digital_Input4' */\r\n  boolean_T Digital_Input5;            /* '<S36>/Digital_Input5' */\r\n  boolean_T Digital_Input6;            /* '<S36>/Digital_Input6' */\r\n  boolean_T Digital_Input7;            /* '<S36>/Digital_Input7' */\r\n  boolean_T Quadrature_Decoder_o2;     /* '<S38>/Quadrature_Decoder' */\r\n  boolean_T Quadrature_Decoder_o3;     /* '<S38>/Quadrature_Decoder' */\r\n  boolean_T Quadrature_Decoder_o4;     /* '<S38>/Quadrature_Decoder' */\r\n  boolean_T Digital_Input1_b;          /* '<S26>/Digital_Input1' */\r\n  boolean_T man;                       /* '<S29>/Chart' */\r\n  boolean_T vel;                       /* '<S29>/Chart' */\r\n  boolean_T pos;                       /* '<S29>/Chart' */\r\n} B;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T Delay_DSTATE;                 /* '<S74>/Delay' */\r\n  real_T Controller_DSTATE;            /* '<S66>/Controller' */\r\n  real32_T UnitDelay_DSTATE[4];        /* '<S2>/Unit Delay' */\r\n  real32_T UnitDelay1_DSTATE;          /* '<S39>/Unit Delay1' */\r\n  real32_T UnitDelay_DSTATE_i;         /* '<S69>/Unit Delay' */\r\n  real32_T DiscreteTimeIntegrator_DSTATE;/* '<S60>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator2_DSTATE;/* '<S62>/Discrete-Time Integrator2' */\r\n  real32_T DiscreteTimeIntegrator_DSTATE_k;/* '<S62>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_DSTATE;/* '<S62>/Discrete-Time Integrator1' */\r\n  real32_T UnitDelay_DSTATE_o;         /* '<S35>/Unit Delay' */\r\n  real32_T RateTransition_Buffer[22];  /* '<Root>/Rate Transition' */\r\n  real32_T DiscreteTimeIntegrator_PREV_U;/* '<S60>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator2_PREV_U;/* '<S62>/Discrete-Time Integrator2' */\r\n  real32_T DiscreteTimeIntegrator_PREV_U_d;/* '<S62>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_PREV_U;/* '<S62>/Discrete-Time Integrator1' */\r\n  uint32_T HighLevelDesign_PREV_T;     /* '<Root>/High Level Design' */\r\n  int_T BytePacking_IWORK[2];          /* '<S72>/Byte Packing ' */\r\n  uint16_T UnitDelay_DSTATE_c;         /* '<S39>/Unit Delay' */\r\n  boolean_T Delay_DSTATE_j;            /* '<S72>/Delay' */\r\n  uint8_T RT1_Buffer0[90];             /* '<S4>/RT1' */\r\n  uint8_T DiscreteTimeIntegrator_SYSTEM_E;/* '<S60>/Discrete-Time Integrator' */\r\n  uint8_T DiscreteTimeIntegrator2_SYSTEM_;/* '<S62>/Discrete-Time Integrator2' */\r\n  uint8_T DiscreteTimeIntegrator_SYSTEM_b;/* '<S62>/Discrete-Time Integrator' */\r\n  uint8_T DiscreteTimeIntegrator1_SYSTEM_;/* '<S62>/Discrete-Time Integrator1' */\r\n  uint8_T is_c3_Final_project_template;/* '<S29>/Chart' */\r\n  uint8_T is_active_c3_Final_project_temp;/* '<S29>/Chart' */\r\n  boolean_T RT_Buffer0;                /* '<S4>/RT' */\r\n  boolean_T HighLevelDesign_RESET_ELAPS_T;/* '<Root>/High Level Design' */\r\n  DW_SwitchCaseActionSubsystem3 SwitchCaseActionSubsystem3_f;\r\n                                     /* '<S12>/Switch Case Action Subsystem3' */\r\n  DW_SwitchCaseActionSubsystem2 SwitchCaseActionSubsystem2_p;\r\n                                     /* '<S12>/Switch Case Action Subsystem2' */\r\n  DW_SwitchCaseActionSubsystem3 SwitchCaseActionSubsystem3_h;\r\n                                     /* '<S11>/Switch Case Action Subsystem3' */\r\n  DW_SwitchCaseActionSubsystem2 SwitchCaseActionSubsystem2_m0;\r\n                                     /* '<S11>/Switch Case Action Subsystem2' */\r\n  DW_SwitchCaseActionSubsystem3 SwitchCaseActionSubsystem3_o;\r\n                                     /* '<S10>/Switch Case Action Subsystem3' */\r\n  DW_SwitchCaseActionSubsystem2 SwitchCaseActionSubsystem2_e;\r\n                                     /* '<S10>/Switch Case Action Subsystem2' */\r\n  DW_SwitchCaseActionSubsystem3 SwitchCaseActionSubsystem3_l;\r\n                                      /* '<S9>/Switch Case Action Subsystem3' */\r\n  DW_SwitchCaseActionSubsystem2 SwitchCaseActionSubsystem2_c;\r\n                                      /* '<S9>/Switch Case Action Subsystem2' */\r\n  DW_SwitchCaseActionSubsystem3 SwitchCaseActionSubsystem3_n;\r\n                                      /* '<S8>/Switch Case Action Subsystem3' */\r\n  DW_SwitchCaseActionSubsystem2 SwitchCaseActionSubsystem2_m;\r\n                                      /* '<S8>/Switch Case Action Subsystem2' */\r\n  DW_SwitchCaseActionSubsystem3 SwitchCaseActionSubsystem3_d;\r\n                                      /* '<S7>/Switch Case Action Subsystem3' */\r\n  DW_SwitchCaseActionSubsystem2 SwitchCaseActionSubsystem2_a;\r\n                                      /* '<S7>/Switch Case Action Subsystem2' */\r\n} DW;\r\n\r\n/* Zero-crossing (trigger) state */\r\ntypedef struct {\r\n  ZCSigState ResettableSubsystem_Reset_ZCE;/* '<S73>/Resettable Subsystem' */\r\n} PrevZCX;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Pooled Parameter (Expression: single(1))\r\n   * Referenced by: '<S61>/S-Function Builder'\r\n   */\r\n  real32_T pooled6;\r\n} ConstP;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick1;\r\n    struct {\r\n      uint8_T TID[3];\r\n    } TaskCounters;\r\n\r\n    struct {\r\n      boolean_T TID0_2;\r\n      boolean_T TID1_2;\r\n    } RateInteraction;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B rtB;\r\n\r\n/* Block states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* Zero-crossing (trigger) state */\r\nextern PrevZCX rtPrevZCX;\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP rtConstP;\r\n\r\n/* External function called from main */\r\nextern void Final_project_template_SetEventsForThisBaseStep(boolean_T\r\n  *eventFlags);\r\n\r\n/* Model entry point functions */\r\nextern void Final_project_template_initialize(void);\r\nextern void Final_project_template_step0(void);\r\nextern void Final_project_template_step1(void);\r\nextern void Final_project_template_step2(void);\r\nextern void Final_project_template_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S29>/Display' : Unused code path elimination\r\n * Block '<S29>/Display1' : Unused code path elimination\r\n * Block '<S29>/Display2' : Unused code path elimination\r\n * Block '<S29>/Scope' : Unused code path elimination\r\n * Block '<S67>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S36>/Shift Arithmetic' : Eliminated trivial shift\r\n * Block '<S39>/Data Type Conversion' : Eliminate redundant data type conversion\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'Final_project_template'\r\n * '<S1>'   : 'Final_project_template/Can Network Inputs'\r\n * '<S2>'   : 'Final_project_template/High Level Design'\r\n * '<S3>'   : 'Final_project_template/SC Filter'\r\n * '<S4>'   : 'Final_project_template/Serial Sim Out to Virtual Sim'\r\n * '<S5>'   : 'Final_project_template/Can Network Inputs/Can Message Mailbox Setup'\r\n * '<S6>'   : 'Final_project_template/Can Network Inputs/Extract CAN data'\r\n * '<S7>'   : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us '\r\n * '<S8>'   : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 1'\r\n * '<S9>'   : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 2'\r\n * '<S10>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 3'\r\n * '<S11>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 4'\r\n * '<S12>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 5'\r\n * '<S13>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us /Switch Case Action Subsystem2'\r\n * '<S14>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us /Switch Case Action Subsystem3'\r\n * '<S15>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 1/Switch Case Action Subsystem2'\r\n * '<S16>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 1/Switch Case Action Subsystem3'\r\n * '<S17>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 2/Switch Case Action Subsystem2'\r\n * '<S18>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 2/Switch Case Action Subsystem3'\r\n * '<S19>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 3/Switch Case Action Subsystem2'\r\n * '<S20>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 3/Switch Case Action Subsystem3'\r\n * '<S21>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 4/Switch Case Action Subsystem2'\r\n * '<S22>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 4/Switch Case Action Subsystem3'\r\n * '<S23>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 5/Switch Case Action Subsystem2'\r\n * '<S24>'  : 'Final_project_template/Can Network Inputs/Extract CAN data/Data to s,n,psi,us 5/Switch Case Action Subsystem3'\r\n * '<S25>'  : 'Final_project_template/High Level Design/ACC'\r\n * '<S26>'  : 'Final_project_template/High Level Design/Inputs'\r\n * '<S27>'  : 'Final_project_template/High Level Design/Outputs'\r\n * '<S28>'  : 'Final_project_template/High Level Design/Vehicle Dynamics'\r\n * '<S29>'  : 'Final_project_template/High Level Design/ACC/ACC State Logic'\r\n * '<S30>'  : 'Final_project_template/High Level Design/ACC/Enabled Subsystem'\r\n * '<S31>'  : 'Final_project_template/High Level Design/ACC/Position Ctrl'\r\n * '<S32>'  : 'Final_project_template/High Level Design/ACC/Speed Ctrl'\r\n * '<S33>'  : 'Final_project_template/High Level Design/ACC/ACC State Logic/Chart'\r\n * '<S34>'  : 'Final_project_template/High Level Design/ACC/Speed Ctrl/PI'\r\n * '<S35>'  : 'Final_project_template/High Level Design/ACC/Speed Ctrl/PI/My Discrete Integrator'\r\n * '<S36>'  : 'Final_project_template/High Level Design/Inputs/Select Speed (GPI 122-129)'\r\n * '<S37>'  : 'Final_project_template/High Level Design/Inputs/Throttle (Potentiometer)'\r\n * '<S38>'  : 'Final_project_template/High Level Design/Inputs/get wheel position'\r\n * '<S39>'  : 'Final_project_template/High Level Design/Inputs/get wheel position/Subsystem'\r\n * '<S40>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi'\r\n * '<S41>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)'\r\n * '<S42>'  : 'Final_project_template/High Level Design/Outputs/Tx CAN'\r\n * '<S43>'  : 'Final_project_template/High Level Design/Outputs/write torque'\r\n * '<S44>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi/s,n to x,y'\r\n * '<S45>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi'\r\n * '<S46>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi1'\r\n * '<S47>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi2'\r\n * '<S48>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi3'\r\n * '<S49>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi4'\r\n * '<S50>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi5'\r\n * '<S51>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi/s,n to x,y'\r\n * '<S52>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi1/s,n to x,y'\r\n * '<S53>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi2/s,n to x,y'\r\n * '<S54>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi3/s,n to x,y'\r\n * '<S55>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi4/s,n to x,y'\r\n * '<S56>'  : 'Final_project_template/High Level Design/Outputs/Extract x,y,psi (Cars 1 - 6)/Extract x,y,psi5/s,n to x,y'\r\n * '<S57>'  : 'Final_project_template/High Level Design/Outputs/write torque/Write_Reaction_Torque'\r\n * '<S58>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/Vehicle Dynamics'\r\n * '<S59>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs'\r\n * '<S60>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/Vehicle Dynamics/Subsystem'\r\n * '<S61>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/Vehicle Dynamics/Subsystem1'\r\n * '<S62>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/Vehicle Dynamics/Subsystem2'\r\n * '<S63>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform'\r\n * '<S64>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/projected velocity'\r\n * '<S65>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/Look up Forward Vector'\r\n * '<S66>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/x,y to s,n'\r\n * '<S67>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/x,y to s,n/Data Type Conversion Inherited'\r\n * '<S68>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/x,y to s,n/Look up the Forward Vector'\r\n * '<S69>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/x,y to s,n/My Discrete Integrator'\r\n * '<S70>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/x,y to s,n/My Dot Product1'\r\n * '<S71>'  : 'Final_project_template/High Level Design/Vehicle Dynamics/outputs/coordinate transform/x,y to s,n/My Dot Product2'\r\n * '<S72>'  : 'Final_project_template/Serial Sim Out to Virtual Sim/Serial'\r\n * '<S73>'  : 'Final_project_template/Serial Sim Out to Virtual Sim/UART Iteration'\r\n * '<S74>'  : 'Final_project_template/Serial Sim Out to Virtual Sim/UART Iteration/Resettable Subsystem'\r\n */\r\n#endif                                /* RTW_HEADER_Final_project_template_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Final_project_template_private.h","type":"header","group":"model","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Final_project_template_private.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Final_project_template_private_h_\r\n#define RTW_HEADER_Final_project_template_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"Final_project_template.h\"\r\n#include \"Final_project_template_types.h\"\r\n#include \"path_data.h\"\r\n#include \"path_data.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n#define SFB_EXTERN_C                   extern \"C\"\r\n#else\r\n#define SFB_EXTERN_C                   extern\r\n#endif\r\n\r\nSFB_EXTERN_C void model_Start_wrapper(const real32_T *L1, const int_T p_width0,\r\n  const real32_T *L2, const int_T p_width1);\r\nSFB_EXTERN_C void model_Outputs_wrapper(const real32_T *u,\r\n  const real32_T *delta,\r\n  const real32_T *psi,\r\n  real32_T *xdot,\r\n  real32_T *ydot,\r\n  real32_T *psidot,\r\n  const real32_T *L1, const int_T p_width0,\r\n  const real32_T *L2, const int_T p_width1);\r\nSFB_EXTERN_C void model_Terminate_wrapper(const real32_T *L1, const int_T\r\n  p_width0,\r\n  const real32_T *L2, const int_T p_width1);\r\n\r\n#undef SFB_EXTERN_C\r\n#ifdef __cplusplus\r\n#define SFB_EXTERN_C                   extern \"C\"\r\n#else\r\n#define SFB_EXTERN_C                   extern\r\n#endif\r\n\r\nSFB_EXTERN_C void ahead_logic_Start_wrapper(void);\r\nSFB_EXTERN_C void ahead_logic_Outputs_wrapper(const real32_T *u,\r\n  real32_T *s_out,\r\n  real32_T *us_out);\r\nSFB_EXTERN_C void ahead_logic_Terminate_wrapper(void);\r\n\r\n#undef SFB_EXTERN_C\r\n\r\nextern flexcan_state_t canCom0_State;\r\nextern flexcan_msgbuff_t canCom0_recvBuff16;\r\nextern flexcan_msgbuff_t canCom0_recvBuff17;\r\nextern flexcan_msgbuff_t canCom0_recvBuff12;\r\nextern flexcan_msgbuff_t canCom0_recvBuff13;\r\nextern flexcan_msgbuff_t canCom0_recvBuff2;\r\nextern flexcan_msgbuff_t canCom0_recvBuff3;\r\nextern flexcan_msgbuff_t canCom0_recvBuff14;\r\nextern flexcan_msgbuff_t canCom0_recvBuff15;\r\nextern flexcan_msgbuff_t canCom0_recvBuff4;\r\nextern flexcan_msgbuff_t canCom0_recvBuff5;\r\nextern flexcan_msgbuff_t canCom0_recvBuff6;\r\nextern flexcan_msgbuff_t canCom0_recvBuff7;\r\nextern flexcan_msgbuff_t canCom0_recvBuff8;\r\nextern flexcan_msgbuff_t canCom0_recvBuff9;\r\nextern flexcan_msgbuff_t canCom0_recvBuff10;\r\nextern flexcan_msgbuff_t canCom0_recvBuff11;\r\n\r\n#if defined(__MWERKS__)\r\n\r\ndouble fmod (double x, double y);\r\ndouble fabs (double);\r\n\r\n#endif\r\n\r\nextern void SwitchCaseActionSubsystem2(const uint8_T rtu_sn[8], real32_T *rty_s,\r\n  real32_T *rty_n);\r\nextern void SwitchCaseActionSubsystem3(const uint8_T rtu_psius[8], real32_T\r\n  *rty_psi, real32_T *rty_us);\r\n\r\n#endif                        /* RTW_HEADER_Final_project_template_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Final_project_template_types.h","type":"header","group":"model","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Final_project_template_types.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Final_project_template_types_h_\r\n#define RTW_HEADER_Final_project_template_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n#endif                          /* RTW_HEADER_Final_project_template_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"Final_project_template_data.c","type":"source","group":"data","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: Final_project_template_data.c\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Final_project_template.h\"\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP rtConstP = {\r\n  /* Pooled Parameter (Expression: single(1))\r\n   * Referenced by: '<S61>/S-Function Builder'\r\n   */\r\n  1.0F\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: multiword_types.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"utility","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: zero_crossing_types.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/* Trigger directions: falling, either, and rising */\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\n/* Previous state of a trigger signal */\r\ntypedef uint8_T ZCSigState;\r\n\r\n/* Initial value of a trigger zero crossing signal */\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\n/* Current state of a trigger signal */\r\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 }\r\n  ZCEventType;\r\n\r\n#endif                                 /* ZERO_CROSSING_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ahead_logic_wrapper.c","type":"source","group":"interface","path":"N:\\project","tag":"","groupDisplay":"Interface files","code":"\n/*\n * Include Files\n *\n */\n#if defined(MATLAB_MEX_FILE)\n#include \"tmwtypes.h\"\n#include \"simstruc_types.h\"\n#else\n#define SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#include \"rtwtypes.h\"\n#undef SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#endif\n\n\n\n/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */\n#include <math.h>\n/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */\n#define u_width 28\n#define y_width 1\n#define y_1_width 1\n\n/*\n * Create external references here.  \n *\n */\n/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */\n/* extern double func(double a); */\n/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */\n\n/*\n * Output function\n *\n */\nvoid ahead_logic_Outputs_wrapper(const real32_T *u,\n\t\t\treal32_T *s_out,\n\t\t\treal32_T *us_out)\n{\n/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */\n/* This sample sets the output equal to the input\n      y0[0] = u0[0]; \n For complex signals use: y0[0].re = u0[0].re; \n      y0[0].im = u0[0].im;\n      y1[0].re = u1[0].re;\n      y1[0].im = u1[0].im;\n */\n    int dist = 10000000;\n    int index = 0;\n    for(int i = 1; i < 7; i++) {\n        if(u[0] < u[i * 4]) {\n            if(u[i * 4] - u[0] < dist) {\n                dist = u[i * 4] - u[0];\n                index = i;\n            }\n        }\n    }\n\n    s_out[0] = u[index * 4];\n    us_out[0] = u[index * 4 + 3];\n/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */\n}\n\n\n"},{"name":"model_wrapper.c","type":"source","group":"interface","path":"N:\\project","tag":"","groupDisplay":"Interface files","code":"\n/*\n * Include Files\n *\n */\n#if defined(MATLAB_MEX_FILE)\n#include \"tmwtypes.h\"\n#include \"simstruc_types.h\"\n#else\n#define SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#include \"rtwtypes.h\"\n#undef SIMPLIFIED_RTWTYPES_COMPATIBILITY\n#endif\n\n\n\n/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */\n#include <math.h>\n/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */\n#define u_width 1\n#define u_1_width 1\n#define u_2_width 1\n#define y_width 1\n#define y_1_width 1\n#define y_2_width 1\n\n/*\n * Create external references here.  \n *\n */\n/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */\n/* extern double func(double a); */\n/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */\n\n/*\n * Output function\n *\n */\nvoid model_Outputs_wrapper(const real32_T *u,\n\t\t\tconst real32_T *delta,\n\t\t\tconst real32_T *psi,\n\t\t\treal32_T *xdot,\n\t\t\treal32_T *ydot,\n\t\t\treal32_T *psidot,\n\t\t\tconst real32_T *L1, const int_T p_width0,\n\t\t\tconst real32_T *L2, const int_T p_width1)\n{\n/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */\n/* This sample sets the output equal to the input\n      y0[0] = u0[0]; \n For complex signals use: y0[0].re = u0[0].re; \n      y0[0].im = u0[0].im;\n      y1[0].re = u1[0].re;\n      y1[0].im = u1[0].im;\n */\n    \n    xdot[0] = ((-1 * 0.8/1.6) * sin(delta[0]) * sin(psi[0]) + cos(delta[0]) * cos(psi[0])) * u[0];\n    ydot[0] = ((0.8/1.6) * sin(delta[0]) * cos(psi[0]) + cos(delta[0]) * sin(psi[0])) * u[0];\n    psidot[0] = sin(delta[0])/1.6 * u[0];\n/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */\n}\n\n\n"},{"name":"rtmodel.c","type":"source","group":"interface","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.c\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtmodel.h\"\r\n\r\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\r\nvoid Final_project_template_step(int_T tid)\r\n{\r\n  switch (tid) {\r\n   case 0 :\r\n    Final_project_template_step0();\r\n    break;\r\n\r\n   case 1 :\r\n    Final_project_template_step1();\r\n    break;\r\n\r\n   case 2 :\r\n    Final_project_template_step2();\r\n    break;\r\n\r\n   default :\r\n    /* do nothing */\r\n    break;\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"Final_project_template.h\"\r\n#define GRTINTERFACE                   0\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n\r\n/* Model wrapper function */\r\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\r\nextern void Final_project_template_step(int_T tid);\r\n\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"S32K144.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\S32K144\\include","tag":"","groupDisplay":"Other files","code":"/*\r\n** ###################################################################\r\n**     Processor:           S32K144\r\n**     Reference manual:    S32K1XXRM Rev. 12.1, 02/2020\r\n**     Version:             rev. 4.3, 2020-05-14\r\n**     Build:               b200514\r\n**\r\n**     Abstract:\r\n**         Peripheral Access Layer for S32K144\r\n**\r\n**     Copyright (c) 1997 - 2016 Freescale Semiconductor, Inc.\r\n**     Copyright 2016-2020 NXP\r\n**     All rights reserved.\r\n**\r\n**     NXP Confidential. This software is owned or controlled by NXP and may only be\r\n**     used strictly in accordance with the applicable license terms. By expressly\r\n**     accepting such terms or by downloading, installing, activating and/or otherwise\r\n**     using the software, you are agreeing that you have read, and that you agree to\r\n**     comply with and are bound by, such license terms. If you do not agree to be\r\n**     bound by the applicable license terms, then you may not retain, install,\r\n**     activate or otherwise use the software. The production use license in\r\n**     Section 2.3 is expressly granted for this software.\r\n**\r\n**     http:                 www.nxp.com\r\n**     mail:                 support@nxp.com\r\n**\r\n**     Revisions:\r\n**     - rev. 1.0 (2015-04-09) - Iulian Talpiga\r\n**         Initial version.\r\n**     - rev. 1.1 (2015-05-19) - Bogdan Nitu\r\n**         Updated interrupts table\r\n**         Removed SIM_CHIPCTL_DAC2CMP\r\n**         Compacted PORT_PCR registers\r\n**         Compacted PCC registers\r\n**     - rev. 1.2 (2015-06-02) - Bogdan Nitu\r\n**         Added 'U' suffix to all integer constants\r\n**         Use \"\" instead of <> for Platform type inclusion\r\n**         CNT register from WDOG module is RW\r\n**     - rev. 1.3 (2015-08-05) - Iulian Talpiga\r\n**         Synchronized with latest RDP\r\n**         Removed OSC32 module\r\n**         Removed reserved registers\r\n**         Incorporated bit band acces macros\r\n**         Switched to standard C99 data types\r\n**         Added 'u' to constants\r\n**         Added size defines for register arrays\r\n**         Define peripheral instance count\r\n**     - rev. 1.4 (2015-08-10) - Iulian Talpiga\r\n**         Compacted TRGMUX registers\r\n**         Defined array index offsets for PCC and TRGMUX\r\n**         Added FPU registers\r\n**         Group FTM channel registers\r\n**         Added interrupt information to peripherals\r\n**         Renamed CAN interrupts according  to the reference manual\r\n**         Added author information to revisions\r\n**     - rev. 1.5 (2015-09-16) - Iulian Talpiga\r\n**         Renamed NVIC and SCB to avoid conflict\r\n**         Compacted CAN Wake-up Message buffers\r\n**         Added CAN embedded RAM\r\n**         Updated interrupts: LPIT, FTFE, LPUART,ACMP\r\n**         Corrected ADC_SC1_ADCH_WIDTH\r\n**         Compacted PDB registers\r\n**         Corrected CAN, FTM, and PDB count defines\r\n**         Guarding register acces macro against redefintion\r\n**     - rev. 1.6 (2015-09-29) - Iulian Talpiga\r\n**         Added WATER and FIFO registers to LPUART.\r\n**     - rev. 1.7 (2015-10-21) - Iulian Talpiga\r\n**         Updated ADC, AIPS, CMP, LMEM, LPTMR, PMC, PORT, RCM, RTC, SCG, SIM\r\n**         Compacted MPU and LPIT\r\n**         Added FSL_SysTick\r\n**         Updated doxygen documentation grouping\r\n**         Updated interrupts: RCM\r\n**     - rev. 1.8 (2016-01-06) - Iulian Talpiga\r\n**         Updated DMA, compacted TCD registers\r\n**         Updated SCG, removed SC2P - SC16P\r\n**         Added 8 and 16 bit access to DATA register, CRC module\r\n**     - rev. 1.9 (2016-02-15) - Iulian Talpiga\r\n**         Updated CRC, renamed DATA union\r\n**         Updated PMC, added CLKBIASDIS bitfield\r\n**         Added FSL_NVIC registers to SVD\r\n**     - rev. 2.0 (2016-04-07) - Iulian Talpiga\r\n**         Updated support for Rev2.0 silicon (0N47T)\r\n**         Updated ADC, AIPS, DMA, FlexIO, FTM, GPIO, LPI2C, LPIT, LPSPI, MCM, MPU, MSCM, PMC, RTC, RCM, PCC, RTC, SCG, SIM, TRGMUX and WDOG  module\r\n**         Updated interrupts\r\n**         Added EIM and ERM modules\r\n**         Added EIM and ERM modules\r\n**     - rev. 2.1 (2016-06-10) - Iulian Talpiga\r\n**         Updated to latest RM\r\n**         Minor changes to: CAN, EIM, LPI2C, MPU, PCC, PMC, RTC, SIM and TRGMUX\r\n**     - rev. 2.2 (2016-08-02) - Iulian Talpiga\r\n**         Updated to latest RM\r\n**         Minor changes to: ADC, CAN, CRC, FTFC, LMEM, LPI2C, MCM, MSCM, PCC, RTC, SIM\r\n**         Added CSE_PRAM\r\n**     - rev. 2.3 (2016-09-09) - Iulian Talpiga\r\n**         Updated to latest RM\r\n**         Minor changes to: PCC, FSL_NVIC and FTM\r\n**     - rev. 2.4 (2016-09-28) - Iulian Talpiga\r\n**         Fix RAMn array size in FlexCAN\r\n**         Fix FCSESTAT bit order\r\n**         Added CP0CFG0, CP0CFG1,CP0CFG2 and CP0CFG3 in MSCM\r\n**         Fixed STIR register in FSL_NVIC\r\n**         Fixed SHPR3 and ACTLR registers in FSL_SCB\r\n**     - rev. 2.5 (2016-11-25) - Iulian Talpiga\r\n**         Fix FRAC bit-field in PCC module\r\n**         Removed BITBAND_ACCESS macros\r\n**         Added MISRA declarations\r\n**         Updated copyright\r\n**         Changed prefix of NVIC, SCB and SysTick to S32_\r\n**     - rev. 2.6 (2017-01-09) - Iulian Talpiga\r\n**         Fix interrupts for CAN, LPUART, FTFC\r\n**     - rev. 2.7 (2017-02-22) - Iulian Talpiga\r\n**         Update header as per rev S32K14XRM Rev. 2, 02/2017\r\n**         Updated modules AIPS, CAN, LPI2C, LPSPI, MCM, MPU, SCG and SIM\r\n**     - rev. 2.8 (2017-03-27) - Iulian Talpiga\r\n**         Synchronized PCC_FlexIO on S32K Family\r\n**     - rev. 3.0 (2017-08-04) - Mihai Volmer\r\n**         Update header as per rev S32K1XXRM Rev. 4, 06/2017\r\n**         Updated modules CAN, MCM and PORTn\r\n**     - rev. 3.1 (2017-09-25) - Andrei Bolojan\r\n**         Update NVIC Size of Registers Arrays\r\n**     - rev. 4.0 (2018-02-28) - Mihai Volmer\r\n**         Updated header as per rev S32K1XXRM Rev. 6, 12/2017\r\n**         Updated modules ERM, I2C, MSCM and SIM\r\n**     - rev. 4.1 (2018-07-19) - Dan Nastasa\r\n**         Updated the header based on S32K1XXRM Rev. 8, 06/2018.\r\n**     - rev. 4.2 (2019-02-19) - Ionut Pavel\r\n**         Updated the header based on S32K1XXRM Rev. 9, 09/2018.\r\n**     - rev. 4.3 (2020-05-14) - Van Nguyen Nam\r\n**         Updated the header based on S32K1XXRM Rev. 12.1, 02/2020.\r\n**\r\n** ###################################################################\r\n*/\r\n\r\n/*!\r\n * @file S32K144.h\r\n * @version 4.3\r\n * @date 2020-05-14\r\n * @brief Peripheral Access Layer for S32K144\r\n *\r\n * This file contains register definitions and macros for easy access to their\r\n * bit fields.\r\n *\r\n * This file assumes LITTLE endian system.\r\n */\r\n\r\n/**\r\n* @page misra_violations MISRA-C:2012 violations\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Advisory Rule 2.3, local typedef not referenced\r\n* The SoC header defines typedef for all modules.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Advisory Rule 2.5, local macro not referenced\r\n* The SoC header defines macros for all modules and registers.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Advisory Directive 4.9, Function-like macro\r\n* These are generated macros used for accessing the bit-fields from registers.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n* The supported compilers use more than 31 significant characters for identifiers.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n* The supported compilers use more than 31 significant characters for identifiers.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n* The supported compilers use more than 31 significant characters for identifiers.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n* The supported compilers use more than 31 significant characters for identifiers.\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Required Rule 21.1, defined macro '__I' is reserved to the compiler\r\n* This type qualifier is needed to ensure correct I/O access and addressing.\r\n*/\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MCU activation\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/* Prevention from multiple including the same memory map */\r\n#if !defined(S32K144_H_)  /* Check if memory map has not been already included */\r\n#define S32K144_H_\r\n#define MCU_S32K144\r\n\r\n/* Check if another memory map has not been also included */\r\n#if (defined(MCU_ACTIVE))\r\n  #error S32K144 memory map: There is already included another memory map. Only one memory map can be included.\r\n#endif /* (defined(MCU_ACTIVE)) */\r\n#define MCU_ACTIVE\r\n\r\n#include <stdint.h>\r\n\r\n/** Memory map major version (memory maps with equal major version number are\r\n * compatible) */\r\n#define MCU_MEM_MAP_VERSION 0x0400u\r\n/** Memory map minor version */\r\n#define MCU_MEM_MAP_VERSION_MINOR 0x0002u\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- Generic macros\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/* IO definitions (access restrictions to peripheral registers) */\r\n/**\r\n*   IO Type Qualifiers are used\r\n*   \\li to specify the access to peripheral variables.\r\n*   \\li for automatic generation of peripheral register debug information.\r\n*/\r\n#ifndef __IO\r\n#ifdef __cplusplus\r\n  #define   __I     volatile             /*!< Defines 'read only' permissions                 */\r\n#else\r\n  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */\r\n#endif\r\n#define     __O     volatile             /*!< Defines 'write only' permissions                */\r\n#define     __IO    volatile             /*!< Defines 'read / write' permissions              */\r\n#endif\r\n\r\n\r\n/**\r\n* @brief 32 bits memory read macro.\r\n*/\r\n#if !defined(REG_READ32)\r\n  #define REG_READ32(address)               (*(volatile uint32_t*)(address))\r\n#endif\r\n\r\n/**\r\n* @brief 32 bits memory write macro.\r\n*/\r\n#if !defined(REG_WRITE32)\r\n  #define REG_WRITE32(address, value)       ((*(volatile uint32_t*)(address))= (uint32_t)(value))\r\n#endif\r\n\r\n/**\r\n* @brief 32 bits bits setting macro.\r\n*/\r\n#if !defined(REG_BIT_SET32)\r\n  #define REG_BIT_SET32(address, mask)      ((*(volatile uint32_t*)(address))|= (uint32_t)(mask))\r\n#endif\r\n\r\n/**\r\n* @brief 32 bits bits clearing macro.\r\n*/\r\n#if !defined(REG_BIT_CLEAR32)\r\n  #define REG_BIT_CLEAR32(address, mask)    ((*(volatile uint32_t*)(address))&= ((uint32_t)~((uint32_t)(mask))))\r\n#endif\r\n\r\n/**\r\n* @brief 32 bit clear bits and set with new value\r\n* @note It is user's responsability to make sure that value has only \"mask\" bits set - (value&~mask)==0\r\n*/\r\n#if !defined(REG_RMW32)\r\n  #define REG_RMW32(address, mask, value)   (REG_WRITE32((address), ((REG_READ32(address)& ((uint32_t)~((uint32_t)(mask))))| ((uint32_t)(value)))))\r\n#endif\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- Interrupt vector numbers for S32K144\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup Interrupt_vector_numbers_S32K144 Interrupt vector numbers for S32K144\r\n * @{\r\n */\r\n\r\n/** Interrupt Number Definitions */\r\n#define NUMBER_OF_INT_VECTORS 139u               /**< Number of interrupts in the Vector table */\r\n\r\n/**\r\n * @brief Defines the Interrupt Numbers definitions\r\n *\r\n * This enumeration is used to configure the interrupts.\r\n *\r\n * Implements : IRQn_Type_Class\r\n */\r\ntypedef enum\r\n{\r\n  /* Auxiliary constants */\r\n  NotAvail_IRQn                = -128,             /**< Not available device specific interrupt */\r\n\r\n  /* Core interrupts */\r\n  NonMaskableInt_IRQn          = -14,              /**< Non Maskable Interrupt */\r\n  HardFault_IRQn               = -13,              /**< Cortex-M4 SV Hard Fault Interrupt */\r\n  MemoryManagement_IRQn        = -12,              /**< Cortex-M4 Memory Management Interrupt */\r\n  BusFault_IRQn                = -11,              /**< Cortex-M4 Bus Fault Interrupt */\r\n  UsageFault_IRQn              = -10,              /**< Cortex-M4 Usage Fault Interrupt */\r\n  SVCall_IRQn                  = -5,               /**< Cortex-M4 SV Call Interrupt */\r\n  DebugMonitor_IRQn            = -4,               /**< Cortex-M4 Debug Monitor Interrupt */\r\n  PendSV_IRQn                  = -2,               /**< Cortex-M4 Pend SV Interrupt */\r\n  SysTick_IRQn                 = -1,               /**< Cortex-M4 System Tick Interrupt */\r\n\r\n  /* Device specific interrupts */\r\n  DMA0_IRQn                    = 0u,               /**< DMA channel 0 transfer complete */\r\n  DMA1_IRQn                    = 1u,               /**< DMA channel 1 transfer complete */\r\n  DMA2_IRQn                    = 2u,               /**< DMA channel 2 transfer complete */\r\n  DMA3_IRQn                    = 3u,               /**< DMA channel 3 transfer complete */\r\n  DMA4_IRQn                    = 4u,               /**< DMA channel 4 transfer complete */\r\n  DMA5_IRQn                    = 5u,               /**< DMA channel 5 transfer complete */\r\n  DMA6_IRQn                    = 6u,               /**< DMA channel 6 transfer complete */\r\n  DMA7_IRQn                    = 7u,               /**< DMA channel 7 transfer complete */\r\n  DMA8_IRQn                    = 8u,               /**< DMA channel 8 transfer complete */\r\n  DMA9_IRQn                    = 9u,               /**< DMA channel 9 transfer complete */\r\n  DMA10_IRQn                   = 10u,              /**< DMA channel 10 transfer complete */\r\n  DMA11_IRQn                   = 11u,              /**< DMA channel 11 transfer complete */\r\n  DMA12_IRQn                   = 12u,              /**< DMA channel 12 transfer complete */\r\n  DMA13_IRQn                   = 13u,              /**< DMA channel 13 transfer complete */\r\n  DMA14_IRQn                   = 14u,              /**< DMA channel 14 transfer complete */\r\n  DMA15_IRQn                   = 15u,              /**< DMA channel 15 transfer complete */\r\n  DMA_Error_IRQn               = 16u,              /**< DMA error interrupt channels 0-15 */\r\n  MCM_IRQn                     = 17u,              /**< FPU sources */\r\n  FTFC_IRQn                    = 18u,              /**< FTFC Command complete */\r\n  Read_Collision_IRQn          = 19u,              /**< FTFC Read collision */\r\n  LVD_LVW_IRQn                 = 20u,              /**< PMC Low voltage detect interrupt */\r\n  FTFC_Fault_IRQn              = 21u,              /**< FTFC Double bit fault detect */\r\n  WDOG_EWM_IRQn                = 22u,              /**< Single interrupt vector for WDOG and EWM */\r\n  RCM_IRQn                     = 23u,              /**< RCM Asynchronous Interrupt */\r\n  LPI2C0_Master_IRQn           = 24u,              /**< LPI2C0 Master Interrupt */\r\n  LPI2C0_Slave_IRQn            = 25u,              /**< LPI2C0 Slave Interrupt */\r\n  LPSPI0_IRQn                  = 26u,              /**< LPSPI0 Interrupt */\r\n  LPSPI1_IRQn                  = 27u,              /**< LPSPI1 Interrupt */\r\n  LPSPI2_IRQn                  = 28u,              /**< LPSPI2 Interrupt */\r\n  LPUART0_RxTx_IRQn            = 31u,              /**< LPUART0 Transmit / Receive Interrupt */\r\n  LPUART1_RxTx_IRQn            = 33u,              /**< LPUART1 Transmit / Receive  Interrupt */\r\n  LPUART2_RxTx_IRQn            = 35u,              /**< LPUART2 Transmit / Receive  Interrupt */\r\n  ADC0_IRQn                    = 39u,              /**< ADC0 interrupt request. */\r\n  ADC1_IRQn                    = 40u,              /**< ADC1 interrupt request. */\r\n  CMP0_IRQn                    = 41u,              /**< CMP0 interrupt request */\r\n  ERM_single_fault_IRQn        = 44u,              /**< ERM single bit error correction */\r\n  ERM_double_fault_IRQn        = 45u,              /**< ERM double bit error non-correctable */\r\n  RTC_IRQn                     = 46u,              /**< RTC alarm interrupt */\r\n  RTC_Seconds_IRQn             = 47u,              /**< RTC seconds interrupt */\r\n  LPIT0_Ch0_IRQn               = 48u,              /**< LPIT0 channel 0 overflow interrupt */\r\n  LPIT0_Ch1_IRQn               = 49u,              /**< LPIT0 channel 1 overflow interrupt */\r\n  LPIT0_Ch2_IRQn               = 50u,              /**< LPIT0 channel 2 overflow interrupt */\r\n  LPIT0_Ch3_IRQn               = 51u,              /**< LPIT0 channel 3 overflow interrupt */\r\n  PDB0_IRQn                    = 52u,              /**< PDB0 interrupt */\r\n  SCG_IRQn                     = 57u,              /**< SCG bus interrupt request */\r\n  LPTMR0_IRQn                  = 58u,              /**< LPTIMER interrupt request */\r\n  PORTA_IRQn                   = 59u,              /**< Port A pin detect interrupt */\r\n  PORTB_IRQn                   = 60u,              /**< Port B pin detect interrupt */\r\n  PORTC_IRQn                   = 61u,              /**< Port C pin detect interrupt */\r\n  PORTD_IRQn                   = 62u,              /**< Port D pin detect interrupt */\r\n  PORTE_IRQn                   = 63u,              /**< Port E pin detect interrupt */\r\n  SWI_IRQn                     = 64u,              /**< Software interrupt */\r\n  PDB1_IRQn                    = 68u,              /**< PDB1 interrupt */\r\n  FLEXIO_IRQn                  = 69u,              /**< FlexIO Interrupt */\r\n  CAN0_ORed_IRQn               = 78u,              /**< CAN0 OR'ed [Bus Off OR Transmit Warning OR Receive Warning] */\r\n  CAN0_Error_IRQn              = 79u,              /**< CAN0 Interrupt indicating that errors were detected on the CAN bus */\r\n  CAN0_Wake_Up_IRQn            = 80u,              /**< CAN0 Interrupt asserted when Pretended Networking operation is enabled, and a valid message matches the selected filter criteria during Low Power mode */\r\n  CAN0_ORed_0_15_MB_IRQn       = 81u,              /**< CAN0 OR'ed Message buffer (0-15) */\r\n  CAN0_ORed_16_31_MB_IRQn      = 82u,              /**< CAN0 OR'ed Message buffer (16-31) */\r\n  CAN1_ORed_IRQn               = 85u,              /**< CAN1 OR'ed [Bus Off OR Transmit Warning OR Receive Warning] */\r\n  CAN1_Error_IRQn              = 86u,              /**< CAN1 Interrupt indicating that errors were detected on the CAN bus */\r\n  CAN1_ORed_0_15_MB_IRQn       = 88u,              /**< CAN1 OR'ed Interrupt for Message buffer (0-15) */\r\n  CAN2_ORed_IRQn               = 92u,              /**< CAN2 OR'ed [Bus Off OR Transmit Warning OR Receive Warning] */\r\n  CAN2_Error_IRQn              = 93u,              /**< CAN2 Interrupt indicating that errors were detected on the CAN bus */\r\n  CAN2_ORed_0_15_MB_IRQn       = 95u,              /**< CAN2 OR'ed Message buffer (0-15) */\r\n  FTM0_Ch0_Ch1_IRQn            = 99u,              /**< FTM0 Channel 0 and 1 interrupt */\r\n  FTM0_Ch2_Ch3_IRQn            = 100u,             /**< FTM0 Channel 2 and 3 interrupt */\r\n  FTM0_Ch4_Ch5_IRQn            = 101u,             /**< FTM0 Channel 4 and 5 interrupt */\r\n  FTM0_Ch6_Ch7_IRQn            = 102u,             /**< FTM0 Channel 6 and 7 interrupt */\r\n  FTM0_Fault_IRQn              = 103u,             /**< FTM0 Fault interrupt */\r\n  FTM0_Ovf_Reload_IRQn         = 104u,             /**< FTM0 Counter overflow and Reload interrupt */\r\n  FTM1_Ch0_Ch1_IRQn            = 105u,             /**< FTM1 Channel 0 and 1 interrupt */\r\n  FTM1_Ch2_Ch3_IRQn            = 106u,             /**< FTM1 Channel 2 and 3 interrupt */\r\n  FTM1_Ch4_Ch5_IRQn            = 107u,             /**< FTM1 Channel 4 and 5 interrupt */\r\n  FTM1_Ch6_Ch7_IRQn            = 108u,             /**< FTM1 Channel 6 and 7 interrupt */\r\n  FTM1_Fault_IRQn              = 109u,             /**< FTM1 Fault interrupt */\r\n  FTM1_Ovf_Reload_IRQn         = 110u,             /**< FTM1 Counter overflow and Reload interrupt */\r\n  FTM2_Ch0_Ch1_IRQn            = 111u,             /**< FTM2 Channel 0 and 1 interrupt */\r\n  FTM2_Ch2_Ch3_IRQn            = 112u,             /**< FTM2 Channel 2 and 3 interrupt */\r\n  FTM2_Ch4_Ch5_IRQn            = 113u,             /**< FTM2 Channel 4 and 5 interrupt */\r\n  FTM2_Ch6_Ch7_IRQn            = 114u,             /**< FTM2 Channel 6 and 7 interrupt */\r\n  FTM2_Fault_IRQn              = 115u,             /**< FTM2 Fault interrupt */\r\n  FTM2_Ovf_Reload_IRQn         = 116u,             /**< FTM2 Counter overflow and Reload interrupt */\r\n  FTM3_Ch0_Ch1_IRQn            = 117u,             /**< FTM3 Channel 0 and 1 interrupt */\r\n  FTM3_Ch2_Ch3_IRQn            = 118u,             /**< FTM3 Channel 2 and 3 interrupt */\r\n  FTM3_Ch4_Ch5_IRQn            = 119u,             /**< FTM3 Channel 4 and 5 interrupt */\r\n  FTM3_Ch6_Ch7_IRQn            = 120u,             /**< FTM3 Channel 6 and 7 interrupt */\r\n  FTM3_Fault_IRQn              = 121u,             /**< FTM3 Fault interrupt */\r\n  FTM3_Ovf_Reload_IRQn         = 122u              /**< FTM3 Counter overflow and Reload interrupt */\r\n} IRQn_Type;\r\n\r\n/*!\r\n * @}\r\n */ /* end of group Interrupt_vector_numbers_S32K144 */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- Device Peripheral Access Layer for S32K144\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup Peripheral_access_layer_S32K144 Device Peripheral Access Layer for S32K144\r\n * @{\r\n */\r\n\r\n/* @brief This module covers memory mapped registers available on SoC */\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- ADC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup ADC_Peripheral_Access_Layer ADC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** ADC - Size of Registers Arrays */\r\n#define ADC_SC1_COUNT                            16u\r\n#define ADC_R_COUNT                              16u\r\n#define ADC_CV_COUNT                             2u\r\n\r\n/** ADC - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t SC1[ADC_SC1_COUNT];                /**< ADC Status and Control Register 1, array offset: 0x0, array step: 0x4 */\r\n  __IO uint32_t CFG1;                              /**< ADC Configuration Register 1, offset: 0x40 */\r\n  __IO uint32_t CFG2;                              /**< ADC Configuration Register 2, offset: 0x44 */\r\n  __I  uint32_t R[ADC_R_COUNT];                    /**< ADC Data Result Registers, array offset: 0x48, array step: 0x4 */\r\n  __IO uint32_t CV[ADC_CV_COUNT];                  /**< Compare Value Registers, array offset: 0x88, array step: 0x4 */\r\n  __IO uint32_t SC2;                               /**< Status and Control Register 2, offset: 0x90 */\r\n  __IO uint32_t SC3;                               /**< Status and Control Register 3, offset: 0x94 */\r\n  __IO uint32_t BASE_OFS;                          /**< BASE Offset Register, offset: 0x98 */\r\n  __IO uint32_t OFS;                               /**< ADC Offset Correction Register, offset: 0x9C */\r\n  __IO uint32_t USR_OFS;                           /**< USER Offset Correction Register, offset: 0xA0 */\r\n  __IO uint32_t XOFS;                              /**< ADC X Offset Correction Register, offset: 0xA4 */\r\n  __IO uint32_t YOFS;                              /**< ADC Y Offset Correction Register, offset: 0xA8 */\r\n  __IO uint32_t G;                                 /**< ADC Gain Register, offset: 0xAC */\r\n  __IO uint32_t UG;                                /**< ADC User Gain Register, offset: 0xB0 */\r\n  __IO uint32_t CLPS;                              /**< ADC General Calibration Value Register S, offset: 0xB4 */\r\n  __IO uint32_t CLP3;                              /**< ADC Plus-Side General Calibration Value Register 3, offset: 0xB8 */\r\n  __IO uint32_t CLP2;                              /**< ADC Plus-Side General Calibration Value Register 2, offset: 0xBC */\r\n  __IO uint32_t CLP1;                              /**< ADC Plus-Side General Calibration Value Register 1, offset: 0xC0 */\r\n  __IO uint32_t CLP0;                              /**< ADC Plus-Side General Calibration Value Register 0, offset: 0xC4 */\r\n  __IO uint32_t CLPX;                              /**< ADC Plus-Side General Calibration Value Register X, offset: 0xC8 */\r\n  __IO uint32_t CLP9;                              /**< ADC Plus-Side General Calibration Value Register 9, offset: 0xCC */\r\n  __IO uint32_t CLPS_OFS;                          /**< ADC General Calibration Offset Value Register S, offset: 0xD0 */\r\n  __IO uint32_t CLP3_OFS;                          /**< ADC Plus-Side General Calibration Offset Value Register 3, offset: 0xD4 */\r\n  __IO uint32_t CLP2_OFS;                          /**< ADC Plus-Side General Calibration Offset Value Register 2, offset: 0xD8 */\r\n  __IO uint32_t CLP1_OFS;                          /**< ADC Plus-Side General Calibration Offset Value Register 1, offset: 0xDC */\r\n  __IO uint32_t CLP0_OFS;                          /**< ADC Plus-Side General Calibration Offset Value Register 0, offset: 0xE0 */\r\n  __IO uint32_t CLPX_OFS;                          /**< ADC Plus-Side General Calibration Offset Value Register X, offset: 0xE4 */\r\n  __IO uint32_t CLP9_OFS;                          /**< ADC Plus-Side General Calibration Offset Value Register 9, offset: 0xE8 */\r\n} ADC_Type, *ADC_MemMapPtr;\r\n\r\n /** Number of instances of the ADC module. */\r\n#define ADC_INSTANCE_COUNT                       (2u)\r\n\r\n\r\n/* ADC - Peripheral instance base addresses */\r\n/** Peripheral ADC0 base address */\r\n#define ADC0_BASE                                (0x4003B000u)\r\n/** Peripheral ADC0 base pointer */\r\n#define ADC0                                     ((ADC_Type *)ADC0_BASE)\r\n/** Peripheral ADC1 base address */\r\n#define ADC1_BASE                                (0x40027000u)\r\n/** Peripheral ADC1 base pointer */\r\n#define ADC1                                     ((ADC_Type *)ADC1_BASE)\r\n/** Array initializer of ADC peripheral base addresses */\r\n#define ADC_BASE_ADDRS                           { ADC0_BASE, ADC1_BASE }\r\n/** Array initializer of ADC peripheral base pointers */\r\n#define ADC_BASE_PTRS                            { ADC0, ADC1 }\r\n /** Number of interrupt vector arrays for the ADC module. */\r\n#define ADC_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the ADC module. */\r\n#define ADC_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the ADC peripheral type */\r\n#define ADC_IRQS                                 { ADC0_IRQn, ADC1_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- ADC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup ADC_Register_Masks ADC Register Masks\r\n * @{\r\n */\r\n\r\n/* SC1 Bit Fields */\r\n#define ADC_SC1_ADCH_MASK                        0x1Fu\r\n#define ADC_SC1_ADCH_SHIFT                       0u\r\n#define ADC_SC1_ADCH_WIDTH                       5u\r\n#define ADC_SC1_ADCH(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC1_ADCH_SHIFT))&ADC_SC1_ADCH_MASK)\r\n#define ADC_SC1_AIEN_MASK                        0x40u\r\n#define ADC_SC1_AIEN_SHIFT                       6u\r\n#define ADC_SC1_AIEN_WIDTH                       1u\r\n#define ADC_SC1_AIEN(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC1_AIEN_SHIFT))&ADC_SC1_AIEN_MASK)\r\n#define ADC_SC1_COCO_MASK                        0x80u\r\n#define ADC_SC1_COCO_SHIFT                       7u\r\n#define ADC_SC1_COCO_WIDTH                       1u\r\n#define ADC_SC1_COCO(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC1_COCO_SHIFT))&ADC_SC1_COCO_MASK)\r\n/* CFG1 Bit Fields */\r\n#define ADC_CFG1_ADICLK_MASK                     0x3u\r\n#define ADC_CFG1_ADICLK_SHIFT                    0u\r\n#define ADC_CFG1_ADICLK_WIDTH                    2u\r\n#define ADC_CFG1_ADICLK(x)                       (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_ADICLK_SHIFT))&ADC_CFG1_ADICLK_MASK)\r\n#define ADC_CFG1_MODE_MASK                       0xCu\r\n#define ADC_CFG1_MODE_SHIFT                      2u\r\n#define ADC_CFG1_MODE_WIDTH                      2u\r\n#define ADC_CFG1_MODE(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_MODE_SHIFT))&ADC_CFG1_MODE_MASK)\r\n#define ADC_CFG1_ADIV_MASK                       0x60u\r\n#define ADC_CFG1_ADIV_SHIFT                      5u\r\n#define ADC_CFG1_ADIV_WIDTH                      2u\r\n#define ADC_CFG1_ADIV(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_ADIV_SHIFT))&ADC_CFG1_ADIV_MASK)\r\n#define ADC_CFG1_CLRLTRG_MASK                    0x100u\r\n#define ADC_CFG1_CLRLTRG_SHIFT                   8u\r\n#define ADC_CFG1_CLRLTRG_WIDTH                   1u\r\n#define ADC_CFG1_CLRLTRG(x)                      (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_CLRLTRG_SHIFT))&ADC_CFG1_CLRLTRG_MASK)\r\n/* CFG2 Bit Fields */\r\n#define ADC_CFG2_SMPLTS_MASK                     0xFFu\r\n#define ADC_CFG2_SMPLTS_SHIFT                    0u\r\n#define ADC_CFG2_SMPLTS_WIDTH                    8u\r\n#define ADC_CFG2_SMPLTS(x)                       (((uint32_t)(((uint32_t)(x))<<ADC_CFG2_SMPLTS_SHIFT))&ADC_CFG2_SMPLTS_MASK)\r\n/* R Bit Fields */\r\n#define ADC_R_D_MASK                             0xFFFu\r\n#define ADC_R_D_SHIFT                            0u\r\n#define ADC_R_D_WIDTH                            12u\r\n#define ADC_R_D(x)                               (((uint32_t)(((uint32_t)(x))<<ADC_R_D_SHIFT))&ADC_R_D_MASK)\r\n/* CV Bit Fields */\r\n#define ADC_CV_CV_MASK                           0xFFFFu\r\n#define ADC_CV_CV_SHIFT                          0u\r\n#define ADC_CV_CV_WIDTH                          16u\r\n#define ADC_CV_CV(x)                             (((uint32_t)(((uint32_t)(x))<<ADC_CV_CV_SHIFT))&ADC_CV_CV_MASK)\r\n/* SC2 Bit Fields */\r\n#define ADC_SC2_REFSEL_MASK                      0x3u\r\n#define ADC_SC2_REFSEL_SHIFT                     0u\r\n#define ADC_SC2_REFSEL_WIDTH                     2u\r\n#define ADC_SC2_REFSEL(x)                        (((uint32_t)(((uint32_t)(x))<<ADC_SC2_REFSEL_SHIFT))&ADC_SC2_REFSEL_MASK)\r\n#define ADC_SC2_DMAEN_MASK                       0x4u\r\n#define ADC_SC2_DMAEN_SHIFT                      2u\r\n#define ADC_SC2_DMAEN_WIDTH                      1u\r\n#define ADC_SC2_DMAEN(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_SC2_DMAEN_SHIFT))&ADC_SC2_DMAEN_MASK)\r\n#define ADC_SC2_ACREN_MASK                       0x8u\r\n#define ADC_SC2_ACREN_SHIFT                      3u\r\n#define ADC_SC2_ACREN_WIDTH                      1u\r\n#define ADC_SC2_ACREN(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_SC2_ACREN_SHIFT))&ADC_SC2_ACREN_MASK)\r\n#define ADC_SC2_ACFGT_MASK                       0x10u\r\n#define ADC_SC2_ACFGT_SHIFT                      4u\r\n#define ADC_SC2_ACFGT_WIDTH                      1u\r\n#define ADC_SC2_ACFGT(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_SC2_ACFGT_SHIFT))&ADC_SC2_ACFGT_MASK)\r\n#define ADC_SC2_ACFE_MASK                        0x20u\r\n#define ADC_SC2_ACFE_SHIFT                       5u\r\n#define ADC_SC2_ACFE_WIDTH                       1u\r\n#define ADC_SC2_ACFE(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC2_ACFE_SHIFT))&ADC_SC2_ACFE_MASK)\r\n#define ADC_SC2_ADTRG_MASK                       0x40u\r\n#define ADC_SC2_ADTRG_SHIFT                      6u\r\n#define ADC_SC2_ADTRG_WIDTH                      1u\r\n#define ADC_SC2_ADTRG(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_SC2_ADTRG_SHIFT))&ADC_SC2_ADTRG_MASK)\r\n#define ADC_SC2_ADACT_MASK                       0x80u\r\n#define ADC_SC2_ADACT_SHIFT                      7u\r\n#define ADC_SC2_ADACT_WIDTH                      1u\r\n#define ADC_SC2_ADACT(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_SC2_ADACT_SHIFT))&ADC_SC2_ADACT_MASK)\r\n#define ADC_SC2_TRGPRNUM_MASK                    0x6000u\r\n#define ADC_SC2_TRGPRNUM_SHIFT                   13u\r\n#define ADC_SC2_TRGPRNUM_WIDTH                   2u\r\n#define ADC_SC2_TRGPRNUM(x)                      (((uint32_t)(((uint32_t)(x))<<ADC_SC2_TRGPRNUM_SHIFT))&ADC_SC2_TRGPRNUM_MASK)\r\n#define ADC_SC2_TRGSTLAT_MASK                    0xF0000u\r\n#define ADC_SC2_TRGSTLAT_SHIFT                   16u\r\n#define ADC_SC2_TRGSTLAT_WIDTH                   4u\r\n#define ADC_SC2_TRGSTLAT(x)                      (((uint32_t)(((uint32_t)(x))<<ADC_SC2_TRGSTLAT_SHIFT))&ADC_SC2_TRGSTLAT_MASK)\r\n#define ADC_SC2_TRGSTERR_MASK                    0xF000000u\r\n#define ADC_SC2_TRGSTERR_SHIFT                   24u\r\n#define ADC_SC2_TRGSTERR_WIDTH                   4u\r\n#define ADC_SC2_TRGSTERR(x)                      (((uint32_t)(((uint32_t)(x))<<ADC_SC2_TRGSTERR_SHIFT))&ADC_SC2_TRGSTERR_MASK)\r\n/* SC3 Bit Fields */\r\n#define ADC_SC3_AVGS_MASK                        0x3u\r\n#define ADC_SC3_AVGS_SHIFT                       0u\r\n#define ADC_SC3_AVGS_WIDTH                       2u\r\n#define ADC_SC3_AVGS(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC3_AVGS_SHIFT))&ADC_SC3_AVGS_MASK)\r\n#define ADC_SC3_AVGE_MASK                        0x4u\r\n#define ADC_SC3_AVGE_SHIFT                       2u\r\n#define ADC_SC3_AVGE_WIDTH                       1u\r\n#define ADC_SC3_AVGE(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC3_AVGE_SHIFT))&ADC_SC3_AVGE_MASK)\r\n#define ADC_SC3_ADCO_MASK                        0x8u\r\n#define ADC_SC3_ADCO_SHIFT                       3u\r\n#define ADC_SC3_ADCO_WIDTH                       1u\r\n#define ADC_SC3_ADCO(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC3_ADCO_SHIFT))&ADC_SC3_ADCO_MASK)\r\n#define ADC_SC3_CAL_MASK                         0x80u\r\n#define ADC_SC3_CAL_SHIFT                        7u\r\n#define ADC_SC3_CAL_WIDTH                        1u\r\n#define ADC_SC3_CAL(x)                           (((uint32_t)(((uint32_t)(x))<<ADC_SC3_CAL_SHIFT))&ADC_SC3_CAL_MASK)\r\n/* BASE_OFS Bit Fields */\r\n#define ADC_BASE_OFS_BA_OFS_MASK                 0xFFu\r\n#define ADC_BASE_OFS_BA_OFS_SHIFT                0u\r\n#define ADC_BASE_OFS_BA_OFS_WIDTH                8u\r\n#define ADC_BASE_OFS_BA_OFS(x)                   (((uint32_t)(((uint32_t)(x))<<ADC_BASE_OFS_BA_OFS_SHIFT))&ADC_BASE_OFS_BA_OFS_MASK)\r\n/* OFS Bit Fields */\r\n#define ADC_OFS_OFS_MASK                         0xFFFFu\r\n#define ADC_OFS_OFS_SHIFT                        0u\r\n#define ADC_OFS_OFS_WIDTH                        16u\r\n#define ADC_OFS_OFS(x)                           (((uint32_t)(((uint32_t)(x))<<ADC_OFS_OFS_SHIFT))&ADC_OFS_OFS_MASK)\r\n/* USR_OFS Bit Fields */\r\n#define ADC_USR_OFS_USR_OFS_MASK                 0xFFu\r\n#define ADC_USR_OFS_USR_OFS_SHIFT                0u\r\n#define ADC_USR_OFS_USR_OFS_WIDTH                8u\r\n#define ADC_USR_OFS_USR_OFS(x)                   (((uint32_t)(((uint32_t)(x))<<ADC_USR_OFS_USR_OFS_SHIFT))&ADC_USR_OFS_USR_OFS_MASK)\r\n/* XOFS Bit Fields */\r\n#define ADC_XOFS_XOFS_MASK                       0x3Fu\r\n#define ADC_XOFS_XOFS_SHIFT                      0u\r\n#define ADC_XOFS_XOFS_WIDTH                      6u\r\n#define ADC_XOFS_XOFS(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_XOFS_XOFS_SHIFT))&ADC_XOFS_XOFS_MASK)\r\n/* YOFS Bit Fields */\r\n#define ADC_YOFS_YOFS_MASK                       0xFFu\r\n#define ADC_YOFS_YOFS_SHIFT                      0u\r\n#define ADC_YOFS_YOFS_WIDTH                      8u\r\n#define ADC_YOFS_YOFS(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_YOFS_YOFS_SHIFT))&ADC_YOFS_YOFS_MASK)\r\n/* G Bit Fields */\r\n#define ADC_G_G_MASK                             0x7FFu\r\n#define ADC_G_G_SHIFT                            0u\r\n#define ADC_G_G_WIDTH                            11u\r\n#define ADC_G_G(x)                               (((uint32_t)(((uint32_t)(x))<<ADC_G_G_SHIFT))&ADC_G_G_MASK)\r\n/* UG Bit Fields */\r\n#define ADC_UG_UG_MASK                           0x3FFu\r\n#define ADC_UG_UG_SHIFT                          0u\r\n#define ADC_UG_UG_WIDTH                          10u\r\n#define ADC_UG_UG(x)                             (((uint32_t)(((uint32_t)(x))<<ADC_UG_UG_SHIFT))&ADC_UG_UG_MASK)\r\n/* CLPS Bit Fields */\r\n#define ADC_CLPS_CLPS_MASK                       0x7Fu\r\n#define ADC_CLPS_CLPS_SHIFT                      0u\r\n#define ADC_CLPS_CLPS_WIDTH                      7u\r\n#define ADC_CLPS_CLPS(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLPS_CLPS_SHIFT))&ADC_CLPS_CLPS_MASK)\r\n/* CLP3 Bit Fields */\r\n#define ADC_CLP3_CLP3_MASK                       0x3FFu\r\n#define ADC_CLP3_CLP3_SHIFT                      0u\r\n#define ADC_CLP3_CLP3_WIDTH                      10u\r\n#define ADC_CLP3_CLP3(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP3_CLP3_SHIFT))&ADC_CLP3_CLP3_MASK)\r\n/* CLP2 Bit Fields */\r\n#define ADC_CLP2_CLP2_MASK                       0x3FFu\r\n#define ADC_CLP2_CLP2_SHIFT                      0u\r\n#define ADC_CLP2_CLP2_WIDTH                      10u\r\n#define ADC_CLP2_CLP2(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP2_CLP2_SHIFT))&ADC_CLP2_CLP2_MASK)\r\n/* CLP1 Bit Fields */\r\n#define ADC_CLP1_CLP1_MASK                       0x1FFu\r\n#define ADC_CLP1_CLP1_SHIFT                      0u\r\n#define ADC_CLP1_CLP1_WIDTH                      9u\r\n#define ADC_CLP1_CLP1(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP1_CLP1_SHIFT))&ADC_CLP1_CLP1_MASK)\r\n/* CLP0 Bit Fields */\r\n#define ADC_CLP0_CLP0_MASK                       0xFFu\r\n#define ADC_CLP0_CLP0_SHIFT                      0u\r\n#define ADC_CLP0_CLP0_WIDTH                      8u\r\n#define ADC_CLP0_CLP0(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP0_CLP0_SHIFT))&ADC_CLP0_CLP0_MASK)\r\n/* CLPX Bit Fields */\r\n#define ADC_CLPX_CLPX_MASK                       0x7Fu\r\n#define ADC_CLPX_CLPX_SHIFT                      0u\r\n#define ADC_CLPX_CLPX_WIDTH                      7u\r\n#define ADC_CLPX_CLPX(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLPX_CLPX_SHIFT))&ADC_CLPX_CLPX_MASK)\r\n/* CLP9 Bit Fields */\r\n#define ADC_CLP9_CLP9_MASK                       0x7Fu\r\n#define ADC_CLP9_CLP9_SHIFT                      0u\r\n#define ADC_CLP9_CLP9_WIDTH                      7u\r\n#define ADC_CLP9_CLP9(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP9_CLP9_SHIFT))&ADC_CLP9_CLP9_MASK)\r\n/* CLPS_OFS Bit Fields */\r\n#define ADC_CLPS_OFS_CLPS_OFS_MASK               0xFu\r\n#define ADC_CLPS_OFS_CLPS_OFS_SHIFT              0u\r\n#define ADC_CLPS_OFS_CLPS_OFS_WIDTH              4u\r\n#define ADC_CLPS_OFS_CLPS_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLPS_OFS_CLPS_OFS_SHIFT))&ADC_CLPS_OFS_CLPS_OFS_MASK)\r\n/* CLP3_OFS Bit Fields */\r\n#define ADC_CLP3_OFS_CLP3_OFS_MASK               0xFu\r\n#define ADC_CLP3_OFS_CLP3_OFS_SHIFT              0u\r\n#define ADC_CLP3_OFS_CLP3_OFS_WIDTH              4u\r\n#define ADC_CLP3_OFS_CLP3_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLP3_OFS_CLP3_OFS_SHIFT))&ADC_CLP3_OFS_CLP3_OFS_MASK)\r\n/* CLP2_OFS Bit Fields */\r\n#define ADC_CLP2_OFS_CLP2_OFS_MASK               0xFu\r\n#define ADC_CLP2_OFS_CLP2_OFS_SHIFT              0u\r\n#define ADC_CLP2_OFS_CLP2_OFS_WIDTH              4u\r\n#define ADC_CLP2_OFS_CLP2_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLP2_OFS_CLP2_OFS_SHIFT))&ADC_CLP2_OFS_CLP2_OFS_MASK)\r\n/* CLP1_OFS Bit Fields */\r\n#define ADC_CLP1_OFS_CLP1_OFS_MASK               0xFu\r\n#define ADC_CLP1_OFS_CLP1_OFS_SHIFT              0u\r\n#define ADC_CLP1_OFS_CLP1_OFS_WIDTH              4u\r\n#define ADC_CLP1_OFS_CLP1_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLP1_OFS_CLP1_OFS_SHIFT))&ADC_CLP1_OFS_CLP1_OFS_MASK)\r\n/* CLP0_OFS Bit Fields */\r\n#define ADC_CLP0_OFS_CLP0_OFS_MASK               0xFu\r\n#define ADC_CLP0_OFS_CLP0_OFS_SHIFT              0u\r\n#define ADC_CLP0_OFS_CLP0_OFS_WIDTH              4u\r\n#define ADC_CLP0_OFS_CLP0_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLP0_OFS_CLP0_OFS_SHIFT))&ADC_CLP0_OFS_CLP0_OFS_MASK)\r\n/* CLPX_OFS Bit Fields */\r\n#define ADC_CLPX_OFS_CLPX_OFS_MASK               0xFFFu\r\n#define ADC_CLPX_OFS_CLPX_OFS_SHIFT              0u\r\n#define ADC_CLPX_OFS_CLPX_OFS_WIDTH              12u\r\n#define ADC_CLPX_OFS_CLPX_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLPX_OFS_CLPX_OFS_SHIFT))&ADC_CLPX_OFS_CLPX_OFS_MASK)\r\n/* CLP9_OFS Bit Fields */\r\n#define ADC_CLP9_OFS_CLP9_OFS_MASK               0xFFFu\r\n#define ADC_CLP9_OFS_CLP9_OFS_SHIFT              0u\r\n#define ADC_CLP9_OFS_CLP9_OFS_WIDTH              12u\r\n#define ADC_CLP9_OFS_CLP9_OFS(x)                 (((uint32_t)(((uint32_t)(x))<<ADC_CLP9_OFS_CLP9_OFS_SHIFT))&ADC_CLP9_OFS_CLP9_OFS_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group ADC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group ADC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- AIPS Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup AIPS_Peripheral_Access_Layer AIPS Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** AIPS - Size of Registers Arrays */\r\n#define AIPS_PACR_COUNT                          4u\r\n#define AIPS_OPACR_COUNT                         12u\r\n\r\n/** AIPS - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t MPRA;                              /**< Master Privilege Register A, offset: 0x0 */\r\n       uint8_t RESERVED_0[28];\r\n  __IO uint32_t PACR[AIPS_PACR_COUNT];             /**< Peripheral Access Control Register, array offset: 0x20, array step: 0x4 */\r\n       uint8_t RESERVED_1[16];\r\n  __IO uint32_t OPACR[AIPS_OPACR_COUNT];           /**< Off-Platform Peripheral Access Control Register, array offset: 0x40, array step: 0x4 */\r\n} AIPS_Type, *AIPS_MemMapPtr;\r\n\r\n /** Number of instances of the AIPS module. */\r\n#define AIPS_INSTANCE_COUNT                      (1u)\r\n\r\n\r\n/* AIPS - Peripheral instance base addresses */\r\n/** Peripheral AIPS base address */\r\n#define AIPS_BASE                                (0x40000000u)\r\n/** Peripheral AIPS base pointer */\r\n#define AIPS                                     ((AIPS_Type *)AIPS_BASE)\r\n/** Array initializer of AIPS peripheral base addresses */\r\n#define AIPS_BASE_ADDRS                          { AIPS_BASE }\r\n/** Array initializer of AIPS peripheral base pointers */\r\n#define AIPS_BASE_PTRS                           { AIPS }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- AIPS Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup AIPS_Register_Masks AIPS Register Masks\r\n * @{\r\n */\r\n\r\n/* MPRA Bit Fields */\r\n#define AIPS_MPRA_MPL2_MASK                      0x100000u\r\n#define AIPS_MPRA_MPL2_SHIFT                     20u\r\n#define AIPS_MPRA_MPL2_WIDTH                     1u\r\n#define AIPS_MPRA_MPL2(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MPL2_SHIFT))&AIPS_MPRA_MPL2_MASK)\r\n#define AIPS_MPRA_MTW2_MASK                      0x200000u\r\n#define AIPS_MPRA_MTW2_SHIFT                     21u\r\n#define AIPS_MPRA_MTW2_WIDTH                     1u\r\n#define AIPS_MPRA_MTW2(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MTW2_SHIFT))&AIPS_MPRA_MTW2_MASK)\r\n#define AIPS_MPRA_MTR2_MASK                      0x400000u\r\n#define AIPS_MPRA_MTR2_SHIFT                     22u\r\n#define AIPS_MPRA_MTR2_WIDTH                     1u\r\n#define AIPS_MPRA_MTR2(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MTR2_SHIFT))&AIPS_MPRA_MTR2_MASK)\r\n#define AIPS_MPRA_MPL1_MASK                      0x1000000u\r\n#define AIPS_MPRA_MPL1_SHIFT                     24u\r\n#define AIPS_MPRA_MPL1_WIDTH                     1u\r\n#define AIPS_MPRA_MPL1(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MPL1_SHIFT))&AIPS_MPRA_MPL1_MASK)\r\n#define AIPS_MPRA_MTW1_MASK                      0x2000000u\r\n#define AIPS_MPRA_MTW1_SHIFT                     25u\r\n#define AIPS_MPRA_MTW1_WIDTH                     1u\r\n#define AIPS_MPRA_MTW1(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MTW1_SHIFT))&AIPS_MPRA_MTW1_MASK)\r\n#define AIPS_MPRA_MTR1_MASK                      0x4000000u\r\n#define AIPS_MPRA_MTR1_SHIFT                     26u\r\n#define AIPS_MPRA_MTR1_WIDTH                     1u\r\n#define AIPS_MPRA_MTR1(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MTR1_SHIFT))&AIPS_MPRA_MTR1_MASK)\r\n#define AIPS_MPRA_MPL0_MASK                      0x10000000u\r\n#define AIPS_MPRA_MPL0_SHIFT                     28u\r\n#define AIPS_MPRA_MPL0_WIDTH                     1u\r\n#define AIPS_MPRA_MPL0(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MPL0_SHIFT))&AIPS_MPRA_MPL0_MASK)\r\n#define AIPS_MPRA_MTW0_MASK                      0x20000000u\r\n#define AIPS_MPRA_MTW0_SHIFT                     29u\r\n#define AIPS_MPRA_MTW0_WIDTH                     1u\r\n#define AIPS_MPRA_MTW0(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MTW0_SHIFT))&AIPS_MPRA_MTW0_MASK)\r\n#define AIPS_MPRA_MTR0_MASK                      0x40000000u\r\n#define AIPS_MPRA_MTR0_SHIFT                     30u\r\n#define AIPS_MPRA_MTR0_WIDTH                     1u\r\n#define AIPS_MPRA_MTR0(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_MPRA_MTR0_SHIFT))&AIPS_MPRA_MTR0_MASK)\r\n/* PACR Bit Fields */\r\n#define AIPS_PACR_TP5_MASK                       0x100u\r\n#define AIPS_PACR_TP5_SHIFT                      8u\r\n#define AIPS_PACR_TP5_WIDTH                      1u\r\n#define AIPS_PACR_TP5(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_TP5_SHIFT))&AIPS_PACR_TP5_MASK)\r\n#define AIPS_PACR_WP5_MASK                       0x200u\r\n#define AIPS_PACR_WP5_SHIFT                      9u\r\n#define AIPS_PACR_WP5_WIDTH                      1u\r\n#define AIPS_PACR_WP5(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_WP5_SHIFT))&AIPS_PACR_WP5_MASK)\r\n#define AIPS_PACR_SP5_MASK                       0x400u\r\n#define AIPS_PACR_SP5_SHIFT                      10u\r\n#define AIPS_PACR_SP5_WIDTH                      1u\r\n#define AIPS_PACR_SP5(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_SP5_SHIFT))&AIPS_PACR_SP5_MASK)\r\n#define AIPS_PACR_TP1_MASK                       0x1000000u\r\n#define AIPS_PACR_TP1_SHIFT                      24u\r\n#define AIPS_PACR_TP1_WIDTH                      1u\r\n#define AIPS_PACR_TP1(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_TP1_SHIFT))&AIPS_PACR_TP1_MASK)\r\n#define AIPS_PACR_WP1_MASK                       0x2000000u\r\n#define AIPS_PACR_WP1_SHIFT                      25u\r\n#define AIPS_PACR_WP1_WIDTH                      1u\r\n#define AIPS_PACR_WP1(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_WP1_SHIFT))&AIPS_PACR_WP1_MASK)\r\n#define AIPS_PACR_SP1_MASK                       0x4000000u\r\n#define AIPS_PACR_SP1_SHIFT                      26u\r\n#define AIPS_PACR_SP1_WIDTH                      1u\r\n#define AIPS_PACR_SP1(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_SP1_SHIFT))&AIPS_PACR_SP1_MASK)\r\n#define AIPS_PACR_TP0_MASK                       0x10000000u\r\n#define AIPS_PACR_TP0_SHIFT                      28u\r\n#define AIPS_PACR_TP0_WIDTH                      1u\r\n#define AIPS_PACR_TP0(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_TP0_SHIFT))&AIPS_PACR_TP0_MASK)\r\n#define AIPS_PACR_WP0_MASK                       0x20000000u\r\n#define AIPS_PACR_WP0_SHIFT                      29u\r\n#define AIPS_PACR_WP0_WIDTH                      1u\r\n#define AIPS_PACR_WP0(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_WP0_SHIFT))&AIPS_PACR_WP0_MASK)\r\n#define AIPS_PACR_SP0_MASK                       0x40000000u\r\n#define AIPS_PACR_SP0_SHIFT                      30u\r\n#define AIPS_PACR_SP0_WIDTH                      1u\r\n#define AIPS_PACR_SP0(x)                         (((uint32_t)(((uint32_t)(x))<<AIPS_PACR_SP0_SHIFT))&AIPS_PACR_SP0_MASK)\r\n/* OPACR Bit Fields */\r\n#define AIPS_OPACR_TP7_MASK                      0x1u\r\n#define AIPS_OPACR_TP7_SHIFT                     0u\r\n#define AIPS_OPACR_TP7_WIDTH                     1u\r\n#define AIPS_OPACR_TP7(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP7_SHIFT))&AIPS_OPACR_TP7_MASK)\r\n#define AIPS_OPACR_WP7_MASK                      0x2u\r\n#define AIPS_OPACR_WP7_SHIFT                     1u\r\n#define AIPS_OPACR_WP7_WIDTH                     1u\r\n#define AIPS_OPACR_WP7(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP7_SHIFT))&AIPS_OPACR_WP7_MASK)\r\n#define AIPS_OPACR_SP7_MASK                      0x4u\r\n#define AIPS_OPACR_SP7_SHIFT                     2u\r\n#define AIPS_OPACR_SP7_WIDTH                     1u\r\n#define AIPS_OPACR_SP7(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP7_SHIFT))&AIPS_OPACR_SP7_MASK)\r\n#define AIPS_OPACR_TP6_MASK                      0x10u\r\n#define AIPS_OPACR_TP6_SHIFT                     4u\r\n#define AIPS_OPACR_TP6_WIDTH                     1u\r\n#define AIPS_OPACR_TP6(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP6_SHIFT))&AIPS_OPACR_TP6_MASK)\r\n#define AIPS_OPACR_WP6_MASK                      0x20u\r\n#define AIPS_OPACR_WP6_SHIFT                     5u\r\n#define AIPS_OPACR_WP6_WIDTH                     1u\r\n#define AIPS_OPACR_WP6(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP6_SHIFT))&AIPS_OPACR_WP6_MASK)\r\n#define AIPS_OPACR_SP6_MASK                      0x40u\r\n#define AIPS_OPACR_SP6_SHIFT                     6u\r\n#define AIPS_OPACR_SP6_WIDTH                     1u\r\n#define AIPS_OPACR_SP6(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP6_SHIFT))&AIPS_OPACR_SP6_MASK)\r\n#define AIPS_OPACR_TP5_MASK                      0x100u\r\n#define AIPS_OPACR_TP5_SHIFT                     8u\r\n#define AIPS_OPACR_TP5_WIDTH                     1u\r\n#define AIPS_OPACR_TP5(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP5_SHIFT))&AIPS_OPACR_TP5_MASK)\r\n#define AIPS_OPACR_WP5_MASK                      0x200u\r\n#define AIPS_OPACR_WP5_SHIFT                     9u\r\n#define AIPS_OPACR_WP5_WIDTH                     1u\r\n#define AIPS_OPACR_WP5(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP5_SHIFT))&AIPS_OPACR_WP5_MASK)\r\n#define AIPS_OPACR_SP5_MASK                      0x400u\r\n#define AIPS_OPACR_SP5_SHIFT                     10u\r\n#define AIPS_OPACR_SP5_WIDTH                     1u\r\n#define AIPS_OPACR_SP5(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP5_SHIFT))&AIPS_OPACR_SP5_MASK)\r\n#define AIPS_OPACR_TP4_MASK                      0x1000u\r\n#define AIPS_OPACR_TP4_SHIFT                     12u\r\n#define AIPS_OPACR_TP4_WIDTH                     1u\r\n#define AIPS_OPACR_TP4(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP4_SHIFT))&AIPS_OPACR_TP4_MASK)\r\n#define AIPS_OPACR_WP4_MASK                      0x2000u\r\n#define AIPS_OPACR_WP4_SHIFT                     13u\r\n#define AIPS_OPACR_WP4_WIDTH                     1u\r\n#define AIPS_OPACR_WP4(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP4_SHIFT))&AIPS_OPACR_WP4_MASK)\r\n#define AIPS_OPACR_SP4_MASK                      0x4000u\r\n#define AIPS_OPACR_SP4_SHIFT                     14u\r\n#define AIPS_OPACR_SP4_WIDTH                     1u\r\n#define AIPS_OPACR_SP4(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP4_SHIFT))&AIPS_OPACR_SP4_MASK)\r\n#define AIPS_OPACR_TP3_MASK                      0x10000u\r\n#define AIPS_OPACR_TP3_SHIFT                     16u\r\n#define AIPS_OPACR_TP3_WIDTH                     1u\r\n#define AIPS_OPACR_TP3(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP3_SHIFT))&AIPS_OPACR_TP3_MASK)\r\n#define AIPS_OPACR_WP3_MASK                      0x20000u\r\n#define AIPS_OPACR_WP3_SHIFT                     17u\r\n#define AIPS_OPACR_WP3_WIDTH                     1u\r\n#define AIPS_OPACR_WP3(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP3_SHIFT))&AIPS_OPACR_WP3_MASK)\r\n#define AIPS_OPACR_SP3_MASK                      0x40000u\r\n#define AIPS_OPACR_SP3_SHIFT                     18u\r\n#define AIPS_OPACR_SP3_WIDTH                     1u\r\n#define AIPS_OPACR_SP3(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP3_SHIFT))&AIPS_OPACR_SP3_MASK)\r\n#define AIPS_OPACR_TP2_MASK                      0x100000u\r\n#define AIPS_OPACR_TP2_SHIFT                     20u\r\n#define AIPS_OPACR_TP2_WIDTH                     1u\r\n#define AIPS_OPACR_TP2(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP2_SHIFT))&AIPS_OPACR_TP2_MASK)\r\n#define AIPS_OPACR_WP2_MASK                      0x200000u\r\n#define AIPS_OPACR_WP2_SHIFT                     21u\r\n#define AIPS_OPACR_WP2_WIDTH                     1u\r\n#define AIPS_OPACR_WP2(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP2_SHIFT))&AIPS_OPACR_WP2_MASK)\r\n#define AIPS_OPACR_SP2_MASK                      0x400000u\r\n#define AIPS_OPACR_SP2_SHIFT                     22u\r\n#define AIPS_OPACR_SP2_WIDTH                     1u\r\n#define AIPS_OPACR_SP2(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP2_SHIFT))&AIPS_OPACR_SP2_MASK)\r\n#define AIPS_OPACR_TP1_MASK                      0x1000000u\r\n#define AIPS_OPACR_TP1_SHIFT                     24u\r\n#define AIPS_OPACR_TP1_WIDTH                     1u\r\n#define AIPS_OPACR_TP1(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP1_SHIFT))&AIPS_OPACR_TP1_MASK)\r\n#define AIPS_OPACR_WP1_MASK                      0x2000000u\r\n#define AIPS_OPACR_WP1_SHIFT                     25u\r\n#define AIPS_OPACR_WP1_WIDTH                     1u\r\n#define AIPS_OPACR_WP1(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP1_SHIFT))&AIPS_OPACR_WP1_MASK)\r\n#define AIPS_OPACR_SP1_MASK                      0x4000000u\r\n#define AIPS_OPACR_SP1_SHIFT                     26u\r\n#define AIPS_OPACR_SP1_WIDTH                     1u\r\n#define AIPS_OPACR_SP1(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP1_SHIFT))&AIPS_OPACR_SP1_MASK)\r\n#define AIPS_OPACR_TP0_MASK                      0x10000000u\r\n#define AIPS_OPACR_TP0_SHIFT                     28u\r\n#define AIPS_OPACR_TP0_WIDTH                     1u\r\n#define AIPS_OPACR_TP0(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_TP0_SHIFT))&AIPS_OPACR_TP0_MASK)\r\n#define AIPS_OPACR_WP0_MASK                      0x20000000u\r\n#define AIPS_OPACR_WP0_SHIFT                     29u\r\n#define AIPS_OPACR_WP0_WIDTH                     1u\r\n#define AIPS_OPACR_WP0(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_WP0_SHIFT))&AIPS_OPACR_WP0_MASK)\r\n#define AIPS_OPACR_SP0_MASK                      0x40000000u\r\n#define AIPS_OPACR_SP0_SHIFT                     30u\r\n#define AIPS_OPACR_SP0_WIDTH                     1u\r\n#define AIPS_OPACR_SP0(x)                        (((uint32_t)(((uint32_t)(x))<<AIPS_OPACR_SP0_SHIFT))&AIPS_OPACR_SP0_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group AIPS_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group AIPS_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CAN Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CAN_Peripheral_Access_Layer CAN Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** CAN - Size of Registers Arrays */\r\n#define CAN_RAMn_COUNT                           128u\r\n#define CAN_RXIMR_COUNT                          32u\r\n#define CAN_WMB_COUNT                            4u\r\n\r\n/** CAN - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t MCR;                               /**< Module Configuration Register, offset: 0x0 */\r\n  __IO uint32_t CTRL1;                             /**< Control 1 register, offset: 0x4 */\r\n  __IO uint32_t TIMER;                             /**< Free Running Timer, offset: 0x8 */\r\n       uint8_t RESERVED_0[4];\r\n  __IO uint32_t RXMGMASK;                          /**< Rx Mailboxes Global Mask Register, offset: 0x10 */\r\n  __IO uint32_t RX14MASK;                          /**< Rx 14 Mask register, offset: 0x14 */\r\n  __IO uint32_t RX15MASK;                          /**< Rx 15 Mask register, offset: 0x18 */\r\n  __IO uint32_t ECR;                               /**< Error Counter, offset: 0x1C */\r\n  __IO uint32_t ESR1;                              /**< Error and Status 1 register, offset: 0x20 */\r\n       uint8_t RESERVED_1[4];\r\n  __IO uint32_t IMASK1;                            /**< Interrupt Masks 1 register, offset: 0x28 */\r\n       uint8_t RESERVED_2[4];\r\n  __IO uint32_t IFLAG1;                            /**< Interrupt Flags 1 register, offset: 0x30 */\r\n  __IO uint32_t CTRL2;                             /**< Control 2 register, offset: 0x34 */\r\n  __I  uint32_t ESR2;                              /**< Error and Status 2 register, offset: 0x38 */\r\n       uint8_t RESERVED_3[8];\r\n  __I  uint32_t CRCR;                              /**< CRC Register, offset: 0x44 */\r\n  __IO uint32_t RXFGMASK;                          /**< Rx FIFO Global Mask register, offset: 0x48 */\r\n  __I  uint32_t RXFIR;                             /**< Rx FIFO Information Register, offset: 0x4C */\r\n  __IO uint32_t CBT;                               /**< CAN Bit Timing Register, offset: 0x50 */\r\n       uint8_t RESERVED_4[44];\r\n  __IO uint32_t RAMn[CAN_RAMn_COUNT];              /**< Embedded RAM, array offset: 0x80, array step: 0x4 */\r\n       uint8_t RESERVED_5[1536];\r\n  __IO uint32_t RXIMR[CAN_RXIMR_COUNT];            /**< Rx Individual Mask Registers, array offset: 0x880, array step: 0x4 */\r\n       uint8_t RESERVED_6[512];\r\n  __IO uint32_t CTRL1_PN;                          /**< Pretended Networking Control 1 Register, offset: 0xB00 */\r\n  __IO uint32_t CTRL2_PN;                          /**< Pretended Networking Control 2 Register, offset: 0xB04 */\r\n  __IO uint32_t WU_MTC;                            /**< Pretended Networking Wake Up Match Register, offset: 0xB08 */\r\n  __IO uint32_t FLT_ID1;                           /**< Pretended Networking ID Filter 1 Register, offset: 0xB0C */\r\n  __IO uint32_t FLT_DLC;                           /**< Pretended Networking DLC Filter Register, offset: 0xB10 */\r\n  __IO uint32_t PL1_LO;                            /**< Pretended Networking Payload Low Filter 1 Register, offset: 0xB14 */\r\n  __IO uint32_t PL1_HI;                            /**< Pretended Networking Payload High Filter 1 Register, offset: 0xB18 */\r\n  __IO uint32_t FLT_ID2_IDMASK;                    /**< Pretended Networking ID Filter 2 Register / ID Mask Register, offset: 0xB1C */\r\n  __IO uint32_t PL2_PLMASK_LO;                     /**< Pretended Networking Payload Low Filter 2 Register / Payload Low Mask Register, offset: 0xB20 */\r\n  __IO uint32_t PL2_PLMASK_HI;                     /**< Pretended Networking Payload High Filter 2 low order bits / Payload High Mask Register, offset: 0xB24 */\r\n       uint8_t RESERVED_7[24];\r\n  struct {                                         /* offset: 0xB40, array step: 0x10 */\r\n    __I  uint32_t WMBn_CS;                           /**< Wake Up Message Buffer Register for C/S, array offset: 0xB40, array step: 0x10 */\r\n    __I  uint32_t WMBn_ID;                           /**< Wake Up Message Buffer Register for ID, array offset: 0xB44, array step: 0x10 */\r\n    __I  uint32_t WMBn_D03;                          /**< Wake Up Message Buffer Register for Data 0-3, array offset: 0xB48, array step: 0x10 */\r\n    __I  uint32_t WMBn_D47;                          /**< Wake Up Message Buffer Register Data 4-7, array offset: 0xB4C, array step: 0x10 */\r\n  } WMB[CAN_WMB_COUNT];\r\n       uint8_t RESERVED_8[128];\r\n  __IO uint32_t FDCTRL;                            /**< CAN FD Control Register, offset: 0xC00 */\r\n  __IO uint32_t FDCBT;                             /**< CAN FD Bit Timing Register, offset: 0xC04 */\r\n  __I  uint32_t FDCRC;                             /**< CAN FD CRC Register, offset: 0xC08 */\r\n} CAN_Type, *CAN_MemMapPtr;\r\n\r\n /** Number of instances of the CAN module. */\r\n#define CAN_INSTANCE_COUNT                       (3u)\r\n\r\n\r\n/* CAN - Peripheral instance base addresses */\r\n/** Peripheral CAN0 base address */\r\n#define CAN0_BASE                                (0x40024000u)\r\n/** Peripheral CAN0 base pointer */\r\n#define CAN0                                     ((CAN_Type *)CAN0_BASE)\r\n/** Peripheral CAN1 base address */\r\n#define CAN1_BASE                                (0x40025000u)\r\n/** Peripheral CAN1 base pointer */\r\n#define CAN1                                     ((CAN_Type *)CAN1_BASE)\r\n/** Peripheral CAN2 base address */\r\n#define CAN2_BASE                                (0x4002B000u)\r\n/** Peripheral CAN2 base pointer */\r\n#define CAN2                                     ((CAN_Type *)CAN2_BASE)\r\n/** Array initializer of CAN peripheral base addresses */\r\n#define CAN_BASE_ADDRS                           { CAN0_BASE, CAN1_BASE, CAN2_BASE }\r\n/** Array initializer of CAN peripheral base pointers */\r\n#define CAN_BASE_PTRS                            { CAN0, CAN1, CAN2 }\r\n /** Number of interrupt vector arrays for the CAN module. */\r\n#define CAN_IRQS_ARR_COUNT                       (7u)\r\n /** Number of interrupt channels for the Rx_Warning type of CAN module. */\r\n#define CAN_Rx_Warning_IRQS_CH_COUNT             (1u)\r\n /** Number of interrupt channels for the Tx_Warning type of CAN module. */\r\n#define CAN_Tx_Warning_IRQS_CH_COUNT             (1u)\r\n /** Number of interrupt channels for the Wake_Up type of CAN module. */\r\n#define CAN_Wake_Up_IRQS_CH_COUNT                (1u)\r\n /** Number of interrupt channels for the Error type of CAN module. */\r\n#define CAN_Error_IRQS_CH_COUNT                  (1u)\r\n /** Number of interrupt channels for the Bus_Off type of CAN module. */\r\n#define CAN_Bus_Off_IRQS_CH_COUNT                (1u)\r\n /** Number of interrupt channels for the ORed_0_15_MB type of CAN module. */\r\n#define CAN_ORed_0_15_MB_IRQS_CH_COUNT           (1u)\r\n /** Number of interrupt channels for the ORed_16_31_MB type of CAN module. */\r\n#define CAN_ORed_16_31_MB_IRQS_CH_COUNT          (1u)\r\n/** Interrupt vectors for the CAN peripheral type */\r\n#define CAN_Rx_Warning_IRQS                      { CAN0_ORed_IRQn, CAN1_ORed_IRQn, CAN2_ORed_IRQn }\r\n#define CAN_Tx_Warning_IRQS                      { CAN0_ORed_IRQn, CAN1_ORed_IRQn, CAN2_ORed_IRQn }\r\n#define CAN_Wake_Up_IRQS                         { CAN0_Wake_Up_IRQn, NotAvail_IRQn, NotAvail_IRQn }\r\n#define CAN_Error_IRQS                           { CAN0_Error_IRQn, CAN1_Error_IRQn, CAN2_Error_IRQn }\r\n#define CAN_Bus_Off_IRQS                         { CAN0_ORed_IRQn, CAN1_ORed_IRQn, CAN2_ORed_IRQn }\r\n#define CAN_ORed_0_15_MB_IRQS                    { CAN0_ORed_0_15_MB_IRQn, CAN1_ORed_0_15_MB_IRQn, CAN2_ORed_0_15_MB_IRQn }\r\n#define CAN_ORed_16_31_MB_IRQS                   { CAN0_ORed_16_31_MB_IRQn, NotAvail_IRQn, NotAvail_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CAN Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CAN_Register_Masks CAN Register Masks\r\n * @{\r\n */\r\n\r\n/* MCR Bit Fields */\r\n#define CAN_MCR_MAXMB_MASK                       0x7Fu\r\n#define CAN_MCR_MAXMB_SHIFT                      0u\r\n#define CAN_MCR_MAXMB_WIDTH                      7u\r\n#define CAN_MCR_MAXMB(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_MCR_MAXMB_SHIFT))&CAN_MCR_MAXMB_MASK)\r\n#define CAN_MCR_IDAM_MASK                        0x300u\r\n#define CAN_MCR_IDAM_SHIFT                       8u\r\n#define CAN_MCR_IDAM_WIDTH                       2u\r\n#define CAN_MCR_IDAM(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_IDAM_SHIFT))&CAN_MCR_IDAM_MASK)\r\n#define CAN_MCR_FDEN_MASK                        0x800u\r\n#define CAN_MCR_FDEN_SHIFT                       11u\r\n#define CAN_MCR_FDEN_WIDTH                       1u\r\n#define CAN_MCR_FDEN(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_FDEN_SHIFT))&CAN_MCR_FDEN_MASK)\r\n#define CAN_MCR_AEN_MASK                         0x1000u\r\n#define CAN_MCR_AEN_SHIFT                        12u\r\n#define CAN_MCR_AEN_WIDTH                        1u\r\n#define CAN_MCR_AEN(x)                           (((uint32_t)(((uint32_t)(x))<<CAN_MCR_AEN_SHIFT))&CAN_MCR_AEN_MASK)\r\n#define CAN_MCR_LPRIOEN_MASK                     0x2000u\r\n#define CAN_MCR_LPRIOEN_SHIFT                    13u\r\n#define CAN_MCR_LPRIOEN_WIDTH                    1u\r\n#define CAN_MCR_LPRIOEN(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_MCR_LPRIOEN_SHIFT))&CAN_MCR_LPRIOEN_MASK)\r\n#define CAN_MCR_PNET_EN_MASK                     0x4000u\r\n#define CAN_MCR_PNET_EN_SHIFT                    14u\r\n#define CAN_MCR_PNET_EN_WIDTH                    1u\r\n#define CAN_MCR_PNET_EN(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_MCR_PNET_EN_SHIFT))&CAN_MCR_PNET_EN_MASK)\r\n#define CAN_MCR_DMA_MASK                         0x8000u\r\n#define CAN_MCR_DMA_SHIFT                        15u\r\n#define CAN_MCR_DMA_WIDTH                        1u\r\n#define CAN_MCR_DMA(x)                           (((uint32_t)(((uint32_t)(x))<<CAN_MCR_DMA_SHIFT))&CAN_MCR_DMA_MASK)\r\n#define CAN_MCR_IRMQ_MASK                        0x10000u\r\n#define CAN_MCR_IRMQ_SHIFT                       16u\r\n#define CAN_MCR_IRMQ_WIDTH                       1u\r\n#define CAN_MCR_IRMQ(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_IRMQ_SHIFT))&CAN_MCR_IRMQ_MASK)\r\n#define CAN_MCR_SRXDIS_MASK                      0x20000u\r\n#define CAN_MCR_SRXDIS_SHIFT                     17u\r\n#define CAN_MCR_SRXDIS_WIDTH                     1u\r\n#define CAN_MCR_SRXDIS(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_MCR_SRXDIS_SHIFT))&CAN_MCR_SRXDIS_MASK)\r\n#define CAN_MCR_LPMACK_MASK                      0x100000u\r\n#define CAN_MCR_LPMACK_SHIFT                     20u\r\n#define CAN_MCR_LPMACK_WIDTH                     1u\r\n#define CAN_MCR_LPMACK(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_MCR_LPMACK_SHIFT))&CAN_MCR_LPMACK_MASK)\r\n#define CAN_MCR_WRNEN_MASK                       0x200000u\r\n#define CAN_MCR_WRNEN_SHIFT                      21u\r\n#define CAN_MCR_WRNEN_WIDTH                      1u\r\n#define CAN_MCR_WRNEN(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_MCR_WRNEN_SHIFT))&CAN_MCR_WRNEN_MASK)\r\n#define CAN_MCR_SUPV_MASK                        0x800000u\r\n#define CAN_MCR_SUPV_SHIFT                       23u\r\n#define CAN_MCR_SUPV_WIDTH                       1u\r\n#define CAN_MCR_SUPV(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_SUPV_SHIFT))&CAN_MCR_SUPV_MASK)\r\n#define CAN_MCR_FRZACK_MASK                      0x1000000u\r\n#define CAN_MCR_FRZACK_SHIFT                     24u\r\n#define CAN_MCR_FRZACK_WIDTH                     1u\r\n#define CAN_MCR_FRZACK(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_MCR_FRZACK_SHIFT))&CAN_MCR_FRZACK_MASK)\r\n#define CAN_MCR_SOFTRST_MASK                     0x2000000u\r\n#define CAN_MCR_SOFTRST_SHIFT                    25u\r\n#define CAN_MCR_SOFTRST_WIDTH                    1u\r\n#define CAN_MCR_SOFTRST(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_MCR_SOFTRST_SHIFT))&CAN_MCR_SOFTRST_MASK)\r\n#define CAN_MCR_NOTRDY_MASK                      0x8000000u\r\n#define CAN_MCR_NOTRDY_SHIFT                     27u\r\n#define CAN_MCR_NOTRDY_WIDTH                     1u\r\n#define CAN_MCR_NOTRDY(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_MCR_NOTRDY_SHIFT))&CAN_MCR_NOTRDY_MASK)\r\n#define CAN_MCR_HALT_MASK                        0x10000000u\r\n#define CAN_MCR_HALT_SHIFT                       28u\r\n#define CAN_MCR_HALT_WIDTH                       1u\r\n#define CAN_MCR_HALT(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_HALT_SHIFT))&CAN_MCR_HALT_MASK)\r\n#define CAN_MCR_RFEN_MASK                        0x20000000u\r\n#define CAN_MCR_RFEN_SHIFT                       29u\r\n#define CAN_MCR_RFEN_WIDTH                       1u\r\n#define CAN_MCR_RFEN(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_RFEN_SHIFT))&CAN_MCR_RFEN_MASK)\r\n#define CAN_MCR_FRZ_MASK                         0x40000000u\r\n#define CAN_MCR_FRZ_SHIFT                        30u\r\n#define CAN_MCR_FRZ_WIDTH                        1u\r\n#define CAN_MCR_FRZ(x)                           (((uint32_t)(((uint32_t)(x))<<CAN_MCR_FRZ_SHIFT))&CAN_MCR_FRZ_MASK)\r\n#define CAN_MCR_MDIS_MASK                        0x80000000u\r\n#define CAN_MCR_MDIS_SHIFT                       31u\r\n#define CAN_MCR_MDIS_WIDTH                       1u\r\n#define CAN_MCR_MDIS(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_MCR_MDIS_SHIFT))&CAN_MCR_MDIS_MASK)\r\n/* CTRL1 Bit Fields */\r\n#define CAN_CTRL1_PROPSEG_MASK                   0x7u\r\n#define CAN_CTRL1_PROPSEG_SHIFT                  0u\r\n#define CAN_CTRL1_PROPSEG_WIDTH                  3u\r\n#define CAN_CTRL1_PROPSEG(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PROPSEG_SHIFT))&CAN_CTRL1_PROPSEG_MASK)\r\n#define CAN_CTRL1_LOM_MASK                       0x8u\r\n#define CAN_CTRL1_LOM_SHIFT                      3u\r\n#define CAN_CTRL1_LOM_WIDTH                      1u\r\n#define CAN_CTRL1_LOM(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_LOM_SHIFT))&CAN_CTRL1_LOM_MASK)\r\n#define CAN_CTRL1_LBUF_MASK                      0x10u\r\n#define CAN_CTRL1_LBUF_SHIFT                     4u\r\n#define CAN_CTRL1_LBUF_WIDTH                     1u\r\n#define CAN_CTRL1_LBUF(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_LBUF_SHIFT))&CAN_CTRL1_LBUF_MASK)\r\n#define CAN_CTRL1_TSYN_MASK                      0x20u\r\n#define CAN_CTRL1_TSYN_SHIFT                     5u\r\n#define CAN_CTRL1_TSYN_WIDTH                     1u\r\n#define CAN_CTRL1_TSYN(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_TSYN_SHIFT))&CAN_CTRL1_TSYN_MASK)\r\n#define CAN_CTRL1_BOFFREC_MASK                   0x40u\r\n#define CAN_CTRL1_BOFFREC_SHIFT                  6u\r\n#define CAN_CTRL1_BOFFREC_WIDTH                  1u\r\n#define CAN_CTRL1_BOFFREC(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_BOFFREC_SHIFT))&CAN_CTRL1_BOFFREC_MASK)\r\n#define CAN_CTRL1_SMP_MASK                       0x80u\r\n#define CAN_CTRL1_SMP_SHIFT                      7u\r\n#define CAN_CTRL1_SMP_WIDTH                      1u\r\n#define CAN_CTRL1_SMP(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_SMP_SHIFT))&CAN_CTRL1_SMP_MASK)\r\n#define CAN_CTRL1_RWRNMSK_MASK                   0x400u\r\n#define CAN_CTRL1_RWRNMSK_SHIFT                  10u\r\n#define CAN_CTRL1_RWRNMSK_WIDTH                  1u\r\n#define CAN_CTRL1_RWRNMSK(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_RWRNMSK_SHIFT))&CAN_CTRL1_RWRNMSK_MASK)\r\n#define CAN_CTRL1_TWRNMSK_MASK                   0x800u\r\n#define CAN_CTRL1_TWRNMSK_SHIFT                  11u\r\n#define CAN_CTRL1_TWRNMSK_WIDTH                  1u\r\n#define CAN_CTRL1_TWRNMSK(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_TWRNMSK_SHIFT))&CAN_CTRL1_TWRNMSK_MASK)\r\n#define CAN_CTRL1_LPB_MASK                       0x1000u\r\n#define CAN_CTRL1_LPB_SHIFT                      12u\r\n#define CAN_CTRL1_LPB_WIDTH                      1u\r\n#define CAN_CTRL1_LPB(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_LPB_SHIFT))&CAN_CTRL1_LPB_MASK)\r\n#define CAN_CTRL1_CLKSRC_MASK                    0x2000u\r\n#define CAN_CTRL1_CLKSRC_SHIFT                   13u\r\n#define CAN_CTRL1_CLKSRC_WIDTH                   1u\r\n#define CAN_CTRL1_CLKSRC(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_CLKSRC_SHIFT))&CAN_CTRL1_CLKSRC_MASK)\r\n#define CAN_CTRL1_ERRMSK_MASK                    0x4000u\r\n#define CAN_CTRL1_ERRMSK_SHIFT                   14u\r\n#define CAN_CTRL1_ERRMSK_WIDTH                   1u\r\n#define CAN_CTRL1_ERRMSK(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_ERRMSK_SHIFT))&CAN_CTRL1_ERRMSK_MASK)\r\n#define CAN_CTRL1_BOFFMSK_MASK                   0x8000u\r\n#define CAN_CTRL1_BOFFMSK_SHIFT                  15u\r\n#define CAN_CTRL1_BOFFMSK_WIDTH                  1u\r\n#define CAN_CTRL1_BOFFMSK(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_BOFFMSK_SHIFT))&CAN_CTRL1_BOFFMSK_MASK)\r\n#define CAN_CTRL1_PSEG2_MASK                     0x70000u\r\n#define CAN_CTRL1_PSEG2_SHIFT                    16u\r\n#define CAN_CTRL1_PSEG2_WIDTH                    3u\r\n#define CAN_CTRL1_PSEG2(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PSEG2_SHIFT))&CAN_CTRL1_PSEG2_MASK)\r\n#define CAN_CTRL1_PSEG1_MASK                     0x380000u\r\n#define CAN_CTRL1_PSEG1_SHIFT                    19u\r\n#define CAN_CTRL1_PSEG1_WIDTH                    3u\r\n#define CAN_CTRL1_PSEG1(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PSEG1_SHIFT))&CAN_CTRL1_PSEG1_MASK)\r\n#define CAN_CTRL1_RJW_MASK                       0xC00000u\r\n#define CAN_CTRL1_RJW_SHIFT                      22u\r\n#define CAN_CTRL1_RJW_WIDTH                      2u\r\n#define CAN_CTRL1_RJW(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_RJW_SHIFT))&CAN_CTRL1_RJW_MASK)\r\n#define CAN_CTRL1_PRESDIV_MASK                   0xFF000000u\r\n#define CAN_CTRL1_PRESDIV_SHIFT                  24u\r\n#define CAN_CTRL1_PRESDIV_WIDTH                  8u\r\n#define CAN_CTRL1_PRESDIV(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PRESDIV_SHIFT))&CAN_CTRL1_PRESDIV_MASK)\r\n/* TIMER Bit Fields */\r\n#define CAN_TIMER_TIMER_MASK                     0xFFFFu\r\n#define CAN_TIMER_TIMER_SHIFT                    0u\r\n#define CAN_TIMER_TIMER_WIDTH                    16u\r\n#define CAN_TIMER_TIMER(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_TIMER_TIMER_SHIFT))&CAN_TIMER_TIMER_MASK)\r\n/* RXMGMASK Bit Fields */\r\n#define CAN_RXMGMASK_MG_MASK                     0xFFFFFFFFu\r\n#define CAN_RXMGMASK_MG_SHIFT                    0u\r\n#define CAN_RXMGMASK_MG_WIDTH                    32u\r\n#define CAN_RXMGMASK_MG(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_RXMGMASK_MG_SHIFT))&CAN_RXMGMASK_MG_MASK)\r\n/* RX14MASK Bit Fields */\r\n#define CAN_RX14MASK_RX14M_MASK                  0xFFFFFFFFu\r\n#define CAN_RX14MASK_RX14M_SHIFT                 0u\r\n#define CAN_RX14MASK_RX14M_WIDTH                 32u\r\n#define CAN_RX14MASK_RX14M(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_RX14MASK_RX14M_SHIFT))&CAN_RX14MASK_RX14M_MASK)\r\n/* RX15MASK Bit Fields */\r\n#define CAN_RX15MASK_RX15M_MASK                  0xFFFFFFFFu\r\n#define CAN_RX15MASK_RX15M_SHIFT                 0u\r\n#define CAN_RX15MASK_RX15M_WIDTH                 32u\r\n#define CAN_RX15MASK_RX15M(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_RX15MASK_RX15M_SHIFT))&CAN_RX15MASK_RX15M_MASK)\r\n/* ECR Bit Fields */\r\n#define CAN_ECR_TXERRCNT_MASK                    0xFFu\r\n#define CAN_ECR_TXERRCNT_SHIFT                   0u\r\n#define CAN_ECR_TXERRCNT_WIDTH                   8u\r\n#define CAN_ECR_TXERRCNT(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ECR_TXERRCNT_SHIFT))&CAN_ECR_TXERRCNT_MASK)\r\n#define CAN_ECR_RXERRCNT_MASK                    0xFF00u\r\n#define CAN_ECR_RXERRCNT_SHIFT                   8u\r\n#define CAN_ECR_RXERRCNT_WIDTH                   8u\r\n#define CAN_ECR_RXERRCNT(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ECR_RXERRCNT_SHIFT))&CAN_ECR_RXERRCNT_MASK)\r\n#define CAN_ECR_TXERRCNT_FAST_MASK               0xFF0000u\r\n#define CAN_ECR_TXERRCNT_FAST_SHIFT              16u\r\n#define CAN_ECR_TXERRCNT_FAST_WIDTH              8u\r\n#define CAN_ECR_TXERRCNT_FAST(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_ECR_TXERRCNT_FAST_SHIFT))&CAN_ECR_TXERRCNT_FAST_MASK)\r\n#define CAN_ECR_RXERRCNT_FAST_MASK               0xFF000000u\r\n#define CAN_ECR_RXERRCNT_FAST_SHIFT              24u\r\n#define CAN_ECR_RXERRCNT_FAST_WIDTH              8u\r\n#define CAN_ECR_RXERRCNT_FAST(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_ECR_RXERRCNT_FAST_SHIFT))&CAN_ECR_RXERRCNT_FAST_MASK)\r\n/* ESR1 Bit Fields */\r\n#define CAN_ESR1_ERRINT_MASK                     0x2u\r\n#define CAN_ESR1_ERRINT_SHIFT                    1u\r\n#define CAN_ESR1_ERRINT_WIDTH                    1u\r\n#define CAN_ESR1_ERRINT(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_ERRINT_SHIFT))&CAN_ESR1_ERRINT_MASK)\r\n#define CAN_ESR1_BOFFINT_MASK                    0x4u\r\n#define CAN_ESR1_BOFFINT_SHIFT                   2u\r\n#define CAN_ESR1_BOFFINT_WIDTH                   1u\r\n#define CAN_ESR1_BOFFINT(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_BOFFINT_SHIFT))&CAN_ESR1_BOFFINT_MASK)\r\n#define CAN_ESR1_RX_MASK                         0x8u\r\n#define CAN_ESR1_RX_SHIFT                        3u\r\n#define CAN_ESR1_RX_WIDTH                        1u\r\n#define CAN_ESR1_RX(x)                           (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_RX_SHIFT))&CAN_ESR1_RX_MASK)\r\n#define CAN_ESR1_FLTCONF_MASK                    0x30u\r\n#define CAN_ESR1_FLTCONF_SHIFT                   4u\r\n#define CAN_ESR1_FLTCONF_WIDTH                   2u\r\n#define CAN_ESR1_FLTCONF(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_FLTCONF_SHIFT))&CAN_ESR1_FLTCONF_MASK)\r\n#define CAN_ESR1_TX_MASK                         0x40u\r\n#define CAN_ESR1_TX_SHIFT                        6u\r\n#define CAN_ESR1_TX_WIDTH                        1u\r\n#define CAN_ESR1_TX(x)                           (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_TX_SHIFT))&CAN_ESR1_TX_MASK)\r\n#define CAN_ESR1_IDLE_MASK                       0x80u\r\n#define CAN_ESR1_IDLE_SHIFT                      7u\r\n#define CAN_ESR1_IDLE_WIDTH                      1u\r\n#define CAN_ESR1_IDLE(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_IDLE_SHIFT))&CAN_ESR1_IDLE_MASK)\r\n#define CAN_ESR1_RXWRN_MASK                      0x100u\r\n#define CAN_ESR1_RXWRN_SHIFT                     8u\r\n#define CAN_ESR1_RXWRN_WIDTH                     1u\r\n#define CAN_ESR1_RXWRN(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_RXWRN_SHIFT))&CAN_ESR1_RXWRN_MASK)\r\n#define CAN_ESR1_TXWRN_MASK                      0x200u\r\n#define CAN_ESR1_TXWRN_SHIFT                     9u\r\n#define CAN_ESR1_TXWRN_WIDTH                     1u\r\n#define CAN_ESR1_TXWRN(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_TXWRN_SHIFT))&CAN_ESR1_TXWRN_MASK)\r\n#define CAN_ESR1_STFERR_MASK                     0x400u\r\n#define CAN_ESR1_STFERR_SHIFT                    10u\r\n#define CAN_ESR1_STFERR_WIDTH                    1u\r\n#define CAN_ESR1_STFERR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_STFERR_SHIFT))&CAN_ESR1_STFERR_MASK)\r\n#define CAN_ESR1_FRMERR_MASK                     0x800u\r\n#define CAN_ESR1_FRMERR_SHIFT                    11u\r\n#define CAN_ESR1_FRMERR_WIDTH                    1u\r\n#define CAN_ESR1_FRMERR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_FRMERR_SHIFT))&CAN_ESR1_FRMERR_MASK)\r\n#define CAN_ESR1_CRCERR_MASK                     0x1000u\r\n#define CAN_ESR1_CRCERR_SHIFT                    12u\r\n#define CAN_ESR1_CRCERR_WIDTH                    1u\r\n#define CAN_ESR1_CRCERR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_CRCERR_SHIFT))&CAN_ESR1_CRCERR_MASK)\r\n#define CAN_ESR1_ACKERR_MASK                     0x2000u\r\n#define CAN_ESR1_ACKERR_SHIFT                    13u\r\n#define CAN_ESR1_ACKERR_WIDTH                    1u\r\n#define CAN_ESR1_ACKERR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_ACKERR_SHIFT))&CAN_ESR1_ACKERR_MASK)\r\n#define CAN_ESR1_BIT0ERR_MASK                    0x4000u\r\n#define CAN_ESR1_BIT0ERR_SHIFT                   14u\r\n#define CAN_ESR1_BIT0ERR_WIDTH                   1u\r\n#define CAN_ESR1_BIT0ERR(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_BIT0ERR_SHIFT))&CAN_ESR1_BIT0ERR_MASK)\r\n#define CAN_ESR1_BIT1ERR_MASK                    0x8000u\r\n#define CAN_ESR1_BIT1ERR_SHIFT                   15u\r\n#define CAN_ESR1_BIT1ERR_WIDTH                   1u\r\n#define CAN_ESR1_BIT1ERR(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_BIT1ERR_SHIFT))&CAN_ESR1_BIT1ERR_MASK)\r\n#define CAN_ESR1_RWRNINT_MASK                    0x10000u\r\n#define CAN_ESR1_RWRNINT_SHIFT                   16u\r\n#define CAN_ESR1_RWRNINT_WIDTH                   1u\r\n#define CAN_ESR1_RWRNINT(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_RWRNINT_SHIFT))&CAN_ESR1_RWRNINT_MASK)\r\n#define CAN_ESR1_TWRNINT_MASK                    0x20000u\r\n#define CAN_ESR1_TWRNINT_SHIFT                   17u\r\n#define CAN_ESR1_TWRNINT_WIDTH                   1u\r\n#define CAN_ESR1_TWRNINT(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_TWRNINT_SHIFT))&CAN_ESR1_TWRNINT_MASK)\r\n#define CAN_ESR1_SYNCH_MASK                      0x40000u\r\n#define CAN_ESR1_SYNCH_SHIFT                     18u\r\n#define CAN_ESR1_SYNCH_WIDTH                     1u\r\n#define CAN_ESR1_SYNCH(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_SYNCH_SHIFT))&CAN_ESR1_SYNCH_MASK)\r\n#define CAN_ESR1_BOFFDONEINT_MASK                0x80000u\r\n#define CAN_ESR1_BOFFDONEINT_SHIFT               19u\r\n#define CAN_ESR1_BOFFDONEINT_WIDTH               1u\r\n#define CAN_ESR1_BOFFDONEINT(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_BOFFDONEINT_SHIFT))&CAN_ESR1_BOFFDONEINT_MASK)\r\n#define CAN_ESR1_ERRINT_FAST_MASK                0x100000u\r\n#define CAN_ESR1_ERRINT_FAST_SHIFT               20u\r\n#define CAN_ESR1_ERRINT_FAST_WIDTH               1u\r\n#define CAN_ESR1_ERRINT_FAST(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_ERRINT_FAST_SHIFT))&CAN_ESR1_ERRINT_FAST_MASK)\r\n#define CAN_ESR1_ERROVR_MASK                     0x200000u\r\n#define CAN_ESR1_ERROVR_SHIFT                    21u\r\n#define CAN_ESR1_ERROVR_WIDTH                    1u\r\n#define CAN_ESR1_ERROVR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_ERROVR_SHIFT))&CAN_ESR1_ERROVR_MASK)\r\n#define CAN_ESR1_STFERR_FAST_MASK                0x4000000u\r\n#define CAN_ESR1_STFERR_FAST_SHIFT               26u\r\n#define CAN_ESR1_STFERR_FAST_WIDTH               1u\r\n#define CAN_ESR1_STFERR_FAST(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_STFERR_FAST_SHIFT))&CAN_ESR1_STFERR_FAST_MASK)\r\n#define CAN_ESR1_FRMERR_FAST_MASK                0x8000000u\r\n#define CAN_ESR1_FRMERR_FAST_SHIFT               27u\r\n#define CAN_ESR1_FRMERR_FAST_WIDTH               1u\r\n#define CAN_ESR1_FRMERR_FAST(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_FRMERR_FAST_SHIFT))&CAN_ESR1_FRMERR_FAST_MASK)\r\n#define CAN_ESR1_CRCERR_FAST_MASK                0x10000000u\r\n#define CAN_ESR1_CRCERR_FAST_SHIFT               28u\r\n#define CAN_ESR1_CRCERR_FAST_WIDTH               1u\r\n#define CAN_ESR1_CRCERR_FAST(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_CRCERR_FAST_SHIFT))&CAN_ESR1_CRCERR_FAST_MASK)\r\n#define CAN_ESR1_BIT0ERR_FAST_MASK               0x40000000u\r\n#define CAN_ESR1_BIT0ERR_FAST_SHIFT              30u\r\n#define CAN_ESR1_BIT0ERR_FAST_WIDTH              1u\r\n#define CAN_ESR1_BIT0ERR_FAST(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_BIT0ERR_FAST_SHIFT))&CAN_ESR1_BIT0ERR_FAST_MASK)\r\n#define CAN_ESR1_BIT1ERR_FAST_MASK               0x80000000u\r\n#define CAN_ESR1_BIT1ERR_FAST_SHIFT              31u\r\n#define CAN_ESR1_BIT1ERR_FAST_WIDTH              1u\r\n#define CAN_ESR1_BIT1ERR_FAST(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_ESR1_BIT1ERR_FAST_SHIFT))&CAN_ESR1_BIT1ERR_FAST_MASK)\r\n/* IMASK1 Bit Fields */\r\n#define CAN_IMASK1_BUF31TO0M_MASK                0xFFFFFFFFu\r\n#define CAN_IMASK1_BUF31TO0M_SHIFT               0u\r\n#define CAN_IMASK1_BUF31TO0M_WIDTH               32u\r\n#define CAN_IMASK1_BUF31TO0M(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_IMASK1_BUF31TO0M_SHIFT))&CAN_IMASK1_BUF31TO0M_MASK)\r\n/* IFLAG1 Bit Fields */\r\n#define CAN_IFLAG1_BUF0I_MASK                    0x1u\r\n#define CAN_IFLAG1_BUF0I_SHIFT                   0u\r\n#define CAN_IFLAG1_BUF0I_WIDTH                   1u\r\n#define CAN_IFLAG1_BUF0I(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_IFLAG1_BUF0I_SHIFT))&CAN_IFLAG1_BUF0I_MASK)\r\n#define CAN_IFLAG1_BUF4TO1I_MASK                 0x1Eu\r\n#define CAN_IFLAG1_BUF4TO1I_SHIFT                1u\r\n#define CAN_IFLAG1_BUF4TO1I_WIDTH                4u\r\n#define CAN_IFLAG1_BUF4TO1I(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_IFLAG1_BUF4TO1I_SHIFT))&CAN_IFLAG1_BUF4TO1I_MASK)\r\n#define CAN_IFLAG1_BUF5I_MASK                    0x20u\r\n#define CAN_IFLAG1_BUF5I_SHIFT                   5u\r\n#define CAN_IFLAG1_BUF5I_WIDTH                   1u\r\n#define CAN_IFLAG1_BUF5I(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_IFLAG1_BUF5I_SHIFT))&CAN_IFLAG1_BUF5I_MASK)\r\n#define CAN_IFLAG1_BUF6I_MASK                    0x40u\r\n#define CAN_IFLAG1_BUF6I_SHIFT                   6u\r\n#define CAN_IFLAG1_BUF6I_WIDTH                   1u\r\n#define CAN_IFLAG1_BUF6I(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_IFLAG1_BUF6I_SHIFT))&CAN_IFLAG1_BUF6I_MASK)\r\n#define CAN_IFLAG1_BUF7I_MASK                    0x80u\r\n#define CAN_IFLAG1_BUF7I_SHIFT                   7u\r\n#define CAN_IFLAG1_BUF7I_WIDTH                   1u\r\n#define CAN_IFLAG1_BUF7I(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_IFLAG1_BUF7I_SHIFT))&CAN_IFLAG1_BUF7I_MASK)\r\n#define CAN_IFLAG1_BUF31TO8I_MASK                0xFFFFFF00u\r\n#define CAN_IFLAG1_BUF31TO8I_SHIFT               8u\r\n#define CAN_IFLAG1_BUF31TO8I_WIDTH               24u\r\n#define CAN_IFLAG1_BUF31TO8I(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_IFLAG1_BUF31TO8I_SHIFT))&CAN_IFLAG1_BUF31TO8I_MASK)\r\n/* CTRL2 Bit Fields */\r\n#define CAN_CTRL2_EDFLTDIS_MASK                  0x800u\r\n#define CAN_CTRL2_EDFLTDIS_SHIFT                 11u\r\n#define CAN_CTRL2_EDFLTDIS_WIDTH                 1u\r\n#define CAN_CTRL2_EDFLTDIS(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_EDFLTDIS_SHIFT))&CAN_CTRL2_EDFLTDIS_MASK)\r\n#define CAN_CTRL2_ISOCANFDEN_MASK                0x1000u\r\n#define CAN_CTRL2_ISOCANFDEN_SHIFT               12u\r\n#define CAN_CTRL2_ISOCANFDEN_WIDTH               1u\r\n#define CAN_CTRL2_ISOCANFDEN(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_ISOCANFDEN_SHIFT))&CAN_CTRL2_ISOCANFDEN_MASK)\r\n#define CAN_CTRL2_PREXCEN_MASK                   0x4000u\r\n#define CAN_CTRL2_PREXCEN_SHIFT                  14u\r\n#define CAN_CTRL2_PREXCEN_WIDTH                  1u\r\n#define CAN_CTRL2_PREXCEN(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_PREXCEN_SHIFT))&CAN_CTRL2_PREXCEN_MASK)\r\n#define CAN_CTRL2_TIMER_SRC_MASK                 0x8000u\r\n#define CAN_CTRL2_TIMER_SRC_SHIFT                15u\r\n#define CAN_CTRL2_TIMER_SRC_WIDTH                1u\r\n#define CAN_CTRL2_TIMER_SRC(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_TIMER_SRC_SHIFT))&CAN_CTRL2_TIMER_SRC_MASK)\r\n#define CAN_CTRL2_EACEN_MASK                     0x10000u\r\n#define CAN_CTRL2_EACEN_SHIFT                    16u\r\n#define CAN_CTRL2_EACEN_WIDTH                    1u\r\n#define CAN_CTRL2_EACEN(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_EACEN_SHIFT))&CAN_CTRL2_EACEN_MASK)\r\n#define CAN_CTRL2_RRS_MASK                       0x20000u\r\n#define CAN_CTRL2_RRS_SHIFT                      17u\r\n#define CAN_CTRL2_RRS_WIDTH                      1u\r\n#define CAN_CTRL2_RRS(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_RRS_SHIFT))&CAN_CTRL2_RRS_MASK)\r\n#define CAN_CTRL2_MRP_MASK                       0x40000u\r\n#define CAN_CTRL2_MRP_SHIFT                      18u\r\n#define CAN_CTRL2_MRP_WIDTH                      1u\r\n#define CAN_CTRL2_MRP(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_MRP_SHIFT))&CAN_CTRL2_MRP_MASK)\r\n#define CAN_CTRL2_TASD_MASK                      0xF80000u\r\n#define CAN_CTRL2_TASD_SHIFT                     19u\r\n#define CAN_CTRL2_TASD_WIDTH                     5u\r\n#define CAN_CTRL2_TASD(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_TASD_SHIFT))&CAN_CTRL2_TASD_MASK)\r\n#define CAN_CTRL2_RFFN_MASK                      0xF000000u\r\n#define CAN_CTRL2_RFFN_SHIFT                     24u\r\n#define CAN_CTRL2_RFFN_WIDTH                     4u\r\n#define CAN_CTRL2_RFFN(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_RFFN_SHIFT))&CAN_CTRL2_RFFN_MASK)\r\n#define CAN_CTRL2_BOFFDONEMSK_MASK               0x40000000u\r\n#define CAN_CTRL2_BOFFDONEMSK_SHIFT              30u\r\n#define CAN_CTRL2_BOFFDONEMSK_WIDTH              1u\r\n#define CAN_CTRL2_BOFFDONEMSK(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_BOFFDONEMSK_SHIFT))&CAN_CTRL2_BOFFDONEMSK_MASK)\r\n#define CAN_CTRL2_ERRMSK_FAST_MASK               0x80000000u\r\n#define CAN_CTRL2_ERRMSK_FAST_SHIFT              31u\r\n#define CAN_CTRL2_ERRMSK_FAST_WIDTH              1u\r\n#define CAN_CTRL2_ERRMSK_FAST(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_ERRMSK_FAST_SHIFT))&CAN_CTRL2_ERRMSK_FAST_MASK)\r\n/* ESR2 Bit Fields */\r\n#define CAN_ESR2_IMB_MASK                        0x2000u\r\n#define CAN_ESR2_IMB_SHIFT                       13u\r\n#define CAN_ESR2_IMB_WIDTH                       1u\r\n#define CAN_ESR2_IMB(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_ESR2_IMB_SHIFT))&CAN_ESR2_IMB_MASK)\r\n#define CAN_ESR2_VPS_MASK                        0x4000u\r\n#define CAN_ESR2_VPS_SHIFT                       14u\r\n#define CAN_ESR2_VPS_WIDTH                       1u\r\n#define CAN_ESR2_VPS(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_ESR2_VPS_SHIFT))&CAN_ESR2_VPS_MASK)\r\n#define CAN_ESR2_LPTM_MASK                       0x7F0000u\r\n#define CAN_ESR2_LPTM_SHIFT                      16u\r\n#define CAN_ESR2_LPTM_WIDTH                      7u\r\n#define CAN_ESR2_LPTM(x)                         (((uint32_t)(((uint32_t)(x))<<CAN_ESR2_LPTM_SHIFT))&CAN_ESR2_LPTM_MASK)\r\n/* CRCR Bit Fields */\r\n#define CAN_CRCR_TXCRC_MASK                      0x7FFFu\r\n#define CAN_CRCR_TXCRC_SHIFT                     0u\r\n#define CAN_CRCR_TXCRC_WIDTH                     15u\r\n#define CAN_CRCR_TXCRC(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CRCR_TXCRC_SHIFT))&CAN_CRCR_TXCRC_MASK)\r\n#define CAN_CRCR_MBCRC_MASK                      0x7F0000u\r\n#define CAN_CRCR_MBCRC_SHIFT                     16u\r\n#define CAN_CRCR_MBCRC_WIDTH                     7u\r\n#define CAN_CRCR_MBCRC(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CRCR_MBCRC_SHIFT))&CAN_CRCR_MBCRC_MASK)\r\n/* RXFGMASK Bit Fields */\r\n#define CAN_RXFGMASK_FGM_MASK                    0xFFFFFFFFu\r\n#define CAN_RXFGMASK_FGM_SHIFT                   0u\r\n#define CAN_RXFGMASK_FGM_WIDTH                   32u\r\n#define CAN_RXFGMASK_FGM(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_RXFGMASK_FGM_SHIFT))&CAN_RXFGMASK_FGM_MASK)\r\n/* RXFIR Bit Fields */\r\n#define CAN_RXFIR_IDHIT_MASK                     0x1FFu\r\n#define CAN_RXFIR_IDHIT_SHIFT                    0u\r\n#define CAN_RXFIR_IDHIT_WIDTH                    9u\r\n#define CAN_RXFIR_IDHIT(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_RXFIR_IDHIT_SHIFT))&CAN_RXFIR_IDHIT_MASK)\r\n/* CBT Bit Fields */\r\n#define CAN_CBT_EPSEG2_MASK                      0x1Fu\r\n#define CAN_CBT_EPSEG2_SHIFT                     0u\r\n#define CAN_CBT_EPSEG2_WIDTH                     5u\r\n#define CAN_CBT_EPSEG2(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CBT_EPSEG2_SHIFT))&CAN_CBT_EPSEG2_MASK)\r\n#define CAN_CBT_EPSEG1_MASK                      0x3E0u\r\n#define CAN_CBT_EPSEG1_SHIFT                     5u\r\n#define CAN_CBT_EPSEG1_WIDTH                     5u\r\n#define CAN_CBT_EPSEG1(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_CBT_EPSEG1_SHIFT))&CAN_CBT_EPSEG1_MASK)\r\n#define CAN_CBT_EPROPSEG_MASK                    0xFC00u\r\n#define CAN_CBT_EPROPSEG_SHIFT                   10u\r\n#define CAN_CBT_EPROPSEG_WIDTH                   6u\r\n#define CAN_CBT_EPROPSEG(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_CBT_EPROPSEG_SHIFT))&CAN_CBT_EPROPSEG_MASK)\r\n#define CAN_CBT_ERJW_MASK                        0x1F0000u\r\n#define CAN_CBT_ERJW_SHIFT                       16u\r\n#define CAN_CBT_ERJW_WIDTH                       5u\r\n#define CAN_CBT_ERJW(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_CBT_ERJW_SHIFT))&CAN_CBT_ERJW_MASK)\r\n#define CAN_CBT_EPRESDIV_MASK                    0x7FE00000u\r\n#define CAN_CBT_EPRESDIV_SHIFT                   21u\r\n#define CAN_CBT_EPRESDIV_WIDTH                   10u\r\n#define CAN_CBT_EPRESDIV(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_CBT_EPRESDIV_SHIFT))&CAN_CBT_EPRESDIV_MASK)\r\n#define CAN_CBT_BTF_MASK                         0x80000000u\r\n#define CAN_CBT_BTF_SHIFT                        31u\r\n#define CAN_CBT_BTF_WIDTH                        1u\r\n#define CAN_CBT_BTF(x)                           (((uint32_t)(((uint32_t)(x))<<CAN_CBT_BTF_SHIFT))&CAN_CBT_BTF_MASK)\r\n/* RAMn Bit Fields */\r\n#define CAN_RAMn_DATA_BYTE_3_MASK                0xFFu\r\n#define CAN_RAMn_DATA_BYTE_3_SHIFT               0u\r\n#define CAN_RAMn_DATA_BYTE_3_WIDTH               8u\r\n#define CAN_RAMn_DATA_BYTE_3(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_RAMn_DATA_BYTE_3_SHIFT))&CAN_RAMn_DATA_BYTE_3_MASK)\r\n#define CAN_RAMn_DATA_BYTE_2_MASK                0xFF00u\r\n#define CAN_RAMn_DATA_BYTE_2_SHIFT               8u\r\n#define CAN_RAMn_DATA_BYTE_2_WIDTH               8u\r\n#define CAN_RAMn_DATA_BYTE_2(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_RAMn_DATA_BYTE_2_SHIFT))&CAN_RAMn_DATA_BYTE_2_MASK)\r\n#define CAN_RAMn_DATA_BYTE_1_MASK                0xFF0000u\r\n#define CAN_RAMn_DATA_BYTE_1_SHIFT               16u\r\n#define CAN_RAMn_DATA_BYTE_1_WIDTH               8u\r\n#define CAN_RAMn_DATA_BYTE_1(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_RAMn_DATA_BYTE_1_SHIFT))&CAN_RAMn_DATA_BYTE_1_MASK)\r\n#define CAN_RAMn_DATA_BYTE_0_MASK                0xFF000000u\r\n#define CAN_RAMn_DATA_BYTE_0_SHIFT               24u\r\n#define CAN_RAMn_DATA_BYTE_0_WIDTH               8u\r\n#define CAN_RAMn_DATA_BYTE_0(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_RAMn_DATA_BYTE_0_SHIFT))&CAN_RAMn_DATA_BYTE_0_MASK)\r\n/* RXIMR Bit Fields */\r\n#define CAN_RXIMR_MI_MASK                        0xFFFFFFFFu\r\n#define CAN_RXIMR_MI_SHIFT                       0u\r\n#define CAN_RXIMR_MI_WIDTH                       32u\r\n#define CAN_RXIMR_MI(x)                          (((uint32_t)(((uint32_t)(x))<<CAN_RXIMR_MI_SHIFT))&CAN_RXIMR_MI_MASK)\r\n/* CTRL1_PN Bit Fields */\r\n#define CAN_CTRL1_PN_FCS_MASK                    0x3u\r\n#define CAN_CTRL1_PN_FCS_SHIFT                   0u\r\n#define CAN_CTRL1_PN_FCS_WIDTH                   2u\r\n#define CAN_CTRL1_PN_FCS(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PN_FCS_SHIFT))&CAN_CTRL1_PN_FCS_MASK)\r\n#define CAN_CTRL1_PN_IDFS_MASK                   0xCu\r\n#define CAN_CTRL1_PN_IDFS_SHIFT                  2u\r\n#define CAN_CTRL1_PN_IDFS_WIDTH                  2u\r\n#define CAN_CTRL1_PN_IDFS(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PN_IDFS_SHIFT))&CAN_CTRL1_PN_IDFS_MASK)\r\n#define CAN_CTRL1_PN_PLFS_MASK                   0x30u\r\n#define CAN_CTRL1_PN_PLFS_SHIFT                  4u\r\n#define CAN_CTRL1_PN_PLFS_WIDTH                  2u\r\n#define CAN_CTRL1_PN_PLFS(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PN_PLFS_SHIFT))&CAN_CTRL1_PN_PLFS_MASK)\r\n#define CAN_CTRL1_PN_NMATCH_MASK                 0xFF00u\r\n#define CAN_CTRL1_PN_NMATCH_SHIFT                8u\r\n#define CAN_CTRL1_PN_NMATCH_WIDTH                8u\r\n#define CAN_CTRL1_PN_NMATCH(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PN_NMATCH_SHIFT))&CAN_CTRL1_PN_NMATCH_MASK)\r\n#define CAN_CTRL1_PN_WUMF_MSK_MASK               0x10000u\r\n#define CAN_CTRL1_PN_WUMF_MSK_SHIFT              16u\r\n#define CAN_CTRL1_PN_WUMF_MSK_WIDTH              1u\r\n#define CAN_CTRL1_PN_WUMF_MSK(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PN_WUMF_MSK_SHIFT))&CAN_CTRL1_PN_WUMF_MSK_MASK)\r\n#define CAN_CTRL1_PN_WTOF_MSK_MASK               0x20000u\r\n#define CAN_CTRL1_PN_WTOF_MSK_SHIFT              17u\r\n#define CAN_CTRL1_PN_WTOF_MSK_WIDTH              1u\r\n#define CAN_CTRL1_PN_WTOF_MSK(x)                 (((uint32_t)(((uint32_t)(x))<<CAN_CTRL1_PN_WTOF_MSK_SHIFT))&CAN_CTRL1_PN_WTOF_MSK_MASK)\r\n/* CTRL2_PN Bit Fields */\r\n#define CAN_CTRL2_PN_MATCHTO_MASK                0xFFFFu\r\n#define CAN_CTRL2_PN_MATCHTO_SHIFT               0u\r\n#define CAN_CTRL2_PN_MATCHTO_WIDTH               16u\r\n#define CAN_CTRL2_PN_MATCHTO(x)                  (((uint32_t)(((uint32_t)(x))<<CAN_CTRL2_PN_MATCHTO_SHIFT))&CAN_CTRL2_PN_MATCHTO_MASK)\r\n/* WU_MTC Bit Fields */\r\n#define CAN_WU_MTC_MCOUNTER_MASK                 0xFF00u\r\n#define CAN_WU_MTC_MCOUNTER_SHIFT                8u\r\n#define CAN_WU_MTC_MCOUNTER_WIDTH                8u\r\n#define CAN_WU_MTC_MCOUNTER(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_WU_MTC_MCOUNTER_SHIFT))&CAN_WU_MTC_MCOUNTER_MASK)\r\n#define CAN_WU_MTC_WUMF_MASK                     0x10000u\r\n#define CAN_WU_MTC_WUMF_SHIFT                    16u\r\n#define CAN_WU_MTC_WUMF_WIDTH                    1u\r\n#define CAN_WU_MTC_WUMF(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_WU_MTC_WUMF_SHIFT))&CAN_WU_MTC_WUMF_MASK)\r\n#define CAN_WU_MTC_WTOF_MASK                     0x20000u\r\n#define CAN_WU_MTC_WTOF_SHIFT                    17u\r\n#define CAN_WU_MTC_WTOF_WIDTH                    1u\r\n#define CAN_WU_MTC_WTOF(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_WU_MTC_WTOF_SHIFT))&CAN_WU_MTC_WTOF_MASK)\r\n/* FLT_ID1 Bit Fields */\r\n#define CAN_FLT_ID1_FLT_ID1_MASK                 0x1FFFFFFFu\r\n#define CAN_FLT_ID1_FLT_ID1_SHIFT                0u\r\n#define CAN_FLT_ID1_FLT_ID1_WIDTH                29u\r\n#define CAN_FLT_ID1_FLT_ID1(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_FLT_ID1_FLT_ID1_SHIFT))&CAN_FLT_ID1_FLT_ID1_MASK)\r\n#define CAN_FLT_ID1_FLT_RTR_MASK                 0x20000000u\r\n#define CAN_FLT_ID1_FLT_RTR_SHIFT                29u\r\n#define CAN_FLT_ID1_FLT_RTR_WIDTH                1u\r\n#define CAN_FLT_ID1_FLT_RTR(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_FLT_ID1_FLT_RTR_SHIFT))&CAN_FLT_ID1_FLT_RTR_MASK)\r\n#define CAN_FLT_ID1_FLT_IDE_MASK                 0x40000000u\r\n#define CAN_FLT_ID1_FLT_IDE_SHIFT                30u\r\n#define CAN_FLT_ID1_FLT_IDE_WIDTH                1u\r\n#define CAN_FLT_ID1_FLT_IDE(x)                   (((uint32_t)(((uint32_t)(x))<<CAN_FLT_ID1_FLT_IDE_SHIFT))&CAN_FLT_ID1_FLT_IDE_MASK)\r\n/* FLT_DLC Bit Fields */\r\n#define CAN_FLT_DLC_FLT_DLC_HI_MASK              0xFu\r\n#define CAN_FLT_DLC_FLT_DLC_HI_SHIFT             0u\r\n#define CAN_FLT_DLC_FLT_DLC_HI_WIDTH             4u\r\n#define CAN_FLT_DLC_FLT_DLC_HI(x)                (((uint32_t)(((uint32_t)(x))<<CAN_FLT_DLC_FLT_DLC_HI_SHIFT))&CAN_FLT_DLC_FLT_DLC_HI_MASK)\r\n#define CAN_FLT_DLC_FLT_DLC_LO_MASK              0xF0000u\r\n#define CAN_FLT_DLC_FLT_DLC_LO_SHIFT             16u\r\n#define CAN_FLT_DLC_FLT_DLC_LO_WIDTH             4u\r\n#define CAN_FLT_DLC_FLT_DLC_LO(x)                (((uint32_t)(((uint32_t)(x))<<CAN_FLT_DLC_FLT_DLC_LO_SHIFT))&CAN_FLT_DLC_FLT_DLC_LO_MASK)\r\n/* PL1_LO Bit Fields */\r\n#define CAN_PL1_LO_Data_byte_3_MASK              0xFFu\r\n#define CAN_PL1_LO_Data_byte_3_SHIFT             0u\r\n#define CAN_PL1_LO_Data_byte_3_WIDTH             8u\r\n#define CAN_PL1_LO_Data_byte_3(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_LO_Data_byte_3_SHIFT))&CAN_PL1_LO_Data_byte_3_MASK)\r\n#define CAN_PL1_LO_Data_byte_2_MASK              0xFF00u\r\n#define CAN_PL1_LO_Data_byte_2_SHIFT             8u\r\n#define CAN_PL1_LO_Data_byte_2_WIDTH             8u\r\n#define CAN_PL1_LO_Data_byte_2(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_LO_Data_byte_2_SHIFT))&CAN_PL1_LO_Data_byte_2_MASK)\r\n#define CAN_PL1_LO_Data_byte_1_MASK              0xFF0000u\r\n#define CAN_PL1_LO_Data_byte_1_SHIFT             16u\r\n#define CAN_PL1_LO_Data_byte_1_WIDTH             8u\r\n#define CAN_PL1_LO_Data_byte_1(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_LO_Data_byte_1_SHIFT))&CAN_PL1_LO_Data_byte_1_MASK)\r\n#define CAN_PL1_LO_Data_byte_0_MASK              0xFF000000u\r\n#define CAN_PL1_LO_Data_byte_0_SHIFT             24u\r\n#define CAN_PL1_LO_Data_byte_0_WIDTH             8u\r\n#define CAN_PL1_LO_Data_byte_0(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_LO_Data_byte_0_SHIFT))&CAN_PL1_LO_Data_byte_0_MASK)\r\n/* PL1_HI Bit Fields */\r\n#define CAN_PL1_HI_Data_byte_7_MASK              0xFFu\r\n#define CAN_PL1_HI_Data_byte_7_SHIFT             0u\r\n#define CAN_PL1_HI_Data_byte_7_WIDTH             8u\r\n#define CAN_PL1_HI_Data_byte_7(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_HI_Data_byte_7_SHIFT))&CAN_PL1_HI_Data_byte_7_MASK)\r\n#define CAN_PL1_HI_Data_byte_6_MASK              0xFF00u\r\n#define CAN_PL1_HI_Data_byte_6_SHIFT             8u\r\n#define CAN_PL1_HI_Data_byte_6_WIDTH             8u\r\n#define CAN_PL1_HI_Data_byte_6(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_HI_Data_byte_6_SHIFT))&CAN_PL1_HI_Data_byte_6_MASK)\r\n#define CAN_PL1_HI_Data_byte_5_MASK              0xFF0000u\r\n#define CAN_PL1_HI_Data_byte_5_SHIFT             16u\r\n#define CAN_PL1_HI_Data_byte_5_WIDTH             8u\r\n#define CAN_PL1_HI_Data_byte_5(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_HI_Data_byte_5_SHIFT))&CAN_PL1_HI_Data_byte_5_MASK)\r\n#define CAN_PL1_HI_Data_byte_4_MASK              0xFF000000u\r\n#define CAN_PL1_HI_Data_byte_4_SHIFT             24u\r\n#define CAN_PL1_HI_Data_byte_4_WIDTH             8u\r\n#define CAN_PL1_HI_Data_byte_4(x)                (((uint32_t)(((uint32_t)(x))<<CAN_PL1_HI_Data_byte_4_SHIFT))&CAN_PL1_HI_Data_byte_4_MASK)\r\n/* FLT_ID2_IDMASK Bit Fields */\r\n#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_MASK   0x1FFFFFFFu\r\n#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_SHIFT  0u\r\n#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_WIDTH  29u\r\n#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK(x)     (((uint32_t)(((uint32_t)(x))<<CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_SHIFT))&CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_MASK)\r\n#define CAN_FLT_ID2_IDMASK_RTR_MSK_MASK          0x20000000u\r\n#define CAN_FLT_ID2_IDMASK_RTR_MSK_SHIFT         29u\r\n#define CAN_FLT_ID2_IDMASK_RTR_MSK_WIDTH         1u\r\n#define CAN_FLT_ID2_IDMASK_RTR_MSK(x)            (((uint32_t)(((uint32_t)(x))<<CAN_FLT_ID2_IDMASK_RTR_MSK_SHIFT))&CAN_FLT_ID2_IDMASK_RTR_MSK_MASK)\r\n#define CAN_FLT_ID2_IDMASK_IDE_MSK_MASK          0x40000000u\r\n#define CAN_FLT_ID2_IDMASK_IDE_MSK_SHIFT         30u\r\n#define CAN_FLT_ID2_IDMASK_IDE_MSK_WIDTH         1u\r\n#define CAN_FLT_ID2_IDMASK_IDE_MSK(x)            (((uint32_t)(((uint32_t)(x))<<CAN_FLT_ID2_IDMASK_IDE_MSK_SHIFT))&CAN_FLT_ID2_IDMASK_IDE_MSK_MASK)\r\n/* PL2_PLMASK_LO Bit Fields */\r\n#define CAN_PL2_PLMASK_LO_Data_byte_3_MASK       0xFFu\r\n#define CAN_PL2_PLMASK_LO_Data_byte_3_SHIFT      0u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_3_WIDTH      8u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_3(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_LO_Data_byte_3_SHIFT))&CAN_PL2_PLMASK_LO_Data_byte_3_MASK)\r\n#define CAN_PL2_PLMASK_LO_Data_byte_2_MASK       0xFF00u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_2_SHIFT      8u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_2_WIDTH      8u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_2(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_LO_Data_byte_2_SHIFT))&CAN_PL2_PLMASK_LO_Data_byte_2_MASK)\r\n#define CAN_PL2_PLMASK_LO_Data_byte_1_MASK       0xFF0000u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_1_SHIFT      16u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_1_WIDTH      8u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_1(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_LO_Data_byte_1_SHIFT))&CAN_PL2_PLMASK_LO_Data_byte_1_MASK)\r\n#define CAN_PL2_PLMASK_LO_Data_byte_0_MASK       0xFF000000u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_0_SHIFT      24u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_0_WIDTH      8u\r\n#define CAN_PL2_PLMASK_LO_Data_byte_0(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_LO_Data_byte_0_SHIFT))&CAN_PL2_PLMASK_LO_Data_byte_0_MASK)\r\n/* PL2_PLMASK_HI Bit Fields */\r\n#define CAN_PL2_PLMASK_HI_Data_byte_7_MASK       0xFFu\r\n#define CAN_PL2_PLMASK_HI_Data_byte_7_SHIFT      0u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_7_WIDTH      8u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_7(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_HI_Data_byte_7_SHIFT))&CAN_PL2_PLMASK_HI_Data_byte_7_MASK)\r\n#define CAN_PL2_PLMASK_HI_Data_byte_6_MASK       0xFF00u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_6_SHIFT      8u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_6_WIDTH      8u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_6(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_HI_Data_byte_6_SHIFT))&CAN_PL2_PLMASK_HI_Data_byte_6_MASK)\r\n#define CAN_PL2_PLMASK_HI_Data_byte_5_MASK       0xFF0000u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_5_SHIFT      16u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_5_WIDTH      8u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_5(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_HI_Data_byte_5_SHIFT))&CAN_PL2_PLMASK_HI_Data_byte_5_MASK)\r\n#define CAN_PL2_PLMASK_HI_Data_byte_4_MASK       0xFF000000u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_4_SHIFT      24u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_4_WIDTH      8u\r\n#define CAN_PL2_PLMASK_HI_Data_byte_4(x)         (((uint32_t)(((uint32_t)(x))<<CAN_PL2_PLMASK_HI_Data_byte_4_SHIFT))&CAN_PL2_PLMASK_HI_Data_byte_4_MASK)\r\n/* WMBn_CS Bit Fields */\r\n#define CAN_WMBn_CS_DLC_MASK                     0xF0000u\r\n#define CAN_WMBn_CS_DLC_SHIFT                    16u\r\n#define CAN_WMBn_CS_DLC_WIDTH                    4u\r\n#define CAN_WMBn_CS_DLC(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_CS_DLC_SHIFT))&CAN_WMBn_CS_DLC_MASK)\r\n#define CAN_WMBn_CS_RTR_MASK                     0x100000u\r\n#define CAN_WMBn_CS_RTR_SHIFT                    20u\r\n#define CAN_WMBn_CS_RTR_WIDTH                    1u\r\n#define CAN_WMBn_CS_RTR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_CS_RTR_SHIFT))&CAN_WMBn_CS_RTR_MASK)\r\n#define CAN_WMBn_CS_IDE_MASK                     0x200000u\r\n#define CAN_WMBn_CS_IDE_SHIFT                    21u\r\n#define CAN_WMBn_CS_IDE_WIDTH                    1u\r\n#define CAN_WMBn_CS_IDE(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_CS_IDE_SHIFT))&CAN_WMBn_CS_IDE_MASK)\r\n#define CAN_WMBn_CS_SRR_MASK                     0x400000u\r\n#define CAN_WMBn_CS_SRR_SHIFT                    22u\r\n#define CAN_WMBn_CS_SRR_WIDTH                    1u\r\n#define CAN_WMBn_CS_SRR(x)                       (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_CS_SRR_SHIFT))&CAN_WMBn_CS_SRR_MASK)\r\n/* WMBn_ID Bit Fields */\r\n#define CAN_WMBn_ID_ID_MASK                      0x1FFFFFFFu\r\n#define CAN_WMBn_ID_ID_SHIFT                     0u\r\n#define CAN_WMBn_ID_ID_WIDTH                     29u\r\n#define CAN_WMBn_ID_ID(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_ID_ID_SHIFT))&CAN_WMBn_ID_ID_MASK)\r\n/* WMBn_D03 Bit Fields */\r\n#define CAN_WMBn_D03_Data_byte_3_MASK            0xFFu\r\n#define CAN_WMBn_D03_Data_byte_3_SHIFT           0u\r\n#define CAN_WMBn_D03_Data_byte_3_WIDTH           8u\r\n#define CAN_WMBn_D03_Data_byte_3(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D03_Data_byte_3_SHIFT))&CAN_WMBn_D03_Data_byte_3_MASK)\r\n#define CAN_WMBn_D03_Data_byte_2_MASK            0xFF00u\r\n#define CAN_WMBn_D03_Data_byte_2_SHIFT           8u\r\n#define CAN_WMBn_D03_Data_byte_2_WIDTH           8u\r\n#define CAN_WMBn_D03_Data_byte_2(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D03_Data_byte_2_SHIFT))&CAN_WMBn_D03_Data_byte_2_MASK)\r\n#define CAN_WMBn_D03_Data_byte_1_MASK            0xFF0000u\r\n#define CAN_WMBn_D03_Data_byte_1_SHIFT           16u\r\n#define CAN_WMBn_D03_Data_byte_1_WIDTH           8u\r\n#define CAN_WMBn_D03_Data_byte_1(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D03_Data_byte_1_SHIFT))&CAN_WMBn_D03_Data_byte_1_MASK)\r\n#define CAN_WMBn_D03_Data_byte_0_MASK            0xFF000000u\r\n#define CAN_WMBn_D03_Data_byte_0_SHIFT           24u\r\n#define CAN_WMBn_D03_Data_byte_0_WIDTH           8u\r\n#define CAN_WMBn_D03_Data_byte_0(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D03_Data_byte_0_SHIFT))&CAN_WMBn_D03_Data_byte_0_MASK)\r\n/* WMBn_D47 Bit Fields */\r\n#define CAN_WMBn_D47_Data_byte_7_MASK            0xFFu\r\n#define CAN_WMBn_D47_Data_byte_7_SHIFT           0u\r\n#define CAN_WMBn_D47_Data_byte_7_WIDTH           8u\r\n#define CAN_WMBn_D47_Data_byte_7(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D47_Data_byte_7_SHIFT))&CAN_WMBn_D47_Data_byte_7_MASK)\r\n#define CAN_WMBn_D47_Data_byte_6_MASK            0xFF00u\r\n#define CAN_WMBn_D47_Data_byte_6_SHIFT           8u\r\n#define CAN_WMBn_D47_Data_byte_6_WIDTH           8u\r\n#define CAN_WMBn_D47_Data_byte_6(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D47_Data_byte_6_SHIFT))&CAN_WMBn_D47_Data_byte_6_MASK)\r\n#define CAN_WMBn_D47_Data_byte_5_MASK            0xFF0000u\r\n#define CAN_WMBn_D47_Data_byte_5_SHIFT           16u\r\n#define CAN_WMBn_D47_Data_byte_5_WIDTH           8u\r\n#define CAN_WMBn_D47_Data_byte_5(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D47_Data_byte_5_SHIFT))&CAN_WMBn_D47_Data_byte_5_MASK)\r\n#define CAN_WMBn_D47_Data_byte_4_MASK            0xFF000000u\r\n#define CAN_WMBn_D47_Data_byte_4_SHIFT           24u\r\n#define CAN_WMBn_D47_Data_byte_4_WIDTH           8u\r\n#define CAN_WMBn_D47_Data_byte_4(x)              (((uint32_t)(((uint32_t)(x))<<CAN_WMBn_D47_Data_byte_4_SHIFT))&CAN_WMBn_D47_Data_byte_4_MASK)\r\n/* FDCTRL Bit Fields */\r\n#define CAN_FDCTRL_TDCVAL_MASK                   0x3Fu\r\n#define CAN_FDCTRL_TDCVAL_SHIFT                  0u\r\n#define CAN_FDCTRL_TDCVAL_WIDTH                  6u\r\n#define CAN_FDCTRL_TDCVAL(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_FDCTRL_TDCVAL_SHIFT))&CAN_FDCTRL_TDCVAL_MASK)\r\n#define CAN_FDCTRL_TDCOFF_MASK                   0x1F00u\r\n#define CAN_FDCTRL_TDCOFF_SHIFT                  8u\r\n#define CAN_FDCTRL_TDCOFF_WIDTH                  5u\r\n#define CAN_FDCTRL_TDCOFF(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_FDCTRL_TDCOFF_SHIFT))&CAN_FDCTRL_TDCOFF_MASK)\r\n#define CAN_FDCTRL_TDCFAIL_MASK                  0x4000u\r\n#define CAN_FDCTRL_TDCFAIL_SHIFT                 14u\r\n#define CAN_FDCTRL_TDCFAIL_WIDTH                 1u\r\n#define CAN_FDCTRL_TDCFAIL(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_FDCTRL_TDCFAIL_SHIFT))&CAN_FDCTRL_TDCFAIL_MASK)\r\n#define CAN_FDCTRL_TDCEN_MASK                    0x8000u\r\n#define CAN_FDCTRL_TDCEN_SHIFT                   15u\r\n#define CAN_FDCTRL_TDCEN_WIDTH                   1u\r\n#define CAN_FDCTRL_TDCEN(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_FDCTRL_TDCEN_SHIFT))&CAN_FDCTRL_TDCEN_MASK)\r\n#define CAN_FDCTRL_MBDSR0_MASK                   0x30000u\r\n#define CAN_FDCTRL_MBDSR0_SHIFT                  16u\r\n#define CAN_FDCTRL_MBDSR0_WIDTH                  2u\r\n#define CAN_FDCTRL_MBDSR0(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_FDCTRL_MBDSR0_SHIFT))&CAN_FDCTRL_MBDSR0_MASK)\r\n#define CAN_FDCTRL_FDRATE_MASK                   0x80000000u\r\n#define CAN_FDCTRL_FDRATE_SHIFT                  31u\r\n#define CAN_FDCTRL_FDRATE_WIDTH                  1u\r\n#define CAN_FDCTRL_FDRATE(x)                     (((uint32_t)(((uint32_t)(x))<<CAN_FDCTRL_FDRATE_SHIFT))&CAN_FDCTRL_FDRATE_MASK)\r\n/* FDCBT Bit Fields */\r\n#define CAN_FDCBT_FPSEG2_MASK                    0x7u\r\n#define CAN_FDCBT_FPSEG2_SHIFT                   0u\r\n#define CAN_FDCBT_FPSEG2_WIDTH                   3u\r\n#define CAN_FDCBT_FPSEG2(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_FDCBT_FPSEG2_SHIFT))&CAN_FDCBT_FPSEG2_MASK)\r\n#define CAN_FDCBT_FPSEG1_MASK                    0xE0u\r\n#define CAN_FDCBT_FPSEG1_SHIFT                   5u\r\n#define CAN_FDCBT_FPSEG1_WIDTH                   3u\r\n#define CAN_FDCBT_FPSEG1(x)                      (((uint32_t)(((uint32_t)(x))<<CAN_FDCBT_FPSEG1_SHIFT))&CAN_FDCBT_FPSEG1_MASK)\r\n#define CAN_FDCBT_FPROPSEG_MASK                  0x7C00u\r\n#define CAN_FDCBT_FPROPSEG_SHIFT                 10u\r\n#define CAN_FDCBT_FPROPSEG_WIDTH                 5u\r\n#define CAN_FDCBT_FPROPSEG(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_FDCBT_FPROPSEG_SHIFT))&CAN_FDCBT_FPROPSEG_MASK)\r\n#define CAN_FDCBT_FRJW_MASK                      0x70000u\r\n#define CAN_FDCBT_FRJW_SHIFT                     16u\r\n#define CAN_FDCBT_FRJW_WIDTH                     3u\r\n#define CAN_FDCBT_FRJW(x)                        (((uint32_t)(((uint32_t)(x))<<CAN_FDCBT_FRJW_SHIFT))&CAN_FDCBT_FRJW_MASK)\r\n#define CAN_FDCBT_FPRESDIV_MASK                  0x3FF00000u\r\n#define CAN_FDCBT_FPRESDIV_SHIFT                 20u\r\n#define CAN_FDCBT_FPRESDIV_WIDTH                 10u\r\n#define CAN_FDCBT_FPRESDIV(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_FDCBT_FPRESDIV_SHIFT))&CAN_FDCBT_FPRESDIV_MASK)\r\n/* FDCRC Bit Fields */\r\n#define CAN_FDCRC_FD_TXCRC_MASK                  0x1FFFFFu\r\n#define CAN_FDCRC_FD_TXCRC_SHIFT                 0u\r\n#define CAN_FDCRC_FD_TXCRC_WIDTH                 21u\r\n#define CAN_FDCRC_FD_TXCRC(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_FDCRC_FD_TXCRC_SHIFT))&CAN_FDCRC_FD_TXCRC_MASK)\r\n#define CAN_FDCRC_FD_MBCRC_MASK                  0x7F000000u\r\n#define CAN_FDCRC_FD_MBCRC_SHIFT                 24u\r\n#define CAN_FDCRC_FD_MBCRC_WIDTH                 7u\r\n#define CAN_FDCRC_FD_MBCRC(x)                    (((uint32_t)(((uint32_t)(x))<<CAN_FDCRC_FD_MBCRC_SHIFT))&CAN_FDCRC_FD_MBCRC_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CAN_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CAN_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CMP Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CMP_Peripheral_Access_Layer CMP Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** CMP - Size of Registers Arrays */\r\n\r\n/** CMP - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t C0;                                /**< CMP Control Register 0, offset: 0x0 */\r\n  __IO uint32_t C1;                                /**< CMP Control Register 1, offset: 0x4 */\r\n  __IO uint32_t C2;                                /**< CMP Control Register 2, offset: 0x8 */\r\n} CMP_Type, *CMP_MemMapPtr;\r\n\r\n /** Number of instances of the CMP module. */\r\n#define CMP_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* CMP - Peripheral instance base addresses */\r\n/** Peripheral CMP0 base address */\r\n#define CMP0_BASE                                (0x40073000u)\r\n/** Peripheral CMP0 base pointer */\r\n#define CMP0                                     ((CMP_Type *)CMP0_BASE)\r\n/** Array initializer of CMP peripheral base addresses */\r\n#define CMP_BASE_ADDRS                           { CMP0_BASE }\r\n/** Array initializer of CMP peripheral base pointers */\r\n#define CMP_BASE_PTRS                            { CMP0 }\r\n /** Number of interrupt vector arrays for the CMP module. */\r\n#define CMP_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the CMP module. */\r\n#define CMP_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the CMP peripheral type */\r\n#define CMP_IRQS                                 { CMP0_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CMP Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CMP_Register_Masks CMP Register Masks\r\n * @{\r\n */\r\n\r\n/* C0 Bit Fields */\r\n#define CMP_C0_HYSTCTR_MASK                      0x3u\r\n#define CMP_C0_HYSTCTR_SHIFT                     0u\r\n#define CMP_C0_HYSTCTR_WIDTH                     2u\r\n#define CMP_C0_HYSTCTR(x)                        (((uint32_t)(((uint32_t)(x))<<CMP_C0_HYSTCTR_SHIFT))&CMP_C0_HYSTCTR_MASK)\r\n#define CMP_C0_OFFSET_MASK                       0x4u\r\n#define CMP_C0_OFFSET_SHIFT                      2u\r\n#define CMP_C0_OFFSET_WIDTH                      1u\r\n#define CMP_C0_OFFSET(x)                         (((uint32_t)(((uint32_t)(x))<<CMP_C0_OFFSET_SHIFT))&CMP_C0_OFFSET_MASK)\r\n#define CMP_C0_FILTER_CNT_MASK                   0x70u\r\n#define CMP_C0_FILTER_CNT_SHIFT                  4u\r\n#define CMP_C0_FILTER_CNT_WIDTH                  3u\r\n#define CMP_C0_FILTER_CNT(x)                     (((uint32_t)(((uint32_t)(x))<<CMP_C0_FILTER_CNT_SHIFT))&CMP_C0_FILTER_CNT_MASK)\r\n#define CMP_C0_EN_MASK                           0x100u\r\n#define CMP_C0_EN_SHIFT                          8u\r\n#define CMP_C0_EN_WIDTH                          1u\r\n#define CMP_C0_EN(x)                             (((uint32_t)(((uint32_t)(x))<<CMP_C0_EN_SHIFT))&CMP_C0_EN_MASK)\r\n#define CMP_C0_OPE_MASK                          0x200u\r\n#define CMP_C0_OPE_SHIFT                         9u\r\n#define CMP_C0_OPE_WIDTH                         1u\r\n#define CMP_C0_OPE(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_OPE_SHIFT))&CMP_C0_OPE_MASK)\r\n#define CMP_C0_COS_MASK                          0x400u\r\n#define CMP_C0_COS_SHIFT                         10u\r\n#define CMP_C0_COS_WIDTH                         1u\r\n#define CMP_C0_COS(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_COS_SHIFT))&CMP_C0_COS_MASK)\r\n#define CMP_C0_INVT_MASK                         0x800u\r\n#define CMP_C0_INVT_SHIFT                        11u\r\n#define CMP_C0_INVT_WIDTH                        1u\r\n#define CMP_C0_INVT(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C0_INVT_SHIFT))&CMP_C0_INVT_MASK)\r\n#define CMP_C0_PMODE_MASK                        0x1000u\r\n#define CMP_C0_PMODE_SHIFT                       12u\r\n#define CMP_C0_PMODE_WIDTH                       1u\r\n#define CMP_C0_PMODE(x)                          (((uint32_t)(((uint32_t)(x))<<CMP_C0_PMODE_SHIFT))&CMP_C0_PMODE_MASK)\r\n#define CMP_C0_WE_MASK                           0x4000u\r\n#define CMP_C0_WE_SHIFT                          14u\r\n#define CMP_C0_WE_WIDTH                          1u\r\n#define CMP_C0_WE(x)                             (((uint32_t)(((uint32_t)(x))<<CMP_C0_WE_SHIFT))&CMP_C0_WE_MASK)\r\n#define CMP_C0_SE_MASK                           0x8000u\r\n#define CMP_C0_SE_SHIFT                          15u\r\n#define CMP_C0_SE_WIDTH                          1u\r\n#define CMP_C0_SE(x)                             (((uint32_t)(((uint32_t)(x))<<CMP_C0_SE_SHIFT))&CMP_C0_SE_MASK)\r\n#define CMP_C0_FPR_MASK                          0xFF0000u\r\n#define CMP_C0_FPR_SHIFT                         16u\r\n#define CMP_C0_FPR_WIDTH                         8u\r\n#define CMP_C0_FPR(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_FPR_SHIFT))&CMP_C0_FPR_MASK)\r\n#define CMP_C0_COUT_MASK                         0x1000000u\r\n#define CMP_C0_COUT_SHIFT                        24u\r\n#define CMP_C0_COUT_WIDTH                        1u\r\n#define CMP_C0_COUT(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C0_COUT_SHIFT))&CMP_C0_COUT_MASK)\r\n#define CMP_C0_CFF_MASK                          0x2000000u\r\n#define CMP_C0_CFF_SHIFT                         25u\r\n#define CMP_C0_CFF_WIDTH                         1u\r\n#define CMP_C0_CFF(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_CFF_SHIFT))&CMP_C0_CFF_MASK)\r\n#define CMP_C0_CFR_MASK                          0x4000000u\r\n#define CMP_C0_CFR_SHIFT                         26u\r\n#define CMP_C0_CFR_WIDTH                         1u\r\n#define CMP_C0_CFR(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_CFR_SHIFT))&CMP_C0_CFR_MASK)\r\n#define CMP_C0_IEF_MASK                          0x8000000u\r\n#define CMP_C0_IEF_SHIFT                         27u\r\n#define CMP_C0_IEF_WIDTH                         1u\r\n#define CMP_C0_IEF(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_IEF_SHIFT))&CMP_C0_IEF_MASK)\r\n#define CMP_C0_IER_MASK                          0x10000000u\r\n#define CMP_C0_IER_SHIFT                         28u\r\n#define CMP_C0_IER_WIDTH                         1u\r\n#define CMP_C0_IER(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C0_IER_SHIFT))&CMP_C0_IER_MASK)\r\n#define CMP_C0_DMAEN_MASK                        0x40000000u\r\n#define CMP_C0_DMAEN_SHIFT                       30u\r\n#define CMP_C0_DMAEN_WIDTH                       1u\r\n#define CMP_C0_DMAEN(x)                          (((uint32_t)(((uint32_t)(x))<<CMP_C0_DMAEN_SHIFT))&CMP_C0_DMAEN_MASK)\r\n/* C1 Bit Fields */\r\n#define CMP_C1_VOSEL_MASK                        0xFFu\r\n#define CMP_C1_VOSEL_SHIFT                       0u\r\n#define CMP_C1_VOSEL_WIDTH                       8u\r\n#define CMP_C1_VOSEL(x)                          (((uint32_t)(((uint32_t)(x))<<CMP_C1_VOSEL_SHIFT))&CMP_C1_VOSEL_MASK)\r\n#define CMP_C1_MSEL_MASK                         0x700u\r\n#define CMP_C1_MSEL_SHIFT                        8u\r\n#define CMP_C1_MSEL_WIDTH                        3u\r\n#define CMP_C1_MSEL(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_MSEL_SHIFT))&CMP_C1_MSEL_MASK)\r\n#define CMP_C1_PSEL_MASK                         0x3800u\r\n#define CMP_C1_PSEL_SHIFT                        11u\r\n#define CMP_C1_PSEL_WIDTH                        3u\r\n#define CMP_C1_PSEL(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_PSEL_SHIFT))&CMP_C1_PSEL_MASK)\r\n#define CMP_C1_VRSEL_MASK                        0x4000u\r\n#define CMP_C1_VRSEL_SHIFT                       14u\r\n#define CMP_C1_VRSEL_WIDTH                       1u\r\n#define CMP_C1_VRSEL(x)                          (((uint32_t)(((uint32_t)(x))<<CMP_C1_VRSEL_SHIFT))&CMP_C1_VRSEL_MASK)\r\n#define CMP_C1_DACEN_MASK                        0x8000u\r\n#define CMP_C1_DACEN_SHIFT                       15u\r\n#define CMP_C1_DACEN_WIDTH                       1u\r\n#define CMP_C1_DACEN(x)                          (((uint32_t)(((uint32_t)(x))<<CMP_C1_DACEN_SHIFT))&CMP_C1_DACEN_MASK)\r\n#define CMP_C1_CHN0_MASK                         0x10000u\r\n#define CMP_C1_CHN0_SHIFT                        16u\r\n#define CMP_C1_CHN0_WIDTH                        1u\r\n#define CMP_C1_CHN0(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN0_SHIFT))&CMP_C1_CHN0_MASK)\r\n#define CMP_C1_CHN1_MASK                         0x20000u\r\n#define CMP_C1_CHN1_SHIFT                        17u\r\n#define CMP_C1_CHN1_WIDTH                        1u\r\n#define CMP_C1_CHN1(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN1_SHIFT))&CMP_C1_CHN1_MASK)\r\n#define CMP_C1_CHN2_MASK                         0x40000u\r\n#define CMP_C1_CHN2_SHIFT                        18u\r\n#define CMP_C1_CHN2_WIDTH                        1u\r\n#define CMP_C1_CHN2(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN2_SHIFT))&CMP_C1_CHN2_MASK)\r\n#define CMP_C1_CHN3_MASK                         0x80000u\r\n#define CMP_C1_CHN3_SHIFT                        19u\r\n#define CMP_C1_CHN3_WIDTH                        1u\r\n#define CMP_C1_CHN3(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN3_SHIFT))&CMP_C1_CHN3_MASK)\r\n#define CMP_C1_CHN4_MASK                         0x100000u\r\n#define CMP_C1_CHN4_SHIFT                        20u\r\n#define CMP_C1_CHN4_WIDTH                        1u\r\n#define CMP_C1_CHN4(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN4_SHIFT))&CMP_C1_CHN4_MASK)\r\n#define CMP_C1_CHN5_MASK                         0x200000u\r\n#define CMP_C1_CHN5_SHIFT                        21u\r\n#define CMP_C1_CHN5_WIDTH                        1u\r\n#define CMP_C1_CHN5(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN5_SHIFT))&CMP_C1_CHN5_MASK)\r\n#define CMP_C1_CHN6_MASK                         0x400000u\r\n#define CMP_C1_CHN6_SHIFT                        22u\r\n#define CMP_C1_CHN6_WIDTH                        1u\r\n#define CMP_C1_CHN6(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN6_SHIFT))&CMP_C1_CHN6_MASK)\r\n#define CMP_C1_CHN7_MASK                         0x800000u\r\n#define CMP_C1_CHN7_SHIFT                        23u\r\n#define CMP_C1_CHN7_WIDTH                        1u\r\n#define CMP_C1_CHN7(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C1_CHN7_SHIFT))&CMP_C1_CHN7_MASK)\r\n#define CMP_C1_INNSEL_MASK                       0x3000000u\r\n#define CMP_C1_INNSEL_SHIFT                      24u\r\n#define CMP_C1_INNSEL_WIDTH                      2u\r\n#define CMP_C1_INNSEL(x)                         (((uint32_t)(((uint32_t)(x))<<CMP_C1_INNSEL_SHIFT))&CMP_C1_INNSEL_MASK)\r\n#define CMP_C1_INPSEL_MASK                       0x18000000u\r\n#define CMP_C1_INPSEL_SHIFT                      27u\r\n#define CMP_C1_INPSEL_WIDTH                      2u\r\n#define CMP_C1_INPSEL(x)                         (((uint32_t)(((uint32_t)(x))<<CMP_C1_INPSEL_SHIFT))&CMP_C1_INPSEL_MASK)\r\n/* C2 Bit Fields */\r\n#define CMP_C2_ACOn_MASK                         0xFFu\r\n#define CMP_C2_ACOn_SHIFT                        0u\r\n#define CMP_C2_ACOn_WIDTH                        8u\r\n#define CMP_C2_ACOn(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_ACOn_SHIFT))&CMP_C2_ACOn_MASK)\r\n#define CMP_C2_INITMOD_MASK                      0x3F00u\r\n#define CMP_C2_INITMOD_SHIFT                     8u\r\n#define CMP_C2_INITMOD_WIDTH                     6u\r\n#define CMP_C2_INITMOD(x)                        (((uint32_t)(((uint32_t)(x))<<CMP_C2_INITMOD_SHIFT))&CMP_C2_INITMOD_MASK)\r\n#define CMP_C2_NSAM_MASK                         0xC000u\r\n#define CMP_C2_NSAM_SHIFT                        14u\r\n#define CMP_C2_NSAM_WIDTH                        2u\r\n#define CMP_C2_NSAM(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_NSAM_SHIFT))&CMP_C2_NSAM_MASK)\r\n#define CMP_C2_CH0F_MASK                         0x10000u\r\n#define CMP_C2_CH0F_SHIFT                        16u\r\n#define CMP_C2_CH0F_WIDTH                        1u\r\n#define CMP_C2_CH0F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH0F_SHIFT))&CMP_C2_CH0F_MASK)\r\n#define CMP_C2_CH1F_MASK                         0x20000u\r\n#define CMP_C2_CH1F_SHIFT                        17u\r\n#define CMP_C2_CH1F_WIDTH                        1u\r\n#define CMP_C2_CH1F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH1F_SHIFT))&CMP_C2_CH1F_MASK)\r\n#define CMP_C2_CH2F_MASK                         0x40000u\r\n#define CMP_C2_CH2F_SHIFT                        18u\r\n#define CMP_C2_CH2F_WIDTH                        1u\r\n#define CMP_C2_CH2F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH2F_SHIFT))&CMP_C2_CH2F_MASK)\r\n#define CMP_C2_CH3F_MASK                         0x80000u\r\n#define CMP_C2_CH3F_SHIFT                        19u\r\n#define CMP_C2_CH3F_WIDTH                        1u\r\n#define CMP_C2_CH3F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH3F_SHIFT))&CMP_C2_CH3F_MASK)\r\n#define CMP_C2_CH4F_MASK                         0x100000u\r\n#define CMP_C2_CH4F_SHIFT                        20u\r\n#define CMP_C2_CH4F_WIDTH                        1u\r\n#define CMP_C2_CH4F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH4F_SHIFT))&CMP_C2_CH4F_MASK)\r\n#define CMP_C2_CH5F_MASK                         0x200000u\r\n#define CMP_C2_CH5F_SHIFT                        21u\r\n#define CMP_C2_CH5F_WIDTH                        1u\r\n#define CMP_C2_CH5F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH5F_SHIFT))&CMP_C2_CH5F_MASK)\r\n#define CMP_C2_CH6F_MASK                         0x400000u\r\n#define CMP_C2_CH6F_SHIFT                        22u\r\n#define CMP_C2_CH6F_WIDTH                        1u\r\n#define CMP_C2_CH6F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH6F_SHIFT))&CMP_C2_CH6F_MASK)\r\n#define CMP_C2_CH7F_MASK                         0x800000u\r\n#define CMP_C2_CH7F_SHIFT                        23u\r\n#define CMP_C2_CH7F_WIDTH                        1u\r\n#define CMP_C2_CH7F(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_CH7F_SHIFT))&CMP_C2_CH7F_MASK)\r\n#define CMP_C2_FXMXCH_MASK                       0xE000000u\r\n#define CMP_C2_FXMXCH_SHIFT                      25u\r\n#define CMP_C2_FXMXCH_WIDTH                      3u\r\n#define CMP_C2_FXMXCH(x)                         (((uint32_t)(((uint32_t)(x))<<CMP_C2_FXMXCH_SHIFT))&CMP_C2_FXMXCH_MASK)\r\n#define CMP_C2_FXMP_MASK                         0x20000000u\r\n#define CMP_C2_FXMP_SHIFT                        29u\r\n#define CMP_C2_FXMP_WIDTH                        1u\r\n#define CMP_C2_FXMP(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_FXMP_SHIFT))&CMP_C2_FXMP_MASK)\r\n#define CMP_C2_RRIE_MASK                         0x40000000u\r\n#define CMP_C2_RRIE_SHIFT                        30u\r\n#define CMP_C2_RRIE_WIDTH                        1u\r\n#define CMP_C2_RRIE(x)                           (((uint32_t)(((uint32_t)(x))<<CMP_C2_RRIE_SHIFT))&CMP_C2_RRIE_MASK)\r\n#define CMP_C2_RRE_MASK                          0x80000000u\r\n#define CMP_C2_RRE_SHIFT                         31u\r\n#define CMP_C2_RRE_WIDTH                         1u\r\n#define CMP_C2_RRE(x)                            (((uint32_t)(((uint32_t)(x))<<CMP_C2_RRE_SHIFT))&CMP_C2_RRE_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CMP_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CMP_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CRC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CRC_Peripheral_Access_Layer CRC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** CRC - Size of Registers Arrays */\r\n\r\n/** CRC - Register Layout Typedef */\r\ntypedef struct {\r\n  union {                                          /* offset: 0x0 */\r\n    __IO uint32_t DATA;                              /**< CRC Data register, offset: 0x0 */\r\n    struct {                                         /* offset: 0x0 */\r\n      __IO uint16_t L;                                 /**< CRC_DATAL register., offset: 0x0 */\r\n      __IO uint16_t H;                                 /**< CRC_DATAH register., offset: 0x2 */\r\n    } DATA_16;\r\n    struct {                                         /* offset: 0x0 */\r\n      __IO uint8_t LL;                                 /**< CRC_DATALL register., offset: 0x0 */\r\n      __IO uint8_t LU;                                 /**< CRC_DATALU register., offset: 0x1 */\r\n      __IO uint8_t HL;                                 /**< CRC_DATAHL register., offset: 0x2 */\r\n      __IO uint8_t HU;                                 /**< CRC_DATAHU register., offset: 0x3 */\r\n    } DATA_8;\r\n  } DATAu;\r\n  __IO uint32_t GPOLY;                             /**< CRC Polynomial register, offset: 0x4 */\r\n  __IO uint32_t CTRL;                              /**< CRC Control register, offset: 0x8 */\r\n} CRC_Type, *CRC_MemMapPtr;\r\n\r\n /** Number of instances of the CRC module. */\r\n#define CRC_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* CRC - Peripheral instance base addresses */\r\n/** Peripheral CRC base address */\r\n#define CRC_BASE                                 (0x40032000u)\r\n/** Peripheral CRC base pointer */\r\n#define CRC                                      ((CRC_Type *)CRC_BASE)\r\n/** Array initializer of CRC peripheral base addresses */\r\n#define CRC_BASE_ADDRS                           { CRC_BASE }\r\n/** Array initializer of CRC peripheral base pointers */\r\n#define CRC_BASE_PTRS                            { CRC }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CRC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CRC_Register_Masks CRC Register Masks\r\n * @{\r\n */\r\n\r\n/* DATAu_DATA Bit Fields */\r\n#define CRC_DATAu_DATA_LL_MASK                   0xFFu\r\n#define CRC_DATAu_DATA_LL_SHIFT                  0u\r\n#define CRC_DATAu_DATA_LL_WIDTH                  8u\r\n#define CRC_DATAu_DATA_LL(x)                     (((uint32_t)(((uint32_t)(x))<<CRC_DATAu_DATA_LL_SHIFT))&CRC_DATAu_DATA_LL_MASK)\r\n#define CRC_DATAu_DATA_LU_MASK                   0xFF00u\r\n#define CRC_DATAu_DATA_LU_SHIFT                  8u\r\n#define CRC_DATAu_DATA_LU_WIDTH                  8u\r\n#define CRC_DATAu_DATA_LU(x)                     (((uint32_t)(((uint32_t)(x))<<CRC_DATAu_DATA_LU_SHIFT))&CRC_DATAu_DATA_LU_MASK)\r\n#define CRC_DATAu_DATA_HL_MASK                   0xFF0000u\r\n#define CRC_DATAu_DATA_HL_SHIFT                  16u\r\n#define CRC_DATAu_DATA_HL_WIDTH                  8u\r\n#define CRC_DATAu_DATA_HL(x)                     (((uint32_t)(((uint32_t)(x))<<CRC_DATAu_DATA_HL_SHIFT))&CRC_DATAu_DATA_HL_MASK)\r\n#define CRC_DATAu_DATA_HU_MASK                   0xFF000000u\r\n#define CRC_DATAu_DATA_HU_SHIFT                  24u\r\n#define CRC_DATAu_DATA_HU_WIDTH                  8u\r\n#define CRC_DATAu_DATA_HU(x)                     (((uint32_t)(((uint32_t)(x))<<CRC_DATAu_DATA_HU_SHIFT))&CRC_DATAu_DATA_HU_MASK)\r\n/* DATAu_DATA_16_L Bit Fields */\r\n#define CRC_DATAu_DATA_16_L_DATAL_MASK           0xFFFFu\r\n#define CRC_DATAu_DATA_16_L_DATAL_SHIFT          0u\r\n#define CRC_DATAu_DATA_16_L_DATAL_WIDTH          16u\r\n#define CRC_DATAu_DATA_16_L_DATAL(x)             (((uint16_t)(((uint16_t)(x))<<CRC_DATAu_DATA_16_L_DATAL_SHIFT))&CRC_DATAu_DATA_16_L_DATAL_MASK)\r\n/* DATAu_DATA_16_H Bit Fields */\r\n#define CRC_DATAu_DATA_16_H_DATAH_MASK           0xFFFFu\r\n#define CRC_DATAu_DATA_16_H_DATAH_SHIFT          0u\r\n#define CRC_DATAu_DATA_16_H_DATAH_WIDTH          16u\r\n#define CRC_DATAu_DATA_16_H_DATAH(x)             (((uint16_t)(((uint16_t)(x))<<CRC_DATAu_DATA_16_H_DATAH_SHIFT))&CRC_DATAu_DATA_16_H_DATAH_MASK)\r\n/* DATAu_DATA_8_LL Bit Fields */\r\n#define CRC_DATAu_DATA_8_LL_DATALL_MASK          0xFFu\r\n#define CRC_DATAu_DATA_8_LL_DATALL_SHIFT         0u\r\n#define CRC_DATAu_DATA_8_LL_DATALL_WIDTH         8u\r\n#define CRC_DATAu_DATA_8_LL_DATALL(x)            (((uint8_t)(((uint8_t)(x))<<CRC_DATAu_DATA_8_LL_DATALL_SHIFT))&CRC_DATAu_DATA_8_LL_DATALL_MASK)\r\n/* DATAu_DATA_8_LU Bit Fields */\r\n#define CRC_DATAu_DATA_8_LU_DATALU_MASK          0xFFu\r\n#define CRC_DATAu_DATA_8_LU_DATALU_SHIFT         0u\r\n#define CRC_DATAu_DATA_8_LU_DATALU_WIDTH         8u\r\n#define CRC_DATAu_DATA_8_LU_DATALU(x)            (((uint8_t)(((uint8_t)(x))<<CRC_DATAu_DATA_8_LU_DATALU_SHIFT))&CRC_DATAu_DATA_8_LU_DATALU_MASK)\r\n/* DATAu_DATA_8_HL Bit Fields */\r\n#define CRC_DATAu_DATA_8_HL_DATAHL_MASK          0xFFu\r\n#define CRC_DATAu_DATA_8_HL_DATAHL_SHIFT         0u\r\n#define CRC_DATAu_DATA_8_HL_DATAHL_WIDTH         8u\r\n#define CRC_DATAu_DATA_8_HL_DATAHL(x)            (((uint8_t)(((uint8_t)(x))<<CRC_DATAu_DATA_8_HL_DATAHL_SHIFT))&CRC_DATAu_DATA_8_HL_DATAHL_MASK)\r\n/* DATAu_DATA_8_HU Bit Fields */\r\n#define CRC_DATAu_DATA_8_HU_DATAHU_MASK          0xFFu\r\n#define CRC_DATAu_DATA_8_HU_DATAHU_SHIFT         0u\r\n#define CRC_DATAu_DATA_8_HU_DATAHU_WIDTH         8u\r\n#define CRC_DATAu_DATA_8_HU_DATAHU(x)            (((uint8_t)(((uint8_t)(x))<<CRC_DATAu_DATA_8_HU_DATAHU_SHIFT))&CRC_DATAu_DATA_8_HU_DATAHU_MASK)\r\n/* GPOLY Bit Fields */\r\n#define CRC_GPOLY_LOW_MASK                       0xFFFFu\r\n#define CRC_GPOLY_LOW_SHIFT                      0u\r\n#define CRC_GPOLY_LOW_WIDTH                      16u\r\n#define CRC_GPOLY_LOW(x)                         (((uint32_t)(((uint32_t)(x))<<CRC_GPOLY_LOW_SHIFT))&CRC_GPOLY_LOW_MASK)\r\n#define CRC_GPOLY_HIGH_MASK                      0xFFFF0000u\r\n#define CRC_GPOLY_HIGH_SHIFT                     16u\r\n#define CRC_GPOLY_HIGH_WIDTH                     16u\r\n#define CRC_GPOLY_HIGH(x)                        (((uint32_t)(((uint32_t)(x))<<CRC_GPOLY_HIGH_SHIFT))&CRC_GPOLY_HIGH_MASK)\r\n/* CTRL Bit Fields */\r\n#define CRC_CTRL_TCRC_MASK                       0x1000000u\r\n#define CRC_CTRL_TCRC_SHIFT                      24u\r\n#define CRC_CTRL_TCRC_WIDTH                      1u\r\n#define CRC_CTRL_TCRC(x)                         (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_TCRC_SHIFT))&CRC_CTRL_TCRC_MASK)\r\n#define CRC_CTRL_WAS_MASK                        0x2000000u\r\n#define CRC_CTRL_WAS_SHIFT                       25u\r\n#define CRC_CTRL_WAS_WIDTH                       1u\r\n#define CRC_CTRL_WAS(x)                          (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_WAS_SHIFT))&CRC_CTRL_WAS_MASK)\r\n#define CRC_CTRL_FXOR_MASK                       0x4000000u\r\n#define CRC_CTRL_FXOR_SHIFT                      26u\r\n#define CRC_CTRL_FXOR_WIDTH                      1u\r\n#define CRC_CTRL_FXOR(x)                         (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_FXOR_SHIFT))&CRC_CTRL_FXOR_MASK)\r\n#define CRC_CTRL_TOTR_MASK                       0x30000000u\r\n#define CRC_CTRL_TOTR_SHIFT                      28u\r\n#define CRC_CTRL_TOTR_WIDTH                      2u\r\n#define CRC_CTRL_TOTR(x)                         (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_TOTR_SHIFT))&CRC_CTRL_TOTR_MASK)\r\n#define CRC_CTRL_TOT_MASK                        0xC0000000u\r\n#define CRC_CTRL_TOT_SHIFT                       30u\r\n#define CRC_CTRL_TOT_WIDTH                       2u\r\n#define CRC_CTRL_TOT(x)                          (((uint32_t)(((uint32_t)(x))<<CRC_CTRL_TOT_SHIFT))&CRC_CTRL_TOT_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CRC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CRC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CSE_PRAM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CSE_PRAM_Peripheral_Access_Layer CSE_PRAM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** CSE_PRAM - Size of Registers Arrays */\r\n#define CSE_PRAM_RAMn_COUNT                      32u\r\n\r\n/** CSE_PRAM - Register Layout Typedef */\r\ntypedef struct {\r\n  union {                                          /* offset: 0x0, array step: 0x4 */\r\n    __IO uint32_t DATA_32;                           /**< CSE PRAM 0 Register..CSE PRAM 31 Register, array offset: 0x0, array step: 0x4 */\r\n    struct {                                         /* offset: 0x0, array step: 0x4 */\r\n      __IO uint8_t DATA_8LL;                           /**< CSE PRAM0LL register...CSE PRAM31LL register., array offset: 0x0, array step: 0x4 */\r\n      __IO uint8_t DATA_8LU;                           /**< CSE PRAM0LU register...CSE PRAM31LU register., array offset: 0x1, array step: 0x4 */\r\n      __IO uint8_t DATA_8HL;                           /**< CSE PRAM0HL register...CSE PRAM31HL register., array offset: 0x2, array step: 0x4 */\r\n      __IO uint8_t DATA_8HU;                           /**< CSE PRAM0HU register...CSE PRAM31HU register., array offset: 0x3, array step: 0x4 */\r\n    } ACCESS8BIT;\r\n  } RAMn[CSE_PRAM_RAMn_COUNT];\r\n} CSE_PRAM_Type, *CSE_PRAM_MemMapPtr;\r\n\r\n /** Number of instances of the CSE_PRAM module. */\r\n#define CSE_PRAM_INSTANCE_COUNT                  (1u)\r\n\r\n\r\n/* CSE_PRAM - Peripheral instance base addresses */\r\n/** Peripheral CSE_PRAM base address */\r\n#define CSE_PRAM_BASE                            (0x14001000u)\r\n/** Peripheral CSE_PRAM base pointer */\r\n#define CSE_PRAM                                 ((CSE_PRAM_Type *)CSE_PRAM_BASE)\r\n/** Array initializer of CSE_PRAM peripheral base addresses */\r\n#define CSE_PRAM_BASE_ADDRS                      { CSE_PRAM_BASE }\r\n/** Array initializer of CSE_PRAM peripheral base pointers */\r\n#define CSE_PRAM_BASE_PTRS                       { CSE_PRAM }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- CSE_PRAM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup CSE_PRAM_Register_Masks CSE_PRAM Register Masks\r\n * @{\r\n */\r\n\r\n/* RAMn_DATA_32 Bit Fields */\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_3_MASK        0xFFu\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_3_SHIFT       0u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_3_WIDTH       8u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_3(x)          (((uint32_t)(((uint32_t)(x))<<CSE_PRAM_RAMn_DATA_32_BYTE_3_SHIFT))&CSE_PRAM_RAMn_DATA_32_BYTE_3_MASK)\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_2_MASK        0xFF00u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_2_SHIFT       8u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_2_WIDTH       8u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_2(x)          (((uint32_t)(((uint32_t)(x))<<CSE_PRAM_RAMn_DATA_32_BYTE_2_SHIFT))&CSE_PRAM_RAMn_DATA_32_BYTE_2_MASK)\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_1_MASK        0xFF0000u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_1_SHIFT       16u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_1_WIDTH       8u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_1(x)          (((uint32_t)(((uint32_t)(x))<<CSE_PRAM_RAMn_DATA_32_BYTE_1_SHIFT))&CSE_PRAM_RAMn_DATA_32_BYTE_1_MASK)\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_0_MASK        0xFF000000u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_0_SHIFT       24u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_0_WIDTH       8u\r\n#define CSE_PRAM_RAMn_DATA_32_BYTE_0(x)          (((uint32_t)(((uint32_t)(x))<<CSE_PRAM_RAMn_DATA_32_BYTE_0_SHIFT))&CSE_PRAM_RAMn_DATA_32_BYTE_0_MASK)\r\n/* RAMn_ACCESS8BIT_DATA_8LL Bit Fields */\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LL_RAM_LL_MASK 0xFFu\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LL_RAM_LL_SHIFT 0u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LL_RAM_LL_WIDTH 8u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LL_RAM_LL(x) (((uint8_t)(((uint8_t)(x))<<CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LL_RAM_LL_SHIFT))&CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LL_RAM_LL_MASK)\r\n/* RAMn_ACCESS8BIT_DATA_8LU Bit Fields */\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LU_RAM_LU_MASK 0xFFu\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LU_RAM_LU_SHIFT 0u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LU_RAM_LU_WIDTH 8u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LU_RAM_LU(x) (((uint8_t)(((uint8_t)(x))<<CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LU_RAM_LU_SHIFT))&CSE_PRAM_RAMn_ACCESS8BIT_DATA_8LU_RAM_LU_MASK)\r\n/* RAMn_ACCESS8BIT_DATA_8HL Bit Fields */\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HL_RAM_HL_MASK 0xFFu\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HL_RAM_HL_SHIFT 0u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HL_RAM_HL_WIDTH 8u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HL_RAM_HL(x) (((uint8_t)(((uint8_t)(x))<<CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HL_RAM_HL_SHIFT))&CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HL_RAM_HL_MASK)\r\n/* RAMn_ACCESS8BIT_DATA_8HU Bit Fields */\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HU_RAM_HU_MASK 0xFFu\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HU_RAM_HU_SHIFT 0u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HU_RAM_HU_WIDTH 8u\r\n#define CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HU_RAM_HU(x) (((uint8_t)(((uint8_t)(x))<<CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HU_RAM_HU_SHIFT))&CSE_PRAM_RAMn_ACCESS8BIT_DATA_8HU_RAM_HU_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CSE_PRAM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group CSE_PRAM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- DMA Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup DMA_Peripheral_Access_Layer DMA Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** DMA - Size of Registers Arrays */\r\n#define DMA_DCHPRI_COUNT                         16u\r\n#define DMA_TCD_COUNT                            16u\r\n\r\n/** DMA - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t CR;                                /**< Control Register, offset: 0x0 */\r\n  __I  uint32_t ES;                                /**< Error Status Register, offset: 0x4 */\r\n       uint8_t RESERVED_0[4];\r\n  __IO uint32_t ERQ;                               /**< Enable Request Register, offset: 0xC */\r\n       uint8_t RESERVED_1[4];\r\n  __IO uint32_t EEI;                               /**< Enable Error Interrupt Register, offset: 0x14 */\r\n  __O  uint8_t CEEI;                               /**< Clear Enable Error Interrupt Register, offset: 0x18 */\r\n  __O  uint8_t SEEI;                               /**< Set Enable Error Interrupt Register, offset: 0x19 */\r\n  __O  uint8_t CERQ;                               /**< Clear Enable Request Register, offset: 0x1A */\r\n  __O  uint8_t SERQ;                               /**< Set Enable Request Register, offset: 0x1B */\r\n  __O  uint8_t CDNE;                               /**< Clear DONE Status Bit Register, offset: 0x1C */\r\n  __O  uint8_t SSRT;                               /**< Set START Bit Register, offset: 0x1D */\r\n  __O  uint8_t CERR;                               /**< Clear Error Register, offset: 0x1E */\r\n  __O  uint8_t CINT;                               /**< Clear Interrupt Request Register, offset: 0x1F */\r\n       uint8_t RESERVED_2[4];\r\n  __IO uint32_t INT;                               /**< Interrupt Request Register, offset: 0x24 */\r\n       uint8_t RESERVED_3[4];\r\n  __IO uint32_t ERR;                               /**< Error Register, offset: 0x2C */\r\n       uint8_t RESERVED_4[4];\r\n  __I  uint32_t HRS;                               /**< Hardware Request Status Register, offset: 0x34 */\r\n       uint8_t RESERVED_5[12];\r\n  __IO uint32_t EARS;                              /**< Enable Asynchronous Request in Stop Register, offset: 0x44 */\r\n       uint8_t RESERVED_6[184];\r\n  __IO uint8_t DCHPRI[DMA_DCHPRI_COUNT];           /**< Channel n Priority Register, array offset: 0x100, array step: 0x1 */\r\n       uint8_t RESERVED_7[3824];\r\n  struct {                                         /* offset: 0x1000, array step: 0x20 */\r\n    __IO uint32_t SADDR;                             /**< TCD Source Address, array offset: 0x1000, array step: 0x20 */\r\n    __IO uint16_t SOFF;                              /**< TCD Signed Source Address Offset, array offset: 0x1004, array step: 0x20 */\r\n    __IO uint16_t ATTR;                              /**< TCD Transfer Attributes, array offset: 0x1006, array step: 0x20 */\r\n    union {                                          /* offset: 0x1008, array step: 0x20 */\r\n      __IO uint32_t MLNO;                              /**< TCD Minor Byte Count (Minor Loop Mapping Disabled), array offset: 0x1008, array step: 0x20 */\r\n      __IO uint32_t MLOFFNO;                           /**< TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled), array offset: 0x1008, array step: 0x20 */\r\n      __IO uint32_t MLOFFYES;                          /**< TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled), array offset: 0x1008, array step: 0x20 */\r\n    } NBYTES;\r\n    __IO uint32_t SLAST;                             /**< TCD Last Source Address Adjustment, array offset: 0x100C, array step: 0x20 */\r\n    __IO uint32_t DADDR;                             /**< TCD Destination Address, array offset: 0x1010, array step: 0x20 */\r\n    __IO uint16_t DOFF;                              /**< TCD Signed Destination Address Offset, array offset: 0x1014, array step: 0x20 */\r\n    union {                                          /* offset: 0x1016, array step: 0x20 */\r\n      __IO uint16_t ELINKNO;                           /**< TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled), array offset: 0x1016, array step: 0x20 */\r\n      __IO uint16_t ELINKYES;                          /**< TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled), array offset: 0x1016, array step: 0x20 */\r\n    } CITER;\r\n    __IO uint32_t DLASTSGA;                          /**< TCD Last Destination Address Adjustment/Scatter Gather Address, array offset: 0x1018, array step: 0x20 */\r\n    __IO uint16_t CSR;                               /**< TCD Control and Status, array offset: 0x101C, array step: 0x20 */\r\n    union {                                          /* offset: 0x101E, array step: 0x20 */\r\n      __IO uint16_t ELINKNO;                           /**< TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled), array offset: 0x101E, array step: 0x20 */\r\n      __IO uint16_t ELINKYES;                          /**< TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled), array offset: 0x101E, array step: 0x20 */\r\n    } BITER;\r\n  } TCD[DMA_TCD_COUNT];\r\n} DMA_Type, *DMA_MemMapPtr;\r\n\r\n /** Number of instances of the DMA module. */\r\n#define DMA_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* DMA - Peripheral instance base addresses */\r\n/** Peripheral DMA base address */\r\n#define DMA_BASE                                 (0x40008000u)\r\n/** Peripheral DMA base pointer */\r\n#define DMA                                      ((DMA_Type *)DMA_BASE)\r\n/** Array initializer of DMA peripheral base addresses */\r\n#define DMA_BASE_ADDRS                           { DMA_BASE }\r\n/** Array initializer of DMA peripheral base pointers */\r\n#define DMA_BASE_PTRS                            { DMA }\r\n /** Number of interrupt vector arrays for the DMA module. */\r\n#define DMA_IRQS_ARR_COUNT                       (2u)\r\n /** Number of interrupt channels for the CHN type of DMA module. */\r\n#define DMA_CHN_IRQS_CH_COUNT                    (16u)\r\n /** Number of interrupt channels for the ERROR type of DMA module. */\r\n#define DMA_ERROR_IRQS_CH_COUNT                  (1u)\r\n/** Interrupt vectors for the DMA peripheral type */\r\n#define DMA_CHN_IRQS                             { DMA0_IRQn, DMA1_IRQn, DMA2_IRQn, DMA3_IRQn, DMA4_IRQn, DMA5_IRQn, DMA6_IRQn, DMA7_IRQn, DMA8_IRQn, DMA9_IRQn, DMA10_IRQn, DMA11_IRQn, DMA12_IRQn, DMA13_IRQn, DMA14_IRQn, DMA15_IRQn }\r\n#define DMA_ERROR_IRQS                           { DMA_Error_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- DMA Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup DMA_Register_Masks DMA Register Masks\r\n * @{\r\n */\r\n\r\n/* CR Bit Fields */\r\n#define DMA_CR_EDBG_MASK                         0x2u\r\n#define DMA_CR_EDBG_SHIFT                        1u\r\n#define DMA_CR_EDBG_WIDTH                        1u\r\n#define DMA_CR_EDBG(x)                           (((uint32_t)(((uint32_t)(x))<<DMA_CR_EDBG_SHIFT))&DMA_CR_EDBG_MASK)\r\n#define DMA_CR_ERCA_MASK                         0x4u\r\n#define DMA_CR_ERCA_SHIFT                        2u\r\n#define DMA_CR_ERCA_WIDTH                        1u\r\n#define DMA_CR_ERCA(x)                           (((uint32_t)(((uint32_t)(x))<<DMA_CR_ERCA_SHIFT))&DMA_CR_ERCA_MASK)\r\n#define DMA_CR_HOE_MASK                          0x10u\r\n#define DMA_CR_HOE_SHIFT                         4u\r\n#define DMA_CR_HOE_WIDTH                         1u\r\n#define DMA_CR_HOE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_CR_HOE_SHIFT))&DMA_CR_HOE_MASK)\r\n#define DMA_CR_HALT_MASK                         0x20u\r\n#define DMA_CR_HALT_SHIFT                        5u\r\n#define DMA_CR_HALT_WIDTH                        1u\r\n#define DMA_CR_HALT(x)                           (((uint32_t)(((uint32_t)(x))<<DMA_CR_HALT_SHIFT))&DMA_CR_HALT_MASK)\r\n#define DMA_CR_CLM_MASK                          0x40u\r\n#define DMA_CR_CLM_SHIFT                         6u\r\n#define DMA_CR_CLM_WIDTH                         1u\r\n#define DMA_CR_CLM(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_CR_CLM_SHIFT))&DMA_CR_CLM_MASK)\r\n#define DMA_CR_EMLM_MASK                         0x80u\r\n#define DMA_CR_EMLM_SHIFT                        7u\r\n#define DMA_CR_EMLM_WIDTH                        1u\r\n#define DMA_CR_EMLM(x)                           (((uint32_t)(((uint32_t)(x))<<DMA_CR_EMLM_SHIFT))&DMA_CR_EMLM_MASK)\r\n#define DMA_CR_ECX_MASK                          0x10000u\r\n#define DMA_CR_ECX_SHIFT                         16u\r\n#define DMA_CR_ECX_WIDTH                         1u\r\n#define DMA_CR_ECX(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_CR_ECX_SHIFT))&DMA_CR_ECX_MASK)\r\n#define DMA_CR_CX_MASK                           0x20000u\r\n#define DMA_CR_CX_SHIFT                          17u\r\n#define DMA_CR_CX_WIDTH                          1u\r\n#define DMA_CR_CX(x)                             (((uint32_t)(((uint32_t)(x))<<DMA_CR_CX_SHIFT))&DMA_CR_CX_MASK)\r\n#define DMA_CR_ACTIVE_MASK                       0x80000000u\r\n#define DMA_CR_ACTIVE_SHIFT                      31u\r\n#define DMA_CR_ACTIVE_WIDTH                      1u\r\n#define DMA_CR_ACTIVE(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_CR_ACTIVE_SHIFT))&DMA_CR_ACTIVE_MASK)\r\n/* ES Bit Fields */\r\n#define DMA_ES_DBE_MASK                          0x1u\r\n#define DMA_ES_DBE_SHIFT                         0u\r\n#define DMA_ES_DBE_WIDTH                         1u\r\n#define DMA_ES_DBE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_DBE_SHIFT))&DMA_ES_DBE_MASK)\r\n#define DMA_ES_SBE_MASK                          0x2u\r\n#define DMA_ES_SBE_SHIFT                         1u\r\n#define DMA_ES_SBE_WIDTH                         1u\r\n#define DMA_ES_SBE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_SBE_SHIFT))&DMA_ES_SBE_MASK)\r\n#define DMA_ES_SGE_MASK                          0x4u\r\n#define DMA_ES_SGE_SHIFT                         2u\r\n#define DMA_ES_SGE_WIDTH                         1u\r\n#define DMA_ES_SGE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_SGE_SHIFT))&DMA_ES_SGE_MASK)\r\n#define DMA_ES_NCE_MASK                          0x8u\r\n#define DMA_ES_NCE_SHIFT                         3u\r\n#define DMA_ES_NCE_WIDTH                         1u\r\n#define DMA_ES_NCE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_NCE_SHIFT))&DMA_ES_NCE_MASK)\r\n#define DMA_ES_DOE_MASK                          0x10u\r\n#define DMA_ES_DOE_SHIFT                         4u\r\n#define DMA_ES_DOE_WIDTH                         1u\r\n#define DMA_ES_DOE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_DOE_SHIFT))&DMA_ES_DOE_MASK)\r\n#define DMA_ES_DAE_MASK                          0x20u\r\n#define DMA_ES_DAE_SHIFT                         5u\r\n#define DMA_ES_DAE_WIDTH                         1u\r\n#define DMA_ES_DAE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_DAE_SHIFT))&DMA_ES_DAE_MASK)\r\n#define DMA_ES_SOE_MASK                          0x40u\r\n#define DMA_ES_SOE_SHIFT                         6u\r\n#define DMA_ES_SOE_WIDTH                         1u\r\n#define DMA_ES_SOE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_SOE_SHIFT))&DMA_ES_SOE_MASK)\r\n#define DMA_ES_SAE_MASK                          0x80u\r\n#define DMA_ES_SAE_SHIFT                         7u\r\n#define DMA_ES_SAE_WIDTH                         1u\r\n#define DMA_ES_SAE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_SAE_SHIFT))&DMA_ES_SAE_MASK)\r\n#define DMA_ES_ERRCHN_MASK                       0xF00u\r\n#define DMA_ES_ERRCHN_SHIFT                      8u\r\n#define DMA_ES_ERRCHN_WIDTH                      4u\r\n#define DMA_ES_ERRCHN(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ES_ERRCHN_SHIFT))&DMA_ES_ERRCHN_MASK)\r\n#define DMA_ES_CPE_MASK                          0x4000u\r\n#define DMA_ES_CPE_SHIFT                         14u\r\n#define DMA_ES_CPE_WIDTH                         1u\r\n#define DMA_ES_CPE(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_CPE_SHIFT))&DMA_ES_CPE_MASK)\r\n#define DMA_ES_ECX_MASK                          0x10000u\r\n#define DMA_ES_ECX_SHIFT                         16u\r\n#define DMA_ES_ECX_WIDTH                         1u\r\n#define DMA_ES_ECX(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_ECX_SHIFT))&DMA_ES_ECX_MASK)\r\n#define DMA_ES_VLD_MASK                          0x80000000u\r\n#define DMA_ES_VLD_SHIFT                         31u\r\n#define DMA_ES_VLD_WIDTH                         1u\r\n#define DMA_ES_VLD(x)                            (((uint32_t)(((uint32_t)(x))<<DMA_ES_VLD_SHIFT))&DMA_ES_VLD_MASK)\r\n/* ERQ Bit Fields */\r\n#define DMA_ERQ_ERQ0_MASK                        0x1u\r\n#define DMA_ERQ_ERQ0_SHIFT                       0u\r\n#define DMA_ERQ_ERQ0_WIDTH                       1u\r\n#define DMA_ERQ_ERQ0(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ0_SHIFT))&DMA_ERQ_ERQ0_MASK)\r\n#define DMA_ERQ_ERQ1_MASK                        0x2u\r\n#define DMA_ERQ_ERQ1_SHIFT                       1u\r\n#define DMA_ERQ_ERQ1_WIDTH                       1u\r\n#define DMA_ERQ_ERQ1(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ1_SHIFT))&DMA_ERQ_ERQ1_MASK)\r\n#define DMA_ERQ_ERQ2_MASK                        0x4u\r\n#define DMA_ERQ_ERQ2_SHIFT                       2u\r\n#define DMA_ERQ_ERQ2_WIDTH                       1u\r\n#define DMA_ERQ_ERQ2(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ2_SHIFT))&DMA_ERQ_ERQ2_MASK)\r\n#define DMA_ERQ_ERQ3_MASK                        0x8u\r\n#define DMA_ERQ_ERQ3_SHIFT                       3u\r\n#define DMA_ERQ_ERQ3_WIDTH                       1u\r\n#define DMA_ERQ_ERQ3(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ3_SHIFT))&DMA_ERQ_ERQ3_MASK)\r\n#define DMA_ERQ_ERQ4_MASK                        0x10u\r\n#define DMA_ERQ_ERQ4_SHIFT                       4u\r\n#define DMA_ERQ_ERQ4_WIDTH                       1u\r\n#define DMA_ERQ_ERQ4(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ4_SHIFT))&DMA_ERQ_ERQ4_MASK)\r\n#define DMA_ERQ_ERQ5_MASK                        0x20u\r\n#define DMA_ERQ_ERQ5_SHIFT                       5u\r\n#define DMA_ERQ_ERQ5_WIDTH                       1u\r\n#define DMA_ERQ_ERQ5(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ5_SHIFT))&DMA_ERQ_ERQ5_MASK)\r\n#define DMA_ERQ_ERQ6_MASK                        0x40u\r\n#define DMA_ERQ_ERQ6_SHIFT                       6u\r\n#define DMA_ERQ_ERQ6_WIDTH                       1u\r\n#define DMA_ERQ_ERQ6(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ6_SHIFT))&DMA_ERQ_ERQ6_MASK)\r\n#define DMA_ERQ_ERQ7_MASK                        0x80u\r\n#define DMA_ERQ_ERQ7_SHIFT                       7u\r\n#define DMA_ERQ_ERQ7_WIDTH                       1u\r\n#define DMA_ERQ_ERQ7(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ7_SHIFT))&DMA_ERQ_ERQ7_MASK)\r\n#define DMA_ERQ_ERQ8_MASK                        0x100u\r\n#define DMA_ERQ_ERQ8_SHIFT                       8u\r\n#define DMA_ERQ_ERQ8_WIDTH                       1u\r\n#define DMA_ERQ_ERQ8(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ8_SHIFT))&DMA_ERQ_ERQ8_MASK)\r\n#define DMA_ERQ_ERQ9_MASK                        0x200u\r\n#define DMA_ERQ_ERQ9_SHIFT                       9u\r\n#define DMA_ERQ_ERQ9_WIDTH                       1u\r\n#define DMA_ERQ_ERQ9(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ9_SHIFT))&DMA_ERQ_ERQ9_MASK)\r\n#define DMA_ERQ_ERQ10_MASK                       0x400u\r\n#define DMA_ERQ_ERQ10_SHIFT                      10u\r\n#define DMA_ERQ_ERQ10_WIDTH                      1u\r\n#define DMA_ERQ_ERQ10(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ10_SHIFT))&DMA_ERQ_ERQ10_MASK)\r\n#define DMA_ERQ_ERQ11_MASK                       0x800u\r\n#define DMA_ERQ_ERQ11_SHIFT                      11u\r\n#define DMA_ERQ_ERQ11_WIDTH                      1u\r\n#define DMA_ERQ_ERQ11(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ11_SHIFT))&DMA_ERQ_ERQ11_MASK)\r\n#define DMA_ERQ_ERQ12_MASK                       0x1000u\r\n#define DMA_ERQ_ERQ12_SHIFT                      12u\r\n#define DMA_ERQ_ERQ12_WIDTH                      1u\r\n#define DMA_ERQ_ERQ12(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ12_SHIFT))&DMA_ERQ_ERQ12_MASK)\r\n#define DMA_ERQ_ERQ13_MASK                       0x2000u\r\n#define DMA_ERQ_ERQ13_SHIFT                      13u\r\n#define DMA_ERQ_ERQ13_WIDTH                      1u\r\n#define DMA_ERQ_ERQ13(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ13_SHIFT))&DMA_ERQ_ERQ13_MASK)\r\n#define DMA_ERQ_ERQ14_MASK                       0x4000u\r\n#define DMA_ERQ_ERQ14_SHIFT                      14u\r\n#define DMA_ERQ_ERQ14_WIDTH                      1u\r\n#define DMA_ERQ_ERQ14(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ14_SHIFT))&DMA_ERQ_ERQ14_MASK)\r\n#define DMA_ERQ_ERQ15_MASK                       0x8000u\r\n#define DMA_ERQ_ERQ15_SHIFT                      15u\r\n#define DMA_ERQ_ERQ15_WIDTH                      1u\r\n#define DMA_ERQ_ERQ15(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERQ_ERQ15_SHIFT))&DMA_ERQ_ERQ15_MASK)\r\n/* EEI Bit Fields */\r\n#define DMA_EEI_EEI0_MASK                        0x1u\r\n#define DMA_EEI_EEI0_SHIFT                       0u\r\n#define DMA_EEI_EEI0_WIDTH                       1u\r\n#define DMA_EEI_EEI0(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI0_SHIFT))&DMA_EEI_EEI0_MASK)\r\n#define DMA_EEI_EEI1_MASK                        0x2u\r\n#define DMA_EEI_EEI1_SHIFT                       1u\r\n#define DMA_EEI_EEI1_WIDTH                       1u\r\n#define DMA_EEI_EEI1(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI1_SHIFT))&DMA_EEI_EEI1_MASK)\r\n#define DMA_EEI_EEI2_MASK                        0x4u\r\n#define DMA_EEI_EEI2_SHIFT                       2u\r\n#define DMA_EEI_EEI2_WIDTH                       1u\r\n#define DMA_EEI_EEI2(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI2_SHIFT))&DMA_EEI_EEI2_MASK)\r\n#define DMA_EEI_EEI3_MASK                        0x8u\r\n#define DMA_EEI_EEI3_SHIFT                       3u\r\n#define DMA_EEI_EEI3_WIDTH                       1u\r\n#define DMA_EEI_EEI3(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI3_SHIFT))&DMA_EEI_EEI3_MASK)\r\n#define DMA_EEI_EEI4_MASK                        0x10u\r\n#define DMA_EEI_EEI4_SHIFT                       4u\r\n#define DMA_EEI_EEI4_WIDTH                       1u\r\n#define DMA_EEI_EEI4(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI4_SHIFT))&DMA_EEI_EEI4_MASK)\r\n#define DMA_EEI_EEI5_MASK                        0x20u\r\n#define DMA_EEI_EEI5_SHIFT                       5u\r\n#define DMA_EEI_EEI5_WIDTH                       1u\r\n#define DMA_EEI_EEI5(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI5_SHIFT))&DMA_EEI_EEI5_MASK)\r\n#define DMA_EEI_EEI6_MASK                        0x40u\r\n#define DMA_EEI_EEI6_SHIFT                       6u\r\n#define DMA_EEI_EEI6_WIDTH                       1u\r\n#define DMA_EEI_EEI6(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI6_SHIFT))&DMA_EEI_EEI6_MASK)\r\n#define DMA_EEI_EEI7_MASK                        0x80u\r\n#define DMA_EEI_EEI7_SHIFT                       7u\r\n#define DMA_EEI_EEI7_WIDTH                       1u\r\n#define DMA_EEI_EEI7(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI7_SHIFT))&DMA_EEI_EEI7_MASK)\r\n#define DMA_EEI_EEI8_MASK                        0x100u\r\n#define DMA_EEI_EEI8_SHIFT                       8u\r\n#define DMA_EEI_EEI8_WIDTH                       1u\r\n#define DMA_EEI_EEI8(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI8_SHIFT))&DMA_EEI_EEI8_MASK)\r\n#define DMA_EEI_EEI9_MASK                        0x200u\r\n#define DMA_EEI_EEI9_SHIFT                       9u\r\n#define DMA_EEI_EEI9_WIDTH                       1u\r\n#define DMA_EEI_EEI9(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI9_SHIFT))&DMA_EEI_EEI9_MASK)\r\n#define DMA_EEI_EEI10_MASK                       0x400u\r\n#define DMA_EEI_EEI10_SHIFT                      10u\r\n#define DMA_EEI_EEI10_WIDTH                      1u\r\n#define DMA_EEI_EEI10(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI10_SHIFT))&DMA_EEI_EEI10_MASK)\r\n#define DMA_EEI_EEI11_MASK                       0x800u\r\n#define DMA_EEI_EEI11_SHIFT                      11u\r\n#define DMA_EEI_EEI11_WIDTH                      1u\r\n#define DMA_EEI_EEI11(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI11_SHIFT))&DMA_EEI_EEI11_MASK)\r\n#define DMA_EEI_EEI12_MASK                       0x1000u\r\n#define DMA_EEI_EEI12_SHIFT                      12u\r\n#define DMA_EEI_EEI12_WIDTH                      1u\r\n#define DMA_EEI_EEI12(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI12_SHIFT))&DMA_EEI_EEI12_MASK)\r\n#define DMA_EEI_EEI13_MASK                       0x2000u\r\n#define DMA_EEI_EEI13_SHIFT                      13u\r\n#define DMA_EEI_EEI13_WIDTH                      1u\r\n#define DMA_EEI_EEI13(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI13_SHIFT))&DMA_EEI_EEI13_MASK)\r\n#define DMA_EEI_EEI14_MASK                       0x4000u\r\n#define DMA_EEI_EEI14_SHIFT                      14u\r\n#define DMA_EEI_EEI14_WIDTH                      1u\r\n#define DMA_EEI_EEI14(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI14_SHIFT))&DMA_EEI_EEI14_MASK)\r\n#define DMA_EEI_EEI15_MASK                       0x8000u\r\n#define DMA_EEI_EEI15_SHIFT                      15u\r\n#define DMA_EEI_EEI15_WIDTH                      1u\r\n#define DMA_EEI_EEI15(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_EEI_EEI15_SHIFT))&DMA_EEI_EEI15_MASK)\r\n/* CEEI Bit Fields */\r\n#define DMA_CEEI_CEEI_MASK                       0xFu\r\n#define DMA_CEEI_CEEI_SHIFT                      0u\r\n#define DMA_CEEI_CEEI_WIDTH                      4u\r\n#define DMA_CEEI_CEEI(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CEEI_CEEI_SHIFT))&DMA_CEEI_CEEI_MASK)\r\n#define DMA_CEEI_CAEE_MASK                       0x40u\r\n#define DMA_CEEI_CAEE_SHIFT                      6u\r\n#define DMA_CEEI_CAEE_WIDTH                      1u\r\n#define DMA_CEEI_CAEE(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CEEI_CAEE_SHIFT))&DMA_CEEI_CAEE_MASK)\r\n#define DMA_CEEI_NOP_MASK                        0x80u\r\n#define DMA_CEEI_NOP_SHIFT                       7u\r\n#define DMA_CEEI_NOP_WIDTH                       1u\r\n#define DMA_CEEI_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_CEEI_NOP_SHIFT))&DMA_CEEI_NOP_MASK)\r\n/* SEEI Bit Fields */\r\n#define DMA_SEEI_SEEI_MASK                       0xFu\r\n#define DMA_SEEI_SEEI_SHIFT                      0u\r\n#define DMA_SEEI_SEEI_WIDTH                      4u\r\n#define DMA_SEEI_SEEI(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_SEEI_SEEI_SHIFT))&DMA_SEEI_SEEI_MASK)\r\n#define DMA_SEEI_SAEE_MASK                       0x40u\r\n#define DMA_SEEI_SAEE_SHIFT                      6u\r\n#define DMA_SEEI_SAEE_WIDTH                      1u\r\n#define DMA_SEEI_SAEE(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_SEEI_SAEE_SHIFT))&DMA_SEEI_SAEE_MASK)\r\n#define DMA_SEEI_NOP_MASK                        0x80u\r\n#define DMA_SEEI_NOP_SHIFT                       7u\r\n#define DMA_SEEI_NOP_WIDTH                       1u\r\n#define DMA_SEEI_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_SEEI_NOP_SHIFT))&DMA_SEEI_NOP_MASK)\r\n/* CERQ Bit Fields */\r\n#define DMA_CERQ_CERQ_MASK                       0xFu\r\n#define DMA_CERQ_CERQ_SHIFT                      0u\r\n#define DMA_CERQ_CERQ_WIDTH                      4u\r\n#define DMA_CERQ_CERQ(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CERQ_CERQ_SHIFT))&DMA_CERQ_CERQ_MASK)\r\n#define DMA_CERQ_CAER_MASK                       0x40u\r\n#define DMA_CERQ_CAER_SHIFT                      6u\r\n#define DMA_CERQ_CAER_WIDTH                      1u\r\n#define DMA_CERQ_CAER(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CERQ_CAER_SHIFT))&DMA_CERQ_CAER_MASK)\r\n#define DMA_CERQ_NOP_MASK                        0x80u\r\n#define DMA_CERQ_NOP_SHIFT                       7u\r\n#define DMA_CERQ_NOP_WIDTH                       1u\r\n#define DMA_CERQ_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_CERQ_NOP_SHIFT))&DMA_CERQ_NOP_MASK)\r\n/* SERQ Bit Fields */\r\n#define DMA_SERQ_SERQ_MASK                       0xFu\r\n#define DMA_SERQ_SERQ_SHIFT                      0u\r\n#define DMA_SERQ_SERQ_WIDTH                      4u\r\n#define DMA_SERQ_SERQ(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_SERQ_SERQ_SHIFT))&DMA_SERQ_SERQ_MASK)\r\n#define DMA_SERQ_SAER_MASK                       0x40u\r\n#define DMA_SERQ_SAER_SHIFT                      6u\r\n#define DMA_SERQ_SAER_WIDTH                      1u\r\n#define DMA_SERQ_SAER(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_SERQ_SAER_SHIFT))&DMA_SERQ_SAER_MASK)\r\n#define DMA_SERQ_NOP_MASK                        0x80u\r\n#define DMA_SERQ_NOP_SHIFT                       7u\r\n#define DMA_SERQ_NOP_WIDTH                       1u\r\n#define DMA_SERQ_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_SERQ_NOP_SHIFT))&DMA_SERQ_NOP_MASK)\r\n/* CDNE Bit Fields */\r\n#define DMA_CDNE_CDNE_MASK                       0xFu\r\n#define DMA_CDNE_CDNE_SHIFT                      0u\r\n#define DMA_CDNE_CDNE_WIDTH                      4u\r\n#define DMA_CDNE_CDNE(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CDNE_CDNE_SHIFT))&DMA_CDNE_CDNE_MASK)\r\n#define DMA_CDNE_CADN_MASK                       0x40u\r\n#define DMA_CDNE_CADN_SHIFT                      6u\r\n#define DMA_CDNE_CADN_WIDTH                      1u\r\n#define DMA_CDNE_CADN(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CDNE_CADN_SHIFT))&DMA_CDNE_CADN_MASK)\r\n#define DMA_CDNE_NOP_MASK                        0x80u\r\n#define DMA_CDNE_NOP_SHIFT                       7u\r\n#define DMA_CDNE_NOP_WIDTH                       1u\r\n#define DMA_CDNE_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_CDNE_NOP_SHIFT))&DMA_CDNE_NOP_MASK)\r\n/* SSRT Bit Fields */\r\n#define DMA_SSRT_SSRT_MASK                       0xFu\r\n#define DMA_SSRT_SSRT_SHIFT                      0u\r\n#define DMA_SSRT_SSRT_WIDTH                      4u\r\n#define DMA_SSRT_SSRT(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_SSRT_SSRT_SHIFT))&DMA_SSRT_SSRT_MASK)\r\n#define DMA_SSRT_SAST_MASK                       0x40u\r\n#define DMA_SSRT_SAST_SHIFT                      6u\r\n#define DMA_SSRT_SAST_WIDTH                      1u\r\n#define DMA_SSRT_SAST(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_SSRT_SAST_SHIFT))&DMA_SSRT_SAST_MASK)\r\n#define DMA_SSRT_NOP_MASK                        0x80u\r\n#define DMA_SSRT_NOP_SHIFT                       7u\r\n#define DMA_SSRT_NOP_WIDTH                       1u\r\n#define DMA_SSRT_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_SSRT_NOP_SHIFT))&DMA_SSRT_NOP_MASK)\r\n/* CERR Bit Fields */\r\n#define DMA_CERR_CERR_MASK                       0xFu\r\n#define DMA_CERR_CERR_SHIFT                      0u\r\n#define DMA_CERR_CERR_WIDTH                      4u\r\n#define DMA_CERR_CERR(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CERR_CERR_SHIFT))&DMA_CERR_CERR_MASK)\r\n#define DMA_CERR_CAEI_MASK                       0x40u\r\n#define DMA_CERR_CAEI_SHIFT                      6u\r\n#define DMA_CERR_CAEI_WIDTH                      1u\r\n#define DMA_CERR_CAEI(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CERR_CAEI_SHIFT))&DMA_CERR_CAEI_MASK)\r\n#define DMA_CERR_NOP_MASK                        0x80u\r\n#define DMA_CERR_NOP_SHIFT                       7u\r\n#define DMA_CERR_NOP_WIDTH                       1u\r\n#define DMA_CERR_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_CERR_NOP_SHIFT))&DMA_CERR_NOP_MASK)\r\n/* CINT Bit Fields */\r\n#define DMA_CINT_CINT_MASK                       0xFu\r\n#define DMA_CINT_CINT_SHIFT                      0u\r\n#define DMA_CINT_CINT_WIDTH                      4u\r\n#define DMA_CINT_CINT(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CINT_CINT_SHIFT))&DMA_CINT_CINT_MASK)\r\n#define DMA_CINT_CAIR_MASK                       0x40u\r\n#define DMA_CINT_CAIR_SHIFT                      6u\r\n#define DMA_CINT_CAIR_WIDTH                      1u\r\n#define DMA_CINT_CAIR(x)                         (((uint8_t)(((uint8_t)(x))<<DMA_CINT_CAIR_SHIFT))&DMA_CINT_CAIR_MASK)\r\n#define DMA_CINT_NOP_MASK                        0x80u\r\n#define DMA_CINT_NOP_SHIFT                       7u\r\n#define DMA_CINT_NOP_WIDTH                       1u\r\n#define DMA_CINT_NOP(x)                          (((uint8_t)(((uint8_t)(x))<<DMA_CINT_NOP_SHIFT))&DMA_CINT_NOP_MASK)\r\n/* INT Bit Fields */\r\n#define DMA_INT_INT0_MASK                        0x1u\r\n#define DMA_INT_INT0_SHIFT                       0u\r\n#define DMA_INT_INT0_WIDTH                       1u\r\n#define DMA_INT_INT0(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT0_SHIFT))&DMA_INT_INT0_MASK)\r\n#define DMA_INT_INT1_MASK                        0x2u\r\n#define DMA_INT_INT1_SHIFT                       1u\r\n#define DMA_INT_INT1_WIDTH                       1u\r\n#define DMA_INT_INT1(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT1_SHIFT))&DMA_INT_INT1_MASK)\r\n#define DMA_INT_INT2_MASK                        0x4u\r\n#define DMA_INT_INT2_SHIFT                       2u\r\n#define DMA_INT_INT2_WIDTH                       1u\r\n#define DMA_INT_INT2(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT2_SHIFT))&DMA_INT_INT2_MASK)\r\n#define DMA_INT_INT3_MASK                        0x8u\r\n#define DMA_INT_INT3_SHIFT                       3u\r\n#define DMA_INT_INT3_WIDTH                       1u\r\n#define DMA_INT_INT3(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT3_SHIFT))&DMA_INT_INT3_MASK)\r\n#define DMA_INT_INT4_MASK                        0x10u\r\n#define DMA_INT_INT4_SHIFT                       4u\r\n#define DMA_INT_INT4_WIDTH                       1u\r\n#define DMA_INT_INT4(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT4_SHIFT))&DMA_INT_INT4_MASK)\r\n#define DMA_INT_INT5_MASK                        0x20u\r\n#define DMA_INT_INT5_SHIFT                       5u\r\n#define DMA_INT_INT5_WIDTH                       1u\r\n#define DMA_INT_INT5(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT5_SHIFT))&DMA_INT_INT5_MASK)\r\n#define DMA_INT_INT6_MASK                        0x40u\r\n#define DMA_INT_INT6_SHIFT                       6u\r\n#define DMA_INT_INT6_WIDTH                       1u\r\n#define DMA_INT_INT6(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT6_SHIFT))&DMA_INT_INT6_MASK)\r\n#define DMA_INT_INT7_MASK                        0x80u\r\n#define DMA_INT_INT7_SHIFT                       7u\r\n#define DMA_INT_INT7_WIDTH                       1u\r\n#define DMA_INT_INT7(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT7_SHIFT))&DMA_INT_INT7_MASK)\r\n#define DMA_INT_INT8_MASK                        0x100u\r\n#define DMA_INT_INT8_SHIFT                       8u\r\n#define DMA_INT_INT8_WIDTH                       1u\r\n#define DMA_INT_INT8(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT8_SHIFT))&DMA_INT_INT8_MASK)\r\n#define DMA_INT_INT9_MASK                        0x200u\r\n#define DMA_INT_INT9_SHIFT                       9u\r\n#define DMA_INT_INT9_WIDTH                       1u\r\n#define DMA_INT_INT9(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT9_SHIFT))&DMA_INT_INT9_MASK)\r\n#define DMA_INT_INT10_MASK                       0x400u\r\n#define DMA_INT_INT10_SHIFT                      10u\r\n#define DMA_INT_INT10_WIDTH                      1u\r\n#define DMA_INT_INT10(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT10_SHIFT))&DMA_INT_INT10_MASK)\r\n#define DMA_INT_INT11_MASK                       0x800u\r\n#define DMA_INT_INT11_SHIFT                      11u\r\n#define DMA_INT_INT11_WIDTH                      1u\r\n#define DMA_INT_INT11(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT11_SHIFT))&DMA_INT_INT11_MASK)\r\n#define DMA_INT_INT12_MASK                       0x1000u\r\n#define DMA_INT_INT12_SHIFT                      12u\r\n#define DMA_INT_INT12_WIDTH                      1u\r\n#define DMA_INT_INT12(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT12_SHIFT))&DMA_INT_INT12_MASK)\r\n#define DMA_INT_INT13_MASK                       0x2000u\r\n#define DMA_INT_INT13_SHIFT                      13u\r\n#define DMA_INT_INT13_WIDTH                      1u\r\n#define DMA_INT_INT13(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT13_SHIFT))&DMA_INT_INT13_MASK)\r\n#define DMA_INT_INT14_MASK                       0x4000u\r\n#define DMA_INT_INT14_SHIFT                      14u\r\n#define DMA_INT_INT14_WIDTH                      1u\r\n#define DMA_INT_INT14(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT14_SHIFT))&DMA_INT_INT14_MASK)\r\n#define DMA_INT_INT15_MASK                       0x8000u\r\n#define DMA_INT_INT15_SHIFT                      15u\r\n#define DMA_INT_INT15_WIDTH                      1u\r\n#define DMA_INT_INT15(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_INT_INT15_SHIFT))&DMA_INT_INT15_MASK)\r\n/* ERR Bit Fields */\r\n#define DMA_ERR_ERR0_MASK                        0x1u\r\n#define DMA_ERR_ERR0_SHIFT                       0u\r\n#define DMA_ERR_ERR0_WIDTH                       1u\r\n#define DMA_ERR_ERR0(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR0_SHIFT))&DMA_ERR_ERR0_MASK)\r\n#define DMA_ERR_ERR1_MASK                        0x2u\r\n#define DMA_ERR_ERR1_SHIFT                       1u\r\n#define DMA_ERR_ERR1_WIDTH                       1u\r\n#define DMA_ERR_ERR1(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR1_SHIFT))&DMA_ERR_ERR1_MASK)\r\n#define DMA_ERR_ERR2_MASK                        0x4u\r\n#define DMA_ERR_ERR2_SHIFT                       2u\r\n#define DMA_ERR_ERR2_WIDTH                       1u\r\n#define DMA_ERR_ERR2(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR2_SHIFT))&DMA_ERR_ERR2_MASK)\r\n#define DMA_ERR_ERR3_MASK                        0x8u\r\n#define DMA_ERR_ERR3_SHIFT                       3u\r\n#define DMA_ERR_ERR3_WIDTH                       1u\r\n#define DMA_ERR_ERR3(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR3_SHIFT))&DMA_ERR_ERR3_MASK)\r\n#define DMA_ERR_ERR4_MASK                        0x10u\r\n#define DMA_ERR_ERR4_SHIFT                       4u\r\n#define DMA_ERR_ERR4_WIDTH                       1u\r\n#define DMA_ERR_ERR4(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR4_SHIFT))&DMA_ERR_ERR4_MASK)\r\n#define DMA_ERR_ERR5_MASK                        0x20u\r\n#define DMA_ERR_ERR5_SHIFT                       5u\r\n#define DMA_ERR_ERR5_WIDTH                       1u\r\n#define DMA_ERR_ERR5(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR5_SHIFT))&DMA_ERR_ERR5_MASK)\r\n#define DMA_ERR_ERR6_MASK                        0x40u\r\n#define DMA_ERR_ERR6_SHIFT                       6u\r\n#define DMA_ERR_ERR6_WIDTH                       1u\r\n#define DMA_ERR_ERR6(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR6_SHIFT))&DMA_ERR_ERR6_MASK)\r\n#define DMA_ERR_ERR7_MASK                        0x80u\r\n#define DMA_ERR_ERR7_SHIFT                       7u\r\n#define DMA_ERR_ERR7_WIDTH                       1u\r\n#define DMA_ERR_ERR7(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR7_SHIFT))&DMA_ERR_ERR7_MASK)\r\n#define DMA_ERR_ERR8_MASK                        0x100u\r\n#define DMA_ERR_ERR8_SHIFT                       8u\r\n#define DMA_ERR_ERR8_WIDTH                       1u\r\n#define DMA_ERR_ERR8(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR8_SHIFT))&DMA_ERR_ERR8_MASK)\r\n#define DMA_ERR_ERR9_MASK                        0x200u\r\n#define DMA_ERR_ERR9_SHIFT                       9u\r\n#define DMA_ERR_ERR9_WIDTH                       1u\r\n#define DMA_ERR_ERR9(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR9_SHIFT))&DMA_ERR_ERR9_MASK)\r\n#define DMA_ERR_ERR10_MASK                       0x400u\r\n#define DMA_ERR_ERR10_SHIFT                      10u\r\n#define DMA_ERR_ERR10_WIDTH                      1u\r\n#define DMA_ERR_ERR10(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR10_SHIFT))&DMA_ERR_ERR10_MASK)\r\n#define DMA_ERR_ERR11_MASK                       0x800u\r\n#define DMA_ERR_ERR11_SHIFT                      11u\r\n#define DMA_ERR_ERR11_WIDTH                      1u\r\n#define DMA_ERR_ERR11(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR11_SHIFT))&DMA_ERR_ERR11_MASK)\r\n#define DMA_ERR_ERR12_MASK                       0x1000u\r\n#define DMA_ERR_ERR12_SHIFT                      12u\r\n#define DMA_ERR_ERR12_WIDTH                      1u\r\n#define DMA_ERR_ERR12(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR12_SHIFT))&DMA_ERR_ERR12_MASK)\r\n#define DMA_ERR_ERR13_MASK                       0x2000u\r\n#define DMA_ERR_ERR13_SHIFT                      13u\r\n#define DMA_ERR_ERR13_WIDTH                      1u\r\n#define DMA_ERR_ERR13(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR13_SHIFT))&DMA_ERR_ERR13_MASK)\r\n#define DMA_ERR_ERR14_MASK                       0x4000u\r\n#define DMA_ERR_ERR14_SHIFT                      14u\r\n#define DMA_ERR_ERR14_WIDTH                      1u\r\n#define DMA_ERR_ERR14(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR14_SHIFT))&DMA_ERR_ERR14_MASK)\r\n#define DMA_ERR_ERR15_MASK                       0x8000u\r\n#define DMA_ERR_ERR15_SHIFT                      15u\r\n#define DMA_ERR_ERR15_WIDTH                      1u\r\n#define DMA_ERR_ERR15(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_ERR_ERR15_SHIFT))&DMA_ERR_ERR15_MASK)\r\n/* HRS Bit Fields */\r\n#define DMA_HRS_HRS0_MASK                        0x1u\r\n#define DMA_HRS_HRS0_SHIFT                       0u\r\n#define DMA_HRS_HRS0_WIDTH                       1u\r\n#define DMA_HRS_HRS0(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS0_SHIFT))&DMA_HRS_HRS0_MASK)\r\n#define DMA_HRS_HRS1_MASK                        0x2u\r\n#define DMA_HRS_HRS1_SHIFT                       1u\r\n#define DMA_HRS_HRS1_WIDTH                       1u\r\n#define DMA_HRS_HRS1(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS1_SHIFT))&DMA_HRS_HRS1_MASK)\r\n#define DMA_HRS_HRS2_MASK                        0x4u\r\n#define DMA_HRS_HRS2_SHIFT                       2u\r\n#define DMA_HRS_HRS2_WIDTH                       1u\r\n#define DMA_HRS_HRS2(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS2_SHIFT))&DMA_HRS_HRS2_MASK)\r\n#define DMA_HRS_HRS3_MASK                        0x8u\r\n#define DMA_HRS_HRS3_SHIFT                       3u\r\n#define DMA_HRS_HRS3_WIDTH                       1u\r\n#define DMA_HRS_HRS3(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS3_SHIFT))&DMA_HRS_HRS3_MASK)\r\n#define DMA_HRS_HRS4_MASK                        0x10u\r\n#define DMA_HRS_HRS4_SHIFT                       4u\r\n#define DMA_HRS_HRS4_WIDTH                       1u\r\n#define DMA_HRS_HRS4(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS4_SHIFT))&DMA_HRS_HRS4_MASK)\r\n#define DMA_HRS_HRS5_MASK                        0x20u\r\n#define DMA_HRS_HRS5_SHIFT                       5u\r\n#define DMA_HRS_HRS5_WIDTH                       1u\r\n#define DMA_HRS_HRS5(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS5_SHIFT))&DMA_HRS_HRS5_MASK)\r\n#define DMA_HRS_HRS6_MASK                        0x40u\r\n#define DMA_HRS_HRS6_SHIFT                       6u\r\n#define DMA_HRS_HRS6_WIDTH                       1u\r\n#define DMA_HRS_HRS6(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS6_SHIFT))&DMA_HRS_HRS6_MASK)\r\n#define DMA_HRS_HRS7_MASK                        0x80u\r\n#define DMA_HRS_HRS7_SHIFT                       7u\r\n#define DMA_HRS_HRS7_WIDTH                       1u\r\n#define DMA_HRS_HRS7(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS7_SHIFT))&DMA_HRS_HRS7_MASK)\r\n#define DMA_HRS_HRS8_MASK                        0x100u\r\n#define DMA_HRS_HRS8_SHIFT                       8u\r\n#define DMA_HRS_HRS8_WIDTH                       1u\r\n#define DMA_HRS_HRS8(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS8_SHIFT))&DMA_HRS_HRS8_MASK)\r\n#define DMA_HRS_HRS9_MASK                        0x200u\r\n#define DMA_HRS_HRS9_SHIFT                       9u\r\n#define DMA_HRS_HRS9_WIDTH                       1u\r\n#define DMA_HRS_HRS9(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS9_SHIFT))&DMA_HRS_HRS9_MASK)\r\n#define DMA_HRS_HRS10_MASK                       0x400u\r\n#define DMA_HRS_HRS10_SHIFT                      10u\r\n#define DMA_HRS_HRS10_WIDTH                      1u\r\n#define DMA_HRS_HRS10(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS10_SHIFT))&DMA_HRS_HRS10_MASK)\r\n#define DMA_HRS_HRS11_MASK                       0x800u\r\n#define DMA_HRS_HRS11_SHIFT                      11u\r\n#define DMA_HRS_HRS11_WIDTH                      1u\r\n#define DMA_HRS_HRS11(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS11_SHIFT))&DMA_HRS_HRS11_MASK)\r\n#define DMA_HRS_HRS12_MASK                       0x1000u\r\n#define DMA_HRS_HRS12_SHIFT                      12u\r\n#define DMA_HRS_HRS12_WIDTH                      1u\r\n#define DMA_HRS_HRS12(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS12_SHIFT))&DMA_HRS_HRS12_MASK)\r\n#define DMA_HRS_HRS13_MASK                       0x2000u\r\n#define DMA_HRS_HRS13_SHIFT                      13u\r\n#define DMA_HRS_HRS13_WIDTH                      1u\r\n#define DMA_HRS_HRS13(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS13_SHIFT))&DMA_HRS_HRS13_MASK)\r\n#define DMA_HRS_HRS14_MASK                       0x4000u\r\n#define DMA_HRS_HRS14_SHIFT                      14u\r\n#define DMA_HRS_HRS14_WIDTH                      1u\r\n#define DMA_HRS_HRS14(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS14_SHIFT))&DMA_HRS_HRS14_MASK)\r\n#define DMA_HRS_HRS15_MASK                       0x8000u\r\n#define DMA_HRS_HRS15_SHIFT                      15u\r\n#define DMA_HRS_HRS15_WIDTH                      1u\r\n#define DMA_HRS_HRS15(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_HRS_HRS15_SHIFT))&DMA_HRS_HRS15_MASK)\r\n/* EARS Bit Fields */\r\n#define DMA_EARS_EDREQ_0_MASK                    0x1u\r\n#define DMA_EARS_EDREQ_0_SHIFT                   0u\r\n#define DMA_EARS_EDREQ_0_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_0(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_0_SHIFT))&DMA_EARS_EDREQ_0_MASK)\r\n#define DMA_EARS_EDREQ_1_MASK                    0x2u\r\n#define DMA_EARS_EDREQ_1_SHIFT                   1u\r\n#define DMA_EARS_EDREQ_1_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_1(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_1_SHIFT))&DMA_EARS_EDREQ_1_MASK)\r\n#define DMA_EARS_EDREQ_2_MASK                    0x4u\r\n#define DMA_EARS_EDREQ_2_SHIFT                   2u\r\n#define DMA_EARS_EDREQ_2_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_2(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_2_SHIFT))&DMA_EARS_EDREQ_2_MASK)\r\n#define DMA_EARS_EDREQ_3_MASK                    0x8u\r\n#define DMA_EARS_EDREQ_3_SHIFT                   3u\r\n#define DMA_EARS_EDREQ_3_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_3(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_3_SHIFT))&DMA_EARS_EDREQ_3_MASK)\r\n#define DMA_EARS_EDREQ_4_MASK                    0x10u\r\n#define DMA_EARS_EDREQ_4_SHIFT                   4u\r\n#define DMA_EARS_EDREQ_4_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_4(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_4_SHIFT))&DMA_EARS_EDREQ_4_MASK)\r\n#define DMA_EARS_EDREQ_5_MASK                    0x20u\r\n#define DMA_EARS_EDREQ_5_SHIFT                   5u\r\n#define DMA_EARS_EDREQ_5_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_5(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_5_SHIFT))&DMA_EARS_EDREQ_5_MASK)\r\n#define DMA_EARS_EDREQ_6_MASK                    0x40u\r\n#define DMA_EARS_EDREQ_6_SHIFT                   6u\r\n#define DMA_EARS_EDREQ_6_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_6(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_6_SHIFT))&DMA_EARS_EDREQ_6_MASK)\r\n#define DMA_EARS_EDREQ_7_MASK                    0x80u\r\n#define DMA_EARS_EDREQ_7_SHIFT                   7u\r\n#define DMA_EARS_EDREQ_7_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_7(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_7_SHIFT))&DMA_EARS_EDREQ_7_MASK)\r\n#define DMA_EARS_EDREQ_8_MASK                    0x100u\r\n#define DMA_EARS_EDREQ_8_SHIFT                   8u\r\n#define DMA_EARS_EDREQ_8_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_8(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_8_SHIFT))&DMA_EARS_EDREQ_8_MASK)\r\n#define DMA_EARS_EDREQ_9_MASK                    0x200u\r\n#define DMA_EARS_EDREQ_9_SHIFT                   9u\r\n#define DMA_EARS_EDREQ_9_WIDTH                   1u\r\n#define DMA_EARS_EDREQ_9(x)                      (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_9_SHIFT))&DMA_EARS_EDREQ_9_MASK)\r\n#define DMA_EARS_EDREQ_10_MASK                   0x400u\r\n#define DMA_EARS_EDREQ_10_SHIFT                  10u\r\n#define DMA_EARS_EDREQ_10_WIDTH                  1u\r\n#define DMA_EARS_EDREQ_10(x)                     (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_10_SHIFT))&DMA_EARS_EDREQ_10_MASK)\r\n#define DMA_EARS_EDREQ_11_MASK                   0x800u\r\n#define DMA_EARS_EDREQ_11_SHIFT                  11u\r\n#define DMA_EARS_EDREQ_11_WIDTH                  1u\r\n#define DMA_EARS_EDREQ_11(x)                     (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_11_SHIFT))&DMA_EARS_EDREQ_11_MASK)\r\n#define DMA_EARS_EDREQ_12_MASK                   0x1000u\r\n#define DMA_EARS_EDREQ_12_SHIFT                  12u\r\n#define DMA_EARS_EDREQ_12_WIDTH                  1u\r\n#define DMA_EARS_EDREQ_12(x)                     (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_12_SHIFT))&DMA_EARS_EDREQ_12_MASK)\r\n#define DMA_EARS_EDREQ_13_MASK                   0x2000u\r\n#define DMA_EARS_EDREQ_13_SHIFT                  13u\r\n#define DMA_EARS_EDREQ_13_WIDTH                  1u\r\n#define DMA_EARS_EDREQ_13(x)                     (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_13_SHIFT))&DMA_EARS_EDREQ_13_MASK)\r\n#define DMA_EARS_EDREQ_14_MASK                   0x4000u\r\n#define DMA_EARS_EDREQ_14_SHIFT                  14u\r\n#define DMA_EARS_EDREQ_14_WIDTH                  1u\r\n#define DMA_EARS_EDREQ_14(x)                     (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_14_SHIFT))&DMA_EARS_EDREQ_14_MASK)\r\n#define DMA_EARS_EDREQ_15_MASK                   0x8000u\r\n#define DMA_EARS_EDREQ_15_SHIFT                  15u\r\n#define DMA_EARS_EDREQ_15_WIDTH                  1u\r\n#define DMA_EARS_EDREQ_15(x)                     (((uint32_t)(((uint32_t)(x))<<DMA_EARS_EDREQ_15_SHIFT))&DMA_EARS_EDREQ_15_MASK)\r\n/* DCHPRI Bit Fields */\r\n#define DMA_DCHPRI_CHPRI_MASK                    0xFu\r\n#define DMA_DCHPRI_CHPRI_SHIFT                   0u\r\n#define DMA_DCHPRI_CHPRI_WIDTH                   4u\r\n#define DMA_DCHPRI_CHPRI(x)                      (((uint8_t)(((uint8_t)(x))<<DMA_DCHPRI_CHPRI_SHIFT))&DMA_DCHPRI_CHPRI_MASK)\r\n#define DMA_DCHPRI_DPA_MASK                      0x40u\r\n#define DMA_DCHPRI_DPA_SHIFT                     6u\r\n#define DMA_DCHPRI_DPA_WIDTH                     1u\r\n#define DMA_DCHPRI_DPA(x)                        (((uint8_t)(((uint8_t)(x))<<DMA_DCHPRI_DPA_SHIFT))&DMA_DCHPRI_DPA_MASK)\r\n#define DMA_DCHPRI_ECP_MASK                      0x80u\r\n#define DMA_DCHPRI_ECP_SHIFT                     7u\r\n#define DMA_DCHPRI_ECP_WIDTH                     1u\r\n#define DMA_DCHPRI_ECP(x)                        (((uint8_t)(((uint8_t)(x))<<DMA_DCHPRI_ECP_SHIFT))&DMA_DCHPRI_ECP_MASK)\r\n/* TCD_SADDR Bit Fields */\r\n#define DMA_TCD_SADDR_SADDR_MASK                 0xFFFFFFFFu\r\n#define DMA_TCD_SADDR_SADDR_SHIFT                0u\r\n#define DMA_TCD_SADDR_SADDR_WIDTH                32u\r\n#define DMA_TCD_SADDR_SADDR(x)                   (((uint32_t)(((uint32_t)(x))<<DMA_TCD_SADDR_SADDR_SHIFT))&DMA_TCD_SADDR_SADDR_MASK)\r\n/* TCD_SOFF Bit Fields */\r\n#define DMA_TCD_SOFF_SOFF_MASK                   0xFFFFu\r\n#define DMA_TCD_SOFF_SOFF_SHIFT                  0u\r\n#define DMA_TCD_SOFF_SOFF_WIDTH                  16u\r\n#define DMA_TCD_SOFF_SOFF(x)                     (((uint16_t)(((uint16_t)(x))<<DMA_TCD_SOFF_SOFF_SHIFT))&DMA_TCD_SOFF_SOFF_MASK)\r\n/* TCD_ATTR Bit Fields */\r\n#define DMA_TCD_ATTR_DSIZE_MASK                  0x7u\r\n#define DMA_TCD_ATTR_DSIZE_SHIFT                 0u\r\n#define DMA_TCD_ATTR_DSIZE_WIDTH                 3u\r\n#define DMA_TCD_ATTR_DSIZE(x)                    (((uint16_t)(((uint16_t)(x))<<DMA_TCD_ATTR_DSIZE_SHIFT))&DMA_TCD_ATTR_DSIZE_MASK)\r\n#define DMA_TCD_ATTR_DMOD_MASK                   0xF8u\r\n#define DMA_TCD_ATTR_DMOD_SHIFT                  3u\r\n#define DMA_TCD_ATTR_DMOD_WIDTH                  5u\r\n#define DMA_TCD_ATTR_DMOD(x)                     (((uint16_t)(((uint16_t)(x))<<DMA_TCD_ATTR_DMOD_SHIFT))&DMA_TCD_ATTR_DMOD_MASK)\r\n#define DMA_TCD_ATTR_SSIZE_MASK                  0x700u\r\n#define DMA_TCD_ATTR_SSIZE_SHIFT                 8u\r\n#define DMA_TCD_ATTR_SSIZE_WIDTH                 3u\r\n#define DMA_TCD_ATTR_SSIZE(x)                    (((uint16_t)(((uint16_t)(x))<<DMA_TCD_ATTR_SSIZE_SHIFT))&DMA_TCD_ATTR_SSIZE_MASK)\r\n#define DMA_TCD_ATTR_SMOD_MASK                   0xF800u\r\n#define DMA_TCD_ATTR_SMOD_SHIFT                  11u\r\n#define DMA_TCD_ATTR_SMOD_WIDTH                  5u\r\n#define DMA_TCD_ATTR_SMOD(x)                     (((uint16_t)(((uint16_t)(x))<<DMA_TCD_ATTR_SMOD_SHIFT))&DMA_TCD_ATTR_SMOD_MASK)\r\n/* TCD_NBYTES_MLNO Bit Fields */\r\n#define DMA_TCD_NBYTES_MLNO_NBYTES_MASK          0xFFFFFFFFu\r\n#define DMA_TCD_NBYTES_MLNO_NBYTES_SHIFT         0u\r\n#define DMA_TCD_NBYTES_MLNO_NBYTES_WIDTH         32u\r\n#define DMA_TCD_NBYTES_MLNO_NBYTES(x)            (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLNO_NBYTES_SHIFT))&DMA_TCD_NBYTES_MLNO_NBYTES_MASK)\r\n/* TCD_NBYTES_MLOFFNO Bit Fields */\r\n#define DMA_TCD_NBYTES_MLOFFNO_NBYTES_MASK       0x3FFFFFFFu\r\n#define DMA_TCD_NBYTES_MLOFFNO_NBYTES_SHIFT      0u\r\n#define DMA_TCD_NBYTES_MLOFFNO_NBYTES_WIDTH      30u\r\n#define DMA_TCD_NBYTES_MLOFFNO_NBYTES(x)         (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFNO_NBYTES_SHIFT))&DMA_TCD_NBYTES_MLOFFNO_NBYTES_MASK)\r\n#define DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK        0x40000000u\r\n#define DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT       30u\r\n#define DMA_TCD_NBYTES_MLOFFNO_DMLOE_WIDTH       1u\r\n#define DMA_TCD_NBYTES_MLOFFNO_DMLOE(x)          (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT))&DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK)\r\n#define DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK        0x80000000u\r\n#define DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT       31u\r\n#define DMA_TCD_NBYTES_MLOFFNO_SMLOE_WIDTH       1u\r\n#define DMA_TCD_NBYTES_MLOFFNO_SMLOE(x)          (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT))&DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK)\r\n/* TCD_NBYTES_MLOFFYES Bit Fields */\r\n#define DMA_TCD_NBYTES_MLOFFYES_NBYTES_MASK      0x3FFu\r\n#define DMA_TCD_NBYTES_MLOFFYES_NBYTES_SHIFT     0u\r\n#define DMA_TCD_NBYTES_MLOFFYES_NBYTES_WIDTH     10u\r\n#define DMA_TCD_NBYTES_MLOFFYES_NBYTES(x)        (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFYES_NBYTES_SHIFT))&DMA_TCD_NBYTES_MLOFFYES_NBYTES_MASK)\r\n#define DMA_TCD_NBYTES_MLOFFYES_MLOFF_MASK       0x3FFFFC00u\r\n#define DMA_TCD_NBYTES_MLOFFYES_MLOFF_SHIFT      10u\r\n#define DMA_TCD_NBYTES_MLOFFYES_MLOFF_WIDTH      20u\r\n#define DMA_TCD_NBYTES_MLOFFYES_MLOFF(x)         (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFYES_MLOFF_SHIFT))&DMA_TCD_NBYTES_MLOFFYES_MLOFF_MASK)\r\n#define DMA_TCD_NBYTES_MLOFFYES_DMLOE_MASK       0x40000000u\r\n#define DMA_TCD_NBYTES_MLOFFYES_DMLOE_SHIFT      30u\r\n#define DMA_TCD_NBYTES_MLOFFYES_DMLOE_WIDTH      1u\r\n#define DMA_TCD_NBYTES_MLOFFYES_DMLOE(x)         (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFYES_DMLOE_SHIFT))&DMA_TCD_NBYTES_MLOFFYES_DMLOE_MASK)\r\n#define DMA_TCD_NBYTES_MLOFFYES_SMLOE_MASK       0x80000000u\r\n#define DMA_TCD_NBYTES_MLOFFYES_SMLOE_SHIFT      31u\r\n#define DMA_TCD_NBYTES_MLOFFYES_SMLOE_WIDTH      1u\r\n#define DMA_TCD_NBYTES_MLOFFYES_SMLOE(x)         (((uint32_t)(((uint32_t)(x))<<DMA_TCD_NBYTES_MLOFFYES_SMLOE_SHIFT))&DMA_TCD_NBYTES_MLOFFYES_SMLOE_MASK)\r\n/* TCD_SLAST Bit Fields */\r\n#define DMA_TCD_SLAST_SLAST_MASK                 0xFFFFFFFFu\r\n#define DMA_TCD_SLAST_SLAST_SHIFT                0u\r\n#define DMA_TCD_SLAST_SLAST_WIDTH                32u\r\n#define DMA_TCD_SLAST_SLAST(x)                   (((uint32_t)(((uint32_t)(x))<<DMA_TCD_SLAST_SLAST_SHIFT))&DMA_TCD_SLAST_SLAST_MASK)\r\n/* TCD_DADDR Bit Fields */\r\n#define DMA_TCD_DADDR_DADDR_MASK                 0xFFFFFFFFu\r\n#define DMA_TCD_DADDR_DADDR_SHIFT                0u\r\n#define DMA_TCD_DADDR_DADDR_WIDTH                32u\r\n#define DMA_TCD_DADDR_DADDR(x)                   (((uint32_t)(((uint32_t)(x))<<DMA_TCD_DADDR_DADDR_SHIFT))&DMA_TCD_DADDR_DADDR_MASK)\r\n/* TCD_DOFF Bit Fields */\r\n#define DMA_TCD_DOFF_DOFF_MASK                   0xFFFFu\r\n#define DMA_TCD_DOFF_DOFF_SHIFT                  0u\r\n#define DMA_TCD_DOFF_DOFF_WIDTH                  16u\r\n#define DMA_TCD_DOFF_DOFF(x)                     (((uint16_t)(((uint16_t)(x))<<DMA_TCD_DOFF_DOFF_SHIFT))&DMA_TCD_DOFF_DOFF_MASK)\r\n/* TCD_CITER_ELINKNO Bit Fields */\r\n#define DMA_TCD_CITER_ELINKNO_CITER_MASK         0x7FFFu\r\n#define DMA_TCD_CITER_ELINKNO_CITER_SHIFT        0u\r\n#define DMA_TCD_CITER_ELINKNO_CITER_WIDTH        15u\r\n#define DMA_TCD_CITER_ELINKNO_CITER(x)           (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CITER_ELINKNO_CITER_SHIFT))&DMA_TCD_CITER_ELINKNO_CITER_MASK)\r\n#define DMA_TCD_CITER_ELINKNO_ELINK_MASK         0x8000u\r\n#define DMA_TCD_CITER_ELINKNO_ELINK_SHIFT        15u\r\n#define DMA_TCD_CITER_ELINKNO_ELINK_WIDTH        1u\r\n#define DMA_TCD_CITER_ELINKNO_ELINK(x)           (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CITER_ELINKNO_ELINK_SHIFT))&DMA_TCD_CITER_ELINKNO_ELINK_MASK)\r\n/* TCD_CITER_ELINKYES Bit Fields */\r\n#define DMA_TCD_CITER_ELINKYES_CITER_LE_MASK     0x1FFu\r\n#define DMA_TCD_CITER_ELINKYES_CITER_LE_SHIFT    0u\r\n#define DMA_TCD_CITER_ELINKYES_CITER_LE_WIDTH    9u\r\n#define DMA_TCD_CITER_ELINKYES_CITER_LE(x)       (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CITER_ELINKYES_CITER_LE_SHIFT))&DMA_TCD_CITER_ELINKYES_CITER_LE_MASK)\r\n#define DMA_TCD_CITER_ELINKYES_LINKCH_MASK       0x1E00u\r\n#define DMA_TCD_CITER_ELINKYES_LINKCH_SHIFT      9u\r\n#define DMA_TCD_CITER_ELINKYES_LINKCH_WIDTH      4u\r\n#define DMA_TCD_CITER_ELINKYES_LINKCH(x)         (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CITER_ELINKYES_LINKCH_SHIFT))&DMA_TCD_CITER_ELINKYES_LINKCH_MASK)\r\n#define DMA_TCD_CITER_ELINKYES_ELINK_MASK        0x8000u\r\n#define DMA_TCD_CITER_ELINKYES_ELINK_SHIFT       15u\r\n#define DMA_TCD_CITER_ELINKYES_ELINK_WIDTH       1u\r\n#define DMA_TCD_CITER_ELINKYES_ELINK(x)          (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CITER_ELINKYES_ELINK_SHIFT))&DMA_TCD_CITER_ELINKYES_ELINK_MASK)\r\n/* TCD_DLASTSGA Bit Fields */\r\n#define DMA_TCD_DLASTSGA_DLASTSGA_MASK           0xFFFFFFFFu\r\n#define DMA_TCD_DLASTSGA_DLASTSGA_SHIFT          0u\r\n#define DMA_TCD_DLASTSGA_DLASTSGA_WIDTH          32u\r\n#define DMA_TCD_DLASTSGA_DLASTSGA(x)             (((uint32_t)(((uint32_t)(x))<<DMA_TCD_DLASTSGA_DLASTSGA_SHIFT))&DMA_TCD_DLASTSGA_DLASTSGA_MASK)\r\n/* TCD_CSR Bit Fields */\r\n#define DMA_TCD_CSR_START_MASK                   0x1u\r\n#define DMA_TCD_CSR_START_SHIFT                  0u\r\n#define DMA_TCD_CSR_START_WIDTH                  1u\r\n#define DMA_TCD_CSR_START(x)                     (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_START_SHIFT))&DMA_TCD_CSR_START_MASK)\r\n#define DMA_TCD_CSR_INTMAJOR_MASK                0x2u\r\n#define DMA_TCD_CSR_INTMAJOR_SHIFT               1u\r\n#define DMA_TCD_CSR_INTMAJOR_WIDTH               1u\r\n#define DMA_TCD_CSR_INTMAJOR(x)                  (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_INTMAJOR_SHIFT))&DMA_TCD_CSR_INTMAJOR_MASK)\r\n#define DMA_TCD_CSR_INTHALF_MASK                 0x4u\r\n#define DMA_TCD_CSR_INTHALF_SHIFT                2u\r\n#define DMA_TCD_CSR_INTHALF_WIDTH                1u\r\n#define DMA_TCD_CSR_INTHALF(x)                   (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_INTHALF_SHIFT))&DMA_TCD_CSR_INTHALF_MASK)\r\n#define DMA_TCD_CSR_DREQ_MASK                    0x8u\r\n#define DMA_TCD_CSR_DREQ_SHIFT                   3u\r\n#define DMA_TCD_CSR_DREQ_WIDTH                   1u\r\n#define DMA_TCD_CSR_DREQ(x)                      (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_DREQ_SHIFT))&DMA_TCD_CSR_DREQ_MASK)\r\n#define DMA_TCD_CSR_ESG_MASK                     0x10u\r\n#define DMA_TCD_CSR_ESG_SHIFT                    4u\r\n#define DMA_TCD_CSR_ESG_WIDTH                    1u\r\n#define DMA_TCD_CSR_ESG(x)                       (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_ESG_SHIFT))&DMA_TCD_CSR_ESG_MASK)\r\n#define DMA_TCD_CSR_MAJORELINK_MASK              0x20u\r\n#define DMA_TCD_CSR_MAJORELINK_SHIFT             5u\r\n#define DMA_TCD_CSR_MAJORELINK_WIDTH             1u\r\n#define DMA_TCD_CSR_MAJORELINK(x)                (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_MAJORELINK_SHIFT))&DMA_TCD_CSR_MAJORELINK_MASK)\r\n#define DMA_TCD_CSR_ACTIVE_MASK                  0x40u\r\n#define DMA_TCD_CSR_ACTIVE_SHIFT                 6u\r\n#define DMA_TCD_CSR_ACTIVE_WIDTH                 1u\r\n#define DMA_TCD_CSR_ACTIVE(x)                    (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_ACTIVE_SHIFT))&DMA_TCD_CSR_ACTIVE_MASK)\r\n#define DMA_TCD_CSR_DONE_MASK                    0x80u\r\n#define DMA_TCD_CSR_DONE_SHIFT                   7u\r\n#define DMA_TCD_CSR_DONE_WIDTH                   1u\r\n#define DMA_TCD_CSR_DONE(x)                      (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_DONE_SHIFT))&DMA_TCD_CSR_DONE_MASK)\r\n#define DMA_TCD_CSR_MAJORLINKCH_MASK             0xF00u\r\n#define DMA_TCD_CSR_MAJORLINKCH_SHIFT            8u\r\n#define DMA_TCD_CSR_MAJORLINKCH_WIDTH            4u\r\n#define DMA_TCD_CSR_MAJORLINKCH(x)               (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_MAJORLINKCH_SHIFT))&DMA_TCD_CSR_MAJORLINKCH_MASK)\r\n#define DMA_TCD_CSR_BWC_MASK                     0xC000u\r\n#define DMA_TCD_CSR_BWC_SHIFT                    14u\r\n#define DMA_TCD_CSR_BWC_WIDTH                    2u\r\n#define DMA_TCD_CSR_BWC(x)                       (((uint16_t)(((uint16_t)(x))<<DMA_TCD_CSR_BWC_SHIFT))&DMA_TCD_CSR_BWC_MASK)\r\n/* TCD_BITER_ELINKNO Bit Fields */\r\n#define DMA_TCD_BITER_ELINKNO_BITER_MASK         0x7FFFu\r\n#define DMA_TCD_BITER_ELINKNO_BITER_SHIFT        0u\r\n#define DMA_TCD_BITER_ELINKNO_BITER_WIDTH        15u\r\n#define DMA_TCD_BITER_ELINKNO_BITER(x)           (((uint16_t)(((uint16_t)(x))<<DMA_TCD_BITER_ELINKNO_BITER_SHIFT))&DMA_TCD_BITER_ELINKNO_BITER_MASK)\r\n#define DMA_TCD_BITER_ELINKNO_ELINK_MASK         0x8000u\r\n#define DMA_TCD_BITER_ELINKNO_ELINK_SHIFT        15u\r\n#define DMA_TCD_BITER_ELINKNO_ELINK_WIDTH        1u\r\n#define DMA_TCD_BITER_ELINKNO_ELINK(x)           (((uint16_t)(((uint16_t)(x))<<DMA_TCD_BITER_ELINKNO_ELINK_SHIFT))&DMA_TCD_BITER_ELINKNO_ELINK_MASK)\r\n/* TCD_BITER_ELINKYES Bit Fields */\r\n#define DMA_TCD_BITER_ELINKYES_BITER_MASK        0x1FFu\r\n#define DMA_TCD_BITER_ELINKYES_BITER_SHIFT       0u\r\n#define DMA_TCD_BITER_ELINKYES_BITER_WIDTH       9u\r\n#define DMA_TCD_BITER_ELINKYES_BITER(x)          (((uint16_t)(((uint16_t)(x))<<DMA_TCD_BITER_ELINKYES_BITER_SHIFT))&DMA_TCD_BITER_ELINKYES_BITER_MASK)\r\n#define DMA_TCD_BITER_ELINKYES_LINKCH_MASK       0x1E00u\r\n#define DMA_TCD_BITER_ELINKYES_LINKCH_SHIFT      9u\r\n#define DMA_TCD_BITER_ELINKYES_LINKCH_WIDTH      4u\r\n#define DMA_TCD_BITER_ELINKYES_LINKCH(x)         (((uint16_t)(((uint16_t)(x))<<DMA_TCD_BITER_ELINKYES_LINKCH_SHIFT))&DMA_TCD_BITER_ELINKYES_LINKCH_MASK)\r\n#define DMA_TCD_BITER_ELINKYES_ELINK_MASK        0x8000u\r\n#define DMA_TCD_BITER_ELINKYES_ELINK_SHIFT       15u\r\n#define DMA_TCD_BITER_ELINKYES_ELINK_WIDTH       1u\r\n#define DMA_TCD_BITER_ELINKYES_ELINK(x)          (((uint16_t)(((uint16_t)(x))<<DMA_TCD_BITER_ELINKYES_ELINK_SHIFT))&DMA_TCD_BITER_ELINKYES_ELINK_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group DMA_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group DMA_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- DMAMUX Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup DMAMUX_Peripheral_Access_Layer DMAMUX Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** DMAMUX - Size of Registers Arrays */\r\n#define DMAMUX_CHCFG_COUNT                       16u\r\n\r\n/** DMAMUX - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint8_t CHCFG[DMAMUX_CHCFG_COUNT];          /**< Channel Configuration register, array offset: 0x0, array step: 0x1 */\r\n} DMAMUX_Type, *DMAMUX_MemMapPtr;\r\n\r\n /** Number of instances of the DMAMUX module. */\r\n#define DMAMUX_INSTANCE_COUNT                    (1u)\r\n\r\n\r\n/* DMAMUX - Peripheral instance base addresses */\r\n/** Peripheral DMAMUX base address */\r\n#define DMAMUX_BASE                              (0x40021000u)\r\n/** Peripheral DMAMUX base pointer */\r\n#define DMAMUX                                   ((DMAMUX_Type *)DMAMUX_BASE)\r\n/** Array initializer of DMAMUX peripheral base addresses */\r\n#define DMAMUX_BASE_ADDRS                        { DMAMUX_BASE }\r\n/** Array initializer of DMAMUX peripheral base pointers */\r\n#define DMAMUX_BASE_PTRS                         { DMAMUX }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- DMAMUX Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup DMAMUX_Register_Masks DMAMUX Register Masks\r\n * @{\r\n */\r\n\r\n/* CHCFG Bit Fields */\r\n#define DMAMUX_CHCFG_SOURCE_MASK                 0x3Fu\r\n#define DMAMUX_CHCFG_SOURCE_SHIFT                0u\r\n#define DMAMUX_CHCFG_SOURCE_WIDTH                6u\r\n#define DMAMUX_CHCFG_SOURCE(x)                   (((uint8_t)(((uint8_t)(x))<<DMAMUX_CHCFG_SOURCE_SHIFT))&DMAMUX_CHCFG_SOURCE_MASK)\r\n#define DMAMUX_CHCFG_TRIG_MASK                   0x40u\r\n#define DMAMUX_CHCFG_TRIG_SHIFT                  6u\r\n#define DMAMUX_CHCFG_TRIG_WIDTH                  1u\r\n#define DMAMUX_CHCFG_TRIG(x)                     (((uint8_t)(((uint8_t)(x))<<DMAMUX_CHCFG_TRIG_SHIFT))&DMAMUX_CHCFG_TRIG_MASK)\r\n#define DMAMUX_CHCFG_ENBL_MASK                   0x80u\r\n#define DMAMUX_CHCFG_ENBL_SHIFT                  7u\r\n#define DMAMUX_CHCFG_ENBL_WIDTH                  1u\r\n#define DMAMUX_CHCFG_ENBL(x)                     (((uint8_t)(((uint8_t)(x))<<DMAMUX_CHCFG_ENBL_SHIFT))&DMAMUX_CHCFG_ENBL_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group DMAMUX_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group DMAMUX_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- EIM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup EIM_Peripheral_Access_Layer EIM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** EIM - Size of Registers Arrays */\r\n#define EIM_EICHDn_COUNT                         2u\r\n\r\n/** EIM - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t EIMCR;                             /**< Error Injection Module Configuration Register, offset: 0x0 */\r\n  __IO uint32_t EICHEN;                            /**< Error Injection Channel Enable register, offset: 0x4 */\r\n       uint8_t RESERVED_0[248];\r\n  struct {                                         /* offset: 0x100, array step: 0x100 */\r\n    __IO uint32_t WORD0;                             /**< Error Injection Channel Descriptor n, Word0, array offset: 0x100, array step: 0x100 */\r\n    __IO uint32_t WORD1;                             /**< Error Injection Channel Descriptor n, Word1, array offset: 0x104, array step: 0x100 */\r\n         uint8_t RESERVED_0[248];\r\n  } EICHDn[EIM_EICHDn_COUNT];\r\n} EIM_Type, *EIM_MemMapPtr;\r\n\r\n /** Number of instances of the EIM module. */\r\n#define EIM_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* EIM - Peripheral instance base addresses */\r\n/** Peripheral EIM base address */\r\n#define EIM_BASE                                 (0x40019000u)\r\n/** Peripheral EIM base pointer */\r\n#define EIM                                      ((EIM_Type *)EIM_BASE)\r\n/** Array initializer of EIM peripheral base addresses */\r\n#define EIM_BASE_ADDRS                           { EIM_BASE }\r\n/** Array initializer of EIM peripheral base pointers */\r\n#define EIM_BASE_PTRS                            { EIM }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- EIM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup EIM_Register_Masks EIM Register Masks\r\n * @{\r\n */\r\n\r\n/* EIMCR Bit Fields */\r\n#define EIM_EIMCR_GEIEN_MASK                     0x1u\r\n#define EIM_EIMCR_GEIEN_SHIFT                    0u\r\n#define EIM_EIMCR_GEIEN_WIDTH                    1u\r\n#define EIM_EIMCR_GEIEN(x)                       (((uint32_t)(((uint32_t)(x))<<EIM_EIMCR_GEIEN_SHIFT))&EIM_EIMCR_GEIEN_MASK)\r\n/* EICHEN Bit Fields */\r\n#define EIM_EICHEN_EICH1EN_MASK                  0x40000000u\r\n#define EIM_EICHEN_EICH1EN_SHIFT                 30u\r\n#define EIM_EICHEN_EICH1EN_WIDTH                 1u\r\n#define EIM_EICHEN_EICH1EN(x)                    (((uint32_t)(((uint32_t)(x))<<EIM_EICHEN_EICH1EN_SHIFT))&EIM_EICHEN_EICH1EN_MASK)\r\n#define EIM_EICHEN_EICH0EN_MASK                  0x80000000u\r\n#define EIM_EICHEN_EICH0EN_SHIFT                 31u\r\n#define EIM_EICHEN_EICH0EN_WIDTH                 1u\r\n#define EIM_EICHEN_EICH0EN(x)                    (((uint32_t)(((uint32_t)(x))<<EIM_EICHEN_EICH0EN_SHIFT))&EIM_EICHEN_EICH0EN_MASK)\r\n/* EICHDn_WORD0 Bit Fields */\r\n#define EIM_EICHDn_WORD0_CHKBIT_MASK_MASK        0xFE000000u\r\n#define EIM_EICHDn_WORD0_CHKBIT_MASK_SHIFT       25u\r\n#define EIM_EICHDn_WORD0_CHKBIT_MASK_WIDTH       7u\r\n#define EIM_EICHDn_WORD0_CHKBIT_MASK(x)          (((uint32_t)(((uint32_t)(x))<<EIM_EICHDn_WORD0_CHKBIT_MASK_SHIFT))&EIM_EICHDn_WORD0_CHKBIT_MASK_MASK)\r\n/* EICHDn_WORD1 Bit Fields */\r\n#define EIM_EICHDn_WORD1_B0_3DATA_MASK_MASK      0xFFFFFFFFu\r\n#define EIM_EICHDn_WORD1_B0_3DATA_MASK_SHIFT     0u\r\n#define EIM_EICHDn_WORD1_B0_3DATA_MASK_WIDTH     32u\r\n#define EIM_EICHDn_WORD1_B0_3DATA_MASK(x)        (((uint32_t)(((uint32_t)(x))<<EIM_EICHDn_WORD1_B0_3DATA_MASK_SHIFT))&EIM_EICHDn_WORD1_B0_3DATA_MASK_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group EIM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group EIM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- ERM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup ERM_Peripheral_Access_Layer ERM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** ERM - Size of Registers Arrays */\r\n#define ERM_EARn_COUNT                           2u\r\n\r\n/** ERM - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t CR0;                               /**< ERM Configuration Register 0, offset: 0x0 */\r\n       uint8_t RESERVED_0[12];\r\n  __IO uint32_t SR0;                               /**< ERM Status Register 0, offset: 0x10 */\r\n       uint8_t RESERVED_1[236];\r\n  struct {                                         /* offset: 0x100, array step: 0x10 */\r\n    __I  uint32_t EAR;                               /**< ERM Memory n Error Address Register, array offset: 0x100, array step: 0x10 */\r\n         uint8_t RESERVED_0[12];\r\n  } EARn[ERM_EARn_COUNT];\r\n} ERM_Type, *ERM_MemMapPtr;\r\n\r\n /** Number of instances of the ERM module. */\r\n#define ERM_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* ERM - Peripheral instance base addresses */\r\n/** Peripheral ERM base address */\r\n#define ERM_BASE                                 (0x40018000u)\r\n/** Peripheral ERM base pointer */\r\n#define ERM                                      ((ERM_Type *)ERM_BASE)\r\n/** Array initializer of ERM peripheral base addresses */\r\n#define ERM_BASE_ADDRS                           { ERM_BASE }\r\n/** Array initializer of ERM peripheral base pointers */\r\n#define ERM_BASE_PTRS                            { ERM }\r\n /** Number of interrupt vector arrays for the ERM module. */\r\n#define ERM_IRQS_ARR_COUNT                       (2u)\r\n /** Number of interrupt channels for the SINGLE type of ERM module. */\r\n#define ERM_SINGLE_IRQS_CH_COUNT                 (1u)\r\n /** Number of interrupt channels for the DOUBLE type of ERM module. */\r\n#define ERM_DOUBLE_IRQS_CH_COUNT                 (1u)\r\n/** Interrupt vectors for the ERM peripheral type */\r\n#define ERM_SINGLE_IRQS                          { ERM_single_fault_IRQn }\r\n#define ERM_DOUBLE_IRQS                          { ERM_double_fault_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- ERM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup ERM_Register_Masks ERM Register Masks\r\n * @{\r\n */\r\n\r\n/* CR0 Bit Fields */\r\n#define ERM_CR0_ENCIE1_MASK                      0x4000000u\r\n#define ERM_CR0_ENCIE1_SHIFT                     26u\r\n#define ERM_CR0_ENCIE1_WIDTH                     1u\r\n#define ERM_CR0_ENCIE1(x)                        (((uint32_t)(((uint32_t)(x))<<ERM_CR0_ENCIE1_SHIFT))&ERM_CR0_ENCIE1_MASK)\r\n#define ERM_CR0_ESCIE1_MASK                      0x8000000u\r\n#define ERM_CR0_ESCIE1_SHIFT                     27u\r\n#define ERM_CR0_ESCIE1_WIDTH                     1u\r\n#define ERM_CR0_ESCIE1(x)                        (((uint32_t)(((uint32_t)(x))<<ERM_CR0_ESCIE1_SHIFT))&ERM_CR0_ESCIE1_MASK)\r\n#define ERM_CR0_ENCIE0_MASK                      0x40000000u\r\n#define ERM_CR0_ENCIE0_SHIFT                     30u\r\n#define ERM_CR0_ENCIE0_WIDTH                     1u\r\n#define ERM_CR0_ENCIE0(x)                        (((uint32_t)(((uint32_t)(x))<<ERM_CR0_ENCIE0_SHIFT))&ERM_CR0_ENCIE0_MASK)\r\n#define ERM_CR0_ESCIE0_MASK                      0x80000000u\r\n#define ERM_CR0_ESCIE0_SHIFT                     31u\r\n#define ERM_CR0_ESCIE0_WIDTH                     1u\r\n#define ERM_CR0_ESCIE0(x)                        (((uint32_t)(((uint32_t)(x))<<ERM_CR0_ESCIE0_SHIFT))&ERM_CR0_ESCIE0_MASK)\r\n/* SR0 Bit Fields */\r\n#define ERM_SR0_NCE1_MASK                        0x4000000u\r\n#define ERM_SR0_NCE1_SHIFT                       26u\r\n#define ERM_SR0_NCE1_WIDTH                       1u\r\n#define ERM_SR0_NCE1(x)                          (((uint32_t)(((uint32_t)(x))<<ERM_SR0_NCE1_SHIFT))&ERM_SR0_NCE1_MASK)\r\n#define ERM_SR0_SBC1_MASK                        0x8000000u\r\n#define ERM_SR0_SBC1_SHIFT                       27u\r\n#define ERM_SR0_SBC1_WIDTH                       1u\r\n#define ERM_SR0_SBC1(x)                          (((uint32_t)(((uint32_t)(x))<<ERM_SR0_SBC1_SHIFT))&ERM_SR0_SBC1_MASK)\r\n#define ERM_SR0_NCE0_MASK                        0x40000000u\r\n#define ERM_SR0_NCE0_SHIFT                       30u\r\n#define ERM_SR0_NCE0_WIDTH                       1u\r\n#define ERM_SR0_NCE0(x)                          (((uint32_t)(((uint32_t)(x))<<ERM_SR0_NCE0_SHIFT))&ERM_SR0_NCE0_MASK)\r\n#define ERM_SR0_SBC0_MASK                        0x80000000u\r\n#define ERM_SR0_SBC0_SHIFT                       31u\r\n#define ERM_SR0_SBC0_WIDTH                       1u\r\n#define ERM_SR0_SBC0(x)                          (((uint32_t)(((uint32_t)(x))<<ERM_SR0_SBC0_SHIFT))&ERM_SR0_SBC0_MASK)\r\n/* EAR Bit Fields */\r\n#define ERM_EAR_EAR_MASK                         0xFFFFFFFFu\r\n#define ERM_EAR_EAR_SHIFT                        0u\r\n#define ERM_EAR_EAR_WIDTH                        32u\r\n#define ERM_EAR_EAR(x)                           (((uint32_t)(((uint32_t)(x))<<ERM_EAR_EAR_SHIFT))&ERM_EAR_EAR_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group ERM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group ERM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- EWM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup EWM_Peripheral_Access_Layer EWM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** EWM - Size of Registers Arrays */\r\n\r\n/** EWM - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint8_t CTRL;                               /**< Control Register, offset: 0x0 */\r\n  __O  uint8_t SERV;                               /**< Service Register, offset: 0x1 */\r\n  __IO uint8_t CMPL;                               /**< Compare Low Register, offset: 0x2 */\r\n  __IO uint8_t CMPH;                               /**< Compare High Register, offset: 0x3 */\r\n       uint8_t RESERVED_0[1];\r\n  __IO uint8_t CLKPRESCALER;                       /**< Clock Prescaler Register, offset: 0x5 */\r\n} EWM_Type, *EWM_MemMapPtr;\r\n\r\n /** Number of instances of the EWM module. */\r\n#define EWM_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* EWM - Peripheral instance base addresses */\r\n/** Peripheral EWM base address */\r\n#define EWM_BASE                                 (0x40061000u)\r\n/** Peripheral EWM base pointer */\r\n#define EWM                                      ((EWM_Type *)EWM_BASE)\r\n/** Array initializer of EWM peripheral base addresses */\r\n#define EWM_BASE_ADDRS                           { EWM_BASE }\r\n/** Array initializer of EWM peripheral base pointers */\r\n#define EWM_BASE_PTRS                            { EWM }\r\n /** Number of interrupt vector arrays for the EWM module. */\r\n#define EWM_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the EWM module. */\r\n#define EWM_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the EWM peripheral type */\r\n#define EWM_IRQS                                 { WDOG_EWM_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- EWM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup EWM_Register_Masks EWM Register Masks\r\n * @{\r\n */\r\n\r\n/* CTRL Bit Fields */\r\n#define EWM_CTRL_EWMEN_MASK                      0x1u\r\n#define EWM_CTRL_EWMEN_SHIFT                     0u\r\n#define EWM_CTRL_EWMEN_WIDTH                     1u\r\n#define EWM_CTRL_EWMEN(x)                        (((uint8_t)(((uint8_t)(x))<<EWM_CTRL_EWMEN_SHIFT))&EWM_CTRL_EWMEN_MASK)\r\n#define EWM_CTRL_ASSIN_MASK                      0x2u\r\n#define EWM_CTRL_ASSIN_SHIFT                     1u\r\n#define EWM_CTRL_ASSIN_WIDTH                     1u\r\n#define EWM_CTRL_ASSIN(x)                        (((uint8_t)(((uint8_t)(x))<<EWM_CTRL_ASSIN_SHIFT))&EWM_CTRL_ASSIN_MASK)\r\n#define EWM_CTRL_INEN_MASK                       0x4u\r\n#define EWM_CTRL_INEN_SHIFT                      2u\r\n#define EWM_CTRL_INEN_WIDTH                      1u\r\n#define EWM_CTRL_INEN(x)                         (((uint8_t)(((uint8_t)(x))<<EWM_CTRL_INEN_SHIFT))&EWM_CTRL_INEN_MASK)\r\n#define EWM_CTRL_INTEN_MASK                      0x8u\r\n#define EWM_CTRL_INTEN_SHIFT                     3u\r\n#define EWM_CTRL_INTEN_WIDTH                     1u\r\n#define EWM_CTRL_INTEN(x)                        (((uint8_t)(((uint8_t)(x))<<EWM_CTRL_INTEN_SHIFT))&EWM_CTRL_INTEN_MASK)\r\n/* SERV Bit Fields */\r\n#define EWM_SERV_SERVICE_MASK                    0xFFu\r\n#define EWM_SERV_SERVICE_SHIFT                   0u\r\n#define EWM_SERV_SERVICE_WIDTH                   8u\r\n#define EWM_SERV_SERVICE(x)                      (((uint8_t)(((uint8_t)(x))<<EWM_SERV_SERVICE_SHIFT))&EWM_SERV_SERVICE_MASK)\r\n/* CMPL Bit Fields */\r\n#define EWM_CMPL_COMPAREL_MASK                   0xFFu\r\n#define EWM_CMPL_COMPAREL_SHIFT                  0u\r\n#define EWM_CMPL_COMPAREL_WIDTH                  8u\r\n#define EWM_CMPL_COMPAREL(x)                     (((uint8_t)(((uint8_t)(x))<<EWM_CMPL_COMPAREL_SHIFT))&EWM_CMPL_COMPAREL_MASK)\r\n/* CMPH Bit Fields */\r\n#define EWM_CMPH_COMPAREH_MASK                   0xFFu\r\n#define EWM_CMPH_COMPAREH_SHIFT                  0u\r\n#define EWM_CMPH_COMPAREH_WIDTH                  8u\r\n#define EWM_CMPH_COMPAREH(x)                     (((uint8_t)(((uint8_t)(x))<<EWM_CMPH_COMPAREH_SHIFT))&EWM_CMPH_COMPAREH_MASK)\r\n/* CLKPRESCALER Bit Fields */\r\n#define EWM_CLKPRESCALER_CLK_DIV_MASK            0xFFu\r\n#define EWM_CLKPRESCALER_CLK_DIV_SHIFT           0u\r\n#define EWM_CLKPRESCALER_CLK_DIV_WIDTH           8u\r\n#define EWM_CLKPRESCALER_CLK_DIV(x)              (((uint8_t)(((uint8_t)(x))<<EWM_CLKPRESCALER_CLK_DIV_SHIFT))&EWM_CLKPRESCALER_CLK_DIV_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group EWM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group EWM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- FLEXIO Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup FLEXIO_Peripheral_Access_Layer FLEXIO Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** FLEXIO - Size of Registers Arrays */\r\n#define FLEXIO_SHIFTCTL_COUNT                    4u\r\n#define FLEXIO_SHIFTCFG_COUNT                    4u\r\n#define FLEXIO_SHIFTBUF_COUNT                    4u\r\n#define FLEXIO_SHIFTBUFBIS_COUNT                 4u\r\n#define FLEXIO_SHIFTBUFBYS_COUNT                 4u\r\n#define FLEXIO_SHIFTBUFBBS_COUNT                 4u\r\n#define FLEXIO_TIMCTL_COUNT                      4u\r\n#define FLEXIO_TIMCFG_COUNT                      4u\r\n#define FLEXIO_TIMCMP_COUNT                      4u\r\n\r\n/** FLEXIO - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n  __IO uint32_t CTRL;                              /**< FlexIO Control Register, offset: 0x8 */\r\n  __I  uint32_t PIN;                               /**< Pin State Register, offset: 0xC */\r\n  __IO uint32_t SHIFTSTAT;                         /**< Shifter Status Register, offset: 0x10 */\r\n  __IO uint32_t SHIFTERR;                          /**< Shifter Error Register, offset: 0x14 */\r\n  __IO uint32_t TIMSTAT;                           /**< Timer Status Register, offset: 0x18 */\r\n       uint8_t RESERVED_0[4];\r\n  __IO uint32_t SHIFTSIEN;                         /**< Shifter Status Interrupt Enable, offset: 0x20 */\r\n  __IO uint32_t SHIFTEIEN;                         /**< Shifter Error Interrupt Enable, offset: 0x24 */\r\n  __IO uint32_t TIMIEN;                            /**< Timer Interrupt Enable Register, offset: 0x28 */\r\n       uint8_t RESERVED_1[4];\r\n  __IO uint32_t SHIFTSDEN;                         /**< Shifter Status DMA Enable, offset: 0x30 */\r\n       uint8_t RESERVED_2[76];\r\n  __IO uint32_t SHIFTCTL[FLEXIO_SHIFTCTL_COUNT];   /**< Shifter Control N Register, array offset: 0x80, array step: 0x4 */\r\n       uint8_t RESERVED_3[112];\r\n  __IO uint32_t SHIFTCFG[FLEXIO_SHIFTCFG_COUNT];   /**< Shifter Configuration N Register, array offset: 0x100, array step: 0x4 */\r\n       uint8_t RESERVED_4[240];\r\n  __IO uint32_t SHIFTBUF[FLEXIO_SHIFTBUF_COUNT];   /**< Shifter Buffer N Register, array offset: 0x200, array step: 0x4 */\r\n       uint8_t RESERVED_5[112];\r\n  __IO uint32_t SHIFTBUFBIS[FLEXIO_SHIFTBUFBIS_COUNT]; /**< Shifter Buffer N Bit Swapped Register, array offset: 0x280, array step: 0x4 */\r\n       uint8_t RESERVED_6[112];\r\n  __IO uint32_t SHIFTBUFBYS[FLEXIO_SHIFTBUFBYS_COUNT]; /**< Shifter Buffer N Byte Swapped Register, array offset: 0x300, array step: 0x4 */\r\n       uint8_t RESERVED_7[112];\r\n  __IO uint32_t SHIFTBUFBBS[FLEXIO_SHIFTBUFBBS_COUNT]; /**< Shifter Buffer N Bit Byte Swapped Register, array offset: 0x380, array step: 0x4 */\r\n       uint8_t RESERVED_8[112];\r\n  __IO uint32_t TIMCTL[FLEXIO_TIMCTL_COUNT];       /**< Timer Control N Register, array offset: 0x400, array step: 0x4 */\r\n       uint8_t RESERVED_9[112];\r\n  __IO uint32_t TIMCFG[FLEXIO_TIMCFG_COUNT];       /**< Timer Configuration N Register, array offset: 0x480, array step: 0x4 */\r\n       uint8_t RESERVED_10[112];\r\n  __IO uint32_t TIMCMP[FLEXIO_TIMCMP_COUNT];       /**< Timer Compare N Register, array offset: 0x500, array step: 0x4 */\r\n} FLEXIO_Type, *FLEXIO_MemMapPtr;\r\n\r\n /** Number of instances of the FLEXIO module. */\r\n#define FLEXIO_INSTANCE_COUNT                    (1u)\r\n\r\n\r\n/* FLEXIO - Peripheral instance base addresses */\r\n/** Peripheral FLEXIO base address */\r\n#define FLEXIO_BASE                              (0x4005A000u)\r\n/** Peripheral FLEXIO base pointer */\r\n#define FLEXIO                                   ((FLEXIO_Type *)FLEXIO_BASE)\r\n/** Array initializer of FLEXIO peripheral base addresses */\r\n#define FLEXIO_BASE_ADDRS                        { FLEXIO_BASE }\r\n/** Array initializer of FLEXIO peripheral base pointers */\r\n#define FLEXIO_BASE_PTRS                         { FLEXIO }\r\n /** Number of interrupt vector arrays for the FLEXIO module. */\r\n#define FLEXIO_IRQS_ARR_COUNT                    (1u)\r\n /** Number of interrupt channels for the FLEXIO module. */\r\n#define FLEXIO_IRQS_CH_COUNT                     (1u)\r\n/** Interrupt vectors for the FLEXIO peripheral type */\r\n#define FLEXIO_IRQS                              { FLEXIO_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- FLEXIO Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup FLEXIO_Register_Masks FLEXIO Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define FLEXIO_VERID_FEATURE_MASK                0xFFFFu\r\n#define FLEXIO_VERID_FEATURE_SHIFT               0u\r\n#define FLEXIO_VERID_FEATURE_WIDTH               16u\r\n#define FLEXIO_VERID_FEATURE(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_VERID_FEATURE_SHIFT))&FLEXIO_VERID_FEATURE_MASK)\r\n#define FLEXIO_VERID_MINOR_MASK                  0xFF0000u\r\n#define FLEXIO_VERID_MINOR_SHIFT                 16u\r\n#define FLEXIO_VERID_MINOR_WIDTH                 8u\r\n#define FLEXIO_VERID_MINOR(x)                    (((uint32_t)(((uint32_t)(x))<<FLEXIO_VERID_MINOR_SHIFT))&FLEXIO_VERID_MINOR_MASK)\r\n#define FLEXIO_VERID_MAJOR_MASK                  0xFF000000u\r\n#define FLEXIO_VERID_MAJOR_SHIFT                 24u\r\n#define FLEXIO_VERID_MAJOR_WIDTH                 8u\r\n#define FLEXIO_VERID_MAJOR(x)                    (((uint32_t)(((uint32_t)(x))<<FLEXIO_VERID_MAJOR_SHIFT))&FLEXIO_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define FLEXIO_PARAM_SHIFTER_MASK                0xFFu\r\n#define FLEXIO_PARAM_SHIFTER_SHIFT               0u\r\n#define FLEXIO_PARAM_SHIFTER_WIDTH               8u\r\n#define FLEXIO_PARAM_SHIFTER(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_PARAM_SHIFTER_SHIFT))&FLEXIO_PARAM_SHIFTER_MASK)\r\n#define FLEXIO_PARAM_TIMER_MASK                  0xFF00u\r\n#define FLEXIO_PARAM_TIMER_SHIFT                 8u\r\n#define FLEXIO_PARAM_TIMER_WIDTH                 8u\r\n#define FLEXIO_PARAM_TIMER(x)                    (((uint32_t)(((uint32_t)(x))<<FLEXIO_PARAM_TIMER_SHIFT))&FLEXIO_PARAM_TIMER_MASK)\r\n#define FLEXIO_PARAM_PIN_MASK                    0xFF0000u\r\n#define FLEXIO_PARAM_PIN_SHIFT                   16u\r\n#define FLEXIO_PARAM_PIN_WIDTH                   8u\r\n#define FLEXIO_PARAM_PIN(x)                      (((uint32_t)(((uint32_t)(x))<<FLEXIO_PARAM_PIN_SHIFT))&FLEXIO_PARAM_PIN_MASK)\r\n#define FLEXIO_PARAM_TRIGGER_MASK                0xFF000000u\r\n#define FLEXIO_PARAM_TRIGGER_SHIFT               24u\r\n#define FLEXIO_PARAM_TRIGGER_WIDTH               8u\r\n#define FLEXIO_PARAM_TRIGGER(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_PARAM_TRIGGER_SHIFT))&FLEXIO_PARAM_TRIGGER_MASK)\r\n/* CTRL Bit Fields */\r\n#define FLEXIO_CTRL_FLEXEN_MASK                  0x1u\r\n#define FLEXIO_CTRL_FLEXEN_SHIFT                 0u\r\n#define FLEXIO_CTRL_FLEXEN_WIDTH                 1u\r\n#define FLEXIO_CTRL_FLEXEN(x)                    (((uint32_t)(((uint32_t)(x))<<FLEXIO_CTRL_FLEXEN_SHIFT))&FLEXIO_CTRL_FLEXEN_MASK)\r\n#define FLEXIO_CTRL_SWRST_MASK                   0x2u\r\n#define FLEXIO_CTRL_SWRST_SHIFT                  1u\r\n#define FLEXIO_CTRL_SWRST_WIDTH                  1u\r\n#define FLEXIO_CTRL_SWRST(x)                     (((uint32_t)(((uint32_t)(x))<<FLEXIO_CTRL_SWRST_SHIFT))&FLEXIO_CTRL_SWRST_MASK)\r\n#define FLEXIO_CTRL_FASTACC_MASK                 0x4u\r\n#define FLEXIO_CTRL_FASTACC_SHIFT                2u\r\n#define FLEXIO_CTRL_FASTACC_WIDTH                1u\r\n#define FLEXIO_CTRL_FASTACC(x)                   (((uint32_t)(((uint32_t)(x))<<FLEXIO_CTRL_FASTACC_SHIFT))&FLEXIO_CTRL_FASTACC_MASK)\r\n#define FLEXIO_CTRL_DBGE_MASK                    0x40000000u\r\n#define FLEXIO_CTRL_DBGE_SHIFT                   30u\r\n#define FLEXIO_CTRL_DBGE_WIDTH                   1u\r\n#define FLEXIO_CTRL_DBGE(x)                      (((uint32_t)(((uint32_t)(x))<<FLEXIO_CTRL_DBGE_SHIFT))&FLEXIO_CTRL_DBGE_MASK)\r\n#define FLEXIO_CTRL_DOZEN_MASK                   0x80000000u\r\n#define FLEXIO_CTRL_DOZEN_SHIFT                  31u\r\n#define FLEXIO_CTRL_DOZEN_WIDTH                  1u\r\n#define FLEXIO_CTRL_DOZEN(x)                     (((uint32_t)(((uint32_t)(x))<<FLEXIO_CTRL_DOZEN_SHIFT))&FLEXIO_CTRL_DOZEN_MASK)\r\n/* PIN Bit Fields */\r\n#define FLEXIO_PIN_PDI_MASK                      0xFFu\r\n#define FLEXIO_PIN_PDI_SHIFT                     0u\r\n#define FLEXIO_PIN_PDI_WIDTH                     8u\r\n#define FLEXIO_PIN_PDI(x)                        (((uint32_t)(((uint32_t)(x))<<FLEXIO_PIN_PDI_SHIFT))&FLEXIO_PIN_PDI_MASK)\r\n/* SHIFTSTAT Bit Fields */\r\n#define FLEXIO_SHIFTSTAT_SSF_MASK                0xFu\r\n#define FLEXIO_SHIFTSTAT_SSF_SHIFT               0u\r\n#define FLEXIO_SHIFTSTAT_SSF_WIDTH               4u\r\n#define FLEXIO_SHIFTSTAT_SSF(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTSTAT_SSF_SHIFT))&FLEXIO_SHIFTSTAT_SSF_MASK)\r\n/* SHIFTERR Bit Fields */\r\n#define FLEXIO_SHIFTERR_SEF_MASK                 0xFu\r\n#define FLEXIO_SHIFTERR_SEF_SHIFT                0u\r\n#define FLEXIO_SHIFTERR_SEF_WIDTH                4u\r\n#define FLEXIO_SHIFTERR_SEF(x)                   (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTERR_SEF_SHIFT))&FLEXIO_SHIFTERR_SEF_MASK)\r\n/* TIMSTAT Bit Fields */\r\n#define FLEXIO_TIMSTAT_TSF_MASK                  0xFu\r\n#define FLEXIO_TIMSTAT_TSF_SHIFT                 0u\r\n#define FLEXIO_TIMSTAT_TSF_WIDTH                 4u\r\n#define FLEXIO_TIMSTAT_TSF(x)                    (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMSTAT_TSF_SHIFT))&FLEXIO_TIMSTAT_TSF_MASK)\r\n/* SHIFTSIEN Bit Fields */\r\n#define FLEXIO_SHIFTSIEN_SSIE_MASK               0xFu\r\n#define FLEXIO_SHIFTSIEN_SSIE_SHIFT              0u\r\n#define FLEXIO_SHIFTSIEN_SSIE_WIDTH              4u\r\n#define FLEXIO_SHIFTSIEN_SSIE(x)                 (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTSIEN_SSIE_SHIFT))&FLEXIO_SHIFTSIEN_SSIE_MASK)\r\n/* SHIFTEIEN Bit Fields */\r\n#define FLEXIO_SHIFTEIEN_SEIE_MASK               0xFu\r\n#define FLEXIO_SHIFTEIEN_SEIE_SHIFT              0u\r\n#define FLEXIO_SHIFTEIEN_SEIE_WIDTH              4u\r\n#define FLEXIO_SHIFTEIEN_SEIE(x)                 (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTEIEN_SEIE_SHIFT))&FLEXIO_SHIFTEIEN_SEIE_MASK)\r\n/* TIMIEN Bit Fields */\r\n#define FLEXIO_TIMIEN_TEIE_MASK                  0xFu\r\n#define FLEXIO_TIMIEN_TEIE_SHIFT                 0u\r\n#define FLEXIO_TIMIEN_TEIE_WIDTH                 4u\r\n#define FLEXIO_TIMIEN_TEIE(x)                    (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMIEN_TEIE_SHIFT))&FLEXIO_TIMIEN_TEIE_MASK)\r\n/* SHIFTSDEN Bit Fields */\r\n#define FLEXIO_SHIFTSDEN_SSDE_MASK               0xFu\r\n#define FLEXIO_SHIFTSDEN_SSDE_SHIFT              0u\r\n#define FLEXIO_SHIFTSDEN_SSDE_WIDTH              4u\r\n#define FLEXIO_SHIFTSDEN_SSDE(x)                 (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTSDEN_SSDE_SHIFT))&FLEXIO_SHIFTSDEN_SSDE_MASK)\r\n/* SHIFTCTL Bit Fields */\r\n#define FLEXIO_SHIFTCTL_SMOD_MASK                0x7u\r\n#define FLEXIO_SHIFTCTL_SMOD_SHIFT               0u\r\n#define FLEXIO_SHIFTCTL_SMOD_WIDTH               3u\r\n#define FLEXIO_SHIFTCTL_SMOD(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCTL_SMOD_SHIFT))&FLEXIO_SHIFTCTL_SMOD_MASK)\r\n#define FLEXIO_SHIFTCTL_PINPOL_MASK              0x80u\r\n#define FLEXIO_SHIFTCTL_PINPOL_SHIFT             7u\r\n#define FLEXIO_SHIFTCTL_PINPOL_WIDTH             1u\r\n#define FLEXIO_SHIFTCTL_PINPOL(x)                (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCTL_PINPOL_SHIFT))&FLEXIO_SHIFTCTL_PINPOL_MASK)\r\n#define FLEXIO_SHIFTCTL_PINSEL_MASK              0x700u\r\n#define FLEXIO_SHIFTCTL_PINSEL_SHIFT             8u\r\n#define FLEXIO_SHIFTCTL_PINSEL_WIDTH             3u\r\n#define FLEXIO_SHIFTCTL_PINSEL(x)                (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCTL_PINSEL_SHIFT))&FLEXIO_SHIFTCTL_PINSEL_MASK)\r\n#define FLEXIO_SHIFTCTL_PINCFG_MASK              0x30000u\r\n#define FLEXIO_SHIFTCTL_PINCFG_SHIFT             16u\r\n#define FLEXIO_SHIFTCTL_PINCFG_WIDTH             2u\r\n#define FLEXIO_SHIFTCTL_PINCFG(x)                (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCTL_PINCFG_SHIFT))&FLEXIO_SHIFTCTL_PINCFG_MASK)\r\n#define FLEXIO_SHIFTCTL_TIMPOL_MASK              0x800000u\r\n#define FLEXIO_SHIFTCTL_TIMPOL_SHIFT             23u\r\n#define FLEXIO_SHIFTCTL_TIMPOL_WIDTH             1u\r\n#define FLEXIO_SHIFTCTL_TIMPOL(x)                (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCTL_TIMPOL_SHIFT))&FLEXIO_SHIFTCTL_TIMPOL_MASK)\r\n#define FLEXIO_SHIFTCTL_TIMSEL_MASK              0x3000000u\r\n#define FLEXIO_SHIFTCTL_TIMSEL_SHIFT             24u\r\n#define FLEXIO_SHIFTCTL_TIMSEL_WIDTH             2u\r\n#define FLEXIO_SHIFTCTL_TIMSEL(x)                (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCTL_TIMSEL_SHIFT))&FLEXIO_SHIFTCTL_TIMSEL_MASK)\r\n/* SHIFTCFG Bit Fields */\r\n#define FLEXIO_SHIFTCFG_SSTART_MASK              0x3u\r\n#define FLEXIO_SHIFTCFG_SSTART_SHIFT             0u\r\n#define FLEXIO_SHIFTCFG_SSTART_WIDTH             2u\r\n#define FLEXIO_SHIFTCFG_SSTART(x)                (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCFG_SSTART_SHIFT))&FLEXIO_SHIFTCFG_SSTART_MASK)\r\n#define FLEXIO_SHIFTCFG_SSTOP_MASK               0x30u\r\n#define FLEXIO_SHIFTCFG_SSTOP_SHIFT              4u\r\n#define FLEXIO_SHIFTCFG_SSTOP_WIDTH              2u\r\n#define FLEXIO_SHIFTCFG_SSTOP(x)                 (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCFG_SSTOP_SHIFT))&FLEXIO_SHIFTCFG_SSTOP_MASK)\r\n#define FLEXIO_SHIFTCFG_INSRC_MASK               0x100u\r\n#define FLEXIO_SHIFTCFG_INSRC_SHIFT              8u\r\n#define FLEXIO_SHIFTCFG_INSRC_WIDTH              1u\r\n#define FLEXIO_SHIFTCFG_INSRC(x)                 (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTCFG_INSRC_SHIFT))&FLEXIO_SHIFTCFG_INSRC_MASK)\r\n/* SHIFTBUF Bit Fields */\r\n#define FLEXIO_SHIFTBUF_SHIFTBUF_MASK            0xFFFFFFFFu\r\n#define FLEXIO_SHIFTBUF_SHIFTBUF_SHIFT           0u\r\n#define FLEXIO_SHIFTBUF_SHIFTBUF_WIDTH           32u\r\n#define FLEXIO_SHIFTBUF_SHIFTBUF(x)              (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTBUF_SHIFTBUF_SHIFT))&FLEXIO_SHIFTBUF_SHIFTBUF_MASK)\r\n/* SHIFTBUFBIS Bit Fields */\r\n#define FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_MASK      0xFFFFFFFFu\r\n#define FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_SHIFT     0u\r\n#define FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_WIDTH     32u\r\n#define FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS(x)        (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_SHIFT))&FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_MASK)\r\n/* SHIFTBUFBYS Bit Fields */\r\n#define FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_MASK      0xFFFFFFFFu\r\n#define FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_SHIFT     0u\r\n#define FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_WIDTH     32u\r\n#define FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS(x)        (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_SHIFT))&FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_MASK)\r\n/* SHIFTBUFBBS Bit Fields */\r\n#define FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_MASK      0xFFFFFFFFu\r\n#define FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_SHIFT     0u\r\n#define FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_WIDTH     32u\r\n#define FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS(x)        (((uint32_t)(((uint32_t)(x))<<FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_SHIFT))&FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_MASK)\r\n/* TIMCTL Bit Fields */\r\n#define FLEXIO_TIMCTL_TIMOD_MASK                 0x3u\r\n#define FLEXIO_TIMCTL_TIMOD_SHIFT                0u\r\n#define FLEXIO_TIMCTL_TIMOD_WIDTH                2u\r\n#define FLEXIO_TIMCTL_TIMOD(x)                   (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_TIMOD_SHIFT))&FLEXIO_TIMCTL_TIMOD_MASK)\r\n#define FLEXIO_TIMCTL_PINPOL_MASK                0x80u\r\n#define FLEXIO_TIMCTL_PINPOL_SHIFT               7u\r\n#define FLEXIO_TIMCTL_PINPOL_WIDTH               1u\r\n#define FLEXIO_TIMCTL_PINPOL(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_PINPOL_SHIFT))&FLEXIO_TIMCTL_PINPOL_MASK)\r\n#define FLEXIO_TIMCTL_PINSEL_MASK                0x700u\r\n#define FLEXIO_TIMCTL_PINSEL_SHIFT               8u\r\n#define FLEXIO_TIMCTL_PINSEL_WIDTH               3u\r\n#define FLEXIO_TIMCTL_PINSEL(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_PINSEL_SHIFT))&FLEXIO_TIMCTL_PINSEL_MASK)\r\n#define FLEXIO_TIMCTL_PINCFG_MASK                0x30000u\r\n#define FLEXIO_TIMCTL_PINCFG_SHIFT               16u\r\n#define FLEXIO_TIMCTL_PINCFG_WIDTH               2u\r\n#define FLEXIO_TIMCTL_PINCFG(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_PINCFG_SHIFT))&FLEXIO_TIMCTL_PINCFG_MASK)\r\n#define FLEXIO_TIMCTL_TRGSRC_MASK                0x400000u\r\n#define FLEXIO_TIMCTL_TRGSRC_SHIFT               22u\r\n#define FLEXIO_TIMCTL_TRGSRC_WIDTH               1u\r\n#define FLEXIO_TIMCTL_TRGSRC(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_TRGSRC_SHIFT))&FLEXIO_TIMCTL_TRGSRC_MASK)\r\n#define FLEXIO_TIMCTL_TRGPOL_MASK                0x800000u\r\n#define FLEXIO_TIMCTL_TRGPOL_SHIFT               23u\r\n#define FLEXIO_TIMCTL_TRGPOL_WIDTH               1u\r\n#define FLEXIO_TIMCTL_TRGPOL(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_TRGPOL_SHIFT))&FLEXIO_TIMCTL_TRGPOL_MASK)\r\n#define FLEXIO_TIMCTL_TRGSEL_MASK                0xF000000u\r\n#define FLEXIO_TIMCTL_TRGSEL_SHIFT               24u\r\n#define FLEXIO_TIMCTL_TRGSEL_WIDTH               4u\r\n#define FLEXIO_TIMCTL_TRGSEL(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCTL_TRGSEL_SHIFT))&FLEXIO_TIMCTL_TRGSEL_MASK)\r\n/* TIMCFG Bit Fields */\r\n#define FLEXIO_TIMCFG_TSTART_MASK                0x2u\r\n#define FLEXIO_TIMCFG_TSTART_SHIFT               1u\r\n#define FLEXIO_TIMCFG_TSTART_WIDTH               1u\r\n#define FLEXIO_TIMCFG_TSTART(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TSTART_SHIFT))&FLEXIO_TIMCFG_TSTART_MASK)\r\n#define FLEXIO_TIMCFG_TSTOP_MASK                 0x30u\r\n#define FLEXIO_TIMCFG_TSTOP_SHIFT                4u\r\n#define FLEXIO_TIMCFG_TSTOP_WIDTH                2u\r\n#define FLEXIO_TIMCFG_TSTOP(x)                   (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TSTOP_SHIFT))&FLEXIO_TIMCFG_TSTOP_MASK)\r\n#define FLEXIO_TIMCFG_TIMENA_MASK                0x700u\r\n#define FLEXIO_TIMCFG_TIMENA_SHIFT               8u\r\n#define FLEXIO_TIMCFG_TIMENA_WIDTH               3u\r\n#define FLEXIO_TIMCFG_TIMENA(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TIMENA_SHIFT))&FLEXIO_TIMCFG_TIMENA_MASK)\r\n#define FLEXIO_TIMCFG_TIMDIS_MASK                0x7000u\r\n#define FLEXIO_TIMCFG_TIMDIS_SHIFT               12u\r\n#define FLEXIO_TIMCFG_TIMDIS_WIDTH               3u\r\n#define FLEXIO_TIMCFG_TIMDIS(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TIMDIS_SHIFT))&FLEXIO_TIMCFG_TIMDIS_MASK)\r\n#define FLEXIO_TIMCFG_TIMRST_MASK                0x70000u\r\n#define FLEXIO_TIMCFG_TIMRST_SHIFT               16u\r\n#define FLEXIO_TIMCFG_TIMRST_WIDTH               3u\r\n#define FLEXIO_TIMCFG_TIMRST(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TIMRST_SHIFT))&FLEXIO_TIMCFG_TIMRST_MASK)\r\n#define FLEXIO_TIMCFG_TIMDEC_MASK                0x300000u\r\n#define FLEXIO_TIMCFG_TIMDEC_SHIFT               20u\r\n#define FLEXIO_TIMCFG_TIMDEC_WIDTH               2u\r\n#define FLEXIO_TIMCFG_TIMDEC(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TIMDEC_SHIFT))&FLEXIO_TIMCFG_TIMDEC_MASK)\r\n#define FLEXIO_TIMCFG_TIMOUT_MASK                0x3000000u\r\n#define FLEXIO_TIMCFG_TIMOUT_SHIFT               24u\r\n#define FLEXIO_TIMCFG_TIMOUT_WIDTH               2u\r\n#define FLEXIO_TIMCFG_TIMOUT(x)                  (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCFG_TIMOUT_SHIFT))&FLEXIO_TIMCFG_TIMOUT_MASK)\r\n/* TIMCMP Bit Fields */\r\n#define FLEXIO_TIMCMP_CMP_MASK                   0xFFFFu\r\n#define FLEXIO_TIMCMP_CMP_SHIFT                  0u\r\n#define FLEXIO_TIMCMP_CMP_WIDTH                  16u\r\n#define FLEXIO_TIMCMP_CMP(x)                     (((uint32_t)(((uint32_t)(x))<<FLEXIO_TIMCMP_CMP_SHIFT))&FLEXIO_TIMCMP_CMP_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group FLEXIO_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group FLEXIO_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- FTFC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup FTFC_Peripheral_Access_Layer FTFC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** FTFC - Size of Registers Arrays */\r\n#define FTFC_FCCOB_COUNT                         12u\r\n#define FTFC_FPROT_COUNT                         4u\r\n\r\n/** FTFC - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint8_t FSTAT;                              /**< Flash Status Register, offset: 0x0 */\r\n  __IO uint8_t FCNFG;                              /**< Flash Configuration Register, offset: 0x1 */\r\n  __I  uint8_t FSEC;                               /**< Flash Security Register, offset: 0x2 */\r\n  __I  uint8_t FOPT;                               /**< Flash Option Register, offset: 0x3 */\r\n  __IO uint8_t FCCOB[FTFC_FCCOB_COUNT];            /**< Flash Common Command Object Registers, array offset: 0x4, array step: 0x1 */\r\n  __IO uint8_t FPROT[FTFC_FPROT_COUNT];            /**< Program Flash Protection Registers, array offset: 0x10, array step: 0x1 */\r\n       uint8_t RESERVED_0[2];\r\n  __IO uint8_t FEPROT;                             /**< EEPROM Protection Register, offset: 0x16 */\r\n  __IO uint8_t FDPROT;                             /**< Data Flash Protection Register, offset: 0x17 */\r\n       uint8_t RESERVED_1[20];\r\n  __I  uint8_t FCSESTAT;                           /**< Flash CSEc Status Register, offset: 0x2C */\r\n       uint8_t RESERVED_2[1];\r\n  __IO uint8_t FERSTAT;                            /**< Flash Error Status Register, offset: 0x2E */\r\n  __IO uint8_t FERCNFG;                            /**< Flash Error Configuration Register, offset: 0x2F */\r\n} FTFC_Type, *FTFC_MemMapPtr;\r\n\r\n /** Number of instances of the FTFC module. */\r\n#define FTFC_INSTANCE_COUNT                      (1u)\r\n\r\n\r\n/* FTFC - Peripheral instance base addresses */\r\n/** Peripheral FTFC base address */\r\n#define FTFC_BASE                                (0x40020000u)\r\n/** Peripheral FTFC base pointer */\r\n#define FTFC                                     ((FTFC_Type *)FTFC_BASE)\r\n/** Array initializer of FTFC peripheral base addresses */\r\n#define FTFC_BASE_ADDRS                          { FTFC_BASE }\r\n/** Array initializer of FTFC peripheral base pointers */\r\n#define FTFC_BASE_PTRS                           { FTFC }\r\n /** Number of interrupt vector arrays for the FTFC module. */\r\n#define FTFC_IRQS_ARR_COUNT                      (2u)\r\n /** Number of interrupt channels for the COMMAND_COMPLETE type of FTFC module. */\r\n#define FTFC_COMMAND_COMPLETE_IRQS_CH_COUNT      (1u)\r\n /** Number of interrupt channels for the READ_COLLISION type of FTFC module. */\r\n#define FTFC_READ_COLLISION_IRQS_CH_COUNT        (1u)\r\n/** Interrupt vectors for the FTFC peripheral type */\r\n#define FTFC_COMMAND_COMPLETE_IRQS               { FTFC_IRQn }\r\n#define FTFC_READ_COLLISION_IRQS                 { Read_Collision_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- FTFC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup FTFC_Register_Masks FTFC Register Masks\r\n * @{\r\n */\r\n\r\n/* FSTAT Bit Fields */\r\n#define FTFC_FSTAT_MGSTAT0_MASK                  0x1u\r\n#define FTFC_FSTAT_MGSTAT0_SHIFT                 0u\r\n#define FTFC_FSTAT_MGSTAT0_WIDTH                 1u\r\n#define FTFC_FSTAT_MGSTAT0(x)                    (((uint8_t)(((uint8_t)(x))<<FTFC_FSTAT_MGSTAT0_SHIFT))&FTFC_FSTAT_MGSTAT0_MASK)\r\n#define FTFC_FSTAT_FPVIOL_MASK                   0x10u\r\n#define FTFC_FSTAT_FPVIOL_SHIFT                  4u\r\n#define FTFC_FSTAT_FPVIOL_WIDTH                  1u\r\n#define FTFC_FSTAT_FPVIOL(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FSTAT_FPVIOL_SHIFT))&FTFC_FSTAT_FPVIOL_MASK)\r\n#define FTFC_FSTAT_ACCERR_MASK                   0x20u\r\n#define FTFC_FSTAT_ACCERR_SHIFT                  5u\r\n#define FTFC_FSTAT_ACCERR_WIDTH                  1u\r\n#define FTFC_FSTAT_ACCERR(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FSTAT_ACCERR_SHIFT))&FTFC_FSTAT_ACCERR_MASK)\r\n#define FTFC_FSTAT_RDCOLERR_MASK                 0x40u\r\n#define FTFC_FSTAT_RDCOLERR_SHIFT                6u\r\n#define FTFC_FSTAT_RDCOLERR_WIDTH                1u\r\n#define FTFC_FSTAT_RDCOLERR(x)                   (((uint8_t)(((uint8_t)(x))<<FTFC_FSTAT_RDCOLERR_SHIFT))&FTFC_FSTAT_RDCOLERR_MASK)\r\n#define FTFC_FSTAT_CCIF_MASK                     0x80u\r\n#define FTFC_FSTAT_CCIF_SHIFT                    7u\r\n#define FTFC_FSTAT_CCIF_WIDTH                    1u\r\n#define FTFC_FSTAT_CCIF(x)                       (((uint8_t)(((uint8_t)(x))<<FTFC_FSTAT_CCIF_SHIFT))&FTFC_FSTAT_CCIF_MASK)\r\n/* FCNFG Bit Fields */\r\n#define FTFC_FCNFG_EEERDY_MASK                   0x1u\r\n#define FTFC_FCNFG_EEERDY_SHIFT                  0u\r\n#define FTFC_FCNFG_EEERDY_WIDTH                  1u\r\n#define FTFC_FCNFG_EEERDY(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCNFG_EEERDY_SHIFT))&FTFC_FCNFG_EEERDY_MASK)\r\n#define FTFC_FCNFG_RAMRDY_MASK                   0x2u\r\n#define FTFC_FCNFG_RAMRDY_SHIFT                  1u\r\n#define FTFC_FCNFG_RAMRDY_WIDTH                  1u\r\n#define FTFC_FCNFG_RAMRDY(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCNFG_RAMRDY_SHIFT))&FTFC_FCNFG_RAMRDY_MASK)\r\n#define FTFC_FCNFG_ERSSUSP_MASK                  0x10u\r\n#define FTFC_FCNFG_ERSSUSP_SHIFT                 4u\r\n#define FTFC_FCNFG_ERSSUSP_WIDTH                 1u\r\n#define FTFC_FCNFG_ERSSUSP(x)                    (((uint8_t)(((uint8_t)(x))<<FTFC_FCNFG_ERSSUSP_SHIFT))&FTFC_FCNFG_ERSSUSP_MASK)\r\n#define FTFC_FCNFG_ERSAREQ_MASK                  0x20u\r\n#define FTFC_FCNFG_ERSAREQ_SHIFT                 5u\r\n#define FTFC_FCNFG_ERSAREQ_WIDTH                 1u\r\n#define FTFC_FCNFG_ERSAREQ(x)                    (((uint8_t)(((uint8_t)(x))<<FTFC_FCNFG_ERSAREQ_SHIFT))&FTFC_FCNFG_ERSAREQ_MASK)\r\n#define FTFC_FCNFG_RDCOLLIE_MASK                 0x40u\r\n#define FTFC_FCNFG_RDCOLLIE_SHIFT                6u\r\n#define FTFC_FCNFG_RDCOLLIE_WIDTH                1u\r\n#define FTFC_FCNFG_RDCOLLIE(x)                   (((uint8_t)(((uint8_t)(x))<<FTFC_FCNFG_RDCOLLIE_SHIFT))&FTFC_FCNFG_RDCOLLIE_MASK)\r\n#define FTFC_FCNFG_CCIE_MASK                     0x80u\r\n#define FTFC_FCNFG_CCIE_SHIFT                    7u\r\n#define FTFC_FCNFG_CCIE_WIDTH                    1u\r\n#define FTFC_FCNFG_CCIE(x)                       (((uint8_t)(((uint8_t)(x))<<FTFC_FCNFG_CCIE_SHIFT))&FTFC_FCNFG_CCIE_MASK)\r\n/* FSEC Bit Fields */\r\n#define FTFC_FSEC_SEC_MASK                       0x3u\r\n#define FTFC_FSEC_SEC_SHIFT                      0u\r\n#define FTFC_FSEC_SEC_WIDTH                      2u\r\n#define FTFC_FSEC_SEC(x)                         (((uint8_t)(((uint8_t)(x))<<FTFC_FSEC_SEC_SHIFT))&FTFC_FSEC_SEC_MASK)\r\n#define FTFC_FSEC_FSLACC_MASK                    0xCu\r\n#define FTFC_FSEC_FSLACC_SHIFT                   2u\r\n#define FTFC_FSEC_FSLACC_WIDTH                   2u\r\n#define FTFC_FSEC_FSLACC(x)                      (((uint8_t)(((uint8_t)(x))<<FTFC_FSEC_FSLACC_SHIFT))&FTFC_FSEC_FSLACC_MASK)\r\n#define FTFC_FSEC_MEEN_MASK                      0x30u\r\n#define FTFC_FSEC_MEEN_SHIFT                     4u\r\n#define FTFC_FSEC_MEEN_WIDTH                     2u\r\n#define FTFC_FSEC_MEEN(x)                        (((uint8_t)(((uint8_t)(x))<<FTFC_FSEC_MEEN_SHIFT))&FTFC_FSEC_MEEN_MASK)\r\n#define FTFC_FSEC_KEYEN_MASK                     0xC0u\r\n#define FTFC_FSEC_KEYEN_SHIFT                    6u\r\n#define FTFC_FSEC_KEYEN_WIDTH                    2u\r\n#define FTFC_FSEC_KEYEN(x)                       (((uint8_t)(((uint8_t)(x))<<FTFC_FSEC_KEYEN_SHIFT))&FTFC_FSEC_KEYEN_MASK)\r\n/* FOPT Bit Fields */\r\n#define FTFC_FOPT_OPT_MASK                       0xFFu\r\n#define FTFC_FOPT_OPT_SHIFT                      0u\r\n#define FTFC_FOPT_OPT_WIDTH                      8u\r\n#define FTFC_FOPT_OPT(x)                         (((uint8_t)(((uint8_t)(x))<<FTFC_FOPT_OPT_SHIFT))&FTFC_FOPT_OPT_MASK)\r\n/* FCCOB Bit Fields */\r\n#define FTFC_FCCOB_CCOBn_MASK                    0xFFu\r\n#define FTFC_FCCOB_CCOBn_SHIFT                   0u\r\n#define FTFC_FCCOB_CCOBn_WIDTH                   8u\r\n#define FTFC_FCCOB_CCOBn(x)                      (((uint8_t)(((uint8_t)(x))<<FTFC_FCCOB_CCOBn_SHIFT))&FTFC_FCCOB_CCOBn_MASK)\r\n/* FPROT Bit Fields */\r\n#define FTFC_FPROT_PROT_MASK                     0xFFu\r\n#define FTFC_FPROT_PROT_SHIFT                    0u\r\n#define FTFC_FPROT_PROT_WIDTH                    8u\r\n#define FTFC_FPROT_PROT(x)                       (((uint8_t)(((uint8_t)(x))<<FTFC_FPROT_PROT_SHIFT))&FTFC_FPROT_PROT_MASK)\r\n/* FEPROT Bit Fields */\r\n#define FTFC_FEPROT_EPROT_MASK                   0xFFu\r\n#define FTFC_FEPROT_EPROT_SHIFT                  0u\r\n#define FTFC_FEPROT_EPROT_WIDTH                  8u\r\n#define FTFC_FEPROT_EPROT(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FEPROT_EPROT_SHIFT))&FTFC_FEPROT_EPROT_MASK)\r\n/* FDPROT Bit Fields */\r\n#define FTFC_FDPROT_DPROT_MASK                   0xFFu\r\n#define FTFC_FDPROT_DPROT_SHIFT                  0u\r\n#define FTFC_FDPROT_DPROT_WIDTH                  8u\r\n#define FTFC_FDPROT_DPROT(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FDPROT_DPROT_SHIFT))&FTFC_FDPROT_DPROT_MASK)\r\n/* FCSESTAT Bit Fields */\r\n#define FTFC_FCSESTAT_BSY_MASK                   0x1u\r\n#define FTFC_FCSESTAT_BSY_SHIFT                  0u\r\n#define FTFC_FCSESTAT_BSY_WIDTH                  1u\r\n#define FTFC_FCSESTAT_BSY(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_BSY_SHIFT))&FTFC_FCSESTAT_BSY_MASK)\r\n#define FTFC_FCSESTAT_SB_MASK                    0x2u\r\n#define FTFC_FCSESTAT_SB_SHIFT                   1u\r\n#define FTFC_FCSESTAT_SB_WIDTH                   1u\r\n#define FTFC_FCSESTAT_SB(x)                      (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_SB_SHIFT))&FTFC_FCSESTAT_SB_MASK)\r\n#define FTFC_FCSESTAT_BIN_MASK                   0x4u\r\n#define FTFC_FCSESTAT_BIN_SHIFT                  2u\r\n#define FTFC_FCSESTAT_BIN_WIDTH                  1u\r\n#define FTFC_FCSESTAT_BIN(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_BIN_SHIFT))&FTFC_FCSESTAT_BIN_MASK)\r\n#define FTFC_FCSESTAT_BFN_MASK                   0x8u\r\n#define FTFC_FCSESTAT_BFN_SHIFT                  3u\r\n#define FTFC_FCSESTAT_BFN_WIDTH                  1u\r\n#define FTFC_FCSESTAT_BFN(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_BFN_SHIFT))&FTFC_FCSESTAT_BFN_MASK)\r\n#define FTFC_FCSESTAT_BOK_MASK                   0x10u\r\n#define FTFC_FCSESTAT_BOK_SHIFT                  4u\r\n#define FTFC_FCSESTAT_BOK_WIDTH                  1u\r\n#define FTFC_FCSESTAT_BOK(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_BOK_SHIFT))&FTFC_FCSESTAT_BOK_MASK)\r\n#define FTFC_FCSESTAT_RIN_MASK                   0x20u\r\n#define FTFC_FCSESTAT_RIN_SHIFT                  5u\r\n#define FTFC_FCSESTAT_RIN_WIDTH                  1u\r\n#define FTFC_FCSESTAT_RIN(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_RIN_SHIFT))&FTFC_FCSESTAT_RIN_MASK)\r\n#define FTFC_FCSESTAT_EDB_MASK                   0x40u\r\n#define FTFC_FCSESTAT_EDB_SHIFT                  6u\r\n#define FTFC_FCSESTAT_EDB_WIDTH                  1u\r\n#define FTFC_FCSESTAT_EDB(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_EDB_SHIFT))&FTFC_FCSESTAT_EDB_MASK)\r\n#define FTFC_FCSESTAT_IDB_MASK                   0x80u\r\n#define FTFC_FCSESTAT_IDB_SHIFT                  7u\r\n#define FTFC_FCSESTAT_IDB_WIDTH                  1u\r\n#define FTFC_FCSESTAT_IDB(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FCSESTAT_IDB_SHIFT))&FTFC_FCSESTAT_IDB_MASK)\r\n/* FERSTAT Bit Fields */\r\n#define FTFC_FERSTAT_DFDIF_MASK                  0x2u\r\n#define FTFC_FERSTAT_DFDIF_SHIFT                 1u\r\n#define FTFC_FERSTAT_DFDIF_WIDTH                 1u\r\n#define FTFC_FERSTAT_DFDIF(x)                    (((uint8_t)(((uint8_t)(x))<<FTFC_FERSTAT_DFDIF_SHIFT))&FTFC_FERSTAT_DFDIF_MASK)\r\n/* FERCNFG Bit Fields */\r\n#define FTFC_FERCNFG_DFDIE_MASK                  0x2u\r\n#define FTFC_FERCNFG_DFDIE_SHIFT                 1u\r\n#define FTFC_FERCNFG_DFDIE_WIDTH                 1u\r\n#define FTFC_FERCNFG_DFDIE(x)                    (((uint8_t)(((uint8_t)(x))<<FTFC_FERCNFG_DFDIE_SHIFT))&FTFC_FERCNFG_DFDIE_MASK)\r\n#define FTFC_FERCNFG_FDFD_MASK                   0x20u\r\n#define FTFC_FERCNFG_FDFD_SHIFT                  5u\r\n#define FTFC_FERCNFG_FDFD_WIDTH                  1u\r\n#define FTFC_FERCNFG_FDFD(x)                     (((uint8_t)(((uint8_t)(x))<<FTFC_FERCNFG_FDFD_SHIFT))&FTFC_FERCNFG_FDFD_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group FTFC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group FTFC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- FTM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup FTM_Peripheral_Access_Layer FTM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** FTM - Size of Registers Arrays */\r\n#define FTM_CONTROLS_COUNT                       8u\r\n\r\n/** FTM - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t SC;                                /**< Status And Control, offset: 0x0 */\r\n  __IO uint32_t CNT;                               /**< Counter, offset: 0x4 */\r\n  __IO uint32_t MOD;                               /**< Modulo, offset: 0x8 */\r\n  struct {                                         /* offset: 0xC, array step: 0x8 */\r\n    __IO uint32_t CnSC;                              /**< Channel (n) Status And Control, array offset: 0xC, array step: 0x8 */\r\n    __IO uint32_t CnV;                               /**< Channel (n) Value, array offset: 0x10, array step: 0x8 */\r\n  } CONTROLS[FTM_CONTROLS_COUNT];\r\n  __IO uint32_t CNTIN;                             /**< Counter Initial Value, offset: 0x4C */\r\n  __IO uint32_t STATUS;                            /**< Capture And Compare Status, offset: 0x50 */\r\n  __IO uint32_t MODE;                              /**< Features Mode Selection, offset: 0x54 */\r\n  __IO uint32_t SYNC;                              /**< Synchronization, offset: 0x58 */\r\n  __IO uint32_t OUTINIT;                           /**< Initial State For Channels Output, offset: 0x5C */\r\n  __IO uint32_t OUTMASK;                           /**< Output Mask, offset: 0x60 */\r\n  __IO uint32_t COMBINE;                           /**< Function For Linked Channels, offset: 0x64 */\r\n  __IO uint32_t DEADTIME;                          /**< Deadtime Configuration, offset: 0x68 */\r\n  __IO uint32_t EXTTRIG;                           /**< FTM External Trigger, offset: 0x6C */\r\n  __IO uint32_t POL;                               /**< Channels Polarity, offset: 0x70 */\r\n  __IO uint32_t FMS;                               /**< Fault Mode Status, offset: 0x74 */\r\n  __IO uint32_t FILTER;                            /**< Input Capture Filter Control, offset: 0x78 */\r\n  __IO uint32_t FLTCTRL;                           /**< Fault Control, offset: 0x7C */\r\n  __IO uint32_t QDCTRL;                            /**< Quadrature Decoder Control And Status, offset: 0x80 */\r\n  __IO uint32_t CONF;                              /**< Configuration, offset: 0x84 */\r\n  __IO uint32_t FLTPOL;                            /**< FTM Fault Input Polarity, offset: 0x88 */\r\n  __IO uint32_t SYNCONF;                           /**< Synchronization Configuration, offset: 0x8C */\r\n  __IO uint32_t INVCTRL;                           /**< FTM Inverting Control, offset: 0x90 */\r\n  __IO uint32_t SWOCTRL;                           /**< FTM Software Output Control, offset: 0x94 */\r\n  __IO uint32_t PWMLOAD;                           /**< FTM PWM Load, offset: 0x98 */\r\n  __IO uint32_t HCR;                               /**< Half Cycle Register, offset: 0x9C */\r\n  __IO uint32_t PAIR0DEADTIME;                     /**< Pair 0 Deadtime Configuration, offset: 0xA0 */\r\n       uint8_t RESERVED_0[4];\r\n  __IO uint32_t PAIR1DEADTIME;                     /**< Pair 1 Deadtime Configuration, offset: 0xA8 */\r\n       uint8_t RESERVED_1[4];\r\n  __IO uint32_t PAIR2DEADTIME;                     /**< Pair 2 Deadtime Configuration, offset: 0xB0 */\r\n       uint8_t RESERVED_2[4];\r\n  __IO uint32_t PAIR3DEADTIME;                     /**< Pair 3 Deadtime Configuration, offset: 0xB8 */\r\n} FTM_Type, *FTM_MemMapPtr;\r\n\r\n /** Number of instances of the FTM module. */\r\n#define FTM_INSTANCE_COUNT                       (4u)\r\n\r\n\r\n/* FTM - Peripheral instance base addresses */\r\n/** Peripheral FTM0 base address */\r\n#define FTM0_BASE                                (0x40038000u)\r\n/** Peripheral FTM0 base pointer */\r\n#define FTM0                                     ((FTM_Type *)FTM0_BASE)\r\n/** Peripheral FTM1 base address */\r\n#define FTM1_BASE                                (0x40039000u)\r\n/** Peripheral FTM1 base pointer */\r\n#define FTM1                                     ((FTM_Type *)FTM1_BASE)\r\n/** Peripheral FTM2 base address */\r\n#define FTM2_BASE                                (0x4003A000u)\r\n/** Peripheral FTM2 base pointer */\r\n#define FTM2                                     ((FTM_Type *)FTM2_BASE)\r\n/** Peripheral FTM3 base address */\r\n#define FTM3_BASE                                (0x40026000u)\r\n/** Peripheral FTM3 base pointer */\r\n#define FTM3                                     ((FTM_Type *)FTM3_BASE)\r\n/** Array initializer of FTM peripheral base addresses */\r\n#define FTM_BASE_ADDRS                           { FTM0_BASE, FTM1_BASE, FTM2_BASE, FTM3_BASE }\r\n/** Array initializer of FTM peripheral base pointers */\r\n#define FTM_BASE_PTRS                            { FTM0, FTM1, FTM2, FTM3 }\r\n /** Number of interrupt vector arrays for the FTM module. */\r\n#define FTM_IRQS_ARR_COUNT                       (4u)\r\n /** Number of interrupt channels for the FTM module. */\r\n#define FTM_IRQS_CH_COUNT                        (8u)\r\n /** Number of interrupt channels for the Fault type of FTM module. */\r\n#define FTM_Fault_IRQS_CH_COUNT                  (1u)\r\n /** Number of interrupt channels for the Overflow type of FTM module. */\r\n#define FTM_Overflow_IRQS_CH_COUNT               (1u)\r\n /** Number of interrupt channels for the Reload type of FTM module. */\r\n#define FTM_Reload_IRQS_CH_COUNT                 (1u)\r\n/** Interrupt vectors for the FTM peripheral type */\r\n#define FTM_IRQS                                 { { FTM0_Ch0_Ch1_IRQn, FTM0_Ch0_Ch1_IRQn, FTM0_Ch2_Ch3_IRQn, FTM0_Ch2_Ch3_IRQn, FTM0_Ch4_Ch5_IRQn, FTM0_Ch4_Ch5_IRQn, FTM0_Ch6_Ch7_IRQn, FTM0_Ch6_Ch7_IRQn }, \\\r\n                                                   { FTM1_Ch0_Ch1_IRQn, FTM1_Ch0_Ch1_IRQn, FTM1_Ch2_Ch3_IRQn, FTM1_Ch2_Ch3_IRQn, FTM1_Ch4_Ch5_IRQn, FTM1_Ch4_Ch5_IRQn, FTM1_Ch6_Ch7_IRQn, FTM1_Ch6_Ch7_IRQn }, \\\r\n                                                   { FTM2_Ch0_Ch1_IRQn, FTM2_Ch0_Ch1_IRQn, FTM2_Ch2_Ch3_IRQn, FTM2_Ch2_Ch3_IRQn, FTM2_Ch4_Ch5_IRQn, FTM2_Ch4_Ch5_IRQn, FTM2_Ch6_Ch7_IRQn, FTM2_Ch6_Ch7_IRQn }, \\\r\n                                                   { FTM3_Ch0_Ch1_IRQn, FTM3_Ch0_Ch1_IRQn, FTM3_Ch2_Ch3_IRQn, FTM3_Ch2_Ch3_IRQn, FTM3_Ch4_Ch5_IRQn, FTM3_Ch4_Ch5_IRQn, FTM3_Ch6_Ch7_IRQn, FTM3_Ch6_Ch7_IRQn } }\r\n#define FTM_Fault_IRQS                           { FTM0_Fault_IRQn, FTM1_Fault_IRQn, FTM2_Fault_IRQn, FTM3_Fault_IRQn }\r\n#define FTM_Overflow_IRQS                        { FTM0_Ovf_Reload_IRQn, FTM1_Ovf_Reload_IRQn, FTM2_Ovf_Reload_IRQn, FTM3_Ovf_Reload_IRQn }\r\n#define FTM_Reload_IRQS                          { FTM0_Ovf_Reload_IRQn, FTM1_Ovf_Reload_IRQn, FTM2_Ovf_Reload_IRQn, FTM3_Ovf_Reload_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- FTM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup FTM_Register_Masks FTM Register Masks\r\n * @{\r\n */\r\n\r\n/* SC Bit Fields */\r\n#define FTM_SC_PS_MASK                           0x7u\r\n#define FTM_SC_PS_SHIFT                          0u\r\n#define FTM_SC_PS_WIDTH                          3u\r\n#define FTM_SC_PS(x)                             (((uint32_t)(((uint32_t)(x))<<FTM_SC_PS_SHIFT))&FTM_SC_PS_MASK)\r\n#define FTM_SC_CLKS_MASK                         0x18u\r\n#define FTM_SC_CLKS_SHIFT                        3u\r\n#define FTM_SC_CLKS_WIDTH                        2u\r\n#define FTM_SC_CLKS(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_SC_CLKS_SHIFT))&FTM_SC_CLKS_MASK)\r\n#define FTM_SC_CPWMS_MASK                        0x20u\r\n#define FTM_SC_CPWMS_SHIFT                       5u\r\n#define FTM_SC_CPWMS_WIDTH                       1u\r\n#define FTM_SC_CPWMS(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_SC_CPWMS_SHIFT))&FTM_SC_CPWMS_MASK)\r\n#define FTM_SC_RIE_MASK                          0x40u\r\n#define FTM_SC_RIE_SHIFT                         6u\r\n#define FTM_SC_RIE_WIDTH                         1u\r\n#define FTM_SC_RIE(x)                            (((uint32_t)(((uint32_t)(x))<<FTM_SC_RIE_SHIFT))&FTM_SC_RIE_MASK)\r\n#define FTM_SC_RF_MASK                           0x80u\r\n#define FTM_SC_RF_SHIFT                          7u\r\n#define FTM_SC_RF_WIDTH                          1u\r\n#define FTM_SC_RF(x)                             (((uint32_t)(((uint32_t)(x))<<FTM_SC_RF_SHIFT))&FTM_SC_RF_MASK)\r\n#define FTM_SC_TOIE_MASK                         0x100u\r\n#define FTM_SC_TOIE_SHIFT                        8u\r\n#define FTM_SC_TOIE_WIDTH                        1u\r\n#define FTM_SC_TOIE(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_SC_TOIE_SHIFT))&FTM_SC_TOIE_MASK)\r\n#define FTM_SC_TOF_MASK                          0x200u\r\n#define FTM_SC_TOF_SHIFT                         9u\r\n#define FTM_SC_TOF_WIDTH                         1u\r\n#define FTM_SC_TOF(x)                            (((uint32_t)(((uint32_t)(x))<<FTM_SC_TOF_SHIFT))&FTM_SC_TOF_MASK)\r\n#define FTM_SC_PWMEN0_MASK                       0x10000u\r\n#define FTM_SC_PWMEN0_SHIFT                      16u\r\n#define FTM_SC_PWMEN0_WIDTH                      1u\r\n#define FTM_SC_PWMEN0(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN0_SHIFT))&FTM_SC_PWMEN0_MASK)\r\n#define FTM_SC_PWMEN1_MASK                       0x20000u\r\n#define FTM_SC_PWMEN1_SHIFT                      17u\r\n#define FTM_SC_PWMEN1_WIDTH                      1u\r\n#define FTM_SC_PWMEN1(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN1_SHIFT))&FTM_SC_PWMEN1_MASK)\r\n#define FTM_SC_PWMEN2_MASK                       0x40000u\r\n#define FTM_SC_PWMEN2_SHIFT                      18u\r\n#define FTM_SC_PWMEN2_WIDTH                      1u\r\n#define FTM_SC_PWMEN2(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN2_SHIFT))&FTM_SC_PWMEN2_MASK)\r\n#define FTM_SC_PWMEN3_MASK                       0x80000u\r\n#define FTM_SC_PWMEN3_SHIFT                      19u\r\n#define FTM_SC_PWMEN3_WIDTH                      1u\r\n#define FTM_SC_PWMEN3(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN3_SHIFT))&FTM_SC_PWMEN3_MASK)\r\n#define FTM_SC_PWMEN4_MASK                       0x100000u\r\n#define FTM_SC_PWMEN4_SHIFT                      20u\r\n#define FTM_SC_PWMEN4_WIDTH                      1u\r\n#define FTM_SC_PWMEN4(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN4_SHIFT))&FTM_SC_PWMEN4_MASK)\r\n#define FTM_SC_PWMEN5_MASK                       0x200000u\r\n#define FTM_SC_PWMEN5_SHIFT                      21u\r\n#define FTM_SC_PWMEN5_WIDTH                      1u\r\n#define FTM_SC_PWMEN5(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN5_SHIFT))&FTM_SC_PWMEN5_MASK)\r\n#define FTM_SC_PWMEN6_MASK                       0x400000u\r\n#define FTM_SC_PWMEN6_SHIFT                      22u\r\n#define FTM_SC_PWMEN6_WIDTH                      1u\r\n#define FTM_SC_PWMEN6(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN6_SHIFT))&FTM_SC_PWMEN6_MASK)\r\n#define FTM_SC_PWMEN7_MASK                       0x800000u\r\n#define FTM_SC_PWMEN7_SHIFT                      23u\r\n#define FTM_SC_PWMEN7_WIDTH                      1u\r\n#define FTM_SC_PWMEN7(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_SC_PWMEN7_SHIFT))&FTM_SC_PWMEN7_MASK)\r\n#define FTM_SC_FLTPS_MASK                        0xF000000u\r\n#define FTM_SC_FLTPS_SHIFT                       24u\r\n#define FTM_SC_FLTPS_WIDTH                       4u\r\n#define FTM_SC_FLTPS(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_SC_FLTPS_SHIFT))&FTM_SC_FLTPS_MASK)\r\n/* CNT Bit Fields */\r\n#define FTM_CNT_COUNT_MASK                       0xFFFFu\r\n#define FTM_CNT_COUNT_SHIFT                      0u\r\n#define FTM_CNT_COUNT_WIDTH                      16u\r\n#define FTM_CNT_COUNT(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CNT_COUNT_SHIFT))&FTM_CNT_COUNT_MASK)\r\n/* MOD Bit Fields */\r\n#define FTM_MOD_MOD_MASK                         0xFFFFu\r\n#define FTM_MOD_MOD_SHIFT                        0u\r\n#define FTM_MOD_MOD_WIDTH                        16u\r\n#define FTM_MOD_MOD(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_MOD_MOD_SHIFT))&FTM_MOD_MOD_MASK)\r\n/* CnSC Bit Fields */\r\n#define FTM_CnSC_DMA_MASK                        0x1u\r\n#define FTM_CnSC_DMA_SHIFT                       0u\r\n#define FTM_CnSC_DMA_WIDTH                       1u\r\n#define FTM_CnSC_DMA(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_DMA_SHIFT))&FTM_CnSC_DMA_MASK)\r\n#define FTM_CnSC_ICRST_MASK                      0x2u\r\n#define FTM_CnSC_ICRST_SHIFT                     1u\r\n#define FTM_CnSC_ICRST_WIDTH                     1u\r\n#define FTM_CnSC_ICRST(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_ICRST_SHIFT))&FTM_CnSC_ICRST_MASK)\r\n#define FTM_CnSC_ELSA_MASK                       0x4u\r\n#define FTM_CnSC_ELSA_SHIFT                      2u\r\n#define FTM_CnSC_ELSA_WIDTH                      1u\r\n#define FTM_CnSC_ELSA(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_ELSA_SHIFT))&FTM_CnSC_ELSA_MASK)\r\n#define FTM_CnSC_ELSB_MASK                       0x8u\r\n#define FTM_CnSC_ELSB_SHIFT                      3u\r\n#define FTM_CnSC_ELSB_WIDTH                      1u\r\n#define FTM_CnSC_ELSB(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_ELSB_SHIFT))&FTM_CnSC_ELSB_MASK)\r\n#define FTM_CnSC_MSA_MASK                        0x10u\r\n#define FTM_CnSC_MSA_SHIFT                       4u\r\n#define FTM_CnSC_MSA_WIDTH                       1u\r\n#define FTM_CnSC_MSA(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_MSA_SHIFT))&FTM_CnSC_MSA_MASK)\r\n#define FTM_CnSC_MSB_MASK                        0x20u\r\n#define FTM_CnSC_MSB_SHIFT                       5u\r\n#define FTM_CnSC_MSB_WIDTH                       1u\r\n#define FTM_CnSC_MSB(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_MSB_SHIFT))&FTM_CnSC_MSB_MASK)\r\n#define FTM_CnSC_CHIE_MASK                       0x40u\r\n#define FTM_CnSC_CHIE_SHIFT                      6u\r\n#define FTM_CnSC_CHIE_WIDTH                      1u\r\n#define FTM_CnSC_CHIE(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_CHIE_SHIFT))&FTM_CnSC_CHIE_MASK)\r\n#define FTM_CnSC_CHF_MASK                        0x80u\r\n#define FTM_CnSC_CHF_SHIFT                       7u\r\n#define FTM_CnSC_CHF_WIDTH                       1u\r\n#define FTM_CnSC_CHF(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_CHF_SHIFT))&FTM_CnSC_CHF_MASK)\r\n#define FTM_CnSC_TRIGMODE_MASK                   0x100u\r\n#define FTM_CnSC_TRIGMODE_SHIFT                  8u\r\n#define FTM_CnSC_TRIGMODE_WIDTH                  1u\r\n#define FTM_CnSC_TRIGMODE(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_TRIGMODE_SHIFT))&FTM_CnSC_TRIGMODE_MASK)\r\n#define FTM_CnSC_CHIS_MASK                       0x200u\r\n#define FTM_CnSC_CHIS_SHIFT                      9u\r\n#define FTM_CnSC_CHIS_WIDTH                      1u\r\n#define FTM_CnSC_CHIS(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_CHIS_SHIFT))&FTM_CnSC_CHIS_MASK)\r\n#define FTM_CnSC_CHOV_MASK                       0x400u\r\n#define FTM_CnSC_CHOV_SHIFT                      10u\r\n#define FTM_CnSC_CHOV_WIDTH                      1u\r\n#define FTM_CnSC_CHOV(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CnSC_CHOV_SHIFT))&FTM_CnSC_CHOV_MASK)\r\n/* CnV Bit Fields */\r\n#define FTM_CnV_VAL_MASK                         0xFFFFu\r\n#define FTM_CnV_VAL_SHIFT                        0u\r\n#define FTM_CnV_VAL_WIDTH                        16u\r\n#define FTM_CnV_VAL(x)                           (((uint32_t)(((uint32_t)(x))<<FTM_CnV_VAL_SHIFT))&FTM_CnV_VAL_MASK)\r\n/* CNTIN Bit Fields */\r\n#define FTM_CNTIN_INIT_MASK                      0xFFFFu\r\n#define FTM_CNTIN_INIT_SHIFT                     0u\r\n#define FTM_CNTIN_INIT_WIDTH                     16u\r\n#define FTM_CNTIN_INIT(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_CNTIN_INIT_SHIFT))&FTM_CNTIN_INIT_MASK)\r\n/* STATUS Bit Fields */\r\n#define FTM_STATUS_CH0F_MASK                     0x1u\r\n#define FTM_STATUS_CH0F_SHIFT                    0u\r\n#define FTM_STATUS_CH0F_WIDTH                    1u\r\n#define FTM_STATUS_CH0F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH0F_SHIFT))&FTM_STATUS_CH0F_MASK)\r\n#define FTM_STATUS_CH1F_MASK                     0x2u\r\n#define FTM_STATUS_CH1F_SHIFT                    1u\r\n#define FTM_STATUS_CH1F_WIDTH                    1u\r\n#define FTM_STATUS_CH1F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH1F_SHIFT))&FTM_STATUS_CH1F_MASK)\r\n#define FTM_STATUS_CH2F_MASK                     0x4u\r\n#define FTM_STATUS_CH2F_SHIFT                    2u\r\n#define FTM_STATUS_CH2F_WIDTH                    1u\r\n#define FTM_STATUS_CH2F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH2F_SHIFT))&FTM_STATUS_CH2F_MASK)\r\n#define FTM_STATUS_CH3F_MASK                     0x8u\r\n#define FTM_STATUS_CH3F_SHIFT                    3u\r\n#define FTM_STATUS_CH3F_WIDTH                    1u\r\n#define FTM_STATUS_CH3F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH3F_SHIFT))&FTM_STATUS_CH3F_MASK)\r\n#define FTM_STATUS_CH4F_MASK                     0x10u\r\n#define FTM_STATUS_CH4F_SHIFT                    4u\r\n#define FTM_STATUS_CH4F_WIDTH                    1u\r\n#define FTM_STATUS_CH4F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH4F_SHIFT))&FTM_STATUS_CH4F_MASK)\r\n#define FTM_STATUS_CH5F_MASK                     0x20u\r\n#define FTM_STATUS_CH5F_SHIFT                    5u\r\n#define FTM_STATUS_CH5F_WIDTH                    1u\r\n#define FTM_STATUS_CH5F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH5F_SHIFT))&FTM_STATUS_CH5F_MASK)\r\n#define FTM_STATUS_CH6F_MASK                     0x40u\r\n#define FTM_STATUS_CH6F_SHIFT                    6u\r\n#define FTM_STATUS_CH6F_WIDTH                    1u\r\n#define FTM_STATUS_CH6F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH6F_SHIFT))&FTM_STATUS_CH6F_MASK)\r\n#define FTM_STATUS_CH7F_MASK                     0x80u\r\n#define FTM_STATUS_CH7F_SHIFT                    7u\r\n#define FTM_STATUS_CH7F_WIDTH                    1u\r\n#define FTM_STATUS_CH7F(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_STATUS_CH7F_SHIFT))&FTM_STATUS_CH7F_MASK)\r\n/* MODE Bit Fields */\r\n#define FTM_MODE_FTMEN_MASK                      0x1u\r\n#define FTM_MODE_FTMEN_SHIFT                     0u\r\n#define FTM_MODE_FTMEN_WIDTH                     1u\r\n#define FTM_MODE_FTMEN(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_MODE_FTMEN_SHIFT))&FTM_MODE_FTMEN_MASK)\r\n#define FTM_MODE_INIT_MASK                       0x2u\r\n#define FTM_MODE_INIT_SHIFT                      1u\r\n#define FTM_MODE_INIT_WIDTH                      1u\r\n#define FTM_MODE_INIT(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_MODE_INIT_SHIFT))&FTM_MODE_INIT_MASK)\r\n#define FTM_MODE_WPDIS_MASK                      0x4u\r\n#define FTM_MODE_WPDIS_SHIFT                     2u\r\n#define FTM_MODE_WPDIS_WIDTH                     1u\r\n#define FTM_MODE_WPDIS(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_MODE_WPDIS_SHIFT))&FTM_MODE_WPDIS_MASK)\r\n#define FTM_MODE_PWMSYNC_MASK                    0x8u\r\n#define FTM_MODE_PWMSYNC_SHIFT                   3u\r\n#define FTM_MODE_PWMSYNC_WIDTH                   1u\r\n#define FTM_MODE_PWMSYNC(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_MODE_PWMSYNC_SHIFT))&FTM_MODE_PWMSYNC_MASK)\r\n#define FTM_MODE_CAPTEST_MASK                    0x10u\r\n#define FTM_MODE_CAPTEST_SHIFT                   4u\r\n#define FTM_MODE_CAPTEST_WIDTH                   1u\r\n#define FTM_MODE_CAPTEST(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_MODE_CAPTEST_SHIFT))&FTM_MODE_CAPTEST_MASK)\r\n#define FTM_MODE_FAULTM_MASK                     0x60u\r\n#define FTM_MODE_FAULTM_SHIFT                    5u\r\n#define FTM_MODE_FAULTM_WIDTH                    2u\r\n#define FTM_MODE_FAULTM(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_MODE_FAULTM_SHIFT))&FTM_MODE_FAULTM_MASK)\r\n#define FTM_MODE_FAULTIE_MASK                    0x80u\r\n#define FTM_MODE_FAULTIE_SHIFT                   7u\r\n#define FTM_MODE_FAULTIE_WIDTH                   1u\r\n#define FTM_MODE_FAULTIE(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_MODE_FAULTIE_SHIFT))&FTM_MODE_FAULTIE_MASK)\r\n/* SYNC Bit Fields */\r\n#define FTM_SYNC_CNTMIN_MASK                     0x1u\r\n#define FTM_SYNC_CNTMIN_SHIFT                    0u\r\n#define FTM_SYNC_CNTMIN_WIDTH                    1u\r\n#define FTM_SYNC_CNTMIN(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_CNTMIN_SHIFT))&FTM_SYNC_CNTMIN_MASK)\r\n#define FTM_SYNC_CNTMAX_MASK                     0x2u\r\n#define FTM_SYNC_CNTMAX_SHIFT                    1u\r\n#define FTM_SYNC_CNTMAX_WIDTH                    1u\r\n#define FTM_SYNC_CNTMAX(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_CNTMAX_SHIFT))&FTM_SYNC_CNTMAX_MASK)\r\n#define FTM_SYNC_REINIT_MASK                     0x4u\r\n#define FTM_SYNC_REINIT_SHIFT                    2u\r\n#define FTM_SYNC_REINIT_WIDTH                    1u\r\n#define FTM_SYNC_REINIT(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_REINIT_SHIFT))&FTM_SYNC_REINIT_MASK)\r\n#define FTM_SYNC_SYNCHOM_MASK                    0x8u\r\n#define FTM_SYNC_SYNCHOM_SHIFT                   3u\r\n#define FTM_SYNC_SYNCHOM_WIDTH                   1u\r\n#define FTM_SYNC_SYNCHOM(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_SYNCHOM_SHIFT))&FTM_SYNC_SYNCHOM_MASK)\r\n#define FTM_SYNC_TRIG0_MASK                      0x10u\r\n#define FTM_SYNC_TRIG0_SHIFT                     4u\r\n#define FTM_SYNC_TRIG0_WIDTH                     1u\r\n#define FTM_SYNC_TRIG0(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_TRIG0_SHIFT))&FTM_SYNC_TRIG0_MASK)\r\n#define FTM_SYNC_TRIG1_MASK                      0x20u\r\n#define FTM_SYNC_TRIG1_SHIFT                     5u\r\n#define FTM_SYNC_TRIG1_WIDTH                     1u\r\n#define FTM_SYNC_TRIG1(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_TRIG1_SHIFT))&FTM_SYNC_TRIG1_MASK)\r\n#define FTM_SYNC_TRIG2_MASK                      0x40u\r\n#define FTM_SYNC_TRIG2_SHIFT                     6u\r\n#define FTM_SYNC_TRIG2_WIDTH                     1u\r\n#define FTM_SYNC_TRIG2(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_TRIG2_SHIFT))&FTM_SYNC_TRIG2_MASK)\r\n#define FTM_SYNC_SWSYNC_MASK                     0x80u\r\n#define FTM_SYNC_SWSYNC_SHIFT                    7u\r\n#define FTM_SYNC_SWSYNC_WIDTH                    1u\r\n#define FTM_SYNC_SWSYNC(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_SYNC_SWSYNC_SHIFT))&FTM_SYNC_SWSYNC_MASK)\r\n/* OUTINIT Bit Fields */\r\n#define FTM_OUTINIT_CH0OI_MASK                   0x1u\r\n#define FTM_OUTINIT_CH0OI_SHIFT                  0u\r\n#define FTM_OUTINIT_CH0OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH0OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH0OI_SHIFT))&FTM_OUTINIT_CH0OI_MASK)\r\n#define FTM_OUTINIT_CH1OI_MASK                   0x2u\r\n#define FTM_OUTINIT_CH1OI_SHIFT                  1u\r\n#define FTM_OUTINIT_CH1OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH1OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH1OI_SHIFT))&FTM_OUTINIT_CH1OI_MASK)\r\n#define FTM_OUTINIT_CH2OI_MASK                   0x4u\r\n#define FTM_OUTINIT_CH2OI_SHIFT                  2u\r\n#define FTM_OUTINIT_CH2OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH2OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH2OI_SHIFT))&FTM_OUTINIT_CH2OI_MASK)\r\n#define FTM_OUTINIT_CH3OI_MASK                   0x8u\r\n#define FTM_OUTINIT_CH3OI_SHIFT                  3u\r\n#define FTM_OUTINIT_CH3OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH3OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH3OI_SHIFT))&FTM_OUTINIT_CH3OI_MASK)\r\n#define FTM_OUTINIT_CH4OI_MASK                   0x10u\r\n#define FTM_OUTINIT_CH4OI_SHIFT                  4u\r\n#define FTM_OUTINIT_CH4OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH4OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH4OI_SHIFT))&FTM_OUTINIT_CH4OI_MASK)\r\n#define FTM_OUTINIT_CH5OI_MASK                   0x20u\r\n#define FTM_OUTINIT_CH5OI_SHIFT                  5u\r\n#define FTM_OUTINIT_CH5OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH5OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH5OI_SHIFT))&FTM_OUTINIT_CH5OI_MASK)\r\n#define FTM_OUTINIT_CH6OI_MASK                   0x40u\r\n#define FTM_OUTINIT_CH6OI_SHIFT                  6u\r\n#define FTM_OUTINIT_CH6OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH6OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH6OI_SHIFT))&FTM_OUTINIT_CH6OI_MASK)\r\n#define FTM_OUTINIT_CH7OI_MASK                   0x80u\r\n#define FTM_OUTINIT_CH7OI_SHIFT                  7u\r\n#define FTM_OUTINIT_CH7OI_WIDTH                  1u\r\n#define FTM_OUTINIT_CH7OI(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTINIT_CH7OI_SHIFT))&FTM_OUTINIT_CH7OI_MASK)\r\n/* OUTMASK Bit Fields */\r\n#define FTM_OUTMASK_CH0OM_MASK                   0x1u\r\n#define FTM_OUTMASK_CH0OM_SHIFT                  0u\r\n#define FTM_OUTMASK_CH0OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH0OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH0OM_SHIFT))&FTM_OUTMASK_CH0OM_MASK)\r\n#define FTM_OUTMASK_CH1OM_MASK                   0x2u\r\n#define FTM_OUTMASK_CH1OM_SHIFT                  1u\r\n#define FTM_OUTMASK_CH1OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH1OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH1OM_SHIFT))&FTM_OUTMASK_CH1OM_MASK)\r\n#define FTM_OUTMASK_CH2OM_MASK                   0x4u\r\n#define FTM_OUTMASK_CH2OM_SHIFT                  2u\r\n#define FTM_OUTMASK_CH2OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH2OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH2OM_SHIFT))&FTM_OUTMASK_CH2OM_MASK)\r\n#define FTM_OUTMASK_CH3OM_MASK                   0x8u\r\n#define FTM_OUTMASK_CH3OM_SHIFT                  3u\r\n#define FTM_OUTMASK_CH3OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH3OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH3OM_SHIFT))&FTM_OUTMASK_CH3OM_MASK)\r\n#define FTM_OUTMASK_CH4OM_MASK                   0x10u\r\n#define FTM_OUTMASK_CH4OM_SHIFT                  4u\r\n#define FTM_OUTMASK_CH4OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH4OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH4OM_SHIFT))&FTM_OUTMASK_CH4OM_MASK)\r\n#define FTM_OUTMASK_CH5OM_MASK                   0x20u\r\n#define FTM_OUTMASK_CH5OM_SHIFT                  5u\r\n#define FTM_OUTMASK_CH5OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH5OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH5OM_SHIFT))&FTM_OUTMASK_CH5OM_MASK)\r\n#define FTM_OUTMASK_CH6OM_MASK                   0x40u\r\n#define FTM_OUTMASK_CH6OM_SHIFT                  6u\r\n#define FTM_OUTMASK_CH6OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH6OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH6OM_SHIFT))&FTM_OUTMASK_CH6OM_MASK)\r\n#define FTM_OUTMASK_CH7OM_MASK                   0x80u\r\n#define FTM_OUTMASK_CH7OM_SHIFT                  7u\r\n#define FTM_OUTMASK_CH7OM_WIDTH                  1u\r\n#define FTM_OUTMASK_CH7OM(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_OUTMASK_CH7OM_SHIFT))&FTM_OUTMASK_CH7OM_MASK)\r\n/* COMBINE Bit Fields */\r\n#define FTM_COMBINE_COMBINE0_MASK                0x1u\r\n#define FTM_COMBINE_COMBINE0_SHIFT               0u\r\n#define FTM_COMBINE_COMBINE0_WIDTH               1u\r\n#define FTM_COMBINE_COMBINE0(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMBINE0_SHIFT))&FTM_COMBINE_COMBINE0_MASK)\r\n#define FTM_COMBINE_COMP0_MASK                   0x2u\r\n#define FTM_COMBINE_COMP0_SHIFT                  1u\r\n#define FTM_COMBINE_COMP0_WIDTH                  1u\r\n#define FTM_COMBINE_COMP0(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMP0_SHIFT))&FTM_COMBINE_COMP0_MASK)\r\n#define FTM_COMBINE_DECAPEN0_MASK                0x4u\r\n#define FTM_COMBINE_DECAPEN0_SHIFT               2u\r\n#define FTM_COMBINE_DECAPEN0_WIDTH               1u\r\n#define FTM_COMBINE_DECAPEN0(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAPEN0_SHIFT))&FTM_COMBINE_DECAPEN0_MASK)\r\n#define FTM_COMBINE_DECAP0_MASK                  0x8u\r\n#define FTM_COMBINE_DECAP0_SHIFT                 3u\r\n#define FTM_COMBINE_DECAP0_WIDTH                 1u\r\n#define FTM_COMBINE_DECAP0(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAP0_SHIFT))&FTM_COMBINE_DECAP0_MASK)\r\n#define FTM_COMBINE_DTEN0_MASK                   0x10u\r\n#define FTM_COMBINE_DTEN0_SHIFT                  4u\r\n#define FTM_COMBINE_DTEN0_WIDTH                  1u\r\n#define FTM_COMBINE_DTEN0(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DTEN0_SHIFT))&FTM_COMBINE_DTEN0_MASK)\r\n#define FTM_COMBINE_SYNCEN0_MASK                 0x20u\r\n#define FTM_COMBINE_SYNCEN0_SHIFT                5u\r\n#define FTM_COMBINE_SYNCEN0_WIDTH                1u\r\n#define FTM_COMBINE_SYNCEN0(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_SYNCEN0_SHIFT))&FTM_COMBINE_SYNCEN0_MASK)\r\n#define FTM_COMBINE_FAULTEN0_MASK                0x40u\r\n#define FTM_COMBINE_FAULTEN0_SHIFT               6u\r\n#define FTM_COMBINE_FAULTEN0_WIDTH               1u\r\n#define FTM_COMBINE_FAULTEN0(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_FAULTEN0_SHIFT))&FTM_COMBINE_FAULTEN0_MASK)\r\n#define FTM_COMBINE_MCOMBINE0_MASK               0x80u\r\n#define FTM_COMBINE_MCOMBINE0_SHIFT              7u\r\n#define FTM_COMBINE_MCOMBINE0_WIDTH              1u\r\n#define FTM_COMBINE_MCOMBINE0(x)                 (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_MCOMBINE0_SHIFT))&FTM_COMBINE_MCOMBINE0_MASK)\r\n#define FTM_COMBINE_COMBINE1_MASK                0x100u\r\n#define FTM_COMBINE_COMBINE1_SHIFT               8u\r\n#define FTM_COMBINE_COMBINE1_WIDTH               1u\r\n#define FTM_COMBINE_COMBINE1(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMBINE1_SHIFT))&FTM_COMBINE_COMBINE1_MASK)\r\n#define FTM_COMBINE_COMP1_MASK                   0x200u\r\n#define FTM_COMBINE_COMP1_SHIFT                  9u\r\n#define FTM_COMBINE_COMP1_WIDTH                  1u\r\n#define FTM_COMBINE_COMP1(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMP1_SHIFT))&FTM_COMBINE_COMP1_MASK)\r\n#define FTM_COMBINE_DECAPEN1_MASK                0x400u\r\n#define FTM_COMBINE_DECAPEN1_SHIFT               10u\r\n#define FTM_COMBINE_DECAPEN1_WIDTH               1u\r\n#define FTM_COMBINE_DECAPEN1(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAPEN1_SHIFT))&FTM_COMBINE_DECAPEN1_MASK)\r\n#define FTM_COMBINE_DECAP1_MASK                  0x800u\r\n#define FTM_COMBINE_DECAP1_SHIFT                 11u\r\n#define FTM_COMBINE_DECAP1_WIDTH                 1u\r\n#define FTM_COMBINE_DECAP1(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAP1_SHIFT))&FTM_COMBINE_DECAP1_MASK)\r\n#define FTM_COMBINE_DTEN1_MASK                   0x1000u\r\n#define FTM_COMBINE_DTEN1_SHIFT                  12u\r\n#define FTM_COMBINE_DTEN1_WIDTH                  1u\r\n#define FTM_COMBINE_DTEN1(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DTEN1_SHIFT))&FTM_COMBINE_DTEN1_MASK)\r\n#define FTM_COMBINE_SYNCEN1_MASK                 0x2000u\r\n#define FTM_COMBINE_SYNCEN1_SHIFT                13u\r\n#define FTM_COMBINE_SYNCEN1_WIDTH                1u\r\n#define FTM_COMBINE_SYNCEN1(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_SYNCEN1_SHIFT))&FTM_COMBINE_SYNCEN1_MASK)\r\n#define FTM_COMBINE_FAULTEN1_MASK                0x4000u\r\n#define FTM_COMBINE_FAULTEN1_SHIFT               14u\r\n#define FTM_COMBINE_FAULTEN1_WIDTH               1u\r\n#define FTM_COMBINE_FAULTEN1(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_FAULTEN1_SHIFT))&FTM_COMBINE_FAULTEN1_MASK)\r\n#define FTM_COMBINE_MCOMBINE1_MASK               0x8000u\r\n#define FTM_COMBINE_MCOMBINE1_SHIFT              15u\r\n#define FTM_COMBINE_MCOMBINE1_WIDTH              1u\r\n#define FTM_COMBINE_MCOMBINE1(x)                 (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_MCOMBINE1_SHIFT))&FTM_COMBINE_MCOMBINE1_MASK)\r\n#define FTM_COMBINE_COMBINE2_MASK                0x10000u\r\n#define FTM_COMBINE_COMBINE2_SHIFT               16u\r\n#define FTM_COMBINE_COMBINE2_WIDTH               1u\r\n#define FTM_COMBINE_COMBINE2(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMBINE2_SHIFT))&FTM_COMBINE_COMBINE2_MASK)\r\n#define FTM_COMBINE_COMP2_MASK                   0x20000u\r\n#define FTM_COMBINE_COMP2_SHIFT                  17u\r\n#define FTM_COMBINE_COMP2_WIDTH                  1u\r\n#define FTM_COMBINE_COMP2(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMP2_SHIFT))&FTM_COMBINE_COMP2_MASK)\r\n#define FTM_COMBINE_DECAPEN2_MASK                0x40000u\r\n#define FTM_COMBINE_DECAPEN2_SHIFT               18u\r\n#define FTM_COMBINE_DECAPEN2_WIDTH               1u\r\n#define FTM_COMBINE_DECAPEN2(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAPEN2_SHIFT))&FTM_COMBINE_DECAPEN2_MASK)\r\n#define FTM_COMBINE_DECAP2_MASK                  0x80000u\r\n#define FTM_COMBINE_DECAP2_SHIFT                 19u\r\n#define FTM_COMBINE_DECAP2_WIDTH                 1u\r\n#define FTM_COMBINE_DECAP2(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAP2_SHIFT))&FTM_COMBINE_DECAP2_MASK)\r\n#define FTM_COMBINE_DTEN2_MASK                   0x100000u\r\n#define FTM_COMBINE_DTEN2_SHIFT                  20u\r\n#define FTM_COMBINE_DTEN2_WIDTH                  1u\r\n#define FTM_COMBINE_DTEN2(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DTEN2_SHIFT))&FTM_COMBINE_DTEN2_MASK)\r\n#define FTM_COMBINE_SYNCEN2_MASK                 0x200000u\r\n#define FTM_COMBINE_SYNCEN2_SHIFT                21u\r\n#define FTM_COMBINE_SYNCEN2_WIDTH                1u\r\n#define FTM_COMBINE_SYNCEN2(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_SYNCEN2_SHIFT))&FTM_COMBINE_SYNCEN2_MASK)\r\n#define FTM_COMBINE_FAULTEN2_MASK                0x400000u\r\n#define FTM_COMBINE_FAULTEN2_SHIFT               22u\r\n#define FTM_COMBINE_FAULTEN2_WIDTH               1u\r\n#define FTM_COMBINE_FAULTEN2(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_FAULTEN2_SHIFT))&FTM_COMBINE_FAULTEN2_MASK)\r\n#define FTM_COMBINE_MCOMBINE2_MASK               0x800000u\r\n#define FTM_COMBINE_MCOMBINE2_SHIFT              23u\r\n#define FTM_COMBINE_MCOMBINE2_WIDTH              1u\r\n#define FTM_COMBINE_MCOMBINE2(x)                 (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_MCOMBINE2_SHIFT))&FTM_COMBINE_MCOMBINE2_MASK)\r\n#define FTM_COMBINE_COMBINE3_MASK                0x1000000u\r\n#define FTM_COMBINE_COMBINE3_SHIFT               24u\r\n#define FTM_COMBINE_COMBINE3_WIDTH               1u\r\n#define FTM_COMBINE_COMBINE3(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMBINE3_SHIFT))&FTM_COMBINE_COMBINE3_MASK)\r\n#define FTM_COMBINE_COMP3_MASK                   0x2000000u\r\n#define FTM_COMBINE_COMP3_SHIFT                  25u\r\n#define FTM_COMBINE_COMP3_WIDTH                  1u\r\n#define FTM_COMBINE_COMP3(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_COMP3_SHIFT))&FTM_COMBINE_COMP3_MASK)\r\n#define FTM_COMBINE_DECAPEN3_MASK                0x4000000u\r\n#define FTM_COMBINE_DECAPEN3_SHIFT               26u\r\n#define FTM_COMBINE_DECAPEN3_WIDTH               1u\r\n#define FTM_COMBINE_DECAPEN3(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAPEN3_SHIFT))&FTM_COMBINE_DECAPEN3_MASK)\r\n#define FTM_COMBINE_DECAP3_MASK                  0x8000000u\r\n#define FTM_COMBINE_DECAP3_SHIFT                 27u\r\n#define FTM_COMBINE_DECAP3_WIDTH                 1u\r\n#define FTM_COMBINE_DECAP3(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DECAP3_SHIFT))&FTM_COMBINE_DECAP3_MASK)\r\n#define FTM_COMBINE_DTEN3_MASK                   0x10000000u\r\n#define FTM_COMBINE_DTEN3_SHIFT                  28u\r\n#define FTM_COMBINE_DTEN3_WIDTH                  1u\r\n#define FTM_COMBINE_DTEN3(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_DTEN3_SHIFT))&FTM_COMBINE_DTEN3_MASK)\r\n#define FTM_COMBINE_SYNCEN3_MASK                 0x20000000u\r\n#define FTM_COMBINE_SYNCEN3_SHIFT                29u\r\n#define FTM_COMBINE_SYNCEN3_WIDTH                1u\r\n#define FTM_COMBINE_SYNCEN3(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_SYNCEN3_SHIFT))&FTM_COMBINE_SYNCEN3_MASK)\r\n#define FTM_COMBINE_FAULTEN3_MASK                0x40000000u\r\n#define FTM_COMBINE_FAULTEN3_SHIFT               30u\r\n#define FTM_COMBINE_FAULTEN3_WIDTH               1u\r\n#define FTM_COMBINE_FAULTEN3(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_FAULTEN3_SHIFT))&FTM_COMBINE_FAULTEN3_MASK)\r\n#define FTM_COMBINE_MCOMBINE3_MASK               0x80000000u\r\n#define FTM_COMBINE_MCOMBINE3_SHIFT              31u\r\n#define FTM_COMBINE_MCOMBINE3_WIDTH              1u\r\n#define FTM_COMBINE_MCOMBINE3(x)                 (((uint32_t)(((uint32_t)(x))<<FTM_COMBINE_MCOMBINE3_SHIFT))&FTM_COMBINE_MCOMBINE3_MASK)\r\n/* DEADTIME Bit Fields */\r\n#define FTM_DEADTIME_DTVAL_MASK                  0x3Fu\r\n#define FTM_DEADTIME_DTVAL_SHIFT                 0u\r\n#define FTM_DEADTIME_DTVAL_WIDTH                 6u\r\n#define FTM_DEADTIME_DTVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_DEADTIME_DTVAL_SHIFT))&FTM_DEADTIME_DTVAL_MASK)\r\n#define FTM_DEADTIME_DTPS_MASK                   0xC0u\r\n#define FTM_DEADTIME_DTPS_SHIFT                  6u\r\n#define FTM_DEADTIME_DTPS_WIDTH                  2u\r\n#define FTM_DEADTIME_DTPS(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_DEADTIME_DTPS_SHIFT))&FTM_DEADTIME_DTPS_MASK)\r\n#define FTM_DEADTIME_DTVALEX_MASK                0xF0000u\r\n#define FTM_DEADTIME_DTVALEX_SHIFT               16u\r\n#define FTM_DEADTIME_DTVALEX_WIDTH               4u\r\n#define FTM_DEADTIME_DTVALEX(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_DEADTIME_DTVALEX_SHIFT))&FTM_DEADTIME_DTVALEX_MASK)\r\n/* EXTTRIG Bit Fields */\r\n#define FTM_EXTTRIG_CH2TRIG_MASK                 0x1u\r\n#define FTM_EXTTRIG_CH2TRIG_SHIFT                0u\r\n#define FTM_EXTTRIG_CH2TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH2TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH2TRIG_SHIFT))&FTM_EXTTRIG_CH2TRIG_MASK)\r\n#define FTM_EXTTRIG_CH3TRIG_MASK                 0x2u\r\n#define FTM_EXTTRIG_CH3TRIG_SHIFT                1u\r\n#define FTM_EXTTRIG_CH3TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH3TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH3TRIG_SHIFT))&FTM_EXTTRIG_CH3TRIG_MASK)\r\n#define FTM_EXTTRIG_CH4TRIG_MASK                 0x4u\r\n#define FTM_EXTTRIG_CH4TRIG_SHIFT                2u\r\n#define FTM_EXTTRIG_CH4TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH4TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH4TRIG_SHIFT))&FTM_EXTTRIG_CH4TRIG_MASK)\r\n#define FTM_EXTTRIG_CH5TRIG_MASK                 0x8u\r\n#define FTM_EXTTRIG_CH5TRIG_SHIFT                3u\r\n#define FTM_EXTTRIG_CH5TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH5TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH5TRIG_SHIFT))&FTM_EXTTRIG_CH5TRIG_MASK)\r\n#define FTM_EXTTRIG_CH0TRIG_MASK                 0x10u\r\n#define FTM_EXTTRIG_CH0TRIG_SHIFT                4u\r\n#define FTM_EXTTRIG_CH0TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH0TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH0TRIG_SHIFT))&FTM_EXTTRIG_CH0TRIG_MASK)\r\n#define FTM_EXTTRIG_CH1TRIG_MASK                 0x20u\r\n#define FTM_EXTTRIG_CH1TRIG_SHIFT                5u\r\n#define FTM_EXTTRIG_CH1TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH1TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH1TRIG_SHIFT))&FTM_EXTTRIG_CH1TRIG_MASK)\r\n#define FTM_EXTTRIG_INITTRIGEN_MASK              0x40u\r\n#define FTM_EXTTRIG_INITTRIGEN_SHIFT             6u\r\n#define FTM_EXTTRIG_INITTRIGEN_WIDTH             1u\r\n#define FTM_EXTTRIG_INITTRIGEN(x)                (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_INITTRIGEN_SHIFT))&FTM_EXTTRIG_INITTRIGEN_MASK)\r\n#define FTM_EXTTRIG_TRIGF_MASK                   0x80u\r\n#define FTM_EXTTRIG_TRIGF_SHIFT                  7u\r\n#define FTM_EXTTRIG_TRIGF_WIDTH                  1u\r\n#define FTM_EXTTRIG_TRIGF(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_TRIGF_SHIFT))&FTM_EXTTRIG_TRIGF_MASK)\r\n#define FTM_EXTTRIG_CH6TRIG_MASK                 0x100u\r\n#define FTM_EXTTRIG_CH6TRIG_SHIFT                8u\r\n#define FTM_EXTTRIG_CH6TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH6TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH6TRIG_SHIFT))&FTM_EXTTRIG_CH6TRIG_MASK)\r\n#define FTM_EXTTRIG_CH7TRIG_MASK                 0x200u\r\n#define FTM_EXTTRIG_CH7TRIG_SHIFT                9u\r\n#define FTM_EXTTRIG_CH7TRIG_WIDTH                1u\r\n#define FTM_EXTTRIG_CH7TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_EXTTRIG_CH7TRIG_SHIFT))&FTM_EXTTRIG_CH7TRIG_MASK)\r\n/* POL Bit Fields */\r\n#define FTM_POL_POL0_MASK                        0x1u\r\n#define FTM_POL_POL0_SHIFT                       0u\r\n#define FTM_POL_POL0_WIDTH                       1u\r\n#define FTM_POL_POL0(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL0_SHIFT))&FTM_POL_POL0_MASK)\r\n#define FTM_POL_POL1_MASK                        0x2u\r\n#define FTM_POL_POL1_SHIFT                       1u\r\n#define FTM_POL_POL1_WIDTH                       1u\r\n#define FTM_POL_POL1(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL1_SHIFT))&FTM_POL_POL1_MASK)\r\n#define FTM_POL_POL2_MASK                        0x4u\r\n#define FTM_POL_POL2_SHIFT                       2u\r\n#define FTM_POL_POL2_WIDTH                       1u\r\n#define FTM_POL_POL2(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL2_SHIFT))&FTM_POL_POL2_MASK)\r\n#define FTM_POL_POL3_MASK                        0x8u\r\n#define FTM_POL_POL3_SHIFT                       3u\r\n#define FTM_POL_POL3_WIDTH                       1u\r\n#define FTM_POL_POL3(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL3_SHIFT))&FTM_POL_POL3_MASK)\r\n#define FTM_POL_POL4_MASK                        0x10u\r\n#define FTM_POL_POL4_SHIFT                       4u\r\n#define FTM_POL_POL4_WIDTH                       1u\r\n#define FTM_POL_POL4(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL4_SHIFT))&FTM_POL_POL4_MASK)\r\n#define FTM_POL_POL5_MASK                        0x20u\r\n#define FTM_POL_POL5_SHIFT                       5u\r\n#define FTM_POL_POL5_WIDTH                       1u\r\n#define FTM_POL_POL5(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL5_SHIFT))&FTM_POL_POL5_MASK)\r\n#define FTM_POL_POL6_MASK                        0x40u\r\n#define FTM_POL_POL6_SHIFT                       6u\r\n#define FTM_POL_POL6_WIDTH                       1u\r\n#define FTM_POL_POL6(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL6_SHIFT))&FTM_POL_POL6_MASK)\r\n#define FTM_POL_POL7_MASK                        0x80u\r\n#define FTM_POL_POL7_SHIFT                       7u\r\n#define FTM_POL_POL7_WIDTH                       1u\r\n#define FTM_POL_POL7(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_POL_POL7_SHIFT))&FTM_POL_POL7_MASK)\r\n/* FMS Bit Fields */\r\n#define FTM_FMS_FAULTF0_MASK                     0x1u\r\n#define FTM_FMS_FAULTF0_SHIFT                    0u\r\n#define FTM_FMS_FAULTF0_WIDTH                    1u\r\n#define FTM_FMS_FAULTF0(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_FMS_FAULTF0_SHIFT))&FTM_FMS_FAULTF0_MASK)\r\n#define FTM_FMS_FAULTF1_MASK                     0x2u\r\n#define FTM_FMS_FAULTF1_SHIFT                    1u\r\n#define FTM_FMS_FAULTF1_WIDTH                    1u\r\n#define FTM_FMS_FAULTF1(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_FMS_FAULTF1_SHIFT))&FTM_FMS_FAULTF1_MASK)\r\n#define FTM_FMS_FAULTF2_MASK                     0x4u\r\n#define FTM_FMS_FAULTF2_SHIFT                    2u\r\n#define FTM_FMS_FAULTF2_WIDTH                    1u\r\n#define FTM_FMS_FAULTF2(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_FMS_FAULTF2_SHIFT))&FTM_FMS_FAULTF2_MASK)\r\n#define FTM_FMS_FAULTF3_MASK                     0x8u\r\n#define FTM_FMS_FAULTF3_SHIFT                    3u\r\n#define FTM_FMS_FAULTF3_WIDTH                    1u\r\n#define FTM_FMS_FAULTF3(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_FMS_FAULTF3_SHIFT))&FTM_FMS_FAULTF3_MASK)\r\n#define FTM_FMS_FAULTIN_MASK                     0x20u\r\n#define FTM_FMS_FAULTIN_SHIFT                    5u\r\n#define FTM_FMS_FAULTIN_WIDTH                    1u\r\n#define FTM_FMS_FAULTIN(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_FMS_FAULTIN_SHIFT))&FTM_FMS_FAULTIN_MASK)\r\n#define FTM_FMS_WPEN_MASK                        0x40u\r\n#define FTM_FMS_WPEN_SHIFT                       6u\r\n#define FTM_FMS_WPEN_WIDTH                       1u\r\n#define FTM_FMS_WPEN(x)                          (((uint32_t)(((uint32_t)(x))<<FTM_FMS_WPEN_SHIFT))&FTM_FMS_WPEN_MASK)\r\n#define FTM_FMS_FAULTF_MASK                      0x80u\r\n#define FTM_FMS_FAULTF_SHIFT                     7u\r\n#define FTM_FMS_FAULTF_WIDTH                     1u\r\n#define FTM_FMS_FAULTF(x)                        (((uint32_t)(((uint32_t)(x))<<FTM_FMS_FAULTF_SHIFT))&FTM_FMS_FAULTF_MASK)\r\n/* FILTER Bit Fields */\r\n#define FTM_FILTER_CH0FVAL_MASK                  0xFu\r\n#define FTM_FILTER_CH0FVAL_SHIFT                 0u\r\n#define FTM_FILTER_CH0FVAL_WIDTH                 4u\r\n#define FTM_FILTER_CH0FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH0FVAL_SHIFT))&FTM_FILTER_CH0FVAL_MASK)\r\n#define FTM_FILTER_CH1FVAL_MASK                  0xF0u\r\n#define FTM_FILTER_CH1FVAL_SHIFT                 4u\r\n#define FTM_FILTER_CH1FVAL_WIDTH                 4u\r\n#define FTM_FILTER_CH1FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH1FVAL_SHIFT))&FTM_FILTER_CH1FVAL_MASK)\r\n#define FTM_FILTER_CH2FVAL_MASK                  0xF00u\r\n#define FTM_FILTER_CH2FVAL_SHIFT                 8u\r\n#define FTM_FILTER_CH2FVAL_WIDTH                 4u\r\n#define FTM_FILTER_CH2FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH2FVAL_SHIFT))&FTM_FILTER_CH2FVAL_MASK)\r\n#define FTM_FILTER_CH3FVAL_MASK                  0xF000u\r\n#define FTM_FILTER_CH3FVAL_SHIFT                 12u\r\n#define FTM_FILTER_CH3FVAL_WIDTH                 4u\r\n#define FTM_FILTER_CH3FVAL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FILTER_CH3FVAL_SHIFT))&FTM_FILTER_CH3FVAL_MASK)\r\n/* FLTCTRL Bit Fields */\r\n#define FTM_FLTCTRL_FAULT0EN_MASK                0x1u\r\n#define FTM_FLTCTRL_FAULT0EN_SHIFT               0u\r\n#define FTM_FLTCTRL_FAULT0EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FAULT0EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FAULT0EN_SHIFT))&FTM_FLTCTRL_FAULT0EN_MASK)\r\n#define FTM_FLTCTRL_FAULT1EN_MASK                0x2u\r\n#define FTM_FLTCTRL_FAULT1EN_SHIFT               1u\r\n#define FTM_FLTCTRL_FAULT1EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FAULT1EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FAULT1EN_SHIFT))&FTM_FLTCTRL_FAULT1EN_MASK)\r\n#define FTM_FLTCTRL_FAULT2EN_MASK                0x4u\r\n#define FTM_FLTCTRL_FAULT2EN_SHIFT               2u\r\n#define FTM_FLTCTRL_FAULT2EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FAULT2EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FAULT2EN_SHIFT))&FTM_FLTCTRL_FAULT2EN_MASK)\r\n#define FTM_FLTCTRL_FAULT3EN_MASK                0x8u\r\n#define FTM_FLTCTRL_FAULT3EN_SHIFT               3u\r\n#define FTM_FLTCTRL_FAULT3EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FAULT3EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FAULT3EN_SHIFT))&FTM_FLTCTRL_FAULT3EN_MASK)\r\n#define FTM_FLTCTRL_FFLTR0EN_MASK                0x10u\r\n#define FTM_FLTCTRL_FFLTR0EN_SHIFT               4u\r\n#define FTM_FLTCTRL_FFLTR0EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FFLTR0EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FFLTR0EN_SHIFT))&FTM_FLTCTRL_FFLTR0EN_MASK)\r\n#define FTM_FLTCTRL_FFLTR1EN_MASK                0x20u\r\n#define FTM_FLTCTRL_FFLTR1EN_SHIFT               5u\r\n#define FTM_FLTCTRL_FFLTR1EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FFLTR1EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FFLTR1EN_SHIFT))&FTM_FLTCTRL_FFLTR1EN_MASK)\r\n#define FTM_FLTCTRL_FFLTR2EN_MASK                0x40u\r\n#define FTM_FLTCTRL_FFLTR2EN_SHIFT               6u\r\n#define FTM_FLTCTRL_FFLTR2EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FFLTR2EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FFLTR2EN_SHIFT))&FTM_FLTCTRL_FFLTR2EN_MASK)\r\n#define FTM_FLTCTRL_FFLTR3EN_MASK                0x80u\r\n#define FTM_FLTCTRL_FFLTR3EN_SHIFT               7u\r\n#define FTM_FLTCTRL_FFLTR3EN_WIDTH               1u\r\n#define FTM_FLTCTRL_FFLTR3EN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FFLTR3EN_SHIFT))&FTM_FLTCTRL_FFLTR3EN_MASK)\r\n#define FTM_FLTCTRL_FFVAL_MASK                   0xF00u\r\n#define FTM_FLTCTRL_FFVAL_SHIFT                  8u\r\n#define FTM_FLTCTRL_FFVAL_WIDTH                  4u\r\n#define FTM_FLTCTRL_FFVAL(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FFVAL_SHIFT))&FTM_FLTCTRL_FFVAL_MASK)\r\n#define FTM_FLTCTRL_FSTATE_MASK                  0x8000u\r\n#define FTM_FLTCTRL_FSTATE_SHIFT                 15u\r\n#define FTM_FLTCTRL_FSTATE_WIDTH                 1u\r\n#define FTM_FLTCTRL_FSTATE(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FLTCTRL_FSTATE_SHIFT))&FTM_FLTCTRL_FSTATE_MASK)\r\n/* QDCTRL Bit Fields */\r\n#define FTM_QDCTRL_QUADEN_MASK                   0x1u\r\n#define FTM_QDCTRL_QUADEN_SHIFT                  0u\r\n#define FTM_QDCTRL_QUADEN_WIDTH                  1u\r\n#define FTM_QDCTRL_QUADEN(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_QUADEN_SHIFT))&FTM_QDCTRL_QUADEN_MASK)\r\n#define FTM_QDCTRL_TOFDIR_MASK                   0x2u\r\n#define FTM_QDCTRL_TOFDIR_SHIFT                  1u\r\n#define FTM_QDCTRL_TOFDIR_WIDTH                  1u\r\n#define FTM_QDCTRL_TOFDIR(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_TOFDIR_SHIFT))&FTM_QDCTRL_TOFDIR_MASK)\r\n#define FTM_QDCTRL_QUADIR_MASK                   0x4u\r\n#define FTM_QDCTRL_QUADIR_SHIFT                  2u\r\n#define FTM_QDCTRL_QUADIR_WIDTH                  1u\r\n#define FTM_QDCTRL_QUADIR(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_QUADIR_SHIFT))&FTM_QDCTRL_QUADIR_MASK)\r\n#define FTM_QDCTRL_QUADMODE_MASK                 0x8u\r\n#define FTM_QDCTRL_QUADMODE_SHIFT                3u\r\n#define FTM_QDCTRL_QUADMODE_WIDTH                1u\r\n#define FTM_QDCTRL_QUADMODE(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_QUADMODE_SHIFT))&FTM_QDCTRL_QUADMODE_MASK)\r\n#define FTM_QDCTRL_PHBPOL_MASK                   0x10u\r\n#define FTM_QDCTRL_PHBPOL_SHIFT                  4u\r\n#define FTM_QDCTRL_PHBPOL_WIDTH                  1u\r\n#define FTM_QDCTRL_PHBPOL(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_PHBPOL_SHIFT))&FTM_QDCTRL_PHBPOL_MASK)\r\n#define FTM_QDCTRL_PHAPOL_MASK                   0x20u\r\n#define FTM_QDCTRL_PHAPOL_SHIFT                  5u\r\n#define FTM_QDCTRL_PHAPOL_WIDTH                  1u\r\n#define FTM_QDCTRL_PHAPOL(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_PHAPOL_SHIFT))&FTM_QDCTRL_PHAPOL_MASK)\r\n#define FTM_QDCTRL_PHBFLTREN_MASK                0x40u\r\n#define FTM_QDCTRL_PHBFLTREN_SHIFT               6u\r\n#define FTM_QDCTRL_PHBFLTREN_WIDTH               1u\r\n#define FTM_QDCTRL_PHBFLTREN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_PHBFLTREN_SHIFT))&FTM_QDCTRL_PHBFLTREN_MASK)\r\n#define FTM_QDCTRL_PHAFLTREN_MASK                0x80u\r\n#define FTM_QDCTRL_PHAFLTREN_SHIFT               7u\r\n#define FTM_QDCTRL_PHAFLTREN_WIDTH               1u\r\n#define FTM_QDCTRL_PHAFLTREN(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_QDCTRL_PHAFLTREN_SHIFT))&FTM_QDCTRL_PHAFLTREN_MASK)\r\n/* CONF Bit Fields */\r\n#define FTM_CONF_LDFQ_MASK                       0x1Fu\r\n#define FTM_CONF_LDFQ_SHIFT                      0u\r\n#define FTM_CONF_LDFQ_WIDTH                      5u\r\n#define FTM_CONF_LDFQ(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_CONF_LDFQ_SHIFT))&FTM_CONF_LDFQ_MASK)\r\n#define FTM_CONF_BDMMODE_MASK                    0xC0u\r\n#define FTM_CONF_BDMMODE_SHIFT                   6u\r\n#define FTM_CONF_BDMMODE_WIDTH                   2u\r\n#define FTM_CONF_BDMMODE(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_CONF_BDMMODE_SHIFT))&FTM_CONF_BDMMODE_MASK)\r\n#define FTM_CONF_GTBEEN_MASK                     0x200u\r\n#define FTM_CONF_GTBEEN_SHIFT                    9u\r\n#define FTM_CONF_GTBEEN_WIDTH                    1u\r\n#define FTM_CONF_GTBEEN(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_CONF_GTBEEN_SHIFT))&FTM_CONF_GTBEEN_MASK)\r\n#define FTM_CONF_GTBEOUT_MASK                    0x400u\r\n#define FTM_CONF_GTBEOUT_SHIFT                   10u\r\n#define FTM_CONF_GTBEOUT_WIDTH                   1u\r\n#define FTM_CONF_GTBEOUT(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_CONF_GTBEOUT_SHIFT))&FTM_CONF_GTBEOUT_MASK)\r\n#define FTM_CONF_ITRIGR_MASK                     0x800u\r\n#define FTM_CONF_ITRIGR_SHIFT                    11u\r\n#define FTM_CONF_ITRIGR_WIDTH                    1u\r\n#define FTM_CONF_ITRIGR(x)                       (((uint32_t)(((uint32_t)(x))<<FTM_CONF_ITRIGR_SHIFT))&FTM_CONF_ITRIGR_MASK)\r\n/* FLTPOL Bit Fields */\r\n#define FTM_FLTPOL_FLT0POL_MASK                  0x1u\r\n#define FTM_FLTPOL_FLT0POL_SHIFT                 0u\r\n#define FTM_FLTPOL_FLT0POL_WIDTH                 1u\r\n#define FTM_FLTPOL_FLT0POL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FLTPOL_FLT0POL_SHIFT))&FTM_FLTPOL_FLT0POL_MASK)\r\n#define FTM_FLTPOL_FLT1POL_MASK                  0x2u\r\n#define FTM_FLTPOL_FLT1POL_SHIFT                 1u\r\n#define FTM_FLTPOL_FLT1POL_WIDTH                 1u\r\n#define FTM_FLTPOL_FLT1POL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FLTPOL_FLT1POL_SHIFT))&FTM_FLTPOL_FLT1POL_MASK)\r\n#define FTM_FLTPOL_FLT2POL_MASK                  0x4u\r\n#define FTM_FLTPOL_FLT2POL_SHIFT                 2u\r\n#define FTM_FLTPOL_FLT2POL_WIDTH                 1u\r\n#define FTM_FLTPOL_FLT2POL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FLTPOL_FLT2POL_SHIFT))&FTM_FLTPOL_FLT2POL_MASK)\r\n#define FTM_FLTPOL_FLT3POL_MASK                  0x8u\r\n#define FTM_FLTPOL_FLT3POL_SHIFT                 3u\r\n#define FTM_FLTPOL_FLT3POL_WIDTH                 1u\r\n#define FTM_FLTPOL_FLT3POL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_FLTPOL_FLT3POL_SHIFT))&FTM_FLTPOL_FLT3POL_MASK)\r\n/* SYNCONF Bit Fields */\r\n#define FTM_SYNCONF_HWTRIGMODE_MASK              0x1u\r\n#define FTM_SYNCONF_HWTRIGMODE_SHIFT             0u\r\n#define FTM_SYNCONF_HWTRIGMODE_WIDTH             1u\r\n#define FTM_SYNCONF_HWTRIGMODE(x)                (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_HWTRIGMODE_SHIFT))&FTM_SYNCONF_HWTRIGMODE_MASK)\r\n#define FTM_SYNCONF_CNTINC_MASK                  0x4u\r\n#define FTM_SYNCONF_CNTINC_SHIFT                 2u\r\n#define FTM_SYNCONF_CNTINC_WIDTH                 1u\r\n#define FTM_SYNCONF_CNTINC(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_CNTINC_SHIFT))&FTM_SYNCONF_CNTINC_MASK)\r\n#define FTM_SYNCONF_INVC_MASK                    0x10u\r\n#define FTM_SYNCONF_INVC_SHIFT                   4u\r\n#define FTM_SYNCONF_INVC_WIDTH                   1u\r\n#define FTM_SYNCONF_INVC(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_INVC_SHIFT))&FTM_SYNCONF_INVC_MASK)\r\n#define FTM_SYNCONF_SWOC_MASK                    0x20u\r\n#define FTM_SYNCONF_SWOC_SHIFT                   5u\r\n#define FTM_SYNCONF_SWOC_WIDTH                   1u\r\n#define FTM_SYNCONF_SWOC(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SWOC_SHIFT))&FTM_SYNCONF_SWOC_MASK)\r\n#define FTM_SYNCONF_SYNCMODE_MASK                0x80u\r\n#define FTM_SYNCONF_SYNCMODE_SHIFT               7u\r\n#define FTM_SYNCONF_SYNCMODE_WIDTH               1u\r\n#define FTM_SYNCONF_SYNCMODE(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SYNCMODE_SHIFT))&FTM_SYNCONF_SYNCMODE_MASK)\r\n#define FTM_SYNCONF_SWRSTCNT_MASK                0x100u\r\n#define FTM_SYNCONF_SWRSTCNT_SHIFT               8u\r\n#define FTM_SYNCONF_SWRSTCNT_WIDTH               1u\r\n#define FTM_SYNCONF_SWRSTCNT(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SWRSTCNT_SHIFT))&FTM_SYNCONF_SWRSTCNT_MASK)\r\n#define FTM_SYNCONF_SWWRBUF_MASK                 0x200u\r\n#define FTM_SYNCONF_SWWRBUF_SHIFT                9u\r\n#define FTM_SYNCONF_SWWRBUF_WIDTH                1u\r\n#define FTM_SYNCONF_SWWRBUF(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SWWRBUF_SHIFT))&FTM_SYNCONF_SWWRBUF_MASK)\r\n#define FTM_SYNCONF_SWOM_MASK                    0x400u\r\n#define FTM_SYNCONF_SWOM_SHIFT                   10u\r\n#define FTM_SYNCONF_SWOM_WIDTH                   1u\r\n#define FTM_SYNCONF_SWOM(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SWOM_SHIFT))&FTM_SYNCONF_SWOM_MASK)\r\n#define FTM_SYNCONF_SWINVC_MASK                  0x800u\r\n#define FTM_SYNCONF_SWINVC_SHIFT                 11u\r\n#define FTM_SYNCONF_SWINVC_WIDTH                 1u\r\n#define FTM_SYNCONF_SWINVC(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SWINVC_SHIFT))&FTM_SYNCONF_SWINVC_MASK)\r\n#define FTM_SYNCONF_SWSOC_MASK                   0x1000u\r\n#define FTM_SYNCONF_SWSOC_SHIFT                  12u\r\n#define FTM_SYNCONF_SWSOC_WIDTH                  1u\r\n#define FTM_SYNCONF_SWSOC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_SWSOC_SHIFT))&FTM_SYNCONF_SWSOC_MASK)\r\n#define FTM_SYNCONF_HWRSTCNT_MASK                0x10000u\r\n#define FTM_SYNCONF_HWRSTCNT_SHIFT               16u\r\n#define FTM_SYNCONF_HWRSTCNT_WIDTH               1u\r\n#define FTM_SYNCONF_HWRSTCNT(x)                  (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_HWRSTCNT_SHIFT))&FTM_SYNCONF_HWRSTCNT_MASK)\r\n#define FTM_SYNCONF_HWWRBUF_MASK                 0x20000u\r\n#define FTM_SYNCONF_HWWRBUF_SHIFT                17u\r\n#define FTM_SYNCONF_HWWRBUF_WIDTH                1u\r\n#define FTM_SYNCONF_HWWRBUF(x)                   (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_HWWRBUF_SHIFT))&FTM_SYNCONF_HWWRBUF_MASK)\r\n#define FTM_SYNCONF_HWOM_MASK                    0x40000u\r\n#define FTM_SYNCONF_HWOM_SHIFT                   18u\r\n#define FTM_SYNCONF_HWOM_WIDTH                   1u\r\n#define FTM_SYNCONF_HWOM(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_HWOM_SHIFT))&FTM_SYNCONF_HWOM_MASK)\r\n#define FTM_SYNCONF_HWINVC_MASK                  0x80000u\r\n#define FTM_SYNCONF_HWINVC_SHIFT                 19u\r\n#define FTM_SYNCONF_HWINVC_WIDTH                 1u\r\n#define FTM_SYNCONF_HWINVC(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_HWINVC_SHIFT))&FTM_SYNCONF_HWINVC_MASK)\r\n#define FTM_SYNCONF_HWSOC_MASK                   0x100000u\r\n#define FTM_SYNCONF_HWSOC_SHIFT                  20u\r\n#define FTM_SYNCONF_HWSOC_WIDTH                  1u\r\n#define FTM_SYNCONF_HWSOC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SYNCONF_HWSOC_SHIFT))&FTM_SYNCONF_HWSOC_MASK)\r\n/* INVCTRL Bit Fields */\r\n#define FTM_INVCTRL_INV0EN_MASK                  0x1u\r\n#define FTM_INVCTRL_INV0EN_SHIFT                 0u\r\n#define FTM_INVCTRL_INV0EN_WIDTH                 1u\r\n#define FTM_INVCTRL_INV0EN(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_INVCTRL_INV0EN_SHIFT))&FTM_INVCTRL_INV0EN_MASK)\r\n#define FTM_INVCTRL_INV1EN_MASK                  0x2u\r\n#define FTM_INVCTRL_INV1EN_SHIFT                 1u\r\n#define FTM_INVCTRL_INV1EN_WIDTH                 1u\r\n#define FTM_INVCTRL_INV1EN(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_INVCTRL_INV1EN_SHIFT))&FTM_INVCTRL_INV1EN_MASK)\r\n#define FTM_INVCTRL_INV2EN_MASK                  0x4u\r\n#define FTM_INVCTRL_INV2EN_SHIFT                 2u\r\n#define FTM_INVCTRL_INV2EN_WIDTH                 1u\r\n#define FTM_INVCTRL_INV2EN(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_INVCTRL_INV2EN_SHIFT))&FTM_INVCTRL_INV2EN_MASK)\r\n#define FTM_INVCTRL_INV3EN_MASK                  0x8u\r\n#define FTM_INVCTRL_INV3EN_SHIFT                 3u\r\n#define FTM_INVCTRL_INV3EN_WIDTH                 1u\r\n#define FTM_INVCTRL_INV3EN(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_INVCTRL_INV3EN_SHIFT))&FTM_INVCTRL_INV3EN_MASK)\r\n/* SWOCTRL Bit Fields */\r\n#define FTM_SWOCTRL_CH0OC_MASK                   0x1u\r\n#define FTM_SWOCTRL_CH0OC_SHIFT                  0u\r\n#define FTM_SWOCTRL_CH0OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH0OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH0OC_SHIFT))&FTM_SWOCTRL_CH0OC_MASK)\r\n#define FTM_SWOCTRL_CH1OC_MASK                   0x2u\r\n#define FTM_SWOCTRL_CH1OC_SHIFT                  1u\r\n#define FTM_SWOCTRL_CH1OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH1OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH1OC_SHIFT))&FTM_SWOCTRL_CH1OC_MASK)\r\n#define FTM_SWOCTRL_CH2OC_MASK                   0x4u\r\n#define FTM_SWOCTRL_CH2OC_SHIFT                  2u\r\n#define FTM_SWOCTRL_CH2OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH2OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH2OC_SHIFT))&FTM_SWOCTRL_CH2OC_MASK)\r\n#define FTM_SWOCTRL_CH3OC_MASK                   0x8u\r\n#define FTM_SWOCTRL_CH3OC_SHIFT                  3u\r\n#define FTM_SWOCTRL_CH3OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH3OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH3OC_SHIFT))&FTM_SWOCTRL_CH3OC_MASK)\r\n#define FTM_SWOCTRL_CH4OC_MASK                   0x10u\r\n#define FTM_SWOCTRL_CH4OC_SHIFT                  4u\r\n#define FTM_SWOCTRL_CH4OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH4OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH4OC_SHIFT))&FTM_SWOCTRL_CH4OC_MASK)\r\n#define FTM_SWOCTRL_CH5OC_MASK                   0x20u\r\n#define FTM_SWOCTRL_CH5OC_SHIFT                  5u\r\n#define FTM_SWOCTRL_CH5OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH5OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH5OC_SHIFT))&FTM_SWOCTRL_CH5OC_MASK)\r\n#define FTM_SWOCTRL_CH6OC_MASK                   0x40u\r\n#define FTM_SWOCTRL_CH6OC_SHIFT                  6u\r\n#define FTM_SWOCTRL_CH6OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH6OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH6OC_SHIFT))&FTM_SWOCTRL_CH6OC_MASK)\r\n#define FTM_SWOCTRL_CH7OC_MASK                   0x80u\r\n#define FTM_SWOCTRL_CH7OC_SHIFT                  7u\r\n#define FTM_SWOCTRL_CH7OC_WIDTH                  1u\r\n#define FTM_SWOCTRL_CH7OC(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH7OC_SHIFT))&FTM_SWOCTRL_CH7OC_MASK)\r\n#define FTM_SWOCTRL_CH0OCV_MASK                  0x100u\r\n#define FTM_SWOCTRL_CH0OCV_SHIFT                 8u\r\n#define FTM_SWOCTRL_CH0OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH0OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH0OCV_SHIFT))&FTM_SWOCTRL_CH0OCV_MASK)\r\n#define FTM_SWOCTRL_CH1OCV_MASK                  0x200u\r\n#define FTM_SWOCTRL_CH1OCV_SHIFT                 9u\r\n#define FTM_SWOCTRL_CH1OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH1OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH1OCV_SHIFT))&FTM_SWOCTRL_CH1OCV_MASK)\r\n#define FTM_SWOCTRL_CH2OCV_MASK                  0x400u\r\n#define FTM_SWOCTRL_CH2OCV_SHIFT                 10u\r\n#define FTM_SWOCTRL_CH2OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH2OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH2OCV_SHIFT))&FTM_SWOCTRL_CH2OCV_MASK)\r\n#define FTM_SWOCTRL_CH3OCV_MASK                  0x800u\r\n#define FTM_SWOCTRL_CH3OCV_SHIFT                 11u\r\n#define FTM_SWOCTRL_CH3OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH3OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH3OCV_SHIFT))&FTM_SWOCTRL_CH3OCV_MASK)\r\n#define FTM_SWOCTRL_CH4OCV_MASK                  0x1000u\r\n#define FTM_SWOCTRL_CH4OCV_SHIFT                 12u\r\n#define FTM_SWOCTRL_CH4OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH4OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH4OCV_SHIFT))&FTM_SWOCTRL_CH4OCV_MASK)\r\n#define FTM_SWOCTRL_CH5OCV_MASK                  0x2000u\r\n#define FTM_SWOCTRL_CH5OCV_SHIFT                 13u\r\n#define FTM_SWOCTRL_CH5OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH5OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH5OCV_SHIFT))&FTM_SWOCTRL_CH5OCV_MASK)\r\n#define FTM_SWOCTRL_CH6OCV_MASK                  0x4000u\r\n#define FTM_SWOCTRL_CH6OCV_SHIFT                 14u\r\n#define FTM_SWOCTRL_CH6OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH6OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH6OCV_SHIFT))&FTM_SWOCTRL_CH6OCV_MASK)\r\n#define FTM_SWOCTRL_CH7OCV_MASK                  0x8000u\r\n#define FTM_SWOCTRL_CH7OCV_SHIFT                 15u\r\n#define FTM_SWOCTRL_CH7OCV_WIDTH                 1u\r\n#define FTM_SWOCTRL_CH7OCV(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_SWOCTRL_CH7OCV_SHIFT))&FTM_SWOCTRL_CH7OCV_MASK)\r\n/* PWMLOAD Bit Fields */\r\n#define FTM_PWMLOAD_CH0SEL_MASK                  0x1u\r\n#define FTM_PWMLOAD_CH0SEL_SHIFT                 0u\r\n#define FTM_PWMLOAD_CH0SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH0SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH0SEL_SHIFT))&FTM_PWMLOAD_CH0SEL_MASK)\r\n#define FTM_PWMLOAD_CH1SEL_MASK                  0x2u\r\n#define FTM_PWMLOAD_CH1SEL_SHIFT                 1u\r\n#define FTM_PWMLOAD_CH1SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH1SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH1SEL_SHIFT))&FTM_PWMLOAD_CH1SEL_MASK)\r\n#define FTM_PWMLOAD_CH2SEL_MASK                  0x4u\r\n#define FTM_PWMLOAD_CH2SEL_SHIFT                 2u\r\n#define FTM_PWMLOAD_CH2SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH2SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH2SEL_SHIFT))&FTM_PWMLOAD_CH2SEL_MASK)\r\n#define FTM_PWMLOAD_CH3SEL_MASK                  0x8u\r\n#define FTM_PWMLOAD_CH3SEL_SHIFT                 3u\r\n#define FTM_PWMLOAD_CH3SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH3SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH3SEL_SHIFT))&FTM_PWMLOAD_CH3SEL_MASK)\r\n#define FTM_PWMLOAD_CH4SEL_MASK                  0x10u\r\n#define FTM_PWMLOAD_CH4SEL_SHIFT                 4u\r\n#define FTM_PWMLOAD_CH4SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH4SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH4SEL_SHIFT))&FTM_PWMLOAD_CH4SEL_MASK)\r\n#define FTM_PWMLOAD_CH5SEL_MASK                  0x20u\r\n#define FTM_PWMLOAD_CH5SEL_SHIFT                 5u\r\n#define FTM_PWMLOAD_CH5SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH5SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH5SEL_SHIFT))&FTM_PWMLOAD_CH5SEL_MASK)\r\n#define FTM_PWMLOAD_CH6SEL_MASK                  0x40u\r\n#define FTM_PWMLOAD_CH6SEL_SHIFT                 6u\r\n#define FTM_PWMLOAD_CH6SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH6SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH6SEL_SHIFT))&FTM_PWMLOAD_CH6SEL_MASK)\r\n#define FTM_PWMLOAD_CH7SEL_MASK                  0x80u\r\n#define FTM_PWMLOAD_CH7SEL_SHIFT                 7u\r\n#define FTM_PWMLOAD_CH7SEL_WIDTH                 1u\r\n#define FTM_PWMLOAD_CH7SEL(x)                    (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_CH7SEL_SHIFT))&FTM_PWMLOAD_CH7SEL_MASK)\r\n#define FTM_PWMLOAD_HCSEL_MASK                   0x100u\r\n#define FTM_PWMLOAD_HCSEL_SHIFT                  8u\r\n#define FTM_PWMLOAD_HCSEL_WIDTH                  1u\r\n#define FTM_PWMLOAD_HCSEL(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_HCSEL_SHIFT))&FTM_PWMLOAD_HCSEL_MASK)\r\n#define FTM_PWMLOAD_LDOK_MASK                    0x200u\r\n#define FTM_PWMLOAD_LDOK_SHIFT                   9u\r\n#define FTM_PWMLOAD_LDOK_WIDTH                   1u\r\n#define FTM_PWMLOAD_LDOK(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_LDOK_SHIFT))&FTM_PWMLOAD_LDOK_MASK)\r\n#define FTM_PWMLOAD_GLEN_MASK                    0x400u\r\n#define FTM_PWMLOAD_GLEN_SHIFT                   10u\r\n#define FTM_PWMLOAD_GLEN_WIDTH                   1u\r\n#define FTM_PWMLOAD_GLEN(x)                      (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_GLEN_SHIFT))&FTM_PWMLOAD_GLEN_MASK)\r\n#define FTM_PWMLOAD_GLDOK_MASK                   0x800u\r\n#define FTM_PWMLOAD_GLDOK_SHIFT                  11u\r\n#define FTM_PWMLOAD_GLDOK_WIDTH                  1u\r\n#define FTM_PWMLOAD_GLDOK(x)                     (((uint32_t)(((uint32_t)(x))<<FTM_PWMLOAD_GLDOK_SHIFT))&FTM_PWMLOAD_GLDOK_MASK)\r\n/* HCR Bit Fields */\r\n#define FTM_HCR_HCVAL_MASK                       0xFFFFu\r\n#define FTM_HCR_HCVAL_SHIFT                      0u\r\n#define FTM_HCR_HCVAL_WIDTH                      16u\r\n#define FTM_HCR_HCVAL(x)                         (((uint32_t)(((uint32_t)(x))<<FTM_HCR_HCVAL_SHIFT))&FTM_HCR_HCVAL_MASK)\r\n/* PAIR0DEADTIME Bit Fields */\r\n#define FTM_PAIR0DEADTIME_DTVAL_MASK             0x3Fu\r\n#define FTM_PAIR0DEADTIME_DTVAL_SHIFT            0u\r\n#define FTM_PAIR0DEADTIME_DTVAL_WIDTH            6u\r\n#define FTM_PAIR0DEADTIME_DTVAL(x)               (((uint32_t)(((uint32_t)(x))<<FTM_PAIR0DEADTIME_DTVAL_SHIFT))&FTM_PAIR0DEADTIME_DTVAL_MASK)\r\n#define FTM_PAIR0DEADTIME_DTPS_MASK              0xC0u\r\n#define FTM_PAIR0DEADTIME_DTPS_SHIFT             6u\r\n#define FTM_PAIR0DEADTIME_DTPS_WIDTH             2u\r\n#define FTM_PAIR0DEADTIME_DTPS(x)                (((uint32_t)(((uint32_t)(x))<<FTM_PAIR0DEADTIME_DTPS_SHIFT))&FTM_PAIR0DEADTIME_DTPS_MASK)\r\n#define FTM_PAIR0DEADTIME_DTVALEX_MASK           0xF0000u\r\n#define FTM_PAIR0DEADTIME_DTVALEX_SHIFT          16u\r\n#define FTM_PAIR0DEADTIME_DTVALEX_WIDTH          4u\r\n#define FTM_PAIR0DEADTIME_DTVALEX(x)             (((uint32_t)(((uint32_t)(x))<<FTM_PAIR0DEADTIME_DTVALEX_SHIFT))&FTM_PAIR0DEADTIME_DTVALEX_MASK)\r\n/* PAIR1DEADTIME Bit Fields */\r\n#define FTM_PAIR1DEADTIME_DTVAL_MASK             0x3Fu\r\n#define FTM_PAIR1DEADTIME_DTVAL_SHIFT            0u\r\n#define FTM_PAIR1DEADTIME_DTVAL_WIDTH            6u\r\n#define FTM_PAIR1DEADTIME_DTVAL(x)               (((uint32_t)(((uint32_t)(x))<<FTM_PAIR1DEADTIME_DTVAL_SHIFT))&FTM_PAIR1DEADTIME_DTVAL_MASK)\r\n#define FTM_PAIR1DEADTIME_DTPS_MASK              0xC0u\r\n#define FTM_PAIR1DEADTIME_DTPS_SHIFT             6u\r\n#define FTM_PAIR1DEADTIME_DTPS_WIDTH             2u\r\n#define FTM_PAIR1DEADTIME_DTPS(x)                (((uint32_t)(((uint32_t)(x))<<FTM_PAIR1DEADTIME_DTPS_SHIFT))&FTM_PAIR1DEADTIME_DTPS_MASK)\r\n#define FTM_PAIR1DEADTIME_DTVALEX_MASK           0xF0000u\r\n#define FTM_PAIR1DEADTIME_DTVALEX_SHIFT          16u\r\n#define FTM_PAIR1DEADTIME_DTVALEX_WIDTH          4u\r\n#define FTM_PAIR1DEADTIME_DTVALEX(x)             (((uint32_t)(((uint32_t)(x))<<FTM_PAIR1DEADTIME_DTVALEX_SHIFT))&FTM_PAIR1DEADTIME_DTVALEX_MASK)\r\n/* PAIR2DEADTIME Bit Fields */\r\n#define FTM_PAIR2DEADTIME_DTVAL_MASK             0x3Fu\r\n#define FTM_PAIR2DEADTIME_DTVAL_SHIFT            0u\r\n#define FTM_PAIR2DEADTIME_DTVAL_WIDTH            6u\r\n#define FTM_PAIR2DEADTIME_DTVAL(x)               (((uint32_t)(((uint32_t)(x))<<FTM_PAIR2DEADTIME_DTVAL_SHIFT))&FTM_PAIR2DEADTIME_DTVAL_MASK)\r\n#define FTM_PAIR2DEADTIME_DTPS_MASK              0xC0u\r\n#define FTM_PAIR2DEADTIME_DTPS_SHIFT             6u\r\n#define FTM_PAIR2DEADTIME_DTPS_WIDTH             2u\r\n#define FTM_PAIR2DEADTIME_DTPS(x)                (((uint32_t)(((uint32_t)(x))<<FTM_PAIR2DEADTIME_DTPS_SHIFT))&FTM_PAIR2DEADTIME_DTPS_MASK)\r\n#define FTM_PAIR2DEADTIME_DTVALEX_MASK           0xF0000u\r\n#define FTM_PAIR2DEADTIME_DTVALEX_SHIFT          16u\r\n#define FTM_PAIR2DEADTIME_DTVALEX_WIDTH          4u\r\n#define FTM_PAIR2DEADTIME_DTVALEX(x)             (((uint32_t)(((uint32_t)(x))<<FTM_PAIR2DEADTIME_DTVALEX_SHIFT))&FTM_PAIR2DEADTIME_DTVALEX_MASK)\r\n/* PAIR3DEADTIME Bit Fields */\r\n#define FTM_PAIR3DEADTIME_DTVAL_MASK             0x3Fu\r\n#define FTM_PAIR3DEADTIME_DTVAL_SHIFT            0u\r\n#define FTM_PAIR3DEADTIME_DTVAL_WIDTH            6u\r\n#define FTM_PAIR3DEADTIME_DTVAL(x)               (((uint32_t)(((uint32_t)(x))<<FTM_PAIR3DEADTIME_DTVAL_SHIFT))&FTM_PAIR3DEADTIME_DTVAL_MASK)\r\n#define FTM_PAIR3DEADTIME_DTPS_MASK              0xC0u\r\n#define FTM_PAIR3DEADTIME_DTPS_SHIFT             6u\r\n#define FTM_PAIR3DEADTIME_DTPS_WIDTH             2u\r\n#define FTM_PAIR3DEADTIME_DTPS(x)                (((uint32_t)(((uint32_t)(x))<<FTM_PAIR3DEADTIME_DTPS_SHIFT))&FTM_PAIR3DEADTIME_DTPS_MASK)\r\n#define FTM_PAIR3DEADTIME_DTVALEX_MASK           0xF0000u\r\n#define FTM_PAIR3DEADTIME_DTVALEX_SHIFT          16u\r\n#define FTM_PAIR3DEADTIME_DTVALEX_WIDTH          4u\r\n#define FTM_PAIR3DEADTIME_DTVALEX(x)             (((uint32_t)(((uint32_t)(x))<<FTM_PAIR3DEADTIME_DTVALEX_SHIFT))&FTM_PAIR3DEADTIME_DTVALEX_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group FTM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group FTM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- GPIO Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** GPIO - Size of Registers Arrays */\r\n\r\n/** GPIO - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */\r\n  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */\r\n  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */\r\n  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */\r\n  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */\r\n  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */\r\n  __IO uint32_t PIDR;                              /**< Port Input Disable Register, offset: 0x18 */\r\n} GPIO_Type, *GPIO_MemMapPtr;\r\n\r\n /** Number of instances of the GPIO module. */\r\n#define GPIO_INSTANCE_COUNT                      (5u)\r\n\r\n\r\n/* GPIO - Peripheral instance base addresses */\r\n/** Peripheral PTA base address */\r\n#define PTA_BASE                                 (0x400FF000u)\r\n/** Peripheral PTA base pointer */\r\n#define PTA                                      ((GPIO_Type *)PTA_BASE)\r\n/** Peripheral PTB base address */\r\n#define PTB_BASE                                 (0x400FF040u)\r\n/** Peripheral PTB base pointer */\r\n#define PTB                                      ((GPIO_Type *)PTB_BASE)\r\n/** Peripheral PTC base address */\r\n#define PTC_BASE                                 (0x400FF080u)\r\n/** Peripheral PTC base pointer */\r\n#define PTC                                      ((GPIO_Type *)PTC_BASE)\r\n/** Peripheral PTD base address */\r\n#define PTD_BASE                                 (0x400FF0C0u)\r\n/** Peripheral PTD base pointer */\r\n#define PTD                                      ((GPIO_Type *)PTD_BASE)\r\n/** Peripheral PTE base address */\r\n#define PTE_BASE                                 (0x400FF100u)\r\n/** Peripheral PTE base pointer */\r\n#define PTE                                      ((GPIO_Type *)PTE_BASE)\r\n/** Array initializer of GPIO peripheral base addresses */\r\n#define GPIO_BASE_ADDRS                          { PTA_BASE, PTB_BASE, PTC_BASE, PTD_BASE, PTE_BASE }\r\n/** Array initializer of GPIO peripheral base pointers */\r\n#define GPIO_BASE_PTRS                           { PTA, PTB, PTC, PTD, PTE }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- GPIO Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup GPIO_Register_Masks GPIO Register Masks\r\n * @{\r\n */\r\n\r\n/* PDOR Bit Fields */\r\n#define GPIO_PDOR_PDO_MASK                       0xFFFFFFFFu\r\n#define GPIO_PDOR_PDO_SHIFT                      0u\r\n#define GPIO_PDOR_PDO_WIDTH                      32u\r\n#define GPIO_PDOR_PDO(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDOR_PDO_SHIFT))&GPIO_PDOR_PDO_MASK)\r\n/* PSOR Bit Fields */\r\n#define GPIO_PSOR_PTSO_MASK                      0xFFFFFFFFu\r\n#define GPIO_PSOR_PTSO_SHIFT                     0u\r\n#define GPIO_PSOR_PTSO_WIDTH                     32u\r\n#define GPIO_PSOR_PTSO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PSOR_PTSO_SHIFT))&GPIO_PSOR_PTSO_MASK)\r\n/* PCOR Bit Fields */\r\n#define GPIO_PCOR_PTCO_MASK                      0xFFFFFFFFu\r\n#define GPIO_PCOR_PTCO_SHIFT                     0u\r\n#define GPIO_PCOR_PTCO_WIDTH                     32u\r\n#define GPIO_PCOR_PTCO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PCOR_PTCO_SHIFT))&GPIO_PCOR_PTCO_MASK)\r\n/* PTOR Bit Fields */\r\n#define GPIO_PTOR_PTTO_MASK                      0xFFFFFFFFu\r\n#define GPIO_PTOR_PTTO_SHIFT                     0u\r\n#define GPIO_PTOR_PTTO_WIDTH                     32u\r\n#define GPIO_PTOR_PTTO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PTOR_PTTO_SHIFT))&GPIO_PTOR_PTTO_MASK)\r\n/* PDIR Bit Fields */\r\n#define GPIO_PDIR_PDI_MASK                       0xFFFFFFFFu\r\n#define GPIO_PDIR_PDI_SHIFT                      0u\r\n#define GPIO_PDIR_PDI_WIDTH                      32u\r\n#define GPIO_PDIR_PDI(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDIR_PDI_SHIFT))&GPIO_PDIR_PDI_MASK)\r\n/* PDDR Bit Fields */\r\n#define GPIO_PDDR_PDD_MASK                       0xFFFFFFFFu\r\n#define GPIO_PDDR_PDD_SHIFT                      0u\r\n#define GPIO_PDDR_PDD_WIDTH                      32u\r\n#define GPIO_PDDR_PDD(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDDR_PDD_SHIFT))&GPIO_PDDR_PDD_MASK)\r\n/* PIDR Bit Fields */\r\n#define GPIO_PIDR_PID_MASK                       0xFFFFFFFFu\r\n#define GPIO_PIDR_PID_SHIFT                      0u\r\n#define GPIO_PIDR_PID_WIDTH                      32u\r\n#define GPIO_PIDR_PID(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PIDR_PID_SHIFT))&GPIO_PIDR_PID_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group GPIO_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group GPIO_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LMEM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LMEM_Peripheral_Access_Layer LMEM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** LMEM - Size of Registers Arrays */\r\n\r\n/** LMEM - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t PCCCR;                             /**< Cache control register, offset: 0x0 */\r\n  __IO uint32_t PCCLCR;                            /**< Cache line control register, offset: 0x4 */\r\n  __IO uint32_t PCCSAR;                            /**< Cache search address register, offset: 0x8 */\r\n  __IO uint32_t PCCCVR;                            /**< Cache read/write value register, offset: 0xC */\r\n       uint8_t RESERVED_0[16];\r\n  __IO uint32_t PCCRMR;                            /**< Cache regions mode register, offset: 0x20 */\r\n} LMEM_Type, *LMEM_MemMapPtr;\r\n\r\n /** Number of instances of the LMEM module. */\r\n#define LMEM_INSTANCE_COUNT                      (1u)\r\n\r\n\r\n/* LMEM - Peripheral instance base addresses */\r\n/** Peripheral LMEM base address */\r\n#define LMEM_BASE                                (0xE0082000u)\r\n/** Peripheral LMEM base pointer */\r\n#define LMEM                                     ((LMEM_Type *)LMEM_BASE)\r\n/** Array initializer of LMEM peripheral base addresses */\r\n#define LMEM_BASE_ADDRS                          { LMEM_BASE }\r\n/** Array initializer of LMEM peripheral base pointers */\r\n#define LMEM_BASE_PTRS                           { LMEM }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LMEM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LMEM_Register_Masks LMEM Register Masks\r\n * @{\r\n */\r\n\r\n/* PCCCR Bit Fields */\r\n#define LMEM_PCCCR_ENCACHE_MASK                  0x1u\r\n#define LMEM_PCCCR_ENCACHE_SHIFT                 0u\r\n#define LMEM_PCCCR_ENCACHE_WIDTH                 1u\r\n#define LMEM_PCCCR_ENCACHE(x)                    (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_ENCACHE_SHIFT))&LMEM_PCCCR_ENCACHE_MASK)\r\n#define LMEM_PCCCR_PCCR2_MASK                    0x4u\r\n#define LMEM_PCCCR_PCCR2_SHIFT                   2u\r\n#define LMEM_PCCCR_PCCR2_WIDTH                   1u\r\n#define LMEM_PCCCR_PCCR2(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_PCCR2_SHIFT))&LMEM_PCCCR_PCCR2_MASK)\r\n#define LMEM_PCCCR_PCCR3_MASK                    0x8u\r\n#define LMEM_PCCCR_PCCR3_SHIFT                   3u\r\n#define LMEM_PCCCR_PCCR3_WIDTH                   1u\r\n#define LMEM_PCCCR_PCCR3(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_PCCR3_SHIFT))&LMEM_PCCCR_PCCR3_MASK)\r\n#define LMEM_PCCCR_INVW0_MASK                    0x1000000u\r\n#define LMEM_PCCCR_INVW0_SHIFT                   24u\r\n#define LMEM_PCCCR_INVW0_WIDTH                   1u\r\n#define LMEM_PCCCR_INVW0(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_INVW0_SHIFT))&LMEM_PCCCR_INVW0_MASK)\r\n#define LMEM_PCCCR_PUSHW0_MASK                   0x2000000u\r\n#define LMEM_PCCCR_PUSHW0_SHIFT                  25u\r\n#define LMEM_PCCCR_PUSHW0_WIDTH                  1u\r\n#define LMEM_PCCCR_PUSHW0(x)                     (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_PUSHW0_SHIFT))&LMEM_PCCCR_PUSHW0_MASK)\r\n#define LMEM_PCCCR_INVW1_MASK                    0x4000000u\r\n#define LMEM_PCCCR_INVW1_SHIFT                   26u\r\n#define LMEM_PCCCR_INVW1_WIDTH                   1u\r\n#define LMEM_PCCCR_INVW1(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_INVW1_SHIFT))&LMEM_PCCCR_INVW1_MASK)\r\n#define LMEM_PCCCR_PUSHW1_MASK                   0x8000000u\r\n#define LMEM_PCCCR_PUSHW1_SHIFT                  27u\r\n#define LMEM_PCCCR_PUSHW1_WIDTH                  1u\r\n#define LMEM_PCCCR_PUSHW1(x)                     (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_PUSHW1_SHIFT))&LMEM_PCCCR_PUSHW1_MASK)\r\n#define LMEM_PCCCR_GO_MASK                       0x80000000u\r\n#define LMEM_PCCCR_GO_SHIFT                      31u\r\n#define LMEM_PCCCR_GO_WIDTH                      1u\r\n#define LMEM_PCCCR_GO(x)                         (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCR_GO_SHIFT))&LMEM_PCCCR_GO_MASK)\r\n/* PCCLCR Bit Fields */\r\n#define LMEM_PCCLCR_LGO_MASK                     0x1u\r\n#define LMEM_PCCLCR_LGO_SHIFT                    0u\r\n#define LMEM_PCCLCR_LGO_WIDTH                    1u\r\n#define LMEM_PCCLCR_LGO(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LGO_SHIFT))&LMEM_PCCLCR_LGO_MASK)\r\n#define LMEM_PCCLCR_CACHEADDR_MASK               0x3FFCu\r\n#define LMEM_PCCLCR_CACHEADDR_SHIFT              2u\r\n#define LMEM_PCCLCR_CACHEADDR_WIDTH              12u\r\n#define LMEM_PCCLCR_CACHEADDR(x)                 (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_CACHEADDR_SHIFT))&LMEM_PCCLCR_CACHEADDR_MASK)\r\n#define LMEM_PCCLCR_WSEL_MASK                    0x4000u\r\n#define LMEM_PCCLCR_WSEL_SHIFT                   14u\r\n#define LMEM_PCCLCR_WSEL_WIDTH                   1u\r\n#define LMEM_PCCLCR_WSEL(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_WSEL_SHIFT))&LMEM_PCCLCR_WSEL_MASK)\r\n#define LMEM_PCCLCR_TDSEL_MASK                   0x10000u\r\n#define LMEM_PCCLCR_TDSEL_SHIFT                  16u\r\n#define LMEM_PCCLCR_TDSEL_WIDTH                  1u\r\n#define LMEM_PCCLCR_TDSEL(x)                     (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_TDSEL_SHIFT))&LMEM_PCCLCR_TDSEL_MASK)\r\n#define LMEM_PCCLCR_LCIVB_MASK                   0x100000u\r\n#define LMEM_PCCLCR_LCIVB_SHIFT                  20u\r\n#define LMEM_PCCLCR_LCIVB_WIDTH                  1u\r\n#define LMEM_PCCLCR_LCIVB(x)                     (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LCIVB_SHIFT))&LMEM_PCCLCR_LCIVB_MASK)\r\n#define LMEM_PCCLCR_LCIMB_MASK                   0x200000u\r\n#define LMEM_PCCLCR_LCIMB_SHIFT                  21u\r\n#define LMEM_PCCLCR_LCIMB_WIDTH                  1u\r\n#define LMEM_PCCLCR_LCIMB(x)                     (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LCIMB_SHIFT))&LMEM_PCCLCR_LCIMB_MASK)\r\n#define LMEM_PCCLCR_LCWAY_MASK                   0x400000u\r\n#define LMEM_PCCLCR_LCWAY_SHIFT                  22u\r\n#define LMEM_PCCLCR_LCWAY_WIDTH                  1u\r\n#define LMEM_PCCLCR_LCWAY(x)                     (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LCWAY_SHIFT))&LMEM_PCCLCR_LCWAY_MASK)\r\n#define LMEM_PCCLCR_LCMD_MASK                    0x3000000u\r\n#define LMEM_PCCLCR_LCMD_SHIFT                   24u\r\n#define LMEM_PCCLCR_LCMD_WIDTH                   2u\r\n#define LMEM_PCCLCR_LCMD(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LCMD_SHIFT))&LMEM_PCCLCR_LCMD_MASK)\r\n#define LMEM_PCCLCR_LADSEL_MASK                  0x4000000u\r\n#define LMEM_PCCLCR_LADSEL_SHIFT                 26u\r\n#define LMEM_PCCLCR_LADSEL_WIDTH                 1u\r\n#define LMEM_PCCLCR_LADSEL(x)                    (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LADSEL_SHIFT))&LMEM_PCCLCR_LADSEL_MASK)\r\n#define LMEM_PCCLCR_LACC_MASK                    0x8000000u\r\n#define LMEM_PCCLCR_LACC_SHIFT                   27u\r\n#define LMEM_PCCLCR_LACC_WIDTH                   1u\r\n#define LMEM_PCCLCR_LACC(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCLCR_LACC_SHIFT))&LMEM_PCCLCR_LACC_MASK)\r\n/* PCCSAR Bit Fields */\r\n#define LMEM_PCCSAR_LGO_MASK                     0x1u\r\n#define LMEM_PCCSAR_LGO_SHIFT                    0u\r\n#define LMEM_PCCSAR_LGO_WIDTH                    1u\r\n#define LMEM_PCCSAR_LGO(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCSAR_LGO_SHIFT))&LMEM_PCCSAR_LGO_MASK)\r\n#define LMEM_PCCSAR_PHYADDR_MASK                 0xFFFFFFFCu\r\n#define LMEM_PCCSAR_PHYADDR_SHIFT                2u\r\n#define LMEM_PCCSAR_PHYADDR_WIDTH                30u\r\n#define LMEM_PCCSAR_PHYADDR(x)                   (((uint32_t)(((uint32_t)(x))<<LMEM_PCCSAR_PHYADDR_SHIFT))&LMEM_PCCSAR_PHYADDR_MASK)\r\n/* PCCCVR Bit Fields */\r\n#define LMEM_PCCCVR_DATA_MASK                    0xFFFFFFFFu\r\n#define LMEM_PCCCVR_DATA_SHIFT                   0u\r\n#define LMEM_PCCCVR_DATA_WIDTH                   32u\r\n#define LMEM_PCCCVR_DATA(x)                      (((uint32_t)(((uint32_t)(x))<<LMEM_PCCCVR_DATA_SHIFT))&LMEM_PCCCVR_DATA_MASK)\r\n/* PCCRMR Bit Fields */\r\n#define LMEM_PCCRMR_R15_MASK                     0x3u\r\n#define LMEM_PCCRMR_R15_SHIFT                    0u\r\n#define LMEM_PCCRMR_R15_WIDTH                    2u\r\n#define LMEM_PCCRMR_R15(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R15_SHIFT))&LMEM_PCCRMR_R15_MASK)\r\n#define LMEM_PCCRMR_R14_MASK                     0xCu\r\n#define LMEM_PCCRMR_R14_SHIFT                    2u\r\n#define LMEM_PCCRMR_R14_WIDTH                    2u\r\n#define LMEM_PCCRMR_R14(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R14_SHIFT))&LMEM_PCCRMR_R14_MASK)\r\n#define LMEM_PCCRMR_R13_MASK                     0x30u\r\n#define LMEM_PCCRMR_R13_SHIFT                    4u\r\n#define LMEM_PCCRMR_R13_WIDTH                    2u\r\n#define LMEM_PCCRMR_R13(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R13_SHIFT))&LMEM_PCCRMR_R13_MASK)\r\n#define LMEM_PCCRMR_R12_MASK                     0xC0u\r\n#define LMEM_PCCRMR_R12_SHIFT                    6u\r\n#define LMEM_PCCRMR_R12_WIDTH                    2u\r\n#define LMEM_PCCRMR_R12(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R12_SHIFT))&LMEM_PCCRMR_R12_MASK)\r\n#define LMEM_PCCRMR_R11_MASK                     0x300u\r\n#define LMEM_PCCRMR_R11_SHIFT                    8u\r\n#define LMEM_PCCRMR_R11_WIDTH                    2u\r\n#define LMEM_PCCRMR_R11(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R11_SHIFT))&LMEM_PCCRMR_R11_MASK)\r\n#define LMEM_PCCRMR_R10_MASK                     0xC00u\r\n#define LMEM_PCCRMR_R10_SHIFT                    10u\r\n#define LMEM_PCCRMR_R10_WIDTH                    2u\r\n#define LMEM_PCCRMR_R10(x)                       (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R10_SHIFT))&LMEM_PCCRMR_R10_MASK)\r\n#define LMEM_PCCRMR_R9_MASK                      0x3000u\r\n#define LMEM_PCCRMR_R9_SHIFT                     12u\r\n#define LMEM_PCCRMR_R9_WIDTH                     2u\r\n#define LMEM_PCCRMR_R9(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R9_SHIFT))&LMEM_PCCRMR_R9_MASK)\r\n#define LMEM_PCCRMR_R8_MASK                      0xC000u\r\n#define LMEM_PCCRMR_R8_SHIFT                     14u\r\n#define LMEM_PCCRMR_R8_WIDTH                     2u\r\n#define LMEM_PCCRMR_R8(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R8_SHIFT))&LMEM_PCCRMR_R8_MASK)\r\n#define LMEM_PCCRMR_R7_MASK                      0x30000u\r\n#define LMEM_PCCRMR_R7_SHIFT                     16u\r\n#define LMEM_PCCRMR_R7_WIDTH                     2u\r\n#define LMEM_PCCRMR_R7(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R7_SHIFT))&LMEM_PCCRMR_R7_MASK)\r\n#define LMEM_PCCRMR_R6_MASK                      0xC0000u\r\n#define LMEM_PCCRMR_R6_SHIFT                     18u\r\n#define LMEM_PCCRMR_R6_WIDTH                     2u\r\n#define LMEM_PCCRMR_R6(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R6_SHIFT))&LMEM_PCCRMR_R6_MASK)\r\n#define LMEM_PCCRMR_R5_MASK                      0x300000u\r\n#define LMEM_PCCRMR_R5_SHIFT                     20u\r\n#define LMEM_PCCRMR_R5_WIDTH                     2u\r\n#define LMEM_PCCRMR_R5(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R5_SHIFT))&LMEM_PCCRMR_R5_MASK)\r\n#define LMEM_PCCRMR_R4_MASK                      0xC00000u\r\n#define LMEM_PCCRMR_R4_SHIFT                     22u\r\n#define LMEM_PCCRMR_R4_WIDTH                     2u\r\n#define LMEM_PCCRMR_R4(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R4_SHIFT))&LMEM_PCCRMR_R4_MASK)\r\n#define LMEM_PCCRMR_R3_MASK                      0x3000000u\r\n#define LMEM_PCCRMR_R3_SHIFT                     24u\r\n#define LMEM_PCCRMR_R3_WIDTH                     2u\r\n#define LMEM_PCCRMR_R3(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R3_SHIFT))&LMEM_PCCRMR_R3_MASK)\r\n#define LMEM_PCCRMR_R2_MASK                      0xC000000u\r\n#define LMEM_PCCRMR_R2_SHIFT                     26u\r\n#define LMEM_PCCRMR_R2_WIDTH                     2u\r\n#define LMEM_PCCRMR_R2(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R2_SHIFT))&LMEM_PCCRMR_R2_MASK)\r\n#define LMEM_PCCRMR_R1_MASK                      0x30000000u\r\n#define LMEM_PCCRMR_R1_SHIFT                     28u\r\n#define LMEM_PCCRMR_R1_WIDTH                     2u\r\n#define LMEM_PCCRMR_R1(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R1_SHIFT))&LMEM_PCCRMR_R1_MASK)\r\n#define LMEM_PCCRMR_R0_MASK                      0xC0000000u\r\n#define LMEM_PCCRMR_R0_SHIFT                     30u\r\n#define LMEM_PCCRMR_R0_WIDTH                     2u\r\n#define LMEM_PCCRMR_R0(x)                        (((uint32_t)(((uint32_t)(x))<<LMEM_PCCRMR_R0_SHIFT))&LMEM_PCCRMR_R0_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LMEM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LMEM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPI2C Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPI2C_Peripheral_Access_Layer LPI2C Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** LPI2C - Size of Registers Arrays */\r\n\r\n/** LPI2C - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n       uint8_t RESERVED_0[8];\r\n  __IO uint32_t MCR;                               /**< Master Control Register, offset: 0x10 */\r\n  __IO uint32_t MSR;                               /**< Master Status Register, offset: 0x14 */\r\n  __IO uint32_t MIER;                              /**< Master Interrupt Enable Register, offset: 0x18 */\r\n  __IO uint32_t MDER;                              /**< Master DMA Enable Register, offset: 0x1C */\r\n  __IO uint32_t MCFGR0;                            /**< Master Configuration Register 0, offset: 0x20 */\r\n  __IO uint32_t MCFGR1;                            /**< Master Configuration Register 1, offset: 0x24 */\r\n  __IO uint32_t MCFGR2;                            /**< Master Configuration Register 2, offset: 0x28 */\r\n  __IO uint32_t MCFGR3;                            /**< Master Configuration Register 3, offset: 0x2C */\r\n       uint8_t RESERVED_1[16];\r\n  __IO uint32_t MDMR;                              /**< Master Data Match Register, offset: 0x40 */\r\n       uint8_t RESERVED_2[4];\r\n  __IO uint32_t MCCR0;                             /**< Master Clock Configuration Register 0, offset: 0x48 */\r\n       uint8_t RESERVED_3[4];\r\n  __IO uint32_t MCCR1;                             /**< Master Clock Configuration Register 1, offset: 0x50 */\r\n       uint8_t RESERVED_4[4];\r\n  __IO uint32_t MFCR;                              /**< Master FIFO Control Register, offset: 0x58 */\r\n  __I  uint32_t MFSR;                              /**< Master FIFO Status Register, offset: 0x5C */\r\n  __IO uint32_t MTDR;                              /**< Master Transmit Data Register, offset: 0x60 */\r\n       uint8_t RESERVED_5[12];\r\n  __I  uint32_t MRDR;                              /**< Master Receive Data Register, offset: 0x70 */\r\n       uint8_t RESERVED_6[156];\r\n  __IO uint32_t SCR;                               /**< Slave Control Register, offset: 0x110 */\r\n  __IO uint32_t SSR;                               /**< Slave Status Register, offset: 0x114 */\r\n  __IO uint32_t SIER;                              /**< Slave Interrupt Enable Register, offset: 0x118 */\r\n  __IO uint32_t SDER;                              /**< Slave DMA Enable Register, offset: 0x11C */\r\n       uint8_t RESERVED_7[4];\r\n  __IO uint32_t SCFGR1;                            /**< Slave Configuration Register 1, offset: 0x124 */\r\n  __IO uint32_t SCFGR2;                            /**< Slave Configuration Register 2, offset: 0x128 */\r\n       uint8_t RESERVED_8[20];\r\n  __IO uint32_t SAMR;                              /**< Slave Address Match Register, offset: 0x140 */\r\n       uint8_t RESERVED_9[12];\r\n  __I  uint32_t SASR;                              /**< Slave Address Status Register, offset: 0x150 */\r\n  __IO uint32_t STAR;                              /**< Slave Transmit ACK Register, offset: 0x154 */\r\n       uint8_t RESERVED_10[8];\r\n  __IO uint32_t STDR;                              /**< Slave Transmit Data Register, offset: 0x160 */\r\n       uint8_t RESERVED_11[12];\r\n  __I  uint32_t SRDR;                              /**< Slave Receive Data Register, offset: 0x170 */\r\n} LPI2C_Type, *LPI2C_MemMapPtr;\r\n\r\n /** Number of instances of the LPI2C module. */\r\n#define LPI2C_INSTANCE_COUNT                     (1u)\r\n\r\n\r\n/* LPI2C - Peripheral instance base addresses */\r\n/** Peripheral LPI2C0 base address */\r\n#define LPI2C0_BASE                              (0x40066000u)\r\n/** Peripheral LPI2C0 base pointer */\r\n#define LPI2C0                                   ((LPI2C_Type *)LPI2C0_BASE)\r\n/** Array initializer of LPI2C peripheral base addresses */\r\n#define LPI2C_BASE_ADDRS                         { LPI2C0_BASE }\r\n/** Array initializer of LPI2C peripheral base pointers */\r\n#define LPI2C_BASE_PTRS                          { LPI2C0 }\r\n /** Number of interrupt vector arrays for the LPI2C module. */\r\n#define LPI2C_IRQS_ARR_COUNT                     (2u)\r\n /** Number of interrupt channels for the MASTER type of LPI2C module. */\r\n#define LPI2C_MASTER_IRQS_CH_COUNT               (1u)\r\n /** Number of interrupt channels for the SLAVE type of LPI2C module. */\r\n#define LPI2C_SLAVE_IRQS_CH_COUNT                (1u)\r\n/** Interrupt vectors for the LPI2C peripheral type */\r\n#define LPI2C_MASTER_IRQS                        { LPI2C0_Master_IRQn }\r\n#define LPI2C_SLAVE_IRQS                         { LPI2C0_Slave_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPI2C Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPI2C_Register_Masks LPI2C Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define LPI2C_VERID_FEATURE_MASK                 0xFFFFu\r\n#define LPI2C_VERID_FEATURE_SHIFT                0u\r\n#define LPI2C_VERID_FEATURE_WIDTH                16u\r\n#define LPI2C_VERID_FEATURE(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_VERID_FEATURE_SHIFT))&LPI2C_VERID_FEATURE_MASK)\r\n#define LPI2C_VERID_MINOR_MASK                   0xFF0000u\r\n#define LPI2C_VERID_MINOR_SHIFT                  16u\r\n#define LPI2C_VERID_MINOR_WIDTH                  8u\r\n#define LPI2C_VERID_MINOR(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_VERID_MINOR_SHIFT))&LPI2C_VERID_MINOR_MASK)\r\n#define LPI2C_VERID_MAJOR_MASK                   0xFF000000u\r\n#define LPI2C_VERID_MAJOR_SHIFT                  24u\r\n#define LPI2C_VERID_MAJOR_WIDTH                  8u\r\n#define LPI2C_VERID_MAJOR(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_VERID_MAJOR_SHIFT))&LPI2C_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define LPI2C_PARAM_MTXFIFO_MASK                 0xFu\r\n#define LPI2C_PARAM_MTXFIFO_SHIFT                0u\r\n#define LPI2C_PARAM_MTXFIFO_WIDTH                4u\r\n#define LPI2C_PARAM_MTXFIFO(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_PARAM_MTXFIFO_SHIFT))&LPI2C_PARAM_MTXFIFO_MASK)\r\n#define LPI2C_PARAM_MRXFIFO_MASK                 0xF00u\r\n#define LPI2C_PARAM_MRXFIFO_SHIFT                8u\r\n#define LPI2C_PARAM_MRXFIFO_WIDTH                4u\r\n#define LPI2C_PARAM_MRXFIFO(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_PARAM_MRXFIFO_SHIFT))&LPI2C_PARAM_MRXFIFO_MASK)\r\n/* MCR Bit Fields */\r\n#define LPI2C_MCR_MEN_MASK                       0x1u\r\n#define LPI2C_MCR_MEN_SHIFT                      0u\r\n#define LPI2C_MCR_MEN_WIDTH                      1u\r\n#define LPI2C_MCR_MEN(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MCR_MEN_SHIFT))&LPI2C_MCR_MEN_MASK)\r\n#define LPI2C_MCR_RST_MASK                       0x2u\r\n#define LPI2C_MCR_RST_SHIFT                      1u\r\n#define LPI2C_MCR_RST_WIDTH                      1u\r\n#define LPI2C_MCR_RST(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MCR_RST_SHIFT))&LPI2C_MCR_RST_MASK)\r\n#define LPI2C_MCR_DOZEN_MASK                     0x4u\r\n#define LPI2C_MCR_DOZEN_SHIFT                    2u\r\n#define LPI2C_MCR_DOZEN_WIDTH                    1u\r\n#define LPI2C_MCR_DOZEN(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MCR_DOZEN_SHIFT))&LPI2C_MCR_DOZEN_MASK)\r\n#define LPI2C_MCR_DBGEN_MASK                     0x8u\r\n#define LPI2C_MCR_DBGEN_SHIFT                    3u\r\n#define LPI2C_MCR_DBGEN_WIDTH                    1u\r\n#define LPI2C_MCR_DBGEN(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MCR_DBGEN_SHIFT))&LPI2C_MCR_DBGEN_MASK)\r\n#define LPI2C_MCR_RTF_MASK                       0x100u\r\n#define LPI2C_MCR_RTF_SHIFT                      8u\r\n#define LPI2C_MCR_RTF_WIDTH                      1u\r\n#define LPI2C_MCR_RTF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MCR_RTF_SHIFT))&LPI2C_MCR_RTF_MASK)\r\n#define LPI2C_MCR_RRF_MASK                       0x200u\r\n#define LPI2C_MCR_RRF_SHIFT                      9u\r\n#define LPI2C_MCR_RRF_WIDTH                      1u\r\n#define LPI2C_MCR_RRF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MCR_RRF_SHIFT))&LPI2C_MCR_RRF_MASK)\r\n/* MSR Bit Fields */\r\n#define LPI2C_MSR_TDF_MASK                       0x1u\r\n#define LPI2C_MSR_TDF_SHIFT                      0u\r\n#define LPI2C_MSR_TDF_WIDTH                      1u\r\n#define LPI2C_MSR_TDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_TDF_SHIFT))&LPI2C_MSR_TDF_MASK)\r\n#define LPI2C_MSR_RDF_MASK                       0x2u\r\n#define LPI2C_MSR_RDF_SHIFT                      1u\r\n#define LPI2C_MSR_RDF_WIDTH                      1u\r\n#define LPI2C_MSR_RDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_RDF_SHIFT))&LPI2C_MSR_RDF_MASK)\r\n#define LPI2C_MSR_EPF_MASK                       0x100u\r\n#define LPI2C_MSR_EPF_SHIFT                      8u\r\n#define LPI2C_MSR_EPF_WIDTH                      1u\r\n#define LPI2C_MSR_EPF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_EPF_SHIFT))&LPI2C_MSR_EPF_MASK)\r\n#define LPI2C_MSR_SDF_MASK                       0x200u\r\n#define LPI2C_MSR_SDF_SHIFT                      9u\r\n#define LPI2C_MSR_SDF_WIDTH                      1u\r\n#define LPI2C_MSR_SDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_SDF_SHIFT))&LPI2C_MSR_SDF_MASK)\r\n#define LPI2C_MSR_NDF_MASK                       0x400u\r\n#define LPI2C_MSR_NDF_SHIFT                      10u\r\n#define LPI2C_MSR_NDF_WIDTH                      1u\r\n#define LPI2C_MSR_NDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_NDF_SHIFT))&LPI2C_MSR_NDF_MASK)\r\n#define LPI2C_MSR_ALF_MASK                       0x800u\r\n#define LPI2C_MSR_ALF_SHIFT                      11u\r\n#define LPI2C_MSR_ALF_WIDTH                      1u\r\n#define LPI2C_MSR_ALF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_ALF_SHIFT))&LPI2C_MSR_ALF_MASK)\r\n#define LPI2C_MSR_FEF_MASK                       0x1000u\r\n#define LPI2C_MSR_FEF_SHIFT                      12u\r\n#define LPI2C_MSR_FEF_WIDTH                      1u\r\n#define LPI2C_MSR_FEF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_FEF_SHIFT))&LPI2C_MSR_FEF_MASK)\r\n#define LPI2C_MSR_PLTF_MASK                      0x2000u\r\n#define LPI2C_MSR_PLTF_SHIFT                     13u\r\n#define LPI2C_MSR_PLTF_WIDTH                     1u\r\n#define LPI2C_MSR_PLTF(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_PLTF_SHIFT))&LPI2C_MSR_PLTF_MASK)\r\n#define LPI2C_MSR_DMF_MASK                       0x4000u\r\n#define LPI2C_MSR_DMF_SHIFT                      14u\r\n#define LPI2C_MSR_DMF_WIDTH                      1u\r\n#define LPI2C_MSR_DMF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_DMF_SHIFT))&LPI2C_MSR_DMF_MASK)\r\n#define LPI2C_MSR_MBF_MASK                       0x1000000u\r\n#define LPI2C_MSR_MBF_SHIFT                      24u\r\n#define LPI2C_MSR_MBF_WIDTH                      1u\r\n#define LPI2C_MSR_MBF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_MBF_SHIFT))&LPI2C_MSR_MBF_MASK)\r\n#define LPI2C_MSR_BBF_MASK                       0x2000000u\r\n#define LPI2C_MSR_BBF_SHIFT                      25u\r\n#define LPI2C_MSR_BBF_WIDTH                      1u\r\n#define LPI2C_MSR_BBF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_MSR_BBF_SHIFT))&LPI2C_MSR_BBF_MASK)\r\n/* MIER Bit Fields */\r\n#define LPI2C_MIER_TDIE_MASK                     0x1u\r\n#define LPI2C_MIER_TDIE_SHIFT                    0u\r\n#define LPI2C_MIER_TDIE_WIDTH                    1u\r\n#define LPI2C_MIER_TDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_TDIE_SHIFT))&LPI2C_MIER_TDIE_MASK)\r\n#define LPI2C_MIER_RDIE_MASK                     0x2u\r\n#define LPI2C_MIER_RDIE_SHIFT                    1u\r\n#define LPI2C_MIER_RDIE_WIDTH                    1u\r\n#define LPI2C_MIER_RDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_RDIE_SHIFT))&LPI2C_MIER_RDIE_MASK)\r\n#define LPI2C_MIER_EPIE_MASK                     0x100u\r\n#define LPI2C_MIER_EPIE_SHIFT                    8u\r\n#define LPI2C_MIER_EPIE_WIDTH                    1u\r\n#define LPI2C_MIER_EPIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_EPIE_SHIFT))&LPI2C_MIER_EPIE_MASK)\r\n#define LPI2C_MIER_SDIE_MASK                     0x200u\r\n#define LPI2C_MIER_SDIE_SHIFT                    9u\r\n#define LPI2C_MIER_SDIE_WIDTH                    1u\r\n#define LPI2C_MIER_SDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_SDIE_SHIFT))&LPI2C_MIER_SDIE_MASK)\r\n#define LPI2C_MIER_NDIE_MASK                     0x400u\r\n#define LPI2C_MIER_NDIE_SHIFT                    10u\r\n#define LPI2C_MIER_NDIE_WIDTH                    1u\r\n#define LPI2C_MIER_NDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_NDIE_SHIFT))&LPI2C_MIER_NDIE_MASK)\r\n#define LPI2C_MIER_ALIE_MASK                     0x800u\r\n#define LPI2C_MIER_ALIE_SHIFT                    11u\r\n#define LPI2C_MIER_ALIE_WIDTH                    1u\r\n#define LPI2C_MIER_ALIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_ALIE_SHIFT))&LPI2C_MIER_ALIE_MASK)\r\n#define LPI2C_MIER_FEIE_MASK                     0x1000u\r\n#define LPI2C_MIER_FEIE_SHIFT                    12u\r\n#define LPI2C_MIER_FEIE_WIDTH                    1u\r\n#define LPI2C_MIER_FEIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_FEIE_SHIFT))&LPI2C_MIER_FEIE_MASK)\r\n#define LPI2C_MIER_PLTIE_MASK                    0x2000u\r\n#define LPI2C_MIER_PLTIE_SHIFT                   13u\r\n#define LPI2C_MIER_PLTIE_WIDTH                   1u\r\n#define LPI2C_MIER_PLTIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_PLTIE_SHIFT))&LPI2C_MIER_PLTIE_MASK)\r\n#define LPI2C_MIER_DMIE_MASK                     0x4000u\r\n#define LPI2C_MIER_DMIE_SHIFT                    14u\r\n#define LPI2C_MIER_DMIE_WIDTH                    1u\r\n#define LPI2C_MIER_DMIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MIER_DMIE_SHIFT))&LPI2C_MIER_DMIE_MASK)\r\n/* MDER Bit Fields */\r\n#define LPI2C_MDER_TDDE_MASK                     0x1u\r\n#define LPI2C_MDER_TDDE_SHIFT                    0u\r\n#define LPI2C_MDER_TDDE_WIDTH                    1u\r\n#define LPI2C_MDER_TDDE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MDER_TDDE_SHIFT))&LPI2C_MDER_TDDE_MASK)\r\n#define LPI2C_MDER_RDDE_MASK                     0x2u\r\n#define LPI2C_MDER_RDDE_SHIFT                    1u\r\n#define LPI2C_MDER_RDDE_WIDTH                    1u\r\n#define LPI2C_MDER_RDDE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MDER_RDDE_SHIFT))&LPI2C_MDER_RDDE_MASK)\r\n/* MCFGR0 Bit Fields */\r\n#define LPI2C_MCFGR0_HREN_MASK                   0x1u\r\n#define LPI2C_MCFGR0_HREN_SHIFT                  0u\r\n#define LPI2C_MCFGR0_HREN_WIDTH                  1u\r\n#define LPI2C_MCFGR0_HREN(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR0_HREN_SHIFT))&LPI2C_MCFGR0_HREN_MASK)\r\n#define LPI2C_MCFGR0_HRPOL_MASK                  0x2u\r\n#define LPI2C_MCFGR0_HRPOL_SHIFT                 1u\r\n#define LPI2C_MCFGR0_HRPOL_WIDTH                 1u\r\n#define LPI2C_MCFGR0_HRPOL(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR0_HRPOL_SHIFT))&LPI2C_MCFGR0_HRPOL_MASK)\r\n#define LPI2C_MCFGR0_HRSEL_MASK                  0x4u\r\n#define LPI2C_MCFGR0_HRSEL_SHIFT                 2u\r\n#define LPI2C_MCFGR0_HRSEL_WIDTH                 1u\r\n#define LPI2C_MCFGR0_HRSEL(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR0_HRSEL_SHIFT))&LPI2C_MCFGR0_HRSEL_MASK)\r\n#define LPI2C_MCFGR0_CIRFIFO_MASK                0x100u\r\n#define LPI2C_MCFGR0_CIRFIFO_SHIFT               8u\r\n#define LPI2C_MCFGR0_CIRFIFO_WIDTH               1u\r\n#define LPI2C_MCFGR0_CIRFIFO(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR0_CIRFIFO_SHIFT))&LPI2C_MCFGR0_CIRFIFO_MASK)\r\n#define LPI2C_MCFGR0_RDMO_MASK                   0x200u\r\n#define LPI2C_MCFGR0_RDMO_SHIFT                  9u\r\n#define LPI2C_MCFGR0_RDMO_WIDTH                  1u\r\n#define LPI2C_MCFGR0_RDMO(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR0_RDMO_SHIFT))&LPI2C_MCFGR0_RDMO_MASK)\r\n/* MCFGR1 Bit Fields */\r\n#define LPI2C_MCFGR1_PRESCALE_MASK               0x7u\r\n#define LPI2C_MCFGR1_PRESCALE_SHIFT              0u\r\n#define LPI2C_MCFGR1_PRESCALE_WIDTH              3u\r\n#define LPI2C_MCFGR1_PRESCALE(x)                 (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR1_PRESCALE_SHIFT))&LPI2C_MCFGR1_PRESCALE_MASK)\r\n#define LPI2C_MCFGR1_AUTOSTOP_MASK               0x100u\r\n#define LPI2C_MCFGR1_AUTOSTOP_SHIFT              8u\r\n#define LPI2C_MCFGR1_AUTOSTOP_WIDTH              1u\r\n#define LPI2C_MCFGR1_AUTOSTOP(x)                 (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR1_AUTOSTOP_SHIFT))&LPI2C_MCFGR1_AUTOSTOP_MASK)\r\n#define LPI2C_MCFGR1_IGNACK_MASK                 0x200u\r\n#define LPI2C_MCFGR1_IGNACK_SHIFT                9u\r\n#define LPI2C_MCFGR1_IGNACK_WIDTH                1u\r\n#define LPI2C_MCFGR1_IGNACK(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR1_IGNACK_SHIFT))&LPI2C_MCFGR1_IGNACK_MASK)\r\n#define LPI2C_MCFGR1_TIMECFG_MASK                0x400u\r\n#define LPI2C_MCFGR1_TIMECFG_SHIFT               10u\r\n#define LPI2C_MCFGR1_TIMECFG_WIDTH               1u\r\n#define LPI2C_MCFGR1_TIMECFG(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR1_TIMECFG_SHIFT))&LPI2C_MCFGR1_TIMECFG_MASK)\r\n#define LPI2C_MCFGR1_MATCFG_MASK                 0x70000u\r\n#define LPI2C_MCFGR1_MATCFG_SHIFT                16u\r\n#define LPI2C_MCFGR1_MATCFG_WIDTH                3u\r\n#define LPI2C_MCFGR1_MATCFG(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR1_MATCFG_SHIFT))&LPI2C_MCFGR1_MATCFG_MASK)\r\n#define LPI2C_MCFGR1_PINCFG_MASK                 0x7000000u\r\n#define LPI2C_MCFGR1_PINCFG_SHIFT                24u\r\n#define LPI2C_MCFGR1_PINCFG_WIDTH                3u\r\n#define LPI2C_MCFGR1_PINCFG(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR1_PINCFG_SHIFT))&LPI2C_MCFGR1_PINCFG_MASK)\r\n/* MCFGR2 Bit Fields */\r\n#define LPI2C_MCFGR2_BUSIDLE_MASK                0xFFFu\r\n#define LPI2C_MCFGR2_BUSIDLE_SHIFT               0u\r\n#define LPI2C_MCFGR2_BUSIDLE_WIDTH               12u\r\n#define LPI2C_MCFGR2_BUSIDLE(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR2_BUSIDLE_SHIFT))&LPI2C_MCFGR2_BUSIDLE_MASK)\r\n#define LPI2C_MCFGR2_FILTSCL_MASK                0xF0000u\r\n#define LPI2C_MCFGR2_FILTSCL_SHIFT               16u\r\n#define LPI2C_MCFGR2_FILTSCL_WIDTH               4u\r\n#define LPI2C_MCFGR2_FILTSCL(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR2_FILTSCL_SHIFT))&LPI2C_MCFGR2_FILTSCL_MASK)\r\n#define LPI2C_MCFGR2_FILTSDA_MASK                0xF000000u\r\n#define LPI2C_MCFGR2_FILTSDA_SHIFT               24u\r\n#define LPI2C_MCFGR2_FILTSDA_WIDTH               4u\r\n#define LPI2C_MCFGR2_FILTSDA(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR2_FILTSDA_SHIFT))&LPI2C_MCFGR2_FILTSDA_MASK)\r\n/* MCFGR3 Bit Fields */\r\n#define LPI2C_MCFGR3_PINLOW_MASK                 0xFFF00u\r\n#define LPI2C_MCFGR3_PINLOW_SHIFT                8u\r\n#define LPI2C_MCFGR3_PINLOW_WIDTH                12u\r\n#define LPI2C_MCFGR3_PINLOW(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_MCFGR3_PINLOW_SHIFT))&LPI2C_MCFGR3_PINLOW_MASK)\r\n/* MDMR Bit Fields */\r\n#define LPI2C_MDMR_MATCH0_MASK                   0xFFu\r\n#define LPI2C_MDMR_MATCH0_SHIFT                  0u\r\n#define LPI2C_MDMR_MATCH0_WIDTH                  8u\r\n#define LPI2C_MDMR_MATCH0(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MDMR_MATCH0_SHIFT))&LPI2C_MDMR_MATCH0_MASK)\r\n#define LPI2C_MDMR_MATCH1_MASK                   0xFF0000u\r\n#define LPI2C_MDMR_MATCH1_SHIFT                  16u\r\n#define LPI2C_MDMR_MATCH1_WIDTH                  8u\r\n#define LPI2C_MDMR_MATCH1(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MDMR_MATCH1_SHIFT))&LPI2C_MDMR_MATCH1_MASK)\r\n/* MCCR0 Bit Fields */\r\n#define LPI2C_MCCR0_CLKLO_MASK                   0x3Fu\r\n#define LPI2C_MCCR0_CLKLO_SHIFT                  0u\r\n#define LPI2C_MCCR0_CLKLO_WIDTH                  6u\r\n#define LPI2C_MCCR0_CLKLO(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR0_CLKLO_SHIFT))&LPI2C_MCCR0_CLKLO_MASK)\r\n#define LPI2C_MCCR0_CLKHI_MASK                   0x3F00u\r\n#define LPI2C_MCCR0_CLKHI_SHIFT                  8u\r\n#define LPI2C_MCCR0_CLKHI_WIDTH                  6u\r\n#define LPI2C_MCCR0_CLKHI(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR0_CLKHI_SHIFT))&LPI2C_MCCR0_CLKHI_MASK)\r\n#define LPI2C_MCCR0_SETHOLD_MASK                 0x3F0000u\r\n#define LPI2C_MCCR0_SETHOLD_SHIFT                16u\r\n#define LPI2C_MCCR0_SETHOLD_WIDTH                6u\r\n#define LPI2C_MCCR0_SETHOLD(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR0_SETHOLD_SHIFT))&LPI2C_MCCR0_SETHOLD_MASK)\r\n#define LPI2C_MCCR0_DATAVD_MASK                  0x3F000000u\r\n#define LPI2C_MCCR0_DATAVD_SHIFT                 24u\r\n#define LPI2C_MCCR0_DATAVD_WIDTH                 6u\r\n#define LPI2C_MCCR0_DATAVD(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR0_DATAVD_SHIFT))&LPI2C_MCCR0_DATAVD_MASK)\r\n/* MCCR1 Bit Fields */\r\n#define LPI2C_MCCR1_CLKLO_MASK                   0x3Fu\r\n#define LPI2C_MCCR1_CLKLO_SHIFT                  0u\r\n#define LPI2C_MCCR1_CLKLO_WIDTH                  6u\r\n#define LPI2C_MCCR1_CLKLO(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR1_CLKLO_SHIFT))&LPI2C_MCCR1_CLKLO_MASK)\r\n#define LPI2C_MCCR1_CLKHI_MASK                   0x3F00u\r\n#define LPI2C_MCCR1_CLKHI_SHIFT                  8u\r\n#define LPI2C_MCCR1_CLKHI_WIDTH                  6u\r\n#define LPI2C_MCCR1_CLKHI(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR1_CLKHI_SHIFT))&LPI2C_MCCR1_CLKHI_MASK)\r\n#define LPI2C_MCCR1_SETHOLD_MASK                 0x3F0000u\r\n#define LPI2C_MCCR1_SETHOLD_SHIFT                16u\r\n#define LPI2C_MCCR1_SETHOLD_WIDTH                6u\r\n#define LPI2C_MCCR1_SETHOLD(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR1_SETHOLD_SHIFT))&LPI2C_MCCR1_SETHOLD_MASK)\r\n#define LPI2C_MCCR1_DATAVD_MASK                  0x3F000000u\r\n#define LPI2C_MCCR1_DATAVD_SHIFT                 24u\r\n#define LPI2C_MCCR1_DATAVD_WIDTH                 6u\r\n#define LPI2C_MCCR1_DATAVD(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MCCR1_DATAVD_SHIFT))&LPI2C_MCCR1_DATAVD_MASK)\r\n/* MFCR Bit Fields */\r\n#define LPI2C_MFCR_TXWATER_MASK                  0x3u\r\n#define LPI2C_MFCR_TXWATER_SHIFT                 0u\r\n#define LPI2C_MFCR_TXWATER_WIDTH                 2u\r\n#define LPI2C_MFCR_TXWATER(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MFCR_TXWATER_SHIFT))&LPI2C_MFCR_TXWATER_MASK)\r\n#define LPI2C_MFCR_RXWATER_MASK                  0x30000u\r\n#define LPI2C_MFCR_RXWATER_SHIFT                 16u\r\n#define LPI2C_MFCR_RXWATER_WIDTH                 2u\r\n#define LPI2C_MFCR_RXWATER(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MFCR_RXWATER_SHIFT))&LPI2C_MFCR_RXWATER_MASK)\r\n/* MFSR Bit Fields */\r\n#define LPI2C_MFSR_TXCOUNT_MASK                  0x7u\r\n#define LPI2C_MFSR_TXCOUNT_SHIFT                 0u\r\n#define LPI2C_MFSR_TXCOUNT_WIDTH                 3u\r\n#define LPI2C_MFSR_TXCOUNT(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MFSR_TXCOUNT_SHIFT))&LPI2C_MFSR_TXCOUNT_MASK)\r\n#define LPI2C_MFSR_RXCOUNT_MASK                  0x70000u\r\n#define LPI2C_MFSR_RXCOUNT_SHIFT                 16u\r\n#define LPI2C_MFSR_RXCOUNT_WIDTH                 3u\r\n#define LPI2C_MFSR_RXCOUNT(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MFSR_RXCOUNT_SHIFT))&LPI2C_MFSR_RXCOUNT_MASK)\r\n/* MTDR Bit Fields */\r\n#define LPI2C_MTDR_DATA_MASK                     0xFFu\r\n#define LPI2C_MTDR_DATA_SHIFT                    0u\r\n#define LPI2C_MTDR_DATA_WIDTH                    8u\r\n#define LPI2C_MTDR_DATA(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MTDR_DATA_SHIFT))&LPI2C_MTDR_DATA_MASK)\r\n#define LPI2C_MTDR_CMD_MASK                      0x700u\r\n#define LPI2C_MTDR_CMD_SHIFT                     8u\r\n#define LPI2C_MTDR_CMD_WIDTH                     3u\r\n#define LPI2C_MTDR_CMD(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_MTDR_CMD_SHIFT))&LPI2C_MTDR_CMD_MASK)\r\n/* MRDR Bit Fields */\r\n#define LPI2C_MRDR_DATA_MASK                     0xFFu\r\n#define LPI2C_MRDR_DATA_SHIFT                    0u\r\n#define LPI2C_MRDR_DATA_WIDTH                    8u\r\n#define LPI2C_MRDR_DATA(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_MRDR_DATA_SHIFT))&LPI2C_MRDR_DATA_MASK)\r\n#define LPI2C_MRDR_RXEMPTY_MASK                  0x4000u\r\n#define LPI2C_MRDR_RXEMPTY_SHIFT                 14u\r\n#define LPI2C_MRDR_RXEMPTY_WIDTH                 1u\r\n#define LPI2C_MRDR_RXEMPTY(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_MRDR_RXEMPTY_SHIFT))&LPI2C_MRDR_RXEMPTY_MASK)\r\n/* SCR Bit Fields */\r\n#define LPI2C_SCR_SEN_MASK                       0x1u\r\n#define LPI2C_SCR_SEN_SHIFT                      0u\r\n#define LPI2C_SCR_SEN_WIDTH                      1u\r\n#define LPI2C_SCR_SEN(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SCR_SEN_SHIFT))&LPI2C_SCR_SEN_MASK)\r\n#define LPI2C_SCR_RST_MASK                       0x2u\r\n#define LPI2C_SCR_RST_SHIFT                      1u\r\n#define LPI2C_SCR_RST_WIDTH                      1u\r\n#define LPI2C_SCR_RST(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SCR_RST_SHIFT))&LPI2C_SCR_RST_MASK)\r\n#define LPI2C_SCR_FILTEN_MASK                    0x10u\r\n#define LPI2C_SCR_FILTEN_SHIFT                   4u\r\n#define LPI2C_SCR_FILTEN_WIDTH                   1u\r\n#define LPI2C_SCR_FILTEN(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SCR_FILTEN_SHIFT))&LPI2C_SCR_FILTEN_MASK)\r\n#define LPI2C_SCR_FILTDZ_MASK                    0x20u\r\n#define LPI2C_SCR_FILTDZ_SHIFT                   5u\r\n#define LPI2C_SCR_FILTDZ_WIDTH                   1u\r\n#define LPI2C_SCR_FILTDZ(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SCR_FILTDZ_SHIFT))&LPI2C_SCR_FILTDZ_MASK)\r\n#define LPI2C_SCR_RTF_MASK                       0x100u\r\n#define LPI2C_SCR_RTF_SHIFT                      8u\r\n#define LPI2C_SCR_RTF_WIDTH                      1u\r\n#define LPI2C_SCR_RTF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SCR_RTF_SHIFT))&LPI2C_SCR_RTF_MASK)\r\n#define LPI2C_SCR_RRF_MASK                       0x200u\r\n#define LPI2C_SCR_RRF_SHIFT                      9u\r\n#define LPI2C_SCR_RRF_WIDTH                      1u\r\n#define LPI2C_SCR_RRF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SCR_RRF_SHIFT))&LPI2C_SCR_RRF_MASK)\r\n/* SSR Bit Fields */\r\n#define LPI2C_SSR_TDF_MASK                       0x1u\r\n#define LPI2C_SSR_TDF_SHIFT                      0u\r\n#define LPI2C_SSR_TDF_WIDTH                      1u\r\n#define LPI2C_SSR_TDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_TDF_SHIFT))&LPI2C_SSR_TDF_MASK)\r\n#define LPI2C_SSR_RDF_MASK                       0x2u\r\n#define LPI2C_SSR_RDF_SHIFT                      1u\r\n#define LPI2C_SSR_RDF_WIDTH                      1u\r\n#define LPI2C_SSR_RDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_RDF_SHIFT))&LPI2C_SSR_RDF_MASK)\r\n#define LPI2C_SSR_AVF_MASK                       0x4u\r\n#define LPI2C_SSR_AVF_SHIFT                      2u\r\n#define LPI2C_SSR_AVF_WIDTH                      1u\r\n#define LPI2C_SSR_AVF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_AVF_SHIFT))&LPI2C_SSR_AVF_MASK)\r\n#define LPI2C_SSR_TAF_MASK                       0x8u\r\n#define LPI2C_SSR_TAF_SHIFT                      3u\r\n#define LPI2C_SSR_TAF_WIDTH                      1u\r\n#define LPI2C_SSR_TAF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_TAF_SHIFT))&LPI2C_SSR_TAF_MASK)\r\n#define LPI2C_SSR_RSF_MASK                       0x100u\r\n#define LPI2C_SSR_RSF_SHIFT                      8u\r\n#define LPI2C_SSR_RSF_WIDTH                      1u\r\n#define LPI2C_SSR_RSF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_RSF_SHIFT))&LPI2C_SSR_RSF_MASK)\r\n#define LPI2C_SSR_SDF_MASK                       0x200u\r\n#define LPI2C_SSR_SDF_SHIFT                      9u\r\n#define LPI2C_SSR_SDF_WIDTH                      1u\r\n#define LPI2C_SSR_SDF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_SDF_SHIFT))&LPI2C_SSR_SDF_MASK)\r\n#define LPI2C_SSR_BEF_MASK                       0x400u\r\n#define LPI2C_SSR_BEF_SHIFT                      10u\r\n#define LPI2C_SSR_BEF_WIDTH                      1u\r\n#define LPI2C_SSR_BEF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_BEF_SHIFT))&LPI2C_SSR_BEF_MASK)\r\n#define LPI2C_SSR_FEF_MASK                       0x800u\r\n#define LPI2C_SSR_FEF_SHIFT                      11u\r\n#define LPI2C_SSR_FEF_WIDTH                      1u\r\n#define LPI2C_SSR_FEF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_FEF_SHIFT))&LPI2C_SSR_FEF_MASK)\r\n#define LPI2C_SSR_AM0F_MASK                      0x1000u\r\n#define LPI2C_SSR_AM0F_SHIFT                     12u\r\n#define LPI2C_SSR_AM0F_WIDTH                     1u\r\n#define LPI2C_SSR_AM0F(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_AM0F_SHIFT))&LPI2C_SSR_AM0F_MASK)\r\n#define LPI2C_SSR_AM1F_MASK                      0x2000u\r\n#define LPI2C_SSR_AM1F_SHIFT                     13u\r\n#define LPI2C_SSR_AM1F_WIDTH                     1u\r\n#define LPI2C_SSR_AM1F(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_AM1F_SHIFT))&LPI2C_SSR_AM1F_MASK)\r\n#define LPI2C_SSR_GCF_MASK                       0x4000u\r\n#define LPI2C_SSR_GCF_SHIFT                      14u\r\n#define LPI2C_SSR_GCF_WIDTH                      1u\r\n#define LPI2C_SSR_GCF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_GCF_SHIFT))&LPI2C_SSR_GCF_MASK)\r\n#define LPI2C_SSR_SARF_MASK                      0x8000u\r\n#define LPI2C_SSR_SARF_SHIFT                     15u\r\n#define LPI2C_SSR_SARF_WIDTH                     1u\r\n#define LPI2C_SSR_SARF(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_SARF_SHIFT))&LPI2C_SSR_SARF_MASK)\r\n#define LPI2C_SSR_SBF_MASK                       0x1000000u\r\n#define LPI2C_SSR_SBF_SHIFT                      24u\r\n#define LPI2C_SSR_SBF_WIDTH                      1u\r\n#define LPI2C_SSR_SBF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_SBF_SHIFT))&LPI2C_SSR_SBF_MASK)\r\n#define LPI2C_SSR_BBF_MASK                       0x2000000u\r\n#define LPI2C_SSR_BBF_SHIFT                      25u\r\n#define LPI2C_SSR_BBF_WIDTH                      1u\r\n#define LPI2C_SSR_BBF(x)                         (((uint32_t)(((uint32_t)(x))<<LPI2C_SSR_BBF_SHIFT))&LPI2C_SSR_BBF_MASK)\r\n/* SIER Bit Fields */\r\n#define LPI2C_SIER_TDIE_MASK                     0x1u\r\n#define LPI2C_SIER_TDIE_SHIFT                    0u\r\n#define LPI2C_SIER_TDIE_WIDTH                    1u\r\n#define LPI2C_SIER_TDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_TDIE_SHIFT))&LPI2C_SIER_TDIE_MASK)\r\n#define LPI2C_SIER_RDIE_MASK                     0x2u\r\n#define LPI2C_SIER_RDIE_SHIFT                    1u\r\n#define LPI2C_SIER_RDIE_WIDTH                    1u\r\n#define LPI2C_SIER_RDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_RDIE_SHIFT))&LPI2C_SIER_RDIE_MASK)\r\n#define LPI2C_SIER_AVIE_MASK                     0x4u\r\n#define LPI2C_SIER_AVIE_SHIFT                    2u\r\n#define LPI2C_SIER_AVIE_WIDTH                    1u\r\n#define LPI2C_SIER_AVIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_AVIE_SHIFT))&LPI2C_SIER_AVIE_MASK)\r\n#define LPI2C_SIER_TAIE_MASK                     0x8u\r\n#define LPI2C_SIER_TAIE_SHIFT                    3u\r\n#define LPI2C_SIER_TAIE_WIDTH                    1u\r\n#define LPI2C_SIER_TAIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_TAIE_SHIFT))&LPI2C_SIER_TAIE_MASK)\r\n#define LPI2C_SIER_RSIE_MASK                     0x100u\r\n#define LPI2C_SIER_RSIE_SHIFT                    8u\r\n#define LPI2C_SIER_RSIE_WIDTH                    1u\r\n#define LPI2C_SIER_RSIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_RSIE_SHIFT))&LPI2C_SIER_RSIE_MASK)\r\n#define LPI2C_SIER_SDIE_MASK                     0x200u\r\n#define LPI2C_SIER_SDIE_SHIFT                    9u\r\n#define LPI2C_SIER_SDIE_WIDTH                    1u\r\n#define LPI2C_SIER_SDIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_SDIE_SHIFT))&LPI2C_SIER_SDIE_MASK)\r\n#define LPI2C_SIER_BEIE_MASK                     0x400u\r\n#define LPI2C_SIER_BEIE_SHIFT                    10u\r\n#define LPI2C_SIER_BEIE_WIDTH                    1u\r\n#define LPI2C_SIER_BEIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_BEIE_SHIFT))&LPI2C_SIER_BEIE_MASK)\r\n#define LPI2C_SIER_FEIE_MASK                     0x800u\r\n#define LPI2C_SIER_FEIE_SHIFT                    11u\r\n#define LPI2C_SIER_FEIE_WIDTH                    1u\r\n#define LPI2C_SIER_FEIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_FEIE_SHIFT))&LPI2C_SIER_FEIE_MASK)\r\n#define LPI2C_SIER_AM0IE_MASK                    0x1000u\r\n#define LPI2C_SIER_AM0IE_SHIFT                   12u\r\n#define LPI2C_SIER_AM0IE_WIDTH                   1u\r\n#define LPI2C_SIER_AM0IE(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_AM0IE_SHIFT))&LPI2C_SIER_AM0IE_MASK)\r\n#define LPI2C_SIER_AM1F_MASK                     0x2000u\r\n#define LPI2C_SIER_AM1F_SHIFT                    13u\r\n#define LPI2C_SIER_AM1F_WIDTH                    1u\r\n#define LPI2C_SIER_AM1F(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_AM1F_SHIFT))&LPI2C_SIER_AM1F_MASK)\r\n#define LPI2C_SIER_GCIE_MASK                     0x4000u\r\n#define LPI2C_SIER_GCIE_SHIFT                    14u\r\n#define LPI2C_SIER_GCIE_WIDTH                    1u\r\n#define LPI2C_SIER_GCIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_GCIE_SHIFT))&LPI2C_SIER_GCIE_MASK)\r\n#define LPI2C_SIER_SARIE_MASK                    0x8000u\r\n#define LPI2C_SIER_SARIE_SHIFT                   15u\r\n#define LPI2C_SIER_SARIE_WIDTH                   1u\r\n#define LPI2C_SIER_SARIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SIER_SARIE_SHIFT))&LPI2C_SIER_SARIE_MASK)\r\n/* SDER Bit Fields */\r\n#define LPI2C_SDER_TDDE_MASK                     0x1u\r\n#define LPI2C_SDER_TDDE_SHIFT                    0u\r\n#define LPI2C_SDER_TDDE_WIDTH                    1u\r\n#define LPI2C_SDER_TDDE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SDER_TDDE_SHIFT))&LPI2C_SDER_TDDE_MASK)\r\n#define LPI2C_SDER_RDDE_MASK                     0x2u\r\n#define LPI2C_SDER_RDDE_SHIFT                    1u\r\n#define LPI2C_SDER_RDDE_WIDTH                    1u\r\n#define LPI2C_SDER_RDDE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SDER_RDDE_SHIFT))&LPI2C_SDER_RDDE_MASK)\r\n#define LPI2C_SDER_AVDE_MASK                     0x4u\r\n#define LPI2C_SDER_AVDE_SHIFT                    2u\r\n#define LPI2C_SDER_AVDE_WIDTH                    1u\r\n#define LPI2C_SDER_AVDE(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SDER_AVDE_SHIFT))&LPI2C_SDER_AVDE_MASK)\r\n/* SCFGR1 Bit Fields */\r\n#define LPI2C_SCFGR1_ADRSTALL_MASK               0x1u\r\n#define LPI2C_SCFGR1_ADRSTALL_SHIFT              0u\r\n#define LPI2C_SCFGR1_ADRSTALL_WIDTH              1u\r\n#define LPI2C_SCFGR1_ADRSTALL(x)                 (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_ADRSTALL_SHIFT))&LPI2C_SCFGR1_ADRSTALL_MASK)\r\n#define LPI2C_SCFGR1_RXSTALL_MASK                0x2u\r\n#define LPI2C_SCFGR1_RXSTALL_SHIFT               1u\r\n#define LPI2C_SCFGR1_RXSTALL_WIDTH               1u\r\n#define LPI2C_SCFGR1_RXSTALL(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_RXSTALL_SHIFT))&LPI2C_SCFGR1_RXSTALL_MASK)\r\n#define LPI2C_SCFGR1_TXDSTALL_MASK               0x4u\r\n#define LPI2C_SCFGR1_TXDSTALL_SHIFT              2u\r\n#define LPI2C_SCFGR1_TXDSTALL_WIDTH              1u\r\n#define LPI2C_SCFGR1_TXDSTALL(x)                 (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_TXDSTALL_SHIFT))&LPI2C_SCFGR1_TXDSTALL_MASK)\r\n#define LPI2C_SCFGR1_ACKSTALL_MASK               0x8u\r\n#define LPI2C_SCFGR1_ACKSTALL_SHIFT              3u\r\n#define LPI2C_SCFGR1_ACKSTALL_WIDTH              1u\r\n#define LPI2C_SCFGR1_ACKSTALL(x)                 (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_ACKSTALL_SHIFT))&LPI2C_SCFGR1_ACKSTALL_MASK)\r\n#define LPI2C_SCFGR1_GCEN_MASK                   0x100u\r\n#define LPI2C_SCFGR1_GCEN_SHIFT                  8u\r\n#define LPI2C_SCFGR1_GCEN_WIDTH                  1u\r\n#define LPI2C_SCFGR1_GCEN(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_GCEN_SHIFT))&LPI2C_SCFGR1_GCEN_MASK)\r\n#define LPI2C_SCFGR1_SAEN_MASK                   0x200u\r\n#define LPI2C_SCFGR1_SAEN_SHIFT                  9u\r\n#define LPI2C_SCFGR1_SAEN_WIDTH                  1u\r\n#define LPI2C_SCFGR1_SAEN(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_SAEN_SHIFT))&LPI2C_SCFGR1_SAEN_MASK)\r\n#define LPI2C_SCFGR1_TXCFG_MASK                  0x400u\r\n#define LPI2C_SCFGR1_TXCFG_SHIFT                 10u\r\n#define LPI2C_SCFGR1_TXCFG_WIDTH                 1u\r\n#define LPI2C_SCFGR1_TXCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_TXCFG_SHIFT))&LPI2C_SCFGR1_TXCFG_MASK)\r\n#define LPI2C_SCFGR1_RXCFG_MASK                  0x800u\r\n#define LPI2C_SCFGR1_RXCFG_SHIFT                 11u\r\n#define LPI2C_SCFGR1_RXCFG_WIDTH                 1u\r\n#define LPI2C_SCFGR1_RXCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_RXCFG_SHIFT))&LPI2C_SCFGR1_RXCFG_MASK)\r\n#define LPI2C_SCFGR1_IGNACK_MASK                 0x1000u\r\n#define LPI2C_SCFGR1_IGNACK_SHIFT                12u\r\n#define LPI2C_SCFGR1_IGNACK_WIDTH                1u\r\n#define LPI2C_SCFGR1_IGNACK(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_IGNACK_SHIFT))&LPI2C_SCFGR1_IGNACK_MASK)\r\n#define LPI2C_SCFGR1_HSMEN_MASK                  0x2000u\r\n#define LPI2C_SCFGR1_HSMEN_SHIFT                 13u\r\n#define LPI2C_SCFGR1_HSMEN_WIDTH                 1u\r\n#define LPI2C_SCFGR1_HSMEN(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_HSMEN_SHIFT))&LPI2C_SCFGR1_HSMEN_MASK)\r\n#define LPI2C_SCFGR1_ADDRCFG_MASK                0x70000u\r\n#define LPI2C_SCFGR1_ADDRCFG_SHIFT               16u\r\n#define LPI2C_SCFGR1_ADDRCFG_WIDTH               3u\r\n#define LPI2C_SCFGR1_ADDRCFG(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR1_ADDRCFG_SHIFT))&LPI2C_SCFGR1_ADDRCFG_MASK)\r\n/* SCFGR2 Bit Fields */\r\n#define LPI2C_SCFGR2_CLKHOLD_MASK                0xFu\r\n#define LPI2C_SCFGR2_CLKHOLD_SHIFT               0u\r\n#define LPI2C_SCFGR2_CLKHOLD_WIDTH               4u\r\n#define LPI2C_SCFGR2_CLKHOLD(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR2_CLKHOLD_SHIFT))&LPI2C_SCFGR2_CLKHOLD_MASK)\r\n#define LPI2C_SCFGR2_DATAVD_MASK                 0x3F00u\r\n#define LPI2C_SCFGR2_DATAVD_SHIFT                8u\r\n#define LPI2C_SCFGR2_DATAVD_WIDTH                6u\r\n#define LPI2C_SCFGR2_DATAVD(x)                   (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR2_DATAVD_SHIFT))&LPI2C_SCFGR2_DATAVD_MASK)\r\n#define LPI2C_SCFGR2_FILTSCL_MASK                0xF0000u\r\n#define LPI2C_SCFGR2_FILTSCL_SHIFT               16u\r\n#define LPI2C_SCFGR2_FILTSCL_WIDTH               4u\r\n#define LPI2C_SCFGR2_FILTSCL(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR2_FILTSCL_SHIFT))&LPI2C_SCFGR2_FILTSCL_MASK)\r\n#define LPI2C_SCFGR2_FILTSDA_MASK                0xF000000u\r\n#define LPI2C_SCFGR2_FILTSDA_SHIFT               24u\r\n#define LPI2C_SCFGR2_FILTSDA_WIDTH               4u\r\n#define LPI2C_SCFGR2_FILTSDA(x)                  (((uint32_t)(((uint32_t)(x))<<LPI2C_SCFGR2_FILTSDA_SHIFT))&LPI2C_SCFGR2_FILTSDA_MASK)\r\n/* SAMR Bit Fields */\r\n#define LPI2C_SAMR_ADDR0_MASK                    0x7FEu\r\n#define LPI2C_SAMR_ADDR0_SHIFT                   1u\r\n#define LPI2C_SAMR_ADDR0_WIDTH                   10u\r\n#define LPI2C_SAMR_ADDR0(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SAMR_ADDR0_SHIFT))&LPI2C_SAMR_ADDR0_MASK)\r\n#define LPI2C_SAMR_ADDR1_MASK                    0x7FE0000u\r\n#define LPI2C_SAMR_ADDR1_SHIFT                   17u\r\n#define LPI2C_SAMR_ADDR1_WIDTH                   10u\r\n#define LPI2C_SAMR_ADDR1(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SAMR_ADDR1_SHIFT))&LPI2C_SAMR_ADDR1_MASK)\r\n/* SASR Bit Fields */\r\n#define LPI2C_SASR_RADDR_MASK                    0x7FFu\r\n#define LPI2C_SASR_RADDR_SHIFT                   0u\r\n#define LPI2C_SASR_RADDR_WIDTH                   11u\r\n#define LPI2C_SASR_RADDR(x)                      (((uint32_t)(((uint32_t)(x))<<LPI2C_SASR_RADDR_SHIFT))&LPI2C_SASR_RADDR_MASK)\r\n#define LPI2C_SASR_ANV_MASK                      0x4000u\r\n#define LPI2C_SASR_ANV_SHIFT                     14u\r\n#define LPI2C_SASR_ANV_WIDTH                     1u\r\n#define LPI2C_SASR_ANV(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_SASR_ANV_SHIFT))&LPI2C_SASR_ANV_MASK)\r\n/* STAR Bit Fields */\r\n#define LPI2C_STAR_TXNACK_MASK                   0x1u\r\n#define LPI2C_STAR_TXNACK_SHIFT                  0u\r\n#define LPI2C_STAR_TXNACK_WIDTH                  1u\r\n#define LPI2C_STAR_TXNACK(x)                     (((uint32_t)(((uint32_t)(x))<<LPI2C_STAR_TXNACK_SHIFT))&LPI2C_STAR_TXNACK_MASK)\r\n/* STDR Bit Fields */\r\n#define LPI2C_STDR_DATA_MASK                     0xFFu\r\n#define LPI2C_STDR_DATA_SHIFT                    0u\r\n#define LPI2C_STDR_DATA_WIDTH                    8u\r\n#define LPI2C_STDR_DATA(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_STDR_DATA_SHIFT))&LPI2C_STDR_DATA_MASK)\r\n/* SRDR Bit Fields */\r\n#define LPI2C_SRDR_DATA_MASK                     0xFFu\r\n#define LPI2C_SRDR_DATA_SHIFT                    0u\r\n#define LPI2C_SRDR_DATA_WIDTH                    8u\r\n#define LPI2C_SRDR_DATA(x)                       (((uint32_t)(((uint32_t)(x))<<LPI2C_SRDR_DATA_SHIFT))&LPI2C_SRDR_DATA_MASK)\r\n#define LPI2C_SRDR_RXEMPTY_MASK                  0x4000u\r\n#define LPI2C_SRDR_RXEMPTY_SHIFT                 14u\r\n#define LPI2C_SRDR_RXEMPTY_WIDTH                 1u\r\n#define LPI2C_SRDR_RXEMPTY(x)                    (((uint32_t)(((uint32_t)(x))<<LPI2C_SRDR_RXEMPTY_SHIFT))&LPI2C_SRDR_RXEMPTY_MASK)\r\n#define LPI2C_SRDR_SOF_MASK                      0x8000u\r\n#define LPI2C_SRDR_SOF_SHIFT                     15u\r\n#define LPI2C_SRDR_SOF_WIDTH                     1u\r\n#define LPI2C_SRDR_SOF(x)                        (((uint32_t)(((uint32_t)(x))<<LPI2C_SRDR_SOF_SHIFT))&LPI2C_SRDR_SOF_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPI2C_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPI2C_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPIT Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPIT_Peripheral_Access_Layer LPIT Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** LPIT - Size of Registers Arrays */\r\n#define LPIT_TMR_COUNT                           4u\r\n\r\n/** LPIT - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n  __IO uint32_t MCR;                               /**< Module Control Register, offset: 0x8 */\r\n  __IO uint32_t MSR;                               /**< Module Status Register, offset: 0xC */\r\n  __IO uint32_t MIER;                              /**< Module Interrupt Enable Register, offset: 0x10 */\r\n  __IO uint32_t SETTEN;                            /**< Set Timer Enable Register, offset: 0x14 */\r\n  __IO uint32_t CLRTEN;                            /**< Clear Timer Enable Register, offset: 0x18 */\r\n       uint8_t RESERVED_0[4];\r\n  struct {                                         /* offset: 0x20, array step: 0x10 */\r\n    __IO uint32_t TVAL;                              /**< Timer Value Register, array offset: 0x20, array step: 0x10 */\r\n    __I  uint32_t CVAL;                              /**< Current Timer Value, array offset: 0x24, array step: 0x10 */\r\n    __IO uint32_t TCTRL;                             /**< Timer Control Register, array offset: 0x28, array step: 0x10 */\r\n         uint8_t RESERVED_0[4];\r\n  } TMR[LPIT_TMR_COUNT];\r\n} LPIT_Type, *LPIT_MemMapPtr;\r\n\r\n /** Number of instances of the LPIT module. */\r\n#define LPIT_INSTANCE_COUNT                      (1u)\r\n\r\n\r\n/* LPIT - Peripheral instance base addresses */\r\n/** Peripheral LPIT0 base address */\r\n#define LPIT0_BASE                               (0x40037000u)\r\n/** Peripheral LPIT0 base pointer */\r\n#define LPIT0                                    ((LPIT_Type *)LPIT0_BASE)\r\n/** Array initializer of LPIT peripheral base addresses */\r\n#define LPIT_BASE_ADDRS                          { LPIT0_BASE }\r\n/** Array initializer of LPIT peripheral base pointers */\r\n#define LPIT_BASE_PTRS                           { LPIT0 }\r\n /** Number of interrupt vector arrays for the LPIT module. */\r\n#define LPIT_IRQS_ARR_COUNT                      (1u)\r\n /** Number of interrupt channels for the LPIT module. */\r\n#define LPIT_IRQS_CH_COUNT                       (4u)\r\n/** Interrupt vectors for the LPIT peripheral type */\r\n#define LPIT_IRQS                                { LPIT0_Ch0_IRQn, LPIT0_Ch1_IRQn, LPIT0_Ch2_IRQn, LPIT0_Ch3_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPIT Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPIT_Register_Masks LPIT Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define LPIT_VERID_FEATURE_MASK                  0xFFFFu\r\n#define LPIT_VERID_FEATURE_SHIFT                 0u\r\n#define LPIT_VERID_FEATURE_WIDTH                 16u\r\n#define LPIT_VERID_FEATURE(x)                    (((uint32_t)(((uint32_t)(x))<<LPIT_VERID_FEATURE_SHIFT))&LPIT_VERID_FEATURE_MASK)\r\n#define LPIT_VERID_MINOR_MASK                    0xFF0000u\r\n#define LPIT_VERID_MINOR_SHIFT                   16u\r\n#define LPIT_VERID_MINOR_WIDTH                   8u\r\n#define LPIT_VERID_MINOR(x)                      (((uint32_t)(((uint32_t)(x))<<LPIT_VERID_MINOR_SHIFT))&LPIT_VERID_MINOR_MASK)\r\n#define LPIT_VERID_MAJOR_MASK                    0xFF000000u\r\n#define LPIT_VERID_MAJOR_SHIFT                   24u\r\n#define LPIT_VERID_MAJOR_WIDTH                   8u\r\n#define LPIT_VERID_MAJOR(x)                      (((uint32_t)(((uint32_t)(x))<<LPIT_VERID_MAJOR_SHIFT))&LPIT_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define LPIT_PARAM_CHANNEL_MASK                  0xFFu\r\n#define LPIT_PARAM_CHANNEL_SHIFT                 0u\r\n#define LPIT_PARAM_CHANNEL_WIDTH                 8u\r\n#define LPIT_PARAM_CHANNEL(x)                    (((uint32_t)(((uint32_t)(x))<<LPIT_PARAM_CHANNEL_SHIFT))&LPIT_PARAM_CHANNEL_MASK)\r\n#define LPIT_PARAM_EXT_TRIG_MASK                 0xFF00u\r\n#define LPIT_PARAM_EXT_TRIG_SHIFT                8u\r\n#define LPIT_PARAM_EXT_TRIG_WIDTH                8u\r\n#define LPIT_PARAM_EXT_TRIG(x)                   (((uint32_t)(((uint32_t)(x))<<LPIT_PARAM_EXT_TRIG_SHIFT))&LPIT_PARAM_EXT_TRIG_MASK)\r\n/* MCR Bit Fields */\r\n#define LPIT_MCR_M_CEN_MASK                      0x1u\r\n#define LPIT_MCR_M_CEN_SHIFT                     0u\r\n#define LPIT_MCR_M_CEN_WIDTH                     1u\r\n#define LPIT_MCR_M_CEN(x)                        (((uint32_t)(((uint32_t)(x))<<LPIT_MCR_M_CEN_SHIFT))&LPIT_MCR_M_CEN_MASK)\r\n#define LPIT_MCR_SW_RST_MASK                     0x2u\r\n#define LPIT_MCR_SW_RST_SHIFT                    1u\r\n#define LPIT_MCR_SW_RST_WIDTH                    1u\r\n#define LPIT_MCR_SW_RST(x)                       (((uint32_t)(((uint32_t)(x))<<LPIT_MCR_SW_RST_SHIFT))&LPIT_MCR_SW_RST_MASK)\r\n#define LPIT_MCR_DOZE_EN_MASK                    0x4u\r\n#define LPIT_MCR_DOZE_EN_SHIFT                   2u\r\n#define LPIT_MCR_DOZE_EN_WIDTH                   1u\r\n#define LPIT_MCR_DOZE_EN(x)                      (((uint32_t)(((uint32_t)(x))<<LPIT_MCR_DOZE_EN_SHIFT))&LPIT_MCR_DOZE_EN_MASK)\r\n#define LPIT_MCR_DBG_EN_MASK                     0x8u\r\n#define LPIT_MCR_DBG_EN_SHIFT                    3u\r\n#define LPIT_MCR_DBG_EN_WIDTH                    1u\r\n#define LPIT_MCR_DBG_EN(x)                       (((uint32_t)(((uint32_t)(x))<<LPIT_MCR_DBG_EN_SHIFT))&LPIT_MCR_DBG_EN_MASK)\r\n/* MSR Bit Fields */\r\n#define LPIT_MSR_TIF0_MASK                       0x1u\r\n#define LPIT_MSR_TIF0_SHIFT                      0u\r\n#define LPIT_MSR_TIF0_WIDTH                      1u\r\n#define LPIT_MSR_TIF0(x)                         (((uint32_t)(((uint32_t)(x))<<LPIT_MSR_TIF0_SHIFT))&LPIT_MSR_TIF0_MASK)\r\n#define LPIT_MSR_TIF1_MASK                       0x2u\r\n#define LPIT_MSR_TIF1_SHIFT                      1u\r\n#define LPIT_MSR_TIF1_WIDTH                      1u\r\n#define LPIT_MSR_TIF1(x)                         (((uint32_t)(((uint32_t)(x))<<LPIT_MSR_TIF1_SHIFT))&LPIT_MSR_TIF1_MASK)\r\n#define LPIT_MSR_TIF2_MASK                       0x4u\r\n#define LPIT_MSR_TIF2_SHIFT                      2u\r\n#define LPIT_MSR_TIF2_WIDTH                      1u\r\n#define LPIT_MSR_TIF2(x)                         (((uint32_t)(((uint32_t)(x))<<LPIT_MSR_TIF2_SHIFT))&LPIT_MSR_TIF2_MASK)\r\n#define LPIT_MSR_TIF3_MASK                       0x8u\r\n#define LPIT_MSR_TIF3_SHIFT                      3u\r\n#define LPIT_MSR_TIF3_WIDTH                      1u\r\n#define LPIT_MSR_TIF3(x)                         (((uint32_t)(((uint32_t)(x))<<LPIT_MSR_TIF3_SHIFT))&LPIT_MSR_TIF3_MASK)\r\n/* MIER Bit Fields */\r\n#define LPIT_MIER_TIE0_MASK                      0x1u\r\n#define LPIT_MIER_TIE0_SHIFT                     0u\r\n#define LPIT_MIER_TIE0_WIDTH                     1u\r\n#define LPIT_MIER_TIE0(x)                        (((uint32_t)(((uint32_t)(x))<<LPIT_MIER_TIE0_SHIFT))&LPIT_MIER_TIE0_MASK)\r\n#define LPIT_MIER_TIE1_MASK                      0x2u\r\n#define LPIT_MIER_TIE1_SHIFT                     1u\r\n#define LPIT_MIER_TIE1_WIDTH                     1u\r\n#define LPIT_MIER_TIE1(x)                        (((uint32_t)(((uint32_t)(x))<<LPIT_MIER_TIE1_SHIFT))&LPIT_MIER_TIE1_MASK)\r\n#define LPIT_MIER_TIE2_MASK                      0x4u\r\n#define LPIT_MIER_TIE2_SHIFT                     2u\r\n#define LPIT_MIER_TIE2_WIDTH                     1u\r\n#define LPIT_MIER_TIE2(x)                        (((uint32_t)(((uint32_t)(x))<<LPIT_MIER_TIE2_SHIFT))&LPIT_MIER_TIE2_MASK)\r\n#define LPIT_MIER_TIE3_MASK                      0x8u\r\n#define LPIT_MIER_TIE3_SHIFT                     3u\r\n#define LPIT_MIER_TIE3_WIDTH                     1u\r\n#define LPIT_MIER_TIE3(x)                        (((uint32_t)(((uint32_t)(x))<<LPIT_MIER_TIE3_SHIFT))&LPIT_MIER_TIE3_MASK)\r\n/* SETTEN Bit Fields */\r\n#define LPIT_SETTEN_SET_T_EN_0_MASK              0x1u\r\n#define LPIT_SETTEN_SET_T_EN_0_SHIFT             0u\r\n#define LPIT_SETTEN_SET_T_EN_0_WIDTH             1u\r\n#define LPIT_SETTEN_SET_T_EN_0(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_SETTEN_SET_T_EN_0_SHIFT))&LPIT_SETTEN_SET_T_EN_0_MASK)\r\n#define LPIT_SETTEN_SET_T_EN_1_MASK              0x2u\r\n#define LPIT_SETTEN_SET_T_EN_1_SHIFT             1u\r\n#define LPIT_SETTEN_SET_T_EN_1_WIDTH             1u\r\n#define LPIT_SETTEN_SET_T_EN_1(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_SETTEN_SET_T_EN_1_SHIFT))&LPIT_SETTEN_SET_T_EN_1_MASK)\r\n#define LPIT_SETTEN_SET_T_EN_2_MASK              0x4u\r\n#define LPIT_SETTEN_SET_T_EN_2_SHIFT             2u\r\n#define LPIT_SETTEN_SET_T_EN_2_WIDTH             1u\r\n#define LPIT_SETTEN_SET_T_EN_2(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_SETTEN_SET_T_EN_2_SHIFT))&LPIT_SETTEN_SET_T_EN_2_MASK)\r\n#define LPIT_SETTEN_SET_T_EN_3_MASK              0x8u\r\n#define LPIT_SETTEN_SET_T_EN_3_SHIFT             3u\r\n#define LPIT_SETTEN_SET_T_EN_3_WIDTH             1u\r\n#define LPIT_SETTEN_SET_T_EN_3(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_SETTEN_SET_T_EN_3_SHIFT))&LPIT_SETTEN_SET_T_EN_3_MASK)\r\n/* CLRTEN Bit Fields */\r\n#define LPIT_CLRTEN_CLR_T_EN_0_MASK              0x1u\r\n#define LPIT_CLRTEN_CLR_T_EN_0_SHIFT             0u\r\n#define LPIT_CLRTEN_CLR_T_EN_0_WIDTH             1u\r\n#define LPIT_CLRTEN_CLR_T_EN_0(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_CLRTEN_CLR_T_EN_0_SHIFT))&LPIT_CLRTEN_CLR_T_EN_0_MASK)\r\n#define LPIT_CLRTEN_CLR_T_EN_1_MASK              0x2u\r\n#define LPIT_CLRTEN_CLR_T_EN_1_SHIFT             1u\r\n#define LPIT_CLRTEN_CLR_T_EN_1_WIDTH             1u\r\n#define LPIT_CLRTEN_CLR_T_EN_1(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_CLRTEN_CLR_T_EN_1_SHIFT))&LPIT_CLRTEN_CLR_T_EN_1_MASK)\r\n#define LPIT_CLRTEN_CLR_T_EN_2_MASK              0x4u\r\n#define LPIT_CLRTEN_CLR_T_EN_2_SHIFT             2u\r\n#define LPIT_CLRTEN_CLR_T_EN_2_WIDTH             1u\r\n#define LPIT_CLRTEN_CLR_T_EN_2(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_CLRTEN_CLR_T_EN_2_SHIFT))&LPIT_CLRTEN_CLR_T_EN_2_MASK)\r\n#define LPIT_CLRTEN_CLR_T_EN_3_MASK              0x8u\r\n#define LPIT_CLRTEN_CLR_T_EN_3_SHIFT             3u\r\n#define LPIT_CLRTEN_CLR_T_EN_3_WIDTH             1u\r\n#define LPIT_CLRTEN_CLR_T_EN_3(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_CLRTEN_CLR_T_EN_3_SHIFT))&LPIT_CLRTEN_CLR_T_EN_3_MASK)\r\n/* TMR_TVAL Bit Fields */\r\n#define LPIT_TMR_TVAL_TMR_VAL_MASK               0xFFFFFFFFu\r\n#define LPIT_TMR_TVAL_TMR_VAL_SHIFT              0u\r\n#define LPIT_TMR_TVAL_TMR_VAL_WIDTH              32u\r\n#define LPIT_TMR_TVAL_TMR_VAL(x)                 (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TVAL_TMR_VAL_SHIFT))&LPIT_TMR_TVAL_TMR_VAL_MASK)\r\n/* TMR_CVAL Bit Fields */\r\n#define LPIT_TMR_CVAL_TMR_CUR_VAL_MASK           0xFFFFFFFFu\r\n#define LPIT_TMR_CVAL_TMR_CUR_VAL_SHIFT          0u\r\n#define LPIT_TMR_CVAL_TMR_CUR_VAL_WIDTH          32u\r\n#define LPIT_TMR_CVAL_TMR_CUR_VAL(x)             (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_CVAL_TMR_CUR_VAL_SHIFT))&LPIT_TMR_CVAL_TMR_CUR_VAL_MASK)\r\n/* TMR_TCTRL Bit Fields */\r\n#define LPIT_TMR_TCTRL_T_EN_MASK                 0x1u\r\n#define LPIT_TMR_TCTRL_T_EN_SHIFT                0u\r\n#define LPIT_TMR_TCTRL_T_EN_WIDTH                1u\r\n#define LPIT_TMR_TCTRL_T_EN(x)                   (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_T_EN_SHIFT))&LPIT_TMR_TCTRL_T_EN_MASK)\r\n#define LPIT_TMR_TCTRL_CHAIN_MASK                0x2u\r\n#define LPIT_TMR_TCTRL_CHAIN_SHIFT               1u\r\n#define LPIT_TMR_TCTRL_CHAIN_WIDTH               1u\r\n#define LPIT_TMR_TCTRL_CHAIN(x)                  (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_CHAIN_SHIFT))&LPIT_TMR_TCTRL_CHAIN_MASK)\r\n#define LPIT_TMR_TCTRL_MODE_MASK                 0xCu\r\n#define LPIT_TMR_TCTRL_MODE_SHIFT                2u\r\n#define LPIT_TMR_TCTRL_MODE_WIDTH                2u\r\n#define LPIT_TMR_TCTRL_MODE(x)                   (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_MODE_SHIFT))&LPIT_TMR_TCTRL_MODE_MASK)\r\n#define LPIT_TMR_TCTRL_TSOT_MASK                 0x10000u\r\n#define LPIT_TMR_TCTRL_TSOT_SHIFT                16u\r\n#define LPIT_TMR_TCTRL_TSOT_WIDTH                1u\r\n#define LPIT_TMR_TCTRL_TSOT(x)                   (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_TSOT_SHIFT))&LPIT_TMR_TCTRL_TSOT_MASK)\r\n#define LPIT_TMR_TCTRL_TSOI_MASK                 0x20000u\r\n#define LPIT_TMR_TCTRL_TSOI_SHIFT                17u\r\n#define LPIT_TMR_TCTRL_TSOI_WIDTH                1u\r\n#define LPIT_TMR_TCTRL_TSOI(x)                   (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_TSOI_SHIFT))&LPIT_TMR_TCTRL_TSOI_MASK)\r\n#define LPIT_TMR_TCTRL_TROT_MASK                 0x40000u\r\n#define LPIT_TMR_TCTRL_TROT_SHIFT                18u\r\n#define LPIT_TMR_TCTRL_TROT_WIDTH                1u\r\n#define LPIT_TMR_TCTRL_TROT(x)                   (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_TROT_SHIFT))&LPIT_TMR_TCTRL_TROT_MASK)\r\n#define LPIT_TMR_TCTRL_TRG_SRC_MASK              0x800000u\r\n#define LPIT_TMR_TCTRL_TRG_SRC_SHIFT             23u\r\n#define LPIT_TMR_TCTRL_TRG_SRC_WIDTH             1u\r\n#define LPIT_TMR_TCTRL_TRG_SRC(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_TRG_SRC_SHIFT))&LPIT_TMR_TCTRL_TRG_SRC_MASK)\r\n#define LPIT_TMR_TCTRL_TRG_SEL_MASK              0xF000000u\r\n#define LPIT_TMR_TCTRL_TRG_SEL_SHIFT             24u\r\n#define LPIT_TMR_TCTRL_TRG_SEL_WIDTH             4u\r\n#define LPIT_TMR_TCTRL_TRG_SEL(x)                (((uint32_t)(((uint32_t)(x))<<LPIT_TMR_TCTRL_TRG_SEL_SHIFT))&LPIT_TMR_TCTRL_TRG_SEL_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPIT_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPIT_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPSPI Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPSPI_Peripheral_Access_Layer LPSPI Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** LPSPI - Size of Registers Arrays */\r\n\r\n/** LPSPI - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n       uint8_t RESERVED_0[8];\r\n  __IO uint32_t CR;                                /**< Control Register, offset: 0x10 */\r\n  __IO uint32_t SR;                                /**< Status Register, offset: 0x14 */\r\n  __IO uint32_t IER;                               /**< Interrupt Enable Register, offset: 0x18 */\r\n  __IO uint32_t DER;                               /**< DMA Enable Register, offset: 0x1C */\r\n  __IO uint32_t CFGR0;                             /**< Configuration Register 0, offset: 0x20 */\r\n  __IO uint32_t CFGR1;                             /**< Configuration Register 1, offset: 0x24 */\r\n       uint8_t RESERVED_1[8];\r\n  __IO uint32_t DMR0;                              /**< Data Match Register 0, offset: 0x30 */\r\n  __IO uint32_t DMR1;                              /**< Data Match Register 1, offset: 0x34 */\r\n       uint8_t RESERVED_2[8];\r\n  __IO uint32_t CCR;                               /**< Clock Configuration Register, offset: 0x40 */\r\n       uint8_t RESERVED_3[20];\r\n  __IO uint32_t FCR;                               /**< FIFO Control Register, offset: 0x58 */\r\n  __I  uint32_t FSR;                               /**< FIFO Status Register, offset: 0x5C */\r\n  __IO uint32_t TCR;                               /**< Transmit Command Register, offset: 0x60 */\r\n  __O  uint32_t TDR;                               /**< Transmit Data Register, offset: 0x64 */\r\n       uint8_t RESERVED_4[8];\r\n  __I  uint32_t RSR;                               /**< Receive Status Register, offset: 0x70 */\r\n  __I  uint32_t RDR;                               /**< Receive Data Register, offset: 0x74 */\r\n} LPSPI_Type, *LPSPI_MemMapPtr;\r\n\r\n /** Number of instances of the LPSPI module. */\r\n#define LPSPI_INSTANCE_COUNT                     (3u)\r\n\r\n\r\n/* LPSPI - Peripheral instance base addresses */\r\n/** Peripheral LPSPI0 base address */\r\n#define LPSPI0_BASE                              (0x4002C000u)\r\n/** Peripheral LPSPI0 base pointer */\r\n#define LPSPI0                                   ((LPSPI_Type *)LPSPI0_BASE)\r\n/** Peripheral LPSPI1 base address */\r\n#define LPSPI1_BASE                              (0x4002D000u)\r\n/** Peripheral LPSPI1 base pointer */\r\n#define LPSPI1                                   ((LPSPI_Type *)LPSPI1_BASE)\r\n/** Peripheral LPSPI2 base address */\r\n#define LPSPI2_BASE                              (0x4002E000u)\r\n/** Peripheral LPSPI2 base pointer */\r\n#define LPSPI2                                   ((LPSPI_Type *)LPSPI2_BASE)\r\n/** Array initializer of LPSPI peripheral base addresses */\r\n#define LPSPI_BASE_ADDRS                         { LPSPI0_BASE, LPSPI1_BASE, LPSPI2_BASE }\r\n/** Array initializer of LPSPI peripheral base pointers */\r\n#define LPSPI_BASE_PTRS                          { LPSPI0, LPSPI1, LPSPI2 }\r\n /** Number of interrupt vector arrays for the LPSPI module. */\r\n#define LPSPI_IRQS_ARR_COUNT                     (1u)\r\n /** Number of interrupt channels for the LPSPI module. */\r\n#define LPSPI_IRQS_CH_COUNT                      (1u)\r\n/** Interrupt vectors for the LPSPI peripheral type */\r\n#define LPSPI_IRQS                               { LPSPI0_IRQn, LPSPI1_IRQn, LPSPI2_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPSPI Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPSPI_Register_Masks LPSPI Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define LPSPI_VERID_FEATURE_MASK                 0xFFFFu\r\n#define LPSPI_VERID_FEATURE_SHIFT                0u\r\n#define LPSPI_VERID_FEATURE_WIDTH                16u\r\n#define LPSPI_VERID_FEATURE(x)                   (((uint32_t)(((uint32_t)(x))<<LPSPI_VERID_FEATURE_SHIFT))&LPSPI_VERID_FEATURE_MASK)\r\n#define LPSPI_VERID_MINOR_MASK                   0xFF0000u\r\n#define LPSPI_VERID_MINOR_SHIFT                  16u\r\n#define LPSPI_VERID_MINOR_WIDTH                  8u\r\n#define LPSPI_VERID_MINOR(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_VERID_MINOR_SHIFT))&LPSPI_VERID_MINOR_MASK)\r\n#define LPSPI_VERID_MAJOR_MASK                   0xFF000000u\r\n#define LPSPI_VERID_MAJOR_SHIFT                  24u\r\n#define LPSPI_VERID_MAJOR_WIDTH                  8u\r\n#define LPSPI_VERID_MAJOR(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_VERID_MAJOR_SHIFT))&LPSPI_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define LPSPI_PARAM_TXFIFO_MASK                  0xFFu\r\n#define LPSPI_PARAM_TXFIFO_SHIFT                 0u\r\n#define LPSPI_PARAM_TXFIFO_WIDTH                 8u\r\n#define LPSPI_PARAM_TXFIFO(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_PARAM_TXFIFO_SHIFT))&LPSPI_PARAM_TXFIFO_MASK)\r\n#define LPSPI_PARAM_RXFIFO_MASK                  0xFF00u\r\n#define LPSPI_PARAM_RXFIFO_SHIFT                 8u\r\n#define LPSPI_PARAM_RXFIFO_WIDTH                 8u\r\n#define LPSPI_PARAM_RXFIFO(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_PARAM_RXFIFO_SHIFT))&LPSPI_PARAM_RXFIFO_MASK)\r\n/* CR Bit Fields */\r\n#define LPSPI_CR_MEN_MASK                        0x1u\r\n#define LPSPI_CR_MEN_SHIFT                       0u\r\n#define LPSPI_CR_MEN_WIDTH                       1u\r\n#define LPSPI_CR_MEN(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_CR_MEN_SHIFT))&LPSPI_CR_MEN_MASK)\r\n#define LPSPI_CR_RST_MASK                        0x2u\r\n#define LPSPI_CR_RST_SHIFT                       1u\r\n#define LPSPI_CR_RST_WIDTH                       1u\r\n#define LPSPI_CR_RST(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_CR_RST_SHIFT))&LPSPI_CR_RST_MASK)\r\n#define LPSPI_CR_DOZEN_MASK                      0x4u\r\n#define LPSPI_CR_DOZEN_SHIFT                     2u\r\n#define LPSPI_CR_DOZEN_WIDTH                     1u\r\n#define LPSPI_CR_DOZEN(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_CR_DOZEN_SHIFT))&LPSPI_CR_DOZEN_MASK)\r\n#define LPSPI_CR_DBGEN_MASK                      0x8u\r\n#define LPSPI_CR_DBGEN_SHIFT                     3u\r\n#define LPSPI_CR_DBGEN_WIDTH                     1u\r\n#define LPSPI_CR_DBGEN(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_CR_DBGEN_SHIFT))&LPSPI_CR_DBGEN_MASK)\r\n#define LPSPI_CR_RTF_MASK                        0x100u\r\n#define LPSPI_CR_RTF_SHIFT                       8u\r\n#define LPSPI_CR_RTF_WIDTH                       1u\r\n#define LPSPI_CR_RTF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_CR_RTF_SHIFT))&LPSPI_CR_RTF_MASK)\r\n#define LPSPI_CR_RRF_MASK                        0x200u\r\n#define LPSPI_CR_RRF_SHIFT                       9u\r\n#define LPSPI_CR_RRF_WIDTH                       1u\r\n#define LPSPI_CR_RRF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_CR_RRF_SHIFT))&LPSPI_CR_RRF_MASK)\r\n/* SR Bit Fields */\r\n#define LPSPI_SR_TDF_MASK                        0x1u\r\n#define LPSPI_SR_TDF_SHIFT                       0u\r\n#define LPSPI_SR_TDF_WIDTH                       1u\r\n#define LPSPI_SR_TDF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_TDF_SHIFT))&LPSPI_SR_TDF_MASK)\r\n#define LPSPI_SR_RDF_MASK                        0x2u\r\n#define LPSPI_SR_RDF_SHIFT                       1u\r\n#define LPSPI_SR_RDF_WIDTH                       1u\r\n#define LPSPI_SR_RDF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_RDF_SHIFT))&LPSPI_SR_RDF_MASK)\r\n#define LPSPI_SR_WCF_MASK                        0x100u\r\n#define LPSPI_SR_WCF_SHIFT                       8u\r\n#define LPSPI_SR_WCF_WIDTH                       1u\r\n#define LPSPI_SR_WCF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_WCF_SHIFT))&LPSPI_SR_WCF_MASK)\r\n#define LPSPI_SR_FCF_MASK                        0x200u\r\n#define LPSPI_SR_FCF_SHIFT                       9u\r\n#define LPSPI_SR_FCF_WIDTH                       1u\r\n#define LPSPI_SR_FCF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_FCF_SHIFT))&LPSPI_SR_FCF_MASK)\r\n#define LPSPI_SR_TCF_MASK                        0x400u\r\n#define LPSPI_SR_TCF_SHIFT                       10u\r\n#define LPSPI_SR_TCF_WIDTH                       1u\r\n#define LPSPI_SR_TCF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_TCF_SHIFT))&LPSPI_SR_TCF_MASK)\r\n#define LPSPI_SR_TEF_MASK                        0x800u\r\n#define LPSPI_SR_TEF_SHIFT                       11u\r\n#define LPSPI_SR_TEF_WIDTH                       1u\r\n#define LPSPI_SR_TEF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_TEF_SHIFT))&LPSPI_SR_TEF_MASK)\r\n#define LPSPI_SR_REF_MASK                        0x1000u\r\n#define LPSPI_SR_REF_SHIFT                       12u\r\n#define LPSPI_SR_REF_WIDTH                       1u\r\n#define LPSPI_SR_REF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_REF_SHIFT))&LPSPI_SR_REF_MASK)\r\n#define LPSPI_SR_DMF_MASK                        0x2000u\r\n#define LPSPI_SR_DMF_SHIFT                       13u\r\n#define LPSPI_SR_DMF_WIDTH                       1u\r\n#define LPSPI_SR_DMF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_DMF_SHIFT))&LPSPI_SR_DMF_MASK)\r\n#define LPSPI_SR_MBF_MASK                        0x1000000u\r\n#define LPSPI_SR_MBF_SHIFT                       24u\r\n#define LPSPI_SR_MBF_WIDTH                       1u\r\n#define LPSPI_SR_MBF(x)                          (((uint32_t)(((uint32_t)(x))<<LPSPI_SR_MBF_SHIFT))&LPSPI_SR_MBF_MASK)\r\n/* IER Bit Fields */\r\n#define LPSPI_IER_TDIE_MASK                      0x1u\r\n#define LPSPI_IER_TDIE_SHIFT                     0u\r\n#define LPSPI_IER_TDIE_WIDTH                     1u\r\n#define LPSPI_IER_TDIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_TDIE_SHIFT))&LPSPI_IER_TDIE_MASK)\r\n#define LPSPI_IER_RDIE_MASK                      0x2u\r\n#define LPSPI_IER_RDIE_SHIFT                     1u\r\n#define LPSPI_IER_RDIE_WIDTH                     1u\r\n#define LPSPI_IER_RDIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_RDIE_SHIFT))&LPSPI_IER_RDIE_MASK)\r\n#define LPSPI_IER_WCIE_MASK                      0x100u\r\n#define LPSPI_IER_WCIE_SHIFT                     8u\r\n#define LPSPI_IER_WCIE_WIDTH                     1u\r\n#define LPSPI_IER_WCIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_WCIE_SHIFT))&LPSPI_IER_WCIE_MASK)\r\n#define LPSPI_IER_FCIE_MASK                      0x200u\r\n#define LPSPI_IER_FCIE_SHIFT                     9u\r\n#define LPSPI_IER_FCIE_WIDTH                     1u\r\n#define LPSPI_IER_FCIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_FCIE_SHIFT))&LPSPI_IER_FCIE_MASK)\r\n#define LPSPI_IER_TCIE_MASK                      0x400u\r\n#define LPSPI_IER_TCIE_SHIFT                     10u\r\n#define LPSPI_IER_TCIE_WIDTH                     1u\r\n#define LPSPI_IER_TCIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_TCIE_SHIFT))&LPSPI_IER_TCIE_MASK)\r\n#define LPSPI_IER_TEIE_MASK                      0x800u\r\n#define LPSPI_IER_TEIE_SHIFT                     11u\r\n#define LPSPI_IER_TEIE_WIDTH                     1u\r\n#define LPSPI_IER_TEIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_TEIE_SHIFT))&LPSPI_IER_TEIE_MASK)\r\n#define LPSPI_IER_REIE_MASK                      0x1000u\r\n#define LPSPI_IER_REIE_SHIFT                     12u\r\n#define LPSPI_IER_REIE_WIDTH                     1u\r\n#define LPSPI_IER_REIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_REIE_SHIFT))&LPSPI_IER_REIE_MASK)\r\n#define LPSPI_IER_DMIE_MASK                      0x2000u\r\n#define LPSPI_IER_DMIE_SHIFT                     13u\r\n#define LPSPI_IER_DMIE_WIDTH                     1u\r\n#define LPSPI_IER_DMIE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_IER_DMIE_SHIFT))&LPSPI_IER_DMIE_MASK)\r\n/* DER Bit Fields */\r\n#define LPSPI_DER_TDDE_MASK                      0x1u\r\n#define LPSPI_DER_TDDE_SHIFT                     0u\r\n#define LPSPI_DER_TDDE_WIDTH                     1u\r\n#define LPSPI_DER_TDDE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_DER_TDDE_SHIFT))&LPSPI_DER_TDDE_MASK)\r\n#define LPSPI_DER_RDDE_MASK                      0x2u\r\n#define LPSPI_DER_RDDE_SHIFT                     1u\r\n#define LPSPI_DER_RDDE_WIDTH                     1u\r\n#define LPSPI_DER_RDDE(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_DER_RDDE_SHIFT))&LPSPI_DER_RDDE_MASK)\r\n/* CFGR0 Bit Fields */\r\n#define LPSPI_CFGR0_HREN_MASK                    0x1u\r\n#define LPSPI_CFGR0_HREN_SHIFT                   0u\r\n#define LPSPI_CFGR0_HREN_WIDTH                   1u\r\n#define LPSPI_CFGR0_HREN(x)                      (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR0_HREN_SHIFT))&LPSPI_CFGR0_HREN_MASK)\r\n#define LPSPI_CFGR0_HRPOL_MASK                   0x2u\r\n#define LPSPI_CFGR0_HRPOL_SHIFT                  1u\r\n#define LPSPI_CFGR0_HRPOL_WIDTH                  1u\r\n#define LPSPI_CFGR0_HRPOL(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR0_HRPOL_SHIFT))&LPSPI_CFGR0_HRPOL_MASK)\r\n#define LPSPI_CFGR0_HRSEL_MASK                   0x4u\r\n#define LPSPI_CFGR0_HRSEL_SHIFT                  2u\r\n#define LPSPI_CFGR0_HRSEL_WIDTH                  1u\r\n#define LPSPI_CFGR0_HRSEL(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR0_HRSEL_SHIFT))&LPSPI_CFGR0_HRSEL_MASK)\r\n#define LPSPI_CFGR0_CIRFIFO_MASK                 0x100u\r\n#define LPSPI_CFGR0_CIRFIFO_SHIFT                8u\r\n#define LPSPI_CFGR0_CIRFIFO_WIDTH                1u\r\n#define LPSPI_CFGR0_CIRFIFO(x)                   (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR0_CIRFIFO_SHIFT))&LPSPI_CFGR0_CIRFIFO_MASK)\r\n#define LPSPI_CFGR0_RDMO_MASK                    0x200u\r\n#define LPSPI_CFGR0_RDMO_SHIFT                   9u\r\n#define LPSPI_CFGR0_RDMO_WIDTH                   1u\r\n#define LPSPI_CFGR0_RDMO(x)                      (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR0_RDMO_SHIFT))&LPSPI_CFGR0_RDMO_MASK)\r\n/* CFGR1 Bit Fields */\r\n#define LPSPI_CFGR1_MASTER_MASK                  0x1u\r\n#define LPSPI_CFGR1_MASTER_SHIFT                 0u\r\n#define LPSPI_CFGR1_MASTER_WIDTH                 1u\r\n#define LPSPI_CFGR1_MASTER(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_MASTER_SHIFT))&LPSPI_CFGR1_MASTER_MASK)\r\n#define LPSPI_CFGR1_SAMPLE_MASK                  0x2u\r\n#define LPSPI_CFGR1_SAMPLE_SHIFT                 1u\r\n#define LPSPI_CFGR1_SAMPLE_WIDTH                 1u\r\n#define LPSPI_CFGR1_SAMPLE(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_SAMPLE_SHIFT))&LPSPI_CFGR1_SAMPLE_MASK)\r\n#define LPSPI_CFGR1_AUTOPCS_MASK                 0x4u\r\n#define LPSPI_CFGR1_AUTOPCS_SHIFT                2u\r\n#define LPSPI_CFGR1_AUTOPCS_WIDTH                1u\r\n#define LPSPI_CFGR1_AUTOPCS(x)                   (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_AUTOPCS_SHIFT))&LPSPI_CFGR1_AUTOPCS_MASK)\r\n#define LPSPI_CFGR1_NOSTALL_MASK                 0x8u\r\n#define LPSPI_CFGR1_NOSTALL_SHIFT                3u\r\n#define LPSPI_CFGR1_NOSTALL_WIDTH                1u\r\n#define LPSPI_CFGR1_NOSTALL(x)                   (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_NOSTALL_SHIFT))&LPSPI_CFGR1_NOSTALL_MASK)\r\n#define LPSPI_CFGR1_PCSPOL_MASK                  0xF00u\r\n#define LPSPI_CFGR1_PCSPOL_SHIFT                 8u\r\n#define LPSPI_CFGR1_PCSPOL_WIDTH                 4u\r\n#define LPSPI_CFGR1_PCSPOL(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_PCSPOL_SHIFT))&LPSPI_CFGR1_PCSPOL_MASK)\r\n#define LPSPI_CFGR1_MATCFG_MASK                  0x70000u\r\n#define LPSPI_CFGR1_MATCFG_SHIFT                 16u\r\n#define LPSPI_CFGR1_MATCFG_WIDTH                 3u\r\n#define LPSPI_CFGR1_MATCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_MATCFG_SHIFT))&LPSPI_CFGR1_MATCFG_MASK)\r\n#define LPSPI_CFGR1_PINCFG_MASK                  0x3000000u\r\n#define LPSPI_CFGR1_PINCFG_SHIFT                 24u\r\n#define LPSPI_CFGR1_PINCFG_WIDTH                 2u\r\n#define LPSPI_CFGR1_PINCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_PINCFG_SHIFT))&LPSPI_CFGR1_PINCFG_MASK)\r\n#define LPSPI_CFGR1_OUTCFG_MASK                  0x4000000u\r\n#define LPSPI_CFGR1_OUTCFG_SHIFT                 26u\r\n#define LPSPI_CFGR1_OUTCFG_WIDTH                 1u\r\n#define LPSPI_CFGR1_OUTCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_OUTCFG_SHIFT))&LPSPI_CFGR1_OUTCFG_MASK)\r\n#define LPSPI_CFGR1_PCSCFG_MASK                  0x8000000u\r\n#define LPSPI_CFGR1_PCSCFG_SHIFT                 27u\r\n#define LPSPI_CFGR1_PCSCFG_WIDTH                 1u\r\n#define LPSPI_CFGR1_PCSCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_CFGR1_PCSCFG_SHIFT))&LPSPI_CFGR1_PCSCFG_MASK)\r\n/* DMR0 Bit Fields */\r\n#define LPSPI_DMR0_MATCH0_MASK                   0xFFFFFFFFu\r\n#define LPSPI_DMR0_MATCH0_SHIFT                  0u\r\n#define LPSPI_DMR0_MATCH0_WIDTH                  32u\r\n#define LPSPI_DMR0_MATCH0(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_DMR0_MATCH0_SHIFT))&LPSPI_DMR0_MATCH0_MASK)\r\n/* DMR1 Bit Fields */\r\n#define LPSPI_DMR1_MATCH1_MASK                   0xFFFFFFFFu\r\n#define LPSPI_DMR1_MATCH1_SHIFT                  0u\r\n#define LPSPI_DMR1_MATCH1_WIDTH                  32u\r\n#define LPSPI_DMR1_MATCH1(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_DMR1_MATCH1_SHIFT))&LPSPI_DMR1_MATCH1_MASK)\r\n/* CCR Bit Fields */\r\n#define LPSPI_CCR_SCKDIV_MASK                    0xFFu\r\n#define LPSPI_CCR_SCKDIV_SHIFT                   0u\r\n#define LPSPI_CCR_SCKDIV_WIDTH                   8u\r\n#define LPSPI_CCR_SCKDIV(x)                      (((uint32_t)(((uint32_t)(x))<<LPSPI_CCR_SCKDIV_SHIFT))&LPSPI_CCR_SCKDIV_MASK)\r\n#define LPSPI_CCR_DBT_MASK                       0xFF00u\r\n#define LPSPI_CCR_DBT_SHIFT                      8u\r\n#define LPSPI_CCR_DBT_WIDTH                      8u\r\n#define LPSPI_CCR_DBT(x)                         (((uint32_t)(((uint32_t)(x))<<LPSPI_CCR_DBT_SHIFT))&LPSPI_CCR_DBT_MASK)\r\n#define LPSPI_CCR_PCSSCK_MASK                    0xFF0000u\r\n#define LPSPI_CCR_PCSSCK_SHIFT                   16u\r\n#define LPSPI_CCR_PCSSCK_WIDTH                   8u\r\n#define LPSPI_CCR_PCSSCK(x)                      (((uint32_t)(((uint32_t)(x))<<LPSPI_CCR_PCSSCK_SHIFT))&LPSPI_CCR_PCSSCK_MASK)\r\n#define LPSPI_CCR_SCKPCS_MASK                    0xFF000000u\r\n#define LPSPI_CCR_SCKPCS_SHIFT                   24u\r\n#define LPSPI_CCR_SCKPCS_WIDTH                   8u\r\n#define LPSPI_CCR_SCKPCS(x)                      (((uint32_t)(((uint32_t)(x))<<LPSPI_CCR_SCKPCS_SHIFT))&LPSPI_CCR_SCKPCS_MASK)\r\n/* FCR Bit Fields */\r\n#define LPSPI_FCR_TXWATER_MASK                   0x3u\r\n#define LPSPI_FCR_TXWATER_SHIFT                  0u\r\n#define LPSPI_FCR_TXWATER_WIDTH                  2u\r\n#define LPSPI_FCR_TXWATER(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_FCR_TXWATER_SHIFT))&LPSPI_FCR_TXWATER_MASK)\r\n#define LPSPI_FCR_RXWATER_MASK                   0x30000u\r\n#define LPSPI_FCR_RXWATER_SHIFT                  16u\r\n#define LPSPI_FCR_RXWATER_WIDTH                  2u\r\n#define LPSPI_FCR_RXWATER(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_FCR_RXWATER_SHIFT))&LPSPI_FCR_RXWATER_MASK)\r\n/* FSR Bit Fields */\r\n#define LPSPI_FSR_TXCOUNT_MASK                   0x7u\r\n#define LPSPI_FSR_TXCOUNT_SHIFT                  0u\r\n#define LPSPI_FSR_TXCOUNT_WIDTH                  3u\r\n#define LPSPI_FSR_TXCOUNT(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_FSR_TXCOUNT_SHIFT))&LPSPI_FSR_TXCOUNT_MASK)\r\n#define LPSPI_FSR_RXCOUNT_MASK                   0x70000u\r\n#define LPSPI_FSR_RXCOUNT_SHIFT                  16u\r\n#define LPSPI_FSR_RXCOUNT_WIDTH                  3u\r\n#define LPSPI_FSR_RXCOUNT(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_FSR_RXCOUNT_SHIFT))&LPSPI_FSR_RXCOUNT_MASK)\r\n/* TCR Bit Fields */\r\n#define LPSPI_TCR_FRAMESZ_MASK                   0xFFFu\r\n#define LPSPI_TCR_FRAMESZ_SHIFT                  0u\r\n#define LPSPI_TCR_FRAMESZ_WIDTH                  12u\r\n#define LPSPI_TCR_FRAMESZ(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_FRAMESZ_SHIFT))&LPSPI_TCR_FRAMESZ_MASK)\r\n#define LPSPI_TCR_WIDTH_MASK                     0x30000u\r\n#define LPSPI_TCR_WIDTH_SHIFT                    16u\r\n#define LPSPI_TCR_WIDTH_WIDTH                    2u\r\n#define LPSPI_TCR_WIDTH(x)                       (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_WIDTH_SHIFT))&LPSPI_TCR_WIDTH_MASK)\r\n#define LPSPI_TCR_TXMSK_MASK                     0x40000u\r\n#define LPSPI_TCR_TXMSK_SHIFT                    18u\r\n#define LPSPI_TCR_TXMSK_WIDTH                    1u\r\n#define LPSPI_TCR_TXMSK(x)                       (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_TXMSK_SHIFT))&LPSPI_TCR_TXMSK_MASK)\r\n#define LPSPI_TCR_RXMSK_MASK                     0x80000u\r\n#define LPSPI_TCR_RXMSK_SHIFT                    19u\r\n#define LPSPI_TCR_RXMSK_WIDTH                    1u\r\n#define LPSPI_TCR_RXMSK(x)                       (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_RXMSK_SHIFT))&LPSPI_TCR_RXMSK_MASK)\r\n#define LPSPI_TCR_CONTC_MASK                     0x100000u\r\n#define LPSPI_TCR_CONTC_SHIFT                    20u\r\n#define LPSPI_TCR_CONTC_WIDTH                    1u\r\n#define LPSPI_TCR_CONTC(x)                       (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_CONTC_SHIFT))&LPSPI_TCR_CONTC_MASK)\r\n#define LPSPI_TCR_CONT_MASK                      0x200000u\r\n#define LPSPI_TCR_CONT_SHIFT                     21u\r\n#define LPSPI_TCR_CONT_WIDTH                     1u\r\n#define LPSPI_TCR_CONT(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_CONT_SHIFT))&LPSPI_TCR_CONT_MASK)\r\n#define LPSPI_TCR_BYSW_MASK                      0x400000u\r\n#define LPSPI_TCR_BYSW_SHIFT                     22u\r\n#define LPSPI_TCR_BYSW_WIDTH                     1u\r\n#define LPSPI_TCR_BYSW(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_BYSW_SHIFT))&LPSPI_TCR_BYSW_MASK)\r\n#define LPSPI_TCR_LSBF_MASK                      0x800000u\r\n#define LPSPI_TCR_LSBF_SHIFT                     23u\r\n#define LPSPI_TCR_LSBF_WIDTH                     1u\r\n#define LPSPI_TCR_LSBF(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_LSBF_SHIFT))&LPSPI_TCR_LSBF_MASK)\r\n#define LPSPI_TCR_PCS_MASK                       0x3000000u\r\n#define LPSPI_TCR_PCS_SHIFT                      24u\r\n#define LPSPI_TCR_PCS_WIDTH                      2u\r\n#define LPSPI_TCR_PCS(x)                         (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_PCS_SHIFT))&LPSPI_TCR_PCS_MASK)\r\n#define LPSPI_TCR_PRESCALE_MASK                  0x38000000u\r\n#define LPSPI_TCR_PRESCALE_SHIFT                 27u\r\n#define LPSPI_TCR_PRESCALE_WIDTH                 3u\r\n#define LPSPI_TCR_PRESCALE(x)                    (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_PRESCALE_SHIFT))&LPSPI_TCR_PRESCALE_MASK)\r\n#define LPSPI_TCR_CPHA_MASK                      0x40000000u\r\n#define LPSPI_TCR_CPHA_SHIFT                     30u\r\n#define LPSPI_TCR_CPHA_WIDTH                     1u\r\n#define LPSPI_TCR_CPHA(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_CPHA_SHIFT))&LPSPI_TCR_CPHA_MASK)\r\n#define LPSPI_TCR_CPOL_MASK                      0x80000000u\r\n#define LPSPI_TCR_CPOL_SHIFT                     31u\r\n#define LPSPI_TCR_CPOL_WIDTH                     1u\r\n#define LPSPI_TCR_CPOL(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_TCR_CPOL_SHIFT))&LPSPI_TCR_CPOL_MASK)\r\n/* TDR Bit Fields */\r\n#define LPSPI_TDR_DATA_MASK                      0xFFFFFFFFu\r\n#define LPSPI_TDR_DATA_SHIFT                     0u\r\n#define LPSPI_TDR_DATA_WIDTH                     32u\r\n#define LPSPI_TDR_DATA(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_TDR_DATA_SHIFT))&LPSPI_TDR_DATA_MASK)\r\n/* RSR Bit Fields */\r\n#define LPSPI_RSR_SOF_MASK                       0x1u\r\n#define LPSPI_RSR_SOF_SHIFT                      0u\r\n#define LPSPI_RSR_SOF_WIDTH                      1u\r\n#define LPSPI_RSR_SOF(x)                         (((uint32_t)(((uint32_t)(x))<<LPSPI_RSR_SOF_SHIFT))&LPSPI_RSR_SOF_MASK)\r\n#define LPSPI_RSR_RXEMPTY_MASK                   0x2u\r\n#define LPSPI_RSR_RXEMPTY_SHIFT                  1u\r\n#define LPSPI_RSR_RXEMPTY_WIDTH                  1u\r\n#define LPSPI_RSR_RXEMPTY(x)                     (((uint32_t)(((uint32_t)(x))<<LPSPI_RSR_RXEMPTY_SHIFT))&LPSPI_RSR_RXEMPTY_MASK)\r\n/* RDR Bit Fields */\r\n#define LPSPI_RDR_DATA_MASK                      0xFFFFFFFFu\r\n#define LPSPI_RDR_DATA_SHIFT                     0u\r\n#define LPSPI_RDR_DATA_WIDTH                     32u\r\n#define LPSPI_RDR_DATA(x)                        (((uint32_t)(((uint32_t)(x))<<LPSPI_RDR_DATA_SHIFT))&LPSPI_RDR_DATA_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPSPI_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPSPI_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPTMR Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPTMR_Peripheral_Access_Layer LPTMR Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** LPTMR - Size of Registers Arrays */\r\n\r\n/** LPTMR - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t CSR;                               /**< Low Power Timer Control Status Register, offset: 0x0 */\r\n  __IO uint32_t PSR;                               /**< Low Power Timer Prescale Register, offset: 0x4 */\r\n  __IO uint32_t CMR;                               /**< Low Power Timer Compare Register, offset: 0x8 */\r\n  __IO uint32_t CNR;                               /**< Low Power Timer Counter Register, offset: 0xC */\r\n} LPTMR_Type, *LPTMR_MemMapPtr;\r\n\r\n /** Number of instances of the LPTMR module. */\r\n#define LPTMR_INSTANCE_COUNT                     (1u)\r\n\r\n\r\n/* LPTMR - Peripheral instance base addresses */\r\n/** Peripheral LPTMR0 base address */\r\n#define LPTMR0_BASE                              (0x40040000u)\r\n/** Peripheral LPTMR0 base pointer */\r\n#define LPTMR0                                   ((LPTMR_Type *)LPTMR0_BASE)\r\n/** Array initializer of LPTMR peripheral base addresses */\r\n#define LPTMR_BASE_ADDRS                         { LPTMR0_BASE }\r\n/** Array initializer of LPTMR peripheral base pointers */\r\n#define LPTMR_BASE_PTRS                          { LPTMR0 }\r\n /** Number of interrupt vector arrays for the LPTMR module. */\r\n#define LPTMR_IRQS_ARR_COUNT                     (1u)\r\n /** Number of interrupt channels for the LPTMR module. */\r\n#define LPTMR_IRQS_CH_COUNT                      (1u)\r\n/** Interrupt vectors for the LPTMR peripheral type */\r\n#define LPTMR_IRQS                               { LPTMR0_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPTMR Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPTMR_Register_Masks LPTMR Register Masks\r\n * @{\r\n */\r\n\r\n/* CSR Bit Fields */\r\n#define LPTMR_CSR_TEN_MASK                       0x1u\r\n#define LPTMR_CSR_TEN_SHIFT                      0u\r\n#define LPTMR_CSR_TEN_WIDTH                      1u\r\n#define LPTMR_CSR_TEN(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TEN_SHIFT))&LPTMR_CSR_TEN_MASK)\r\n#define LPTMR_CSR_TMS_MASK                       0x2u\r\n#define LPTMR_CSR_TMS_SHIFT                      1u\r\n#define LPTMR_CSR_TMS_WIDTH                      1u\r\n#define LPTMR_CSR_TMS(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TMS_SHIFT))&LPTMR_CSR_TMS_MASK)\r\n#define LPTMR_CSR_TFC_MASK                       0x4u\r\n#define LPTMR_CSR_TFC_SHIFT                      2u\r\n#define LPTMR_CSR_TFC_WIDTH                      1u\r\n#define LPTMR_CSR_TFC(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TFC_SHIFT))&LPTMR_CSR_TFC_MASK)\r\n#define LPTMR_CSR_TPP_MASK                       0x8u\r\n#define LPTMR_CSR_TPP_SHIFT                      3u\r\n#define LPTMR_CSR_TPP_WIDTH                      1u\r\n#define LPTMR_CSR_TPP(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TPP_SHIFT))&LPTMR_CSR_TPP_MASK)\r\n#define LPTMR_CSR_TPS_MASK                       0x30u\r\n#define LPTMR_CSR_TPS_SHIFT                      4u\r\n#define LPTMR_CSR_TPS_WIDTH                      2u\r\n#define LPTMR_CSR_TPS(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TPS_SHIFT))&LPTMR_CSR_TPS_MASK)\r\n#define LPTMR_CSR_TIE_MASK                       0x40u\r\n#define LPTMR_CSR_TIE_SHIFT                      6u\r\n#define LPTMR_CSR_TIE_WIDTH                      1u\r\n#define LPTMR_CSR_TIE(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TIE_SHIFT))&LPTMR_CSR_TIE_MASK)\r\n#define LPTMR_CSR_TCF_MASK                       0x80u\r\n#define LPTMR_CSR_TCF_SHIFT                      7u\r\n#define LPTMR_CSR_TCF_WIDTH                      1u\r\n#define LPTMR_CSR_TCF(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TCF_SHIFT))&LPTMR_CSR_TCF_MASK)\r\n#define LPTMR_CSR_TDRE_MASK                      0x100u\r\n#define LPTMR_CSR_TDRE_SHIFT                     8u\r\n#define LPTMR_CSR_TDRE_WIDTH                     1u\r\n#define LPTMR_CSR_TDRE(x)                        (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TDRE_SHIFT))&LPTMR_CSR_TDRE_MASK)\r\n/* PSR Bit Fields */\r\n#define LPTMR_PSR_PCS_MASK                       0x3u\r\n#define LPTMR_PSR_PCS_SHIFT                      0u\r\n#define LPTMR_PSR_PCS_WIDTH                      2u\r\n#define LPTMR_PSR_PCS(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_PSR_PCS_SHIFT))&LPTMR_PSR_PCS_MASK)\r\n#define LPTMR_PSR_PBYP_MASK                      0x4u\r\n#define LPTMR_PSR_PBYP_SHIFT                     2u\r\n#define LPTMR_PSR_PBYP_WIDTH                     1u\r\n#define LPTMR_PSR_PBYP(x)                        (((uint32_t)(((uint32_t)(x))<<LPTMR_PSR_PBYP_SHIFT))&LPTMR_PSR_PBYP_MASK)\r\n#define LPTMR_PSR_PRESCALE_MASK                  0x78u\r\n#define LPTMR_PSR_PRESCALE_SHIFT                 3u\r\n#define LPTMR_PSR_PRESCALE_WIDTH                 4u\r\n#define LPTMR_PSR_PRESCALE(x)                    (((uint32_t)(((uint32_t)(x))<<LPTMR_PSR_PRESCALE_SHIFT))&LPTMR_PSR_PRESCALE_MASK)\r\n/* CMR Bit Fields */\r\n#define LPTMR_CMR_COMPARE_MASK                   0xFFFFu\r\n#define LPTMR_CMR_COMPARE_SHIFT                  0u\r\n#define LPTMR_CMR_COMPARE_WIDTH                  16u\r\n#define LPTMR_CMR_COMPARE(x)                     (((uint32_t)(((uint32_t)(x))<<LPTMR_CMR_COMPARE_SHIFT))&LPTMR_CMR_COMPARE_MASK)\r\n/* CNR Bit Fields */\r\n#define LPTMR_CNR_COUNTER_MASK                   0xFFFFu\r\n#define LPTMR_CNR_COUNTER_SHIFT                  0u\r\n#define LPTMR_CNR_COUNTER_WIDTH                  16u\r\n#define LPTMR_CNR_COUNTER(x)                     (((uint32_t)(((uint32_t)(x))<<LPTMR_CNR_COUNTER_SHIFT))&LPTMR_CNR_COUNTER_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPTMR_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPTMR_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPUART Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPUART_Peripheral_Access_Layer LPUART Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** LPUART - Size of Registers Arrays */\r\n\r\n/** LPUART - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n  __IO uint32_t GLOBAL;                            /**< LPUART Global Register, offset: 0x8 */\r\n  __IO uint32_t PINCFG;                            /**< LPUART Pin Configuration Register, offset: 0xC */\r\n  __IO uint32_t BAUD;                              /**< LPUART Baud Rate Register, offset: 0x10 */\r\n  __IO uint32_t STAT;                              /**< LPUART Status Register, offset: 0x14 */\r\n  __IO uint32_t CTRL;                              /**< LPUART Control Register, offset: 0x18 */\r\n  __IO uint32_t DATA;                              /**< LPUART Data Register, offset: 0x1C */\r\n  __IO uint32_t MATCH;                             /**< LPUART Match Address Register, offset: 0x20 */\r\n  __IO uint32_t MODIR;                             /**< LPUART Modem IrDA Register, offset: 0x24 */\r\n  __IO uint32_t FIFO;                              /**< LPUART FIFO Register, offset: 0x28 */\r\n  __IO uint32_t WATER;                             /**< LPUART Watermark Register, offset: 0x2C */\r\n} LPUART_Type, *LPUART_MemMapPtr;\r\n\r\n /** Number of instances of the LPUART module. */\r\n#define LPUART_INSTANCE_COUNT                    (3u)\r\n\r\n\r\n/* LPUART - Peripheral instance base addresses */\r\n/** Peripheral LPUART0 base address */\r\n#define LPUART0_BASE                             (0x4006A000u)\r\n/** Peripheral LPUART0 base pointer */\r\n#define LPUART0                                  ((LPUART_Type *)LPUART0_BASE)\r\n/** Peripheral LPUART1 base address */\r\n#define LPUART1_BASE                             (0x4006B000u)\r\n/** Peripheral LPUART1 base pointer */\r\n#define LPUART1                                  ((LPUART_Type *)LPUART1_BASE)\r\n/** Peripheral LPUART2 base address */\r\n#define LPUART2_BASE                             (0x4006C000u)\r\n/** Peripheral LPUART2 base pointer */\r\n#define LPUART2                                  ((LPUART_Type *)LPUART2_BASE)\r\n/** Array initializer of LPUART peripheral base addresses */\r\n#define LPUART_BASE_ADDRS                        { LPUART0_BASE, LPUART1_BASE, LPUART2_BASE }\r\n/** Array initializer of LPUART peripheral base pointers */\r\n#define LPUART_BASE_PTRS                         { LPUART0, LPUART1, LPUART2 }\r\n /** Number of interrupt vector arrays for the LPUART module. */\r\n#define LPUART_IRQS_ARR_COUNT                    (1u)\r\n /** Number of interrupt channels for the RX_TX type of LPUART module. */\r\n#define LPUART_RX_TX_IRQS_CH_COUNT               (1u)\r\n/** Interrupt vectors for the LPUART peripheral type */\r\n#define LPUART_RX_TX_IRQS                        { LPUART0_RxTx_IRQn, LPUART1_RxTx_IRQn, LPUART2_RxTx_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- LPUART Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup LPUART_Register_Masks LPUART Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define LPUART_VERID_FEATURE_MASK                0xFFFFu\r\n#define LPUART_VERID_FEATURE_SHIFT               0u\r\n#define LPUART_VERID_FEATURE_WIDTH               16u\r\n#define LPUART_VERID_FEATURE(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_VERID_FEATURE_SHIFT))&LPUART_VERID_FEATURE_MASK)\r\n#define LPUART_VERID_MINOR_MASK                  0xFF0000u\r\n#define LPUART_VERID_MINOR_SHIFT                 16u\r\n#define LPUART_VERID_MINOR_WIDTH                 8u\r\n#define LPUART_VERID_MINOR(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_VERID_MINOR_SHIFT))&LPUART_VERID_MINOR_MASK)\r\n#define LPUART_VERID_MAJOR_MASK                  0xFF000000u\r\n#define LPUART_VERID_MAJOR_SHIFT                 24u\r\n#define LPUART_VERID_MAJOR_WIDTH                 8u\r\n#define LPUART_VERID_MAJOR(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_VERID_MAJOR_SHIFT))&LPUART_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define LPUART_PARAM_TXFIFO_MASK                 0xFFu\r\n#define LPUART_PARAM_TXFIFO_SHIFT                0u\r\n#define LPUART_PARAM_TXFIFO_WIDTH                8u\r\n#define LPUART_PARAM_TXFIFO(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_PARAM_TXFIFO_SHIFT))&LPUART_PARAM_TXFIFO_MASK)\r\n#define LPUART_PARAM_RXFIFO_MASK                 0xFF00u\r\n#define LPUART_PARAM_RXFIFO_SHIFT                8u\r\n#define LPUART_PARAM_RXFIFO_WIDTH                8u\r\n#define LPUART_PARAM_RXFIFO(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_PARAM_RXFIFO_SHIFT))&LPUART_PARAM_RXFIFO_MASK)\r\n/* GLOBAL Bit Fields */\r\n#define LPUART_GLOBAL_RST_MASK                   0x2u\r\n#define LPUART_GLOBAL_RST_SHIFT                  1u\r\n#define LPUART_GLOBAL_RST_WIDTH                  1u\r\n#define LPUART_GLOBAL_RST(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_GLOBAL_RST_SHIFT))&LPUART_GLOBAL_RST_MASK)\r\n/* PINCFG Bit Fields */\r\n#define LPUART_PINCFG_TRGSEL_MASK                0x3u\r\n#define LPUART_PINCFG_TRGSEL_SHIFT               0u\r\n#define LPUART_PINCFG_TRGSEL_WIDTH               2u\r\n#define LPUART_PINCFG_TRGSEL(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_PINCFG_TRGSEL_SHIFT))&LPUART_PINCFG_TRGSEL_MASK)\r\n/* BAUD Bit Fields */\r\n#define LPUART_BAUD_SBR_MASK                     0x1FFFu\r\n#define LPUART_BAUD_SBR_SHIFT                    0u\r\n#define LPUART_BAUD_SBR_WIDTH                    13u\r\n#define LPUART_BAUD_SBR(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_SBR_SHIFT))&LPUART_BAUD_SBR_MASK)\r\n#define LPUART_BAUD_SBNS_MASK                    0x2000u\r\n#define LPUART_BAUD_SBNS_SHIFT                   13u\r\n#define LPUART_BAUD_SBNS_WIDTH                   1u\r\n#define LPUART_BAUD_SBNS(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_SBNS_SHIFT))&LPUART_BAUD_SBNS_MASK)\r\n#define LPUART_BAUD_RXEDGIE_MASK                 0x4000u\r\n#define LPUART_BAUD_RXEDGIE_SHIFT                14u\r\n#define LPUART_BAUD_RXEDGIE_WIDTH                1u\r\n#define LPUART_BAUD_RXEDGIE(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_RXEDGIE_SHIFT))&LPUART_BAUD_RXEDGIE_MASK)\r\n#define LPUART_BAUD_LBKDIE_MASK                  0x8000u\r\n#define LPUART_BAUD_LBKDIE_SHIFT                 15u\r\n#define LPUART_BAUD_LBKDIE_WIDTH                 1u\r\n#define LPUART_BAUD_LBKDIE(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_LBKDIE_SHIFT))&LPUART_BAUD_LBKDIE_MASK)\r\n#define LPUART_BAUD_RESYNCDIS_MASK               0x10000u\r\n#define LPUART_BAUD_RESYNCDIS_SHIFT              16u\r\n#define LPUART_BAUD_RESYNCDIS_WIDTH              1u\r\n#define LPUART_BAUD_RESYNCDIS(x)                 (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_RESYNCDIS_SHIFT))&LPUART_BAUD_RESYNCDIS_MASK)\r\n#define LPUART_BAUD_BOTHEDGE_MASK                0x20000u\r\n#define LPUART_BAUD_BOTHEDGE_SHIFT               17u\r\n#define LPUART_BAUD_BOTHEDGE_WIDTH               1u\r\n#define LPUART_BAUD_BOTHEDGE(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_BOTHEDGE_SHIFT))&LPUART_BAUD_BOTHEDGE_MASK)\r\n#define LPUART_BAUD_MATCFG_MASK                  0xC0000u\r\n#define LPUART_BAUD_MATCFG_SHIFT                 18u\r\n#define LPUART_BAUD_MATCFG_WIDTH                 2u\r\n#define LPUART_BAUD_MATCFG(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_MATCFG_SHIFT))&LPUART_BAUD_MATCFG_MASK)\r\n#define LPUART_BAUD_RIDMAE_MASK                  0x100000u\r\n#define LPUART_BAUD_RIDMAE_SHIFT                 20u\r\n#define LPUART_BAUD_RIDMAE_WIDTH                 1u\r\n#define LPUART_BAUD_RIDMAE(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_RIDMAE_SHIFT))&LPUART_BAUD_RIDMAE_MASK)\r\n#define LPUART_BAUD_RDMAE_MASK                   0x200000u\r\n#define LPUART_BAUD_RDMAE_SHIFT                  21u\r\n#define LPUART_BAUD_RDMAE_WIDTH                  1u\r\n#define LPUART_BAUD_RDMAE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_RDMAE_SHIFT))&LPUART_BAUD_RDMAE_MASK)\r\n#define LPUART_BAUD_TDMAE_MASK                   0x800000u\r\n#define LPUART_BAUD_TDMAE_SHIFT                  23u\r\n#define LPUART_BAUD_TDMAE_WIDTH                  1u\r\n#define LPUART_BAUD_TDMAE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_TDMAE_SHIFT))&LPUART_BAUD_TDMAE_MASK)\r\n#define LPUART_BAUD_OSR_MASK                     0x1F000000u\r\n#define LPUART_BAUD_OSR_SHIFT                    24u\r\n#define LPUART_BAUD_OSR_WIDTH                    5u\r\n#define LPUART_BAUD_OSR(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_OSR_SHIFT))&LPUART_BAUD_OSR_MASK)\r\n#define LPUART_BAUD_M10_MASK                     0x20000000u\r\n#define LPUART_BAUD_M10_SHIFT                    29u\r\n#define LPUART_BAUD_M10_WIDTH                    1u\r\n#define LPUART_BAUD_M10(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_M10_SHIFT))&LPUART_BAUD_M10_MASK)\r\n#define LPUART_BAUD_MAEN2_MASK                   0x40000000u\r\n#define LPUART_BAUD_MAEN2_SHIFT                  30u\r\n#define LPUART_BAUD_MAEN2_WIDTH                  1u\r\n#define LPUART_BAUD_MAEN2(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_MAEN2_SHIFT))&LPUART_BAUD_MAEN2_MASK)\r\n#define LPUART_BAUD_MAEN1_MASK                   0x80000000u\r\n#define LPUART_BAUD_MAEN1_SHIFT                  31u\r\n#define LPUART_BAUD_MAEN1_WIDTH                  1u\r\n#define LPUART_BAUD_MAEN1(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_BAUD_MAEN1_SHIFT))&LPUART_BAUD_MAEN1_MASK)\r\n/* STAT Bit Fields */\r\n#define LPUART_STAT_MA2F_MASK                    0x4000u\r\n#define LPUART_STAT_MA2F_SHIFT                   14u\r\n#define LPUART_STAT_MA2F_WIDTH                   1u\r\n#define LPUART_STAT_MA2F(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_MA2F_SHIFT))&LPUART_STAT_MA2F_MASK)\r\n#define LPUART_STAT_MA1F_MASK                    0x8000u\r\n#define LPUART_STAT_MA1F_SHIFT                   15u\r\n#define LPUART_STAT_MA1F_WIDTH                   1u\r\n#define LPUART_STAT_MA1F(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_MA1F_SHIFT))&LPUART_STAT_MA1F_MASK)\r\n#define LPUART_STAT_PF_MASK                      0x10000u\r\n#define LPUART_STAT_PF_SHIFT                     16u\r\n#define LPUART_STAT_PF_WIDTH                     1u\r\n#define LPUART_STAT_PF(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_PF_SHIFT))&LPUART_STAT_PF_MASK)\r\n#define LPUART_STAT_FE_MASK                      0x20000u\r\n#define LPUART_STAT_FE_SHIFT                     17u\r\n#define LPUART_STAT_FE_WIDTH                     1u\r\n#define LPUART_STAT_FE(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_FE_SHIFT))&LPUART_STAT_FE_MASK)\r\n#define LPUART_STAT_NF_MASK                      0x40000u\r\n#define LPUART_STAT_NF_SHIFT                     18u\r\n#define LPUART_STAT_NF_WIDTH                     1u\r\n#define LPUART_STAT_NF(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_NF_SHIFT))&LPUART_STAT_NF_MASK)\r\n#define LPUART_STAT_OR_MASK                      0x80000u\r\n#define LPUART_STAT_OR_SHIFT                     19u\r\n#define LPUART_STAT_OR_WIDTH                     1u\r\n#define LPUART_STAT_OR(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_OR_SHIFT))&LPUART_STAT_OR_MASK)\r\n#define LPUART_STAT_IDLE_MASK                    0x100000u\r\n#define LPUART_STAT_IDLE_SHIFT                   20u\r\n#define LPUART_STAT_IDLE_WIDTH                   1u\r\n#define LPUART_STAT_IDLE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_IDLE_SHIFT))&LPUART_STAT_IDLE_MASK)\r\n#define LPUART_STAT_RDRF_MASK                    0x200000u\r\n#define LPUART_STAT_RDRF_SHIFT                   21u\r\n#define LPUART_STAT_RDRF_WIDTH                   1u\r\n#define LPUART_STAT_RDRF(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_RDRF_SHIFT))&LPUART_STAT_RDRF_MASK)\r\n#define LPUART_STAT_TC_MASK                      0x400000u\r\n#define LPUART_STAT_TC_SHIFT                     22u\r\n#define LPUART_STAT_TC_WIDTH                     1u\r\n#define LPUART_STAT_TC(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_TC_SHIFT))&LPUART_STAT_TC_MASK)\r\n#define LPUART_STAT_TDRE_MASK                    0x800000u\r\n#define LPUART_STAT_TDRE_SHIFT                   23u\r\n#define LPUART_STAT_TDRE_WIDTH                   1u\r\n#define LPUART_STAT_TDRE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_TDRE_SHIFT))&LPUART_STAT_TDRE_MASK)\r\n#define LPUART_STAT_RAF_MASK                     0x1000000u\r\n#define LPUART_STAT_RAF_SHIFT                    24u\r\n#define LPUART_STAT_RAF_WIDTH                    1u\r\n#define LPUART_STAT_RAF(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_RAF_SHIFT))&LPUART_STAT_RAF_MASK)\r\n#define LPUART_STAT_LBKDE_MASK                   0x2000000u\r\n#define LPUART_STAT_LBKDE_SHIFT                  25u\r\n#define LPUART_STAT_LBKDE_WIDTH                  1u\r\n#define LPUART_STAT_LBKDE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_LBKDE_SHIFT))&LPUART_STAT_LBKDE_MASK)\r\n#define LPUART_STAT_BRK13_MASK                   0x4000000u\r\n#define LPUART_STAT_BRK13_SHIFT                  26u\r\n#define LPUART_STAT_BRK13_WIDTH                  1u\r\n#define LPUART_STAT_BRK13(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_BRK13_SHIFT))&LPUART_STAT_BRK13_MASK)\r\n#define LPUART_STAT_RWUID_MASK                   0x8000000u\r\n#define LPUART_STAT_RWUID_SHIFT                  27u\r\n#define LPUART_STAT_RWUID_WIDTH                  1u\r\n#define LPUART_STAT_RWUID(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_RWUID_SHIFT))&LPUART_STAT_RWUID_MASK)\r\n#define LPUART_STAT_RXINV_MASK                   0x10000000u\r\n#define LPUART_STAT_RXINV_SHIFT                  28u\r\n#define LPUART_STAT_RXINV_WIDTH                  1u\r\n#define LPUART_STAT_RXINV(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_RXINV_SHIFT))&LPUART_STAT_RXINV_MASK)\r\n#define LPUART_STAT_MSBF_MASK                    0x20000000u\r\n#define LPUART_STAT_MSBF_SHIFT                   29u\r\n#define LPUART_STAT_MSBF_WIDTH                   1u\r\n#define LPUART_STAT_MSBF(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_MSBF_SHIFT))&LPUART_STAT_MSBF_MASK)\r\n#define LPUART_STAT_RXEDGIF_MASK                 0x40000000u\r\n#define LPUART_STAT_RXEDGIF_SHIFT                30u\r\n#define LPUART_STAT_RXEDGIF_WIDTH                1u\r\n#define LPUART_STAT_RXEDGIF(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_RXEDGIF_SHIFT))&LPUART_STAT_RXEDGIF_MASK)\r\n#define LPUART_STAT_LBKDIF_MASK                  0x80000000u\r\n#define LPUART_STAT_LBKDIF_SHIFT                 31u\r\n#define LPUART_STAT_LBKDIF_WIDTH                 1u\r\n#define LPUART_STAT_LBKDIF(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_STAT_LBKDIF_SHIFT))&LPUART_STAT_LBKDIF_MASK)\r\n/* CTRL Bit Fields */\r\n#define LPUART_CTRL_PT_MASK                      0x1u\r\n#define LPUART_CTRL_PT_SHIFT                     0u\r\n#define LPUART_CTRL_PT_WIDTH                     1u\r\n#define LPUART_CTRL_PT(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_PT_SHIFT))&LPUART_CTRL_PT_MASK)\r\n#define LPUART_CTRL_PE_MASK                      0x2u\r\n#define LPUART_CTRL_PE_SHIFT                     1u\r\n#define LPUART_CTRL_PE_WIDTH                     1u\r\n#define LPUART_CTRL_PE(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_PE_SHIFT))&LPUART_CTRL_PE_MASK)\r\n#define LPUART_CTRL_ILT_MASK                     0x4u\r\n#define LPUART_CTRL_ILT_SHIFT                    2u\r\n#define LPUART_CTRL_ILT_WIDTH                    1u\r\n#define LPUART_CTRL_ILT(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_ILT_SHIFT))&LPUART_CTRL_ILT_MASK)\r\n#define LPUART_CTRL_WAKE_MASK                    0x8u\r\n#define LPUART_CTRL_WAKE_SHIFT                   3u\r\n#define LPUART_CTRL_WAKE_WIDTH                   1u\r\n#define LPUART_CTRL_WAKE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_WAKE_SHIFT))&LPUART_CTRL_WAKE_MASK)\r\n#define LPUART_CTRL_M_MASK                       0x10u\r\n#define LPUART_CTRL_M_SHIFT                      4u\r\n#define LPUART_CTRL_M_WIDTH                      1u\r\n#define LPUART_CTRL_M(x)                         (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_M_SHIFT))&LPUART_CTRL_M_MASK)\r\n#define LPUART_CTRL_RSRC_MASK                    0x20u\r\n#define LPUART_CTRL_RSRC_SHIFT                   5u\r\n#define LPUART_CTRL_RSRC_WIDTH                   1u\r\n#define LPUART_CTRL_RSRC(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_RSRC_SHIFT))&LPUART_CTRL_RSRC_MASK)\r\n#define LPUART_CTRL_DOZEEN_MASK                  0x40u\r\n#define LPUART_CTRL_DOZEEN_SHIFT                 6u\r\n#define LPUART_CTRL_DOZEEN_WIDTH                 1u\r\n#define LPUART_CTRL_DOZEEN(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_DOZEEN_SHIFT))&LPUART_CTRL_DOZEEN_MASK)\r\n#define LPUART_CTRL_LOOPS_MASK                   0x80u\r\n#define LPUART_CTRL_LOOPS_SHIFT                  7u\r\n#define LPUART_CTRL_LOOPS_WIDTH                  1u\r\n#define LPUART_CTRL_LOOPS(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_LOOPS_SHIFT))&LPUART_CTRL_LOOPS_MASK)\r\n#define LPUART_CTRL_IDLECFG_MASK                 0x700u\r\n#define LPUART_CTRL_IDLECFG_SHIFT                8u\r\n#define LPUART_CTRL_IDLECFG_WIDTH                3u\r\n#define LPUART_CTRL_IDLECFG(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_IDLECFG_SHIFT))&LPUART_CTRL_IDLECFG_MASK)\r\n#define LPUART_CTRL_M7_MASK                      0x800u\r\n#define LPUART_CTRL_M7_SHIFT                     11u\r\n#define LPUART_CTRL_M7_WIDTH                     1u\r\n#define LPUART_CTRL_M7(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_M7_SHIFT))&LPUART_CTRL_M7_MASK)\r\n#define LPUART_CTRL_MA2IE_MASK                   0x4000u\r\n#define LPUART_CTRL_MA2IE_SHIFT                  14u\r\n#define LPUART_CTRL_MA2IE_WIDTH                  1u\r\n#define LPUART_CTRL_MA2IE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_MA2IE_SHIFT))&LPUART_CTRL_MA2IE_MASK)\r\n#define LPUART_CTRL_MA1IE_MASK                   0x8000u\r\n#define LPUART_CTRL_MA1IE_SHIFT                  15u\r\n#define LPUART_CTRL_MA1IE_WIDTH                  1u\r\n#define LPUART_CTRL_MA1IE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_MA1IE_SHIFT))&LPUART_CTRL_MA1IE_MASK)\r\n#define LPUART_CTRL_SBK_MASK                     0x10000u\r\n#define LPUART_CTRL_SBK_SHIFT                    16u\r\n#define LPUART_CTRL_SBK_WIDTH                    1u\r\n#define LPUART_CTRL_SBK(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_SBK_SHIFT))&LPUART_CTRL_SBK_MASK)\r\n#define LPUART_CTRL_RWU_MASK                     0x20000u\r\n#define LPUART_CTRL_RWU_SHIFT                    17u\r\n#define LPUART_CTRL_RWU_WIDTH                    1u\r\n#define LPUART_CTRL_RWU(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_RWU_SHIFT))&LPUART_CTRL_RWU_MASK)\r\n#define LPUART_CTRL_RE_MASK                      0x40000u\r\n#define LPUART_CTRL_RE_SHIFT                     18u\r\n#define LPUART_CTRL_RE_WIDTH                     1u\r\n#define LPUART_CTRL_RE(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_RE_SHIFT))&LPUART_CTRL_RE_MASK)\r\n#define LPUART_CTRL_TE_MASK                      0x80000u\r\n#define LPUART_CTRL_TE_SHIFT                     19u\r\n#define LPUART_CTRL_TE_WIDTH                     1u\r\n#define LPUART_CTRL_TE(x)                        (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_TE_SHIFT))&LPUART_CTRL_TE_MASK)\r\n#define LPUART_CTRL_ILIE_MASK                    0x100000u\r\n#define LPUART_CTRL_ILIE_SHIFT                   20u\r\n#define LPUART_CTRL_ILIE_WIDTH                   1u\r\n#define LPUART_CTRL_ILIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_ILIE_SHIFT))&LPUART_CTRL_ILIE_MASK)\r\n#define LPUART_CTRL_RIE_MASK                     0x200000u\r\n#define LPUART_CTRL_RIE_SHIFT                    21u\r\n#define LPUART_CTRL_RIE_WIDTH                    1u\r\n#define LPUART_CTRL_RIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_RIE_SHIFT))&LPUART_CTRL_RIE_MASK)\r\n#define LPUART_CTRL_TCIE_MASK                    0x400000u\r\n#define LPUART_CTRL_TCIE_SHIFT                   22u\r\n#define LPUART_CTRL_TCIE_WIDTH                   1u\r\n#define LPUART_CTRL_TCIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_TCIE_SHIFT))&LPUART_CTRL_TCIE_MASK)\r\n#define LPUART_CTRL_TIE_MASK                     0x800000u\r\n#define LPUART_CTRL_TIE_SHIFT                    23u\r\n#define LPUART_CTRL_TIE_WIDTH                    1u\r\n#define LPUART_CTRL_TIE(x)                       (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_TIE_SHIFT))&LPUART_CTRL_TIE_MASK)\r\n#define LPUART_CTRL_PEIE_MASK                    0x1000000u\r\n#define LPUART_CTRL_PEIE_SHIFT                   24u\r\n#define LPUART_CTRL_PEIE_WIDTH                   1u\r\n#define LPUART_CTRL_PEIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_PEIE_SHIFT))&LPUART_CTRL_PEIE_MASK)\r\n#define LPUART_CTRL_FEIE_MASK                    0x2000000u\r\n#define LPUART_CTRL_FEIE_SHIFT                   25u\r\n#define LPUART_CTRL_FEIE_WIDTH                   1u\r\n#define LPUART_CTRL_FEIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_FEIE_SHIFT))&LPUART_CTRL_FEIE_MASK)\r\n#define LPUART_CTRL_NEIE_MASK                    0x4000000u\r\n#define LPUART_CTRL_NEIE_SHIFT                   26u\r\n#define LPUART_CTRL_NEIE_WIDTH                   1u\r\n#define LPUART_CTRL_NEIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_NEIE_SHIFT))&LPUART_CTRL_NEIE_MASK)\r\n#define LPUART_CTRL_ORIE_MASK                    0x8000000u\r\n#define LPUART_CTRL_ORIE_SHIFT                   27u\r\n#define LPUART_CTRL_ORIE_WIDTH                   1u\r\n#define LPUART_CTRL_ORIE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_ORIE_SHIFT))&LPUART_CTRL_ORIE_MASK)\r\n#define LPUART_CTRL_TXINV_MASK                   0x10000000u\r\n#define LPUART_CTRL_TXINV_SHIFT                  28u\r\n#define LPUART_CTRL_TXINV_WIDTH                  1u\r\n#define LPUART_CTRL_TXINV(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_TXINV_SHIFT))&LPUART_CTRL_TXINV_MASK)\r\n#define LPUART_CTRL_TXDIR_MASK                   0x20000000u\r\n#define LPUART_CTRL_TXDIR_SHIFT                  29u\r\n#define LPUART_CTRL_TXDIR_WIDTH                  1u\r\n#define LPUART_CTRL_TXDIR(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_TXDIR_SHIFT))&LPUART_CTRL_TXDIR_MASK)\r\n#define LPUART_CTRL_R9T8_MASK                    0x40000000u\r\n#define LPUART_CTRL_R9T8_SHIFT                   30u\r\n#define LPUART_CTRL_R9T8_WIDTH                   1u\r\n#define LPUART_CTRL_R9T8(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_R9T8_SHIFT))&LPUART_CTRL_R9T8_MASK)\r\n#define LPUART_CTRL_R8T9_MASK                    0x80000000u\r\n#define LPUART_CTRL_R8T9_SHIFT                   31u\r\n#define LPUART_CTRL_R8T9_WIDTH                   1u\r\n#define LPUART_CTRL_R8T9(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_CTRL_R8T9_SHIFT))&LPUART_CTRL_R8T9_MASK)\r\n/* DATA Bit Fields */\r\n#define LPUART_DATA_R0T0_MASK                    0x1u\r\n#define LPUART_DATA_R0T0_SHIFT                   0u\r\n#define LPUART_DATA_R0T0_WIDTH                   1u\r\n#define LPUART_DATA_R0T0(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R0T0_SHIFT))&LPUART_DATA_R0T0_MASK)\r\n#define LPUART_DATA_R1T1_MASK                    0x2u\r\n#define LPUART_DATA_R1T1_SHIFT                   1u\r\n#define LPUART_DATA_R1T1_WIDTH                   1u\r\n#define LPUART_DATA_R1T1(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R1T1_SHIFT))&LPUART_DATA_R1T1_MASK)\r\n#define LPUART_DATA_R2T2_MASK                    0x4u\r\n#define LPUART_DATA_R2T2_SHIFT                   2u\r\n#define LPUART_DATA_R2T2_WIDTH                   1u\r\n#define LPUART_DATA_R2T2(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R2T2_SHIFT))&LPUART_DATA_R2T2_MASK)\r\n#define LPUART_DATA_R3T3_MASK                    0x8u\r\n#define LPUART_DATA_R3T3_SHIFT                   3u\r\n#define LPUART_DATA_R3T3_WIDTH                   1u\r\n#define LPUART_DATA_R3T3(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R3T3_SHIFT))&LPUART_DATA_R3T3_MASK)\r\n#define LPUART_DATA_R4T4_MASK                    0x10u\r\n#define LPUART_DATA_R4T4_SHIFT                   4u\r\n#define LPUART_DATA_R4T4_WIDTH                   1u\r\n#define LPUART_DATA_R4T4(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R4T4_SHIFT))&LPUART_DATA_R4T4_MASK)\r\n#define LPUART_DATA_R5T5_MASK                    0x20u\r\n#define LPUART_DATA_R5T5_SHIFT                   5u\r\n#define LPUART_DATA_R5T5_WIDTH                   1u\r\n#define LPUART_DATA_R5T5(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R5T5_SHIFT))&LPUART_DATA_R5T5_MASK)\r\n#define LPUART_DATA_R6T6_MASK                    0x40u\r\n#define LPUART_DATA_R6T6_SHIFT                   6u\r\n#define LPUART_DATA_R6T6_WIDTH                   1u\r\n#define LPUART_DATA_R6T6(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R6T6_SHIFT))&LPUART_DATA_R6T6_MASK)\r\n#define LPUART_DATA_R7T7_MASK                    0x80u\r\n#define LPUART_DATA_R7T7_SHIFT                   7u\r\n#define LPUART_DATA_R7T7_WIDTH                   1u\r\n#define LPUART_DATA_R7T7(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R7T7_SHIFT))&LPUART_DATA_R7T7_MASK)\r\n#define LPUART_DATA_R8T8_MASK                    0x100u\r\n#define LPUART_DATA_R8T8_SHIFT                   8u\r\n#define LPUART_DATA_R8T8_WIDTH                   1u\r\n#define LPUART_DATA_R8T8(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R8T8_SHIFT))&LPUART_DATA_R8T8_MASK)\r\n#define LPUART_DATA_R9T9_MASK                    0x200u\r\n#define LPUART_DATA_R9T9_SHIFT                   9u\r\n#define LPUART_DATA_R9T9_WIDTH                   1u\r\n#define LPUART_DATA_R9T9(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_R9T9_SHIFT))&LPUART_DATA_R9T9_MASK)\r\n#define LPUART_DATA_IDLINE_MASK                  0x800u\r\n#define LPUART_DATA_IDLINE_SHIFT                 11u\r\n#define LPUART_DATA_IDLINE_WIDTH                 1u\r\n#define LPUART_DATA_IDLINE(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_IDLINE_SHIFT))&LPUART_DATA_IDLINE_MASK)\r\n#define LPUART_DATA_RXEMPT_MASK                  0x1000u\r\n#define LPUART_DATA_RXEMPT_SHIFT                 12u\r\n#define LPUART_DATA_RXEMPT_WIDTH                 1u\r\n#define LPUART_DATA_RXEMPT(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_RXEMPT_SHIFT))&LPUART_DATA_RXEMPT_MASK)\r\n#define LPUART_DATA_FRETSC_MASK                  0x2000u\r\n#define LPUART_DATA_FRETSC_SHIFT                 13u\r\n#define LPUART_DATA_FRETSC_WIDTH                 1u\r\n#define LPUART_DATA_FRETSC(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_FRETSC_SHIFT))&LPUART_DATA_FRETSC_MASK)\r\n#define LPUART_DATA_PARITYE_MASK                 0x4000u\r\n#define LPUART_DATA_PARITYE_SHIFT                14u\r\n#define LPUART_DATA_PARITYE_WIDTH                1u\r\n#define LPUART_DATA_PARITYE(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_PARITYE_SHIFT))&LPUART_DATA_PARITYE_MASK)\r\n#define LPUART_DATA_NOISY_MASK                   0x8000u\r\n#define LPUART_DATA_NOISY_SHIFT                  15u\r\n#define LPUART_DATA_NOISY_WIDTH                  1u\r\n#define LPUART_DATA_NOISY(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_DATA_NOISY_SHIFT))&LPUART_DATA_NOISY_MASK)\r\n/* MATCH Bit Fields */\r\n#define LPUART_MATCH_MA1_MASK                    0x3FFu\r\n#define LPUART_MATCH_MA1_SHIFT                   0u\r\n#define LPUART_MATCH_MA1_WIDTH                   10u\r\n#define LPUART_MATCH_MA1(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_MATCH_MA1_SHIFT))&LPUART_MATCH_MA1_MASK)\r\n#define LPUART_MATCH_MA2_MASK                    0x3FF0000u\r\n#define LPUART_MATCH_MA2_SHIFT                   16u\r\n#define LPUART_MATCH_MA2_WIDTH                   10u\r\n#define LPUART_MATCH_MA2(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_MATCH_MA2_SHIFT))&LPUART_MATCH_MA2_MASK)\r\n/* MODIR Bit Fields */\r\n#define LPUART_MODIR_TXCTSE_MASK                 0x1u\r\n#define LPUART_MODIR_TXCTSE_SHIFT                0u\r\n#define LPUART_MODIR_TXCTSE_WIDTH                1u\r\n#define LPUART_MODIR_TXCTSE(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_TXCTSE_SHIFT))&LPUART_MODIR_TXCTSE_MASK)\r\n#define LPUART_MODIR_TXRTSE_MASK                 0x2u\r\n#define LPUART_MODIR_TXRTSE_SHIFT                1u\r\n#define LPUART_MODIR_TXRTSE_WIDTH                1u\r\n#define LPUART_MODIR_TXRTSE(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_TXRTSE_SHIFT))&LPUART_MODIR_TXRTSE_MASK)\r\n#define LPUART_MODIR_TXRTSPOL_MASK               0x4u\r\n#define LPUART_MODIR_TXRTSPOL_SHIFT              2u\r\n#define LPUART_MODIR_TXRTSPOL_WIDTH              1u\r\n#define LPUART_MODIR_TXRTSPOL(x)                 (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_TXRTSPOL_SHIFT))&LPUART_MODIR_TXRTSPOL_MASK)\r\n#define LPUART_MODIR_RXRTSE_MASK                 0x8u\r\n#define LPUART_MODIR_RXRTSE_SHIFT                3u\r\n#define LPUART_MODIR_RXRTSE_WIDTH                1u\r\n#define LPUART_MODIR_RXRTSE(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_RXRTSE_SHIFT))&LPUART_MODIR_RXRTSE_MASK)\r\n#define LPUART_MODIR_TXCTSC_MASK                 0x10u\r\n#define LPUART_MODIR_TXCTSC_SHIFT                4u\r\n#define LPUART_MODIR_TXCTSC_WIDTH                1u\r\n#define LPUART_MODIR_TXCTSC(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_TXCTSC_SHIFT))&LPUART_MODIR_TXCTSC_MASK)\r\n#define LPUART_MODIR_TXCTSSRC_MASK               0x20u\r\n#define LPUART_MODIR_TXCTSSRC_SHIFT              5u\r\n#define LPUART_MODIR_TXCTSSRC_WIDTH              1u\r\n#define LPUART_MODIR_TXCTSSRC(x)                 (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_TXCTSSRC_SHIFT))&LPUART_MODIR_TXCTSSRC_MASK)\r\n#define LPUART_MODIR_RTSWATER_MASK               0x300u\r\n#define LPUART_MODIR_RTSWATER_SHIFT              8u\r\n#define LPUART_MODIR_RTSWATER_WIDTH              2u\r\n#define LPUART_MODIR_RTSWATER(x)                 (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_RTSWATER_SHIFT))&LPUART_MODIR_RTSWATER_MASK)\r\n#define LPUART_MODIR_TNP_MASK                    0x30000u\r\n#define LPUART_MODIR_TNP_SHIFT                   16u\r\n#define LPUART_MODIR_TNP_WIDTH                   2u\r\n#define LPUART_MODIR_TNP(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_TNP_SHIFT))&LPUART_MODIR_TNP_MASK)\r\n#define LPUART_MODIR_IREN_MASK                   0x40000u\r\n#define LPUART_MODIR_IREN_SHIFT                  18u\r\n#define LPUART_MODIR_IREN_WIDTH                  1u\r\n#define LPUART_MODIR_IREN(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_MODIR_IREN_SHIFT))&LPUART_MODIR_IREN_MASK)\r\n/* FIFO Bit Fields */\r\n#define LPUART_FIFO_RXFIFOSIZE_MASK              0x7u\r\n#define LPUART_FIFO_RXFIFOSIZE_SHIFT             0u\r\n#define LPUART_FIFO_RXFIFOSIZE_WIDTH             3u\r\n#define LPUART_FIFO_RXFIFOSIZE(x)                (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXFIFOSIZE_SHIFT))&LPUART_FIFO_RXFIFOSIZE_MASK)\r\n#define LPUART_FIFO_RXFE_MASK                    0x8u\r\n#define LPUART_FIFO_RXFE_SHIFT                   3u\r\n#define LPUART_FIFO_RXFE_WIDTH                   1u\r\n#define LPUART_FIFO_RXFE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXFE_SHIFT))&LPUART_FIFO_RXFE_MASK)\r\n#define LPUART_FIFO_TXFIFOSIZE_MASK              0x70u\r\n#define LPUART_FIFO_TXFIFOSIZE_SHIFT             4u\r\n#define LPUART_FIFO_TXFIFOSIZE_WIDTH             3u\r\n#define LPUART_FIFO_TXFIFOSIZE(x)                (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_TXFIFOSIZE_SHIFT))&LPUART_FIFO_TXFIFOSIZE_MASK)\r\n#define LPUART_FIFO_TXFE_MASK                    0x80u\r\n#define LPUART_FIFO_TXFE_SHIFT                   7u\r\n#define LPUART_FIFO_TXFE_WIDTH                   1u\r\n#define LPUART_FIFO_TXFE(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_TXFE_SHIFT))&LPUART_FIFO_TXFE_MASK)\r\n#define LPUART_FIFO_RXUFE_MASK                   0x100u\r\n#define LPUART_FIFO_RXUFE_SHIFT                  8u\r\n#define LPUART_FIFO_RXUFE_WIDTH                  1u\r\n#define LPUART_FIFO_RXUFE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXUFE_SHIFT))&LPUART_FIFO_RXUFE_MASK)\r\n#define LPUART_FIFO_TXOFE_MASK                   0x200u\r\n#define LPUART_FIFO_TXOFE_SHIFT                  9u\r\n#define LPUART_FIFO_TXOFE_WIDTH                  1u\r\n#define LPUART_FIFO_TXOFE(x)                     (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_TXOFE_SHIFT))&LPUART_FIFO_TXOFE_MASK)\r\n#define LPUART_FIFO_RXIDEN_MASK                  0x1C00u\r\n#define LPUART_FIFO_RXIDEN_SHIFT                 10u\r\n#define LPUART_FIFO_RXIDEN_WIDTH                 3u\r\n#define LPUART_FIFO_RXIDEN(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXIDEN_SHIFT))&LPUART_FIFO_RXIDEN_MASK)\r\n#define LPUART_FIFO_RXFLUSH_MASK                 0x4000u\r\n#define LPUART_FIFO_RXFLUSH_SHIFT                14u\r\n#define LPUART_FIFO_RXFLUSH_WIDTH                1u\r\n#define LPUART_FIFO_RXFLUSH(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXFLUSH_SHIFT))&LPUART_FIFO_RXFLUSH_MASK)\r\n#define LPUART_FIFO_TXFLUSH_MASK                 0x8000u\r\n#define LPUART_FIFO_TXFLUSH_SHIFT                15u\r\n#define LPUART_FIFO_TXFLUSH_WIDTH                1u\r\n#define LPUART_FIFO_TXFLUSH(x)                   (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_TXFLUSH_SHIFT))&LPUART_FIFO_TXFLUSH_MASK)\r\n#define LPUART_FIFO_RXUF_MASK                    0x10000u\r\n#define LPUART_FIFO_RXUF_SHIFT                   16u\r\n#define LPUART_FIFO_RXUF_WIDTH                   1u\r\n#define LPUART_FIFO_RXUF(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXUF_SHIFT))&LPUART_FIFO_RXUF_MASK)\r\n#define LPUART_FIFO_TXOF_MASK                    0x20000u\r\n#define LPUART_FIFO_TXOF_SHIFT                   17u\r\n#define LPUART_FIFO_TXOF_WIDTH                   1u\r\n#define LPUART_FIFO_TXOF(x)                      (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_TXOF_SHIFT))&LPUART_FIFO_TXOF_MASK)\r\n#define LPUART_FIFO_RXEMPT_MASK                  0x400000u\r\n#define LPUART_FIFO_RXEMPT_SHIFT                 22u\r\n#define LPUART_FIFO_RXEMPT_WIDTH                 1u\r\n#define LPUART_FIFO_RXEMPT(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_RXEMPT_SHIFT))&LPUART_FIFO_RXEMPT_MASK)\r\n#define LPUART_FIFO_TXEMPT_MASK                  0x800000u\r\n#define LPUART_FIFO_TXEMPT_SHIFT                 23u\r\n#define LPUART_FIFO_TXEMPT_WIDTH                 1u\r\n#define LPUART_FIFO_TXEMPT(x)                    (((uint32_t)(((uint32_t)(x))<<LPUART_FIFO_TXEMPT_SHIFT))&LPUART_FIFO_TXEMPT_MASK)\r\n/* WATER Bit Fields */\r\n#define LPUART_WATER_TXWATER_MASK                0x3u\r\n#define LPUART_WATER_TXWATER_SHIFT               0u\r\n#define LPUART_WATER_TXWATER_WIDTH               2u\r\n#define LPUART_WATER_TXWATER(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_WATER_TXWATER_SHIFT))&LPUART_WATER_TXWATER_MASK)\r\n#define LPUART_WATER_TXCOUNT_MASK                0x700u\r\n#define LPUART_WATER_TXCOUNT_SHIFT               8u\r\n#define LPUART_WATER_TXCOUNT_WIDTH               3u\r\n#define LPUART_WATER_TXCOUNT(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_WATER_TXCOUNT_SHIFT))&LPUART_WATER_TXCOUNT_MASK)\r\n#define LPUART_WATER_RXWATER_MASK                0x30000u\r\n#define LPUART_WATER_RXWATER_SHIFT               16u\r\n#define LPUART_WATER_RXWATER_WIDTH               2u\r\n#define LPUART_WATER_RXWATER(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_WATER_RXWATER_SHIFT))&LPUART_WATER_RXWATER_MASK)\r\n#define LPUART_WATER_RXCOUNT_MASK                0x7000000u\r\n#define LPUART_WATER_RXCOUNT_SHIFT               24u\r\n#define LPUART_WATER_RXCOUNT_WIDTH               3u\r\n#define LPUART_WATER_RXCOUNT(x)                  (((uint32_t)(((uint32_t)(x))<<LPUART_WATER_RXCOUNT_SHIFT))&LPUART_WATER_RXCOUNT_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPUART_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group LPUART_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MCM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup MCM_Peripheral_Access_Layer MCM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** MCM - Size of Registers Arrays */\r\n#define MCM_LMDR_COUNT                           2u\r\n\r\n/** MCM - Register Layout Typedef */\r\ntypedef struct {\r\n       uint8_t RESERVED_0[8];\r\n  __I  uint16_t PLASC;                             /**< Crossbar Switch (AXBS) Slave Configuration, offset: 0x8 */\r\n  __I  uint16_t PLAMC;                             /**< Crossbar Switch (AXBS) Master Configuration, offset: 0xA */\r\n  __IO uint32_t CPCR;                              /**< Core Platform Control Register, offset: 0xC */\r\n  __IO uint32_t ISCR;                              /**< Interrupt Status and Control Register, offset: 0x10 */\r\n       uint8_t RESERVED_1[28];\r\n  __IO uint32_t PID;                               /**< Process ID Register, offset: 0x30 */\r\n       uint8_t RESERVED_2[12];\r\n  __IO uint32_t CPO;                               /**< Compute Operation Control Register, offset: 0x40 */\r\n       uint8_t RESERVED_3[956];\r\n  __IO uint32_t LMDR[MCM_LMDR_COUNT];              /**< Local Memory Descriptor Register, array offset: 0x400, array step: 0x4 */\r\n  __IO uint32_t LMDR2;                             /**< Local Memory Descriptor Register2, offset: 0x408 */\r\n       uint8_t RESERVED_4[116];\r\n  __IO uint32_t LMPECR;                            /**< LMEM Parity and ECC Control Register, offset: 0x480 */\r\n       uint8_t RESERVED_5[4];\r\n  __IO uint32_t LMPEIR;                            /**< LMEM Parity and ECC Interrupt Register, offset: 0x488 */\r\n       uint8_t RESERVED_6[4];\r\n  __I  uint32_t LMFAR;                             /**< LMEM Fault Address Register, offset: 0x490 */\r\n  __I  uint32_t LMFATR;                            /**< LMEM Fault Attribute Register, offset: 0x494 */\r\n       uint8_t RESERVED_7[8];\r\n  __I  uint32_t LMFDHR;                            /**< LMEM Fault Data High Register, offset: 0x4A0 */\r\n  __I  uint32_t LMFDLR;                            /**< LMEM Fault Data Low Register, offset: 0x4A4 */\r\n} MCM_Type, *MCM_MemMapPtr;\r\n\r\n /** Number of instances of the MCM module. */\r\n#define MCM_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* MCM - Peripheral instance base addresses */\r\n/** Peripheral MCM base address */\r\n#define MCM_BASE                                 (0xE0080000u)\r\n/** Peripheral MCM base pointer */\r\n#define MCM                                      ((MCM_Type *)MCM_BASE)\r\n/** Array initializer of MCM peripheral base addresses */\r\n#define MCM_BASE_ADDRS                           { MCM_BASE }\r\n/** Array initializer of MCM peripheral base pointers */\r\n#define MCM_BASE_PTRS                            { MCM }\r\n /** Number of interrupt vector arrays for the MCM module. */\r\n#define MCM_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the MCM module. */\r\n#define MCM_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the MCM peripheral type */\r\n#define MCM_IRQS                                 { MCM_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MCM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup MCM_Register_Masks MCM Register Masks\r\n * @{\r\n */\r\n\r\n/* PLASC Bit Fields */\r\n#define MCM_PLASC_ASC_MASK                       0xFFu\r\n#define MCM_PLASC_ASC_SHIFT                      0u\r\n#define MCM_PLASC_ASC_WIDTH                      8u\r\n#define MCM_PLASC_ASC(x)                         (((uint16_t)(((uint16_t)(x))<<MCM_PLASC_ASC_SHIFT))&MCM_PLASC_ASC_MASK)\r\n/* PLAMC Bit Fields */\r\n#define MCM_PLAMC_AMC_MASK                       0xFFu\r\n#define MCM_PLAMC_AMC_SHIFT                      0u\r\n#define MCM_PLAMC_AMC_WIDTH                      8u\r\n#define MCM_PLAMC_AMC(x)                         (((uint16_t)(((uint16_t)(x))<<MCM_PLAMC_AMC_SHIFT))&MCM_PLAMC_AMC_MASK)\r\n/* CPCR Bit Fields */\r\n#define MCM_CPCR_HLT_FSM_ST_MASK                 0x3u\r\n#define MCM_CPCR_HLT_FSM_ST_SHIFT                0u\r\n#define MCM_CPCR_HLT_FSM_ST_WIDTH                2u\r\n#define MCM_CPCR_HLT_FSM_ST(x)                   (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_HLT_FSM_ST_SHIFT))&MCM_CPCR_HLT_FSM_ST_MASK)\r\n#define MCM_CPCR_AXBS_HLT_REQ_MASK               0x4u\r\n#define MCM_CPCR_AXBS_HLT_REQ_SHIFT              2u\r\n#define MCM_CPCR_AXBS_HLT_REQ_WIDTH              1u\r\n#define MCM_CPCR_AXBS_HLT_REQ(x)                 (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_AXBS_HLT_REQ_SHIFT))&MCM_CPCR_AXBS_HLT_REQ_MASK)\r\n#define MCM_CPCR_AXBS_HLTD_MASK                  0x8u\r\n#define MCM_CPCR_AXBS_HLTD_SHIFT                 3u\r\n#define MCM_CPCR_AXBS_HLTD_WIDTH                 1u\r\n#define MCM_CPCR_AXBS_HLTD(x)                    (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_AXBS_HLTD_SHIFT))&MCM_CPCR_AXBS_HLTD_MASK)\r\n#define MCM_CPCR_FMC_PF_IDLE_MASK                0x10u\r\n#define MCM_CPCR_FMC_PF_IDLE_SHIFT               4u\r\n#define MCM_CPCR_FMC_PF_IDLE_WIDTH               1u\r\n#define MCM_CPCR_FMC_PF_IDLE(x)                  (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_FMC_PF_IDLE_SHIFT))&MCM_CPCR_FMC_PF_IDLE_MASK)\r\n#define MCM_CPCR_PBRIDGE_IDLE_MASK               0x40u\r\n#define MCM_CPCR_PBRIDGE_IDLE_SHIFT              6u\r\n#define MCM_CPCR_PBRIDGE_IDLE_WIDTH              1u\r\n#define MCM_CPCR_PBRIDGE_IDLE(x)                 (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_PBRIDGE_IDLE_SHIFT))&MCM_CPCR_PBRIDGE_IDLE_MASK)\r\n#define MCM_CPCR_CBRR_MASK                       0x200u\r\n#define MCM_CPCR_CBRR_SHIFT                      9u\r\n#define MCM_CPCR_CBRR_WIDTH                      1u\r\n#define MCM_CPCR_CBRR(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_CBRR_SHIFT))&MCM_CPCR_CBRR_MASK)\r\n#define MCM_CPCR_SRAMUAP_MASK                    0x3000000u\r\n#define MCM_CPCR_SRAMUAP_SHIFT                   24u\r\n#define MCM_CPCR_SRAMUAP_WIDTH                   2u\r\n#define MCM_CPCR_SRAMUAP(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_SRAMUAP_SHIFT))&MCM_CPCR_SRAMUAP_MASK)\r\n#define MCM_CPCR_SRAMUWP_MASK                    0x4000000u\r\n#define MCM_CPCR_SRAMUWP_SHIFT                   26u\r\n#define MCM_CPCR_SRAMUWP_WIDTH                   1u\r\n#define MCM_CPCR_SRAMUWP(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_SRAMUWP_SHIFT))&MCM_CPCR_SRAMUWP_MASK)\r\n#define MCM_CPCR_SRAMLAP_MASK                    0x30000000u\r\n#define MCM_CPCR_SRAMLAP_SHIFT                   28u\r\n#define MCM_CPCR_SRAMLAP_WIDTH                   2u\r\n#define MCM_CPCR_SRAMLAP(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_SRAMLAP_SHIFT))&MCM_CPCR_SRAMLAP_MASK)\r\n#define MCM_CPCR_SRAMLWP_MASK                    0x40000000u\r\n#define MCM_CPCR_SRAMLWP_SHIFT                   30u\r\n#define MCM_CPCR_SRAMLWP_WIDTH                   1u\r\n#define MCM_CPCR_SRAMLWP(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_CPCR_SRAMLWP_SHIFT))&MCM_CPCR_SRAMLWP_MASK)\r\n/* ISCR Bit Fields */\r\n#define MCM_ISCR_FIOC_MASK                       0x100u\r\n#define MCM_ISCR_FIOC_SHIFT                      8u\r\n#define MCM_ISCR_FIOC_WIDTH                      1u\r\n#define MCM_ISCR_FIOC(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FIOC_SHIFT))&MCM_ISCR_FIOC_MASK)\r\n#define MCM_ISCR_FDZC_MASK                       0x200u\r\n#define MCM_ISCR_FDZC_SHIFT                      9u\r\n#define MCM_ISCR_FDZC_WIDTH                      1u\r\n#define MCM_ISCR_FDZC(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FDZC_SHIFT))&MCM_ISCR_FDZC_MASK)\r\n#define MCM_ISCR_FOFC_MASK                       0x400u\r\n#define MCM_ISCR_FOFC_SHIFT                      10u\r\n#define MCM_ISCR_FOFC_WIDTH                      1u\r\n#define MCM_ISCR_FOFC(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FOFC_SHIFT))&MCM_ISCR_FOFC_MASK)\r\n#define MCM_ISCR_FUFC_MASK                       0x800u\r\n#define MCM_ISCR_FUFC_SHIFT                      11u\r\n#define MCM_ISCR_FUFC_WIDTH                      1u\r\n#define MCM_ISCR_FUFC(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FUFC_SHIFT))&MCM_ISCR_FUFC_MASK)\r\n#define MCM_ISCR_FIXC_MASK                       0x1000u\r\n#define MCM_ISCR_FIXC_SHIFT                      12u\r\n#define MCM_ISCR_FIXC_WIDTH                      1u\r\n#define MCM_ISCR_FIXC(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FIXC_SHIFT))&MCM_ISCR_FIXC_MASK)\r\n#define MCM_ISCR_FIDC_MASK                       0x8000u\r\n#define MCM_ISCR_FIDC_SHIFT                      15u\r\n#define MCM_ISCR_FIDC_WIDTH                      1u\r\n#define MCM_ISCR_FIDC(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FIDC_SHIFT))&MCM_ISCR_FIDC_MASK)\r\n#define MCM_ISCR_FIOCE_MASK                      0x1000000u\r\n#define MCM_ISCR_FIOCE_SHIFT                     24u\r\n#define MCM_ISCR_FIOCE_WIDTH                     1u\r\n#define MCM_ISCR_FIOCE(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FIOCE_SHIFT))&MCM_ISCR_FIOCE_MASK)\r\n#define MCM_ISCR_FDZCE_MASK                      0x2000000u\r\n#define MCM_ISCR_FDZCE_SHIFT                     25u\r\n#define MCM_ISCR_FDZCE_WIDTH                     1u\r\n#define MCM_ISCR_FDZCE(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FDZCE_SHIFT))&MCM_ISCR_FDZCE_MASK)\r\n#define MCM_ISCR_FOFCE_MASK                      0x4000000u\r\n#define MCM_ISCR_FOFCE_SHIFT                     26u\r\n#define MCM_ISCR_FOFCE_WIDTH                     1u\r\n#define MCM_ISCR_FOFCE(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FOFCE_SHIFT))&MCM_ISCR_FOFCE_MASK)\r\n#define MCM_ISCR_FUFCE_MASK                      0x8000000u\r\n#define MCM_ISCR_FUFCE_SHIFT                     27u\r\n#define MCM_ISCR_FUFCE_WIDTH                     1u\r\n#define MCM_ISCR_FUFCE(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FUFCE_SHIFT))&MCM_ISCR_FUFCE_MASK)\r\n#define MCM_ISCR_FIXCE_MASK                      0x10000000u\r\n#define MCM_ISCR_FIXCE_SHIFT                     28u\r\n#define MCM_ISCR_FIXCE_WIDTH                     1u\r\n#define MCM_ISCR_FIXCE(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FIXCE_SHIFT))&MCM_ISCR_FIXCE_MASK)\r\n#define MCM_ISCR_FIDCE_MASK                      0x80000000u\r\n#define MCM_ISCR_FIDCE_SHIFT                     31u\r\n#define MCM_ISCR_FIDCE_WIDTH                     1u\r\n#define MCM_ISCR_FIDCE(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_ISCR_FIDCE_SHIFT))&MCM_ISCR_FIDCE_MASK)\r\n/* PID Bit Fields */\r\n#define MCM_PID_PID_MASK                         0xFFu\r\n#define MCM_PID_PID_SHIFT                        0u\r\n#define MCM_PID_PID_WIDTH                        8u\r\n#define MCM_PID_PID(x)                           (((uint32_t)(((uint32_t)(x))<<MCM_PID_PID_SHIFT))&MCM_PID_PID_MASK)\r\n/* CPO Bit Fields */\r\n#define MCM_CPO_CPOREQ_MASK                      0x1u\r\n#define MCM_CPO_CPOREQ_SHIFT                     0u\r\n#define MCM_CPO_CPOREQ_WIDTH                     1u\r\n#define MCM_CPO_CPOREQ(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_CPO_CPOREQ_SHIFT))&MCM_CPO_CPOREQ_MASK)\r\n#define MCM_CPO_CPOACK_MASK                      0x2u\r\n#define MCM_CPO_CPOACK_SHIFT                     1u\r\n#define MCM_CPO_CPOACK_WIDTH                     1u\r\n#define MCM_CPO_CPOACK(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_CPO_CPOACK_SHIFT))&MCM_CPO_CPOACK_MASK)\r\n#define MCM_CPO_CPOWOI_MASK                      0x4u\r\n#define MCM_CPO_CPOWOI_SHIFT                     2u\r\n#define MCM_CPO_CPOWOI_WIDTH                     1u\r\n#define MCM_CPO_CPOWOI(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_CPO_CPOWOI_SHIFT))&MCM_CPO_CPOWOI_MASK)\r\n/* LMDR Bit Fields */\r\n#define MCM_LMDR_CF0_MASK                        0xFu\r\n#define MCM_LMDR_CF0_SHIFT                       0u\r\n#define MCM_LMDR_CF0_WIDTH                       4u\r\n#define MCM_LMDR_CF0(x)                          (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_CF0_SHIFT))&MCM_LMDR_CF0_MASK)\r\n#define MCM_LMDR_MT_MASK                         0xE000u\r\n#define MCM_LMDR_MT_SHIFT                        13u\r\n#define MCM_LMDR_MT_WIDTH                        3u\r\n#define MCM_LMDR_MT(x)                           (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_MT_SHIFT))&MCM_LMDR_MT_MASK)\r\n#define MCM_LMDR_LOCK_MASK                       0x10000u\r\n#define MCM_LMDR_LOCK_SHIFT                      16u\r\n#define MCM_LMDR_LOCK_WIDTH                      1u\r\n#define MCM_LMDR_LOCK(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_LOCK_SHIFT))&MCM_LMDR_LOCK_MASK)\r\n#define MCM_LMDR_DPW_MASK                        0xE0000u\r\n#define MCM_LMDR_DPW_SHIFT                       17u\r\n#define MCM_LMDR_DPW_WIDTH                       3u\r\n#define MCM_LMDR_DPW(x)                          (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_DPW_SHIFT))&MCM_LMDR_DPW_MASK)\r\n#define MCM_LMDR_WY_MASK                         0xF00000u\r\n#define MCM_LMDR_WY_SHIFT                        20u\r\n#define MCM_LMDR_WY_WIDTH                        4u\r\n#define MCM_LMDR_WY(x)                           (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_WY_SHIFT))&MCM_LMDR_WY_MASK)\r\n#define MCM_LMDR_LMSZ_MASK                       0xF000000u\r\n#define MCM_LMDR_LMSZ_SHIFT                      24u\r\n#define MCM_LMDR_LMSZ_WIDTH                      4u\r\n#define MCM_LMDR_LMSZ(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_LMSZ_SHIFT))&MCM_LMDR_LMSZ_MASK)\r\n#define MCM_LMDR_LMSZH_MASK                      0x10000000u\r\n#define MCM_LMDR_LMSZH_SHIFT                     28u\r\n#define MCM_LMDR_LMSZH_WIDTH                     1u\r\n#define MCM_LMDR_LMSZH(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_LMSZH_SHIFT))&MCM_LMDR_LMSZH_MASK)\r\n#define MCM_LMDR_V_MASK                          0x80000000u\r\n#define MCM_LMDR_V_SHIFT                         31u\r\n#define MCM_LMDR_V_WIDTH                         1u\r\n#define MCM_LMDR_V(x)                            (((uint32_t)(((uint32_t)(x))<<MCM_LMDR_V_SHIFT))&MCM_LMDR_V_MASK)\r\n/* LMDR2 Bit Fields */\r\n#define MCM_LMDR2_CF1_MASK                       0xF0u\r\n#define MCM_LMDR2_CF1_SHIFT                      4u\r\n#define MCM_LMDR2_CF1_WIDTH                      4u\r\n#define MCM_LMDR2_CF1(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_CF1_SHIFT))&MCM_LMDR2_CF1_MASK)\r\n#define MCM_LMDR2_MT_MASK                        0xE000u\r\n#define MCM_LMDR2_MT_SHIFT                       13u\r\n#define MCM_LMDR2_MT_WIDTH                       3u\r\n#define MCM_LMDR2_MT(x)                          (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_MT_SHIFT))&MCM_LMDR2_MT_MASK)\r\n#define MCM_LMDR2_LOCK_MASK                      0x10000u\r\n#define MCM_LMDR2_LOCK_SHIFT                     16u\r\n#define MCM_LMDR2_LOCK_WIDTH                     1u\r\n#define MCM_LMDR2_LOCK(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_LOCK_SHIFT))&MCM_LMDR2_LOCK_MASK)\r\n#define MCM_LMDR2_DPW_MASK                       0xE0000u\r\n#define MCM_LMDR2_DPW_SHIFT                      17u\r\n#define MCM_LMDR2_DPW_WIDTH                      3u\r\n#define MCM_LMDR2_DPW(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_DPW_SHIFT))&MCM_LMDR2_DPW_MASK)\r\n#define MCM_LMDR2_WY_MASK                        0xF00000u\r\n#define MCM_LMDR2_WY_SHIFT                       20u\r\n#define MCM_LMDR2_WY_WIDTH                       4u\r\n#define MCM_LMDR2_WY(x)                          (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_WY_SHIFT))&MCM_LMDR2_WY_MASK)\r\n#define MCM_LMDR2_LMSZ_MASK                      0xF000000u\r\n#define MCM_LMDR2_LMSZ_SHIFT                     24u\r\n#define MCM_LMDR2_LMSZ_WIDTH                     4u\r\n#define MCM_LMDR2_LMSZ(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_LMSZ_SHIFT))&MCM_LMDR2_LMSZ_MASK)\r\n#define MCM_LMDR2_LMSZH_MASK                     0x10000000u\r\n#define MCM_LMDR2_LMSZH_SHIFT                    28u\r\n#define MCM_LMDR2_LMSZH_WIDTH                    1u\r\n#define MCM_LMDR2_LMSZH(x)                       (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_LMSZH_SHIFT))&MCM_LMDR2_LMSZH_MASK)\r\n#define MCM_LMDR2_V_MASK                         0x80000000u\r\n#define MCM_LMDR2_V_SHIFT                        31u\r\n#define MCM_LMDR2_V_WIDTH                        1u\r\n#define MCM_LMDR2_V(x)                           (((uint32_t)(((uint32_t)(x))<<MCM_LMDR2_V_SHIFT))&MCM_LMDR2_V_MASK)\r\n/* LMPECR Bit Fields */\r\n#define MCM_LMPECR_ERNCR_MASK                    0x1u\r\n#define MCM_LMPECR_ERNCR_SHIFT                   0u\r\n#define MCM_LMPECR_ERNCR_WIDTH                   1u\r\n#define MCM_LMPECR_ERNCR(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_LMPECR_ERNCR_SHIFT))&MCM_LMPECR_ERNCR_MASK)\r\n#define MCM_LMPECR_ER1BR_MASK                    0x100u\r\n#define MCM_LMPECR_ER1BR_SHIFT                   8u\r\n#define MCM_LMPECR_ER1BR_WIDTH                   1u\r\n#define MCM_LMPECR_ER1BR(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_LMPECR_ER1BR_SHIFT))&MCM_LMPECR_ER1BR_MASK)\r\n#define MCM_LMPECR_ECPR_MASK                     0x100000u\r\n#define MCM_LMPECR_ECPR_SHIFT                    20u\r\n#define MCM_LMPECR_ECPR_WIDTH                    1u\r\n#define MCM_LMPECR_ECPR(x)                       (((uint32_t)(((uint32_t)(x))<<MCM_LMPECR_ECPR_SHIFT))&MCM_LMPECR_ECPR_MASK)\r\n/* LMPEIR Bit Fields */\r\n#define MCM_LMPEIR_ENC_MASK                      0xFFu\r\n#define MCM_LMPEIR_ENC_SHIFT                     0u\r\n#define MCM_LMPEIR_ENC_WIDTH                     8u\r\n#define MCM_LMPEIR_ENC(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_LMPEIR_ENC_SHIFT))&MCM_LMPEIR_ENC_MASK)\r\n#define MCM_LMPEIR_E1B_MASK                      0xFF00u\r\n#define MCM_LMPEIR_E1B_SHIFT                     8u\r\n#define MCM_LMPEIR_E1B_WIDTH                     8u\r\n#define MCM_LMPEIR_E1B(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_LMPEIR_E1B_SHIFT))&MCM_LMPEIR_E1B_MASK)\r\n#define MCM_LMPEIR_PE_MASK                       0xFF0000u\r\n#define MCM_LMPEIR_PE_SHIFT                      16u\r\n#define MCM_LMPEIR_PE_WIDTH                      8u\r\n#define MCM_LMPEIR_PE(x)                         (((uint32_t)(((uint32_t)(x))<<MCM_LMPEIR_PE_SHIFT))&MCM_LMPEIR_PE_MASK)\r\n#define MCM_LMPEIR_PEELOC_MASK                   0x1F000000u\r\n#define MCM_LMPEIR_PEELOC_SHIFT                  24u\r\n#define MCM_LMPEIR_PEELOC_WIDTH                  5u\r\n#define MCM_LMPEIR_PEELOC(x)                     (((uint32_t)(((uint32_t)(x))<<MCM_LMPEIR_PEELOC_SHIFT))&MCM_LMPEIR_PEELOC_MASK)\r\n#define MCM_LMPEIR_V_MASK                        0x80000000u\r\n#define MCM_LMPEIR_V_SHIFT                       31u\r\n#define MCM_LMPEIR_V_WIDTH                       1u\r\n#define MCM_LMPEIR_V(x)                          (((uint32_t)(((uint32_t)(x))<<MCM_LMPEIR_V_SHIFT))&MCM_LMPEIR_V_MASK)\r\n/* LMFAR Bit Fields */\r\n#define MCM_LMFAR_EFADD_MASK                     0xFFFFFFFFu\r\n#define MCM_LMFAR_EFADD_SHIFT                    0u\r\n#define MCM_LMFAR_EFADD_WIDTH                    32u\r\n#define MCM_LMFAR_EFADD(x)                       (((uint32_t)(((uint32_t)(x))<<MCM_LMFAR_EFADD_SHIFT))&MCM_LMFAR_EFADD_MASK)\r\n/* LMFATR Bit Fields */\r\n#define MCM_LMFATR_PEFPRT_MASK                   0xFu\r\n#define MCM_LMFATR_PEFPRT_SHIFT                  0u\r\n#define MCM_LMFATR_PEFPRT_WIDTH                  4u\r\n#define MCM_LMFATR_PEFPRT(x)                     (((uint32_t)(((uint32_t)(x))<<MCM_LMFATR_PEFPRT_SHIFT))&MCM_LMFATR_PEFPRT_MASK)\r\n#define MCM_LMFATR_PEFSIZE_MASK                  0x70u\r\n#define MCM_LMFATR_PEFSIZE_SHIFT                 4u\r\n#define MCM_LMFATR_PEFSIZE_WIDTH                 3u\r\n#define MCM_LMFATR_PEFSIZE(x)                    (((uint32_t)(((uint32_t)(x))<<MCM_LMFATR_PEFSIZE_SHIFT))&MCM_LMFATR_PEFSIZE_MASK)\r\n#define MCM_LMFATR_PEFW_MASK                     0x80u\r\n#define MCM_LMFATR_PEFW_SHIFT                    7u\r\n#define MCM_LMFATR_PEFW_WIDTH                    1u\r\n#define MCM_LMFATR_PEFW(x)                       (((uint32_t)(((uint32_t)(x))<<MCM_LMFATR_PEFW_SHIFT))&MCM_LMFATR_PEFW_MASK)\r\n#define MCM_LMFATR_PEFMST_MASK                   0xFF00u\r\n#define MCM_LMFATR_PEFMST_SHIFT                  8u\r\n#define MCM_LMFATR_PEFMST_WIDTH                  8u\r\n#define MCM_LMFATR_PEFMST(x)                     (((uint32_t)(((uint32_t)(x))<<MCM_LMFATR_PEFMST_SHIFT))&MCM_LMFATR_PEFMST_MASK)\r\n#define MCM_LMFATR_OVR_MASK                      0x80000000u\r\n#define MCM_LMFATR_OVR_SHIFT                     31u\r\n#define MCM_LMFATR_OVR_WIDTH                     1u\r\n#define MCM_LMFATR_OVR(x)                        (((uint32_t)(((uint32_t)(x))<<MCM_LMFATR_OVR_SHIFT))&MCM_LMFATR_OVR_MASK)\r\n/* LMFDHR Bit Fields */\r\n#define MCM_LMFDHR_PEFDH_MASK                    0xFFFFFFFFu\r\n#define MCM_LMFDHR_PEFDH_SHIFT                   0u\r\n#define MCM_LMFDHR_PEFDH_WIDTH                   32u\r\n#define MCM_LMFDHR_PEFDH(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_LMFDHR_PEFDH_SHIFT))&MCM_LMFDHR_PEFDH_MASK)\r\n/* LMFDLR Bit Fields */\r\n#define MCM_LMFDLR_PEFDL_MASK                    0xFFFFFFFFu\r\n#define MCM_LMFDLR_PEFDL_SHIFT                   0u\r\n#define MCM_LMFDLR_PEFDL_WIDTH                   32u\r\n#define MCM_LMFDLR_PEFDL(x)                      (((uint32_t)(((uint32_t)(x))<<MCM_LMFDLR_PEFDL_SHIFT))&MCM_LMFDLR_PEFDL_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group MCM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group MCM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MPU Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup MPU_Peripheral_Access_Layer MPU Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** MPU - Size of Registers Arrays */\r\n#define MPU_EAR_EDR_COUNT                        4u\r\n#define MPU_RGD_COUNT                            8u\r\n#define MPU_RGDAAC_COUNT                         8u\r\n\r\n/** MPU - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t CESR;                              /**< Control/Error Status Register, offset: 0x0 */\r\n       uint8_t RESERVED_0[12];\r\n  struct {                                         /* offset: 0x10, array step: 0x8 */\r\n    __I  uint32_t EAR;                               /**< Error Address Register, slave port\r\n    \t\t\t\t\t\t\t0..Error Address Register, slave port\r\n    \t\t\t\t\t\t\t3, array offset: 0x10, array step: 0x8 */\r\n    __I  uint32_t EDR;                               /**< Error Detail Register, slave port\r\n    \t\t\t\t\t\t\t0..Error Detail Register, slave port\r\n    \t\t\t\t\t\t\t3, array offset: 0x14, array step: 0x8 */\r\n  } EAR_EDR[MPU_EAR_EDR_COUNT];\r\n       uint8_t RESERVED_1[976];\r\n  struct {                                         /* offset: 0x400, array step: 0x10 */\r\n    __IO uint32_t WORD0;                             /**< Region Descriptor 0, Word 0..Region Descriptor 7, Word 0, array offset: 0x400, array step: 0x10 */\r\n    __IO uint32_t WORD1;                             /**< Region Descriptor 0, Word 1..Region Descriptor 7, Word 1, array offset: 0x404, array step: 0x10 */\r\n    __IO uint32_t WORD2;                             /**< Region Descriptor 0, Word 2..Region Descriptor 7, Word 2, array offset: 0x408, array step: 0x10 */\r\n    __IO uint32_t WORD3;                             /**< Region Descriptor 0, Word 3..Region Descriptor 7, Word 3, array offset: 0x40C, array step: 0x10 */\r\n  } RGD[MPU_RGD_COUNT];\r\n       uint8_t RESERVED_2[896];\r\n  __IO uint32_t RGDAAC[MPU_RGDAAC_COUNT];          /**< Region Descriptor Alternate Access Control\r\n  \t\t\t\t\t\t\t0..Region Descriptor Alternate Access Control\r\n  \t\t\t\t\t\t\t7, array offset: 0x800, array step: 0x4 */\r\n} MPU_Type, *MPU_MemMapPtr;\r\n\r\n /** Number of instances of the MPU module. */\r\n#define MPU_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* MPU - Peripheral instance base addresses */\r\n/** Peripheral MPU base address */\r\n#define MPU_BASE                                 (0x4000D000u)\r\n/** Peripheral MPU base pointer */\r\n#define MPU                                      ((MPU_Type *)MPU_BASE)\r\n/** Array initializer of MPU peripheral base addresses */\r\n#define MPU_BASE_ADDRS                           { MPU_BASE }\r\n/** Array initializer of MPU peripheral base pointers */\r\n#define MPU_BASE_PTRS                            { MPU }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MPU Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup MPU_Register_Masks MPU Register Masks\r\n * @{\r\n */\r\n\r\n/* CESR Bit Fields */\r\n#define MPU_CESR_VLD_MASK                        0x1u\r\n#define MPU_CESR_VLD_SHIFT                       0u\r\n#define MPU_CESR_VLD_WIDTH                       1u\r\n#define MPU_CESR_VLD(x)                          (((uint32_t)(((uint32_t)(x))<<MPU_CESR_VLD_SHIFT))&MPU_CESR_VLD_MASK)\r\n#define MPU_CESR_NRGD_MASK                       0xF00u\r\n#define MPU_CESR_NRGD_SHIFT                      8u\r\n#define MPU_CESR_NRGD_WIDTH                      4u\r\n#define MPU_CESR_NRGD(x)                         (((uint32_t)(((uint32_t)(x))<<MPU_CESR_NRGD_SHIFT))&MPU_CESR_NRGD_MASK)\r\n#define MPU_CESR_NSP_MASK                        0xF000u\r\n#define MPU_CESR_NSP_SHIFT                       12u\r\n#define MPU_CESR_NSP_WIDTH                       4u\r\n#define MPU_CESR_NSP(x)                          (((uint32_t)(((uint32_t)(x))<<MPU_CESR_NSP_SHIFT))&MPU_CESR_NSP_MASK)\r\n#define MPU_CESR_HRL_MASK                        0xF0000u\r\n#define MPU_CESR_HRL_SHIFT                       16u\r\n#define MPU_CESR_HRL_WIDTH                       4u\r\n#define MPU_CESR_HRL(x)                          (((uint32_t)(((uint32_t)(x))<<MPU_CESR_HRL_SHIFT))&MPU_CESR_HRL_MASK)\r\n#define MPU_CESR_SPERR3_MASK                     0x10000000u\r\n#define MPU_CESR_SPERR3_SHIFT                    28u\r\n#define MPU_CESR_SPERR3_WIDTH                    1u\r\n#define MPU_CESR_SPERR3(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_CESR_SPERR3_SHIFT))&MPU_CESR_SPERR3_MASK)\r\n#define MPU_CESR_SPERR2_MASK                     0x20000000u\r\n#define MPU_CESR_SPERR2_SHIFT                    29u\r\n#define MPU_CESR_SPERR2_WIDTH                    1u\r\n#define MPU_CESR_SPERR2(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_CESR_SPERR2_SHIFT))&MPU_CESR_SPERR2_MASK)\r\n#define MPU_CESR_SPERR1_MASK                     0x40000000u\r\n#define MPU_CESR_SPERR1_SHIFT                    30u\r\n#define MPU_CESR_SPERR1_WIDTH                    1u\r\n#define MPU_CESR_SPERR1(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_CESR_SPERR1_SHIFT))&MPU_CESR_SPERR1_MASK)\r\n#define MPU_CESR_SPERR0_MASK                     0x80000000u\r\n#define MPU_CESR_SPERR0_SHIFT                    31u\r\n#define MPU_CESR_SPERR0_WIDTH                    1u\r\n#define MPU_CESR_SPERR0(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_CESR_SPERR0_SHIFT))&MPU_CESR_SPERR0_MASK)\r\n/* EAR Bit Fields */\r\n#define MPU_EAR_EADDR_MASK                       0xFFFFFFFFu\r\n#define MPU_EAR_EADDR_SHIFT                      0u\r\n#define MPU_EAR_EADDR_WIDTH                      32u\r\n#define MPU_EAR_EADDR(x)                         (((uint32_t)(((uint32_t)(x))<<MPU_EAR_EADDR_SHIFT))&MPU_EAR_EADDR_MASK)\r\n/* EDR Bit Fields */\r\n#define MPU_EDR_ERW_MASK                         0x1u\r\n#define MPU_EDR_ERW_SHIFT                        0u\r\n#define MPU_EDR_ERW_WIDTH                        1u\r\n#define MPU_EDR_ERW(x)                           (((uint32_t)(((uint32_t)(x))<<MPU_EDR_ERW_SHIFT))&MPU_EDR_ERW_MASK)\r\n#define MPU_EDR_EATTR_MASK                       0xEu\r\n#define MPU_EDR_EATTR_SHIFT                      1u\r\n#define MPU_EDR_EATTR_WIDTH                      3u\r\n#define MPU_EDR_EATTR(x)                         (((uint32_t)(((uint32_t)(x))<<MPU_EDR_EATTR_SHIFT))&MPU_EDR_EATTR_MASK)\r\n#define MPU_EDR_EMN_MASK                         0xF0u\r\n#define MPU_EDR_EMN_SHIFT                        4u\r\n#define MPU_EDR_EMN_WIDTH                        4u\r\n#define MPU_EDR_EMN(x)                           (((uint32_t)(((uint32_t)(x))<<MPU_EDR_EMN_SHIFT))&MPU_EDR_EMN_MASK)\r\n#define MPU_EDR_EPID_MASK                        0xFF00u\r\n#define MPU_EDR_EPID_SHIFT                       8u\r\n#define MPU_EDR_EPID_WIDTH                       8u\r\n#define MPU_EDR_EPID(x)                          (((uint32_t)(((uint32_t)(x))<<MPU_EDR_EPID_SHIFT))&MPU_EDR_EPID_MASK)\r\n#define MPU_EDR_EACD_MASK                        0xFFFF0000u\r\n#define MPU_EDR_EACD_SHIFT                       16u\r\n#define MPU_EDR_EACD_WIDTH                       16u\r\n#define MPU_EDR_EACD(x)                          (((uint32_t)(((uint32_t)(x))<<MPU_EDR_EACD_SHIFT))&MPU_EDR_EACD_MASK)\r\n/* RGD_WORD0 Bit Fields */\r\n#define MPU_RGD_WORD0_SRTADDR_MASK               0xFFFFFFE0u\r\n#define MPU_RGD_WORD0_SRTADDR_SHIFT              5u\r\n#define MPU_RGD_WORD0_SRTADDR_WIDTH              27u\r\n#define MPU_RGD_WORD0_SRTADDR(x)                 (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD0_SRTADDR_SHIFT))&MPU_RGD_WORD0_SRTADDR_MASK)\r\n/* RGD_WORD1 Bit Fields */\r\n#define MPU_RGD_WORD1_ENDADDR_MASK               0xFFFFFFE0u\r\n#define MPU_RGD_WORD1_ENDADDR_SHIFT              5u\r\n#define MPU_RGD_WORD1_ENDADDR_WIDTH              27u\r\n#define MPU_RGD_WORD1_ENDADDR(x)                 (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD1_ENDADDR_SHIFT))&MPU_RGD_WORD1_ENDADDR_MASK)\r\n/* RGD_WORD2 Bit Fields */\r\n#define MPU_RGD_WORD2_M0UM_MASK                  0x7u\r\n#define MPU_RGD_WORD2_M0UM_SHIFT                 0u\r\n#define MPU_RGD_WORD2_M0UM_WIDTH                 3u\r\n#define MPU_RGD_WORD2_M0UM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M0UM_SHIFT))&MPU_RGD_WORD2_M0UM_MASK)\r\n#define MPU_RGD_WORD2_M0SM_MASK                  0x18u\r\n#define MPU_RGD_WORD2_M0SM_SHIFT                 3u\r\n#define MPU_RGD_WORD2_M0SM_WIDTH                 2u\r\n#define MPU_RGD_WORD2_M0SM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M0SM_SHIFT))&MPU_RGD_WORD2_M0SM_MASK)\r\n#define MPU_RGD_WORD2_M0PE_MASK                  0x20u\r\n#define MPU_RGD_WORD2_M0PE_SHIFT                 5u\r\n#define MPU_RGD_WORD2_M0PE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M0PE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M0PE_SHIFT))&MPU_RGD_WORD2_M0PE_MASK)\r\n#define MPU_RGD_WORD2_M1UM_MASK                  0x1C0u\r\n#define MPU_RGD_WORD2_M1UM_SHIFT                 6u\r\n#define MPU_RGD_WORD2_M1UM_WIDTH                 3u\r\n#define MPU_RGD_WORD2_M1UM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M1UM_SHIFT))&MPU_RGD_WORD2_M1UM_MASK)\r\n#define MPU_RGD_WORD2_M1SM_MASK                  0x600u\r\n#define MPU_RGD_WORD2_M1SM_SHIFT                 9u\r\n#define MPU_RGD_WORD2_M1SM_WIDTH                 2u\r\n#define MPU_RGD_WORD2_M1SM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M1SM_SHIFT))&MPU_RGD_WORD2_M1SM_MASK)\r\n#define MPU_RGD_WORD2_M1PE_MASK                  0x800u\r\n#define MPU_RGD_WORD2_M1PE_SHIFT                 11u\r\n#define MPU_RGD_WORD2_M1PE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M1PE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M1PE_SHIFT))&MPU_RGD_WORD2_M1PE_MASK)\r\n#define MPU_RGD_WORD2_M2UM_MASK                  0x7000u\r\n#define MPU_RGD_WORD2_M2UM_SHIFT                 12u\r\n#define MPU_RGD_WORD2_M2UM_WIDTH                 3u\r\n#define MPU_RGD_WORD2_M2UM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M2UM_SHIFT))&MPU_RGD_WORD2_M2UM_MASK)\r\n#define MPU_RGD_WORD2_M2SM_MASK                  0x18000u\r\n#define MPU_RGD_WORD2_M2SM_SHIFT                 15u\r\n#define MPU_RGD_WORD2_M2SM_WIDTH                 2u\r\n#define MPU_RGD_WORD2_M2SM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M2SM_SHIFT))&MPU_RGD_WORD2_M2SM_MASK)\r\n#define MPU_RGD_WORD2_M3UM_MASK                  0x1C0000u\r\n#define MPU_RGD_WORD2_M3UM_SHIFT                 18u\r\n#define MPU_RGD_WORD2_M3UM_WIDTH                 3u\r\n#define MPU_RGD_WORD2_M3UM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M3UM_SHIFT))&MPU_RGD_WORD2_M3UM_MASK)\r\n#define MPU_RGD_WORD2_M3SM_MASK                  0x600000u\r\n#define MPU_RGD_WORD2_M3SM_SHIFT                 21u\r\n#define MPU_RGD_WORD2_M3SM_WIDTH                 2u\r\n#define MPU_RGD_WORD2_M3SM(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M3SM_SHIFT))&MPU_RGD_WORD2_M3SM_MASK)\r\n#define MPU_RGD_WORD2_M4WE_MASK                  0x1000000u\r\n#define MPU_RGD_WORD2_M4WE_SHIFT                 24u\r\n#define MPU_RGD_WORD2_M4WE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M4WE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M4WE_SHIFT))&MPU_RGD_WORD2_M4WE_MASK)\r\n#define MPU_RGD_WORD2_M4RE_MASK                  0x2000000u\r\n#define MPU_RGD_WORD2_M4RE_SHIFT                 25u\r\n#define MPU_RGD_WORD2_M4RE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M4RE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M4RE_SHIFT))&MPU_RGD_WORD2_M4RE_MASK)\r\n#define MPU_RGD_WORD2_M5WE_MASK                  0x4000000u\r\n#define MPU_RGD_WORD2_M5WE_SHIFT                 26u\r\n#define MPU_RGD_WORD2_M5WE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M5WE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M5WE_SHIFT))&MPU_RGD_WORD2_M5WE_MASK)\r\n#define MPU_RGD_WORD2_M5RE_MASK                  0x8000000u\r\n#define MPU_RGD_WORD2_M5RE_SHIFT                 27u\r\n#define MPU_RGD_WORD2_M5RE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M5RE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M5RE_SHIFT))&MPU_RGD_WORD2_M5RE_MASK)\r\n#define MPU_RGD_WORD2_M6WE_MASK                  0x10000000u\r\n#define MPU_RGD_WORD2_M6WE_SHIFT                 28u\r\n#define MPU_RGD_WORD2_M6WE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M6WE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M6WE_SHIFT))&MPU_RGD_WORD2_M6WE_MASK)\r\n#define MPU_RGD_WORD2_M6RE_MASK                  0x20000000u\r\n#define MPU_RGD_WORD2_M6RE_SHIFT                 29u\r\n#define MPU_RGD_WORD2_M6RE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M6RE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M6RE_SHIFT))&MPU_RGD_WORD2_M6RE_MASK)\r\n#define MPU_RGD_WORD2_M7WE_MASK                  0x40000000u\r\n#define MPU_RGD_WORD2_M7WE_SHIFT                 30u\r\n#define MPU_RGD_WORD2_M7WE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M7WE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M7WE_SHIFT))&MPU_RGD_WORD2_M7WE_MASK)\r\n#define MPU_RGD_WORD2_M7RE_MASK                  0x80000000u\r\n#define MPU_RGD_WORD2_M7RE_SHIFT                 31u\r\n#define MPU_RGD_WORD2_M7RE_WIDTH                 1u\r\n#define MPU_RGD_WORD2_M7RE(x)                    (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD2_M7RE_SHIFT))&MPU_RGD_WORD2_M7RE_MASK)\r\n/* RGD_WORD3 Bit Fields */\r\n#define MPU_RGD_WORD3_VLD_MASK                   0x1u\r\n#define MPU_RGD_WORD3_VLD_SHIFT                  0u\r\n#define MPU_RGD_WORD3_VLD_WIDTH                  1u\r\n#define MPU_RGD_WORD3_VLD(x)                     (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD3_VLD_SHIFT))&MPU_RGD_WORD3_VLD_MASK)\r\n#define MPU_RGD_WORD3_PIDMASK_MASK               0xFF0000u\r\n#define MPU_RGD_WORD3_PIDMASK_SHIFT              16u\r\n#define MPU_RGD_WORD3_PIDMASK_WIDTH              8u\r\n#define MPU_RGD_WORD3_PIDMASK(x)                 (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD3_PIDMASK_SHIFT))&MPU_RGD_WORD3_PIDMASK_MASK)\r\n#define MPU_RGD_WORD3_PID_MASK                   0xFF000000u\r\n#define MPU_RGD_WORD3_PID_SHIFT                  24u\r\n#define MPU_RGD_WORD3_PID_WIDTH                  8u\r\n#define MPU_RGD_WORD3_PID(x)                     (((uint32_t)(((uint32_t)(x))<<MPU_RGD_WORD3_PID_SHIFT))&MPU_RGD_WORD3_PID_MASK)\r\n/* RGDAAC Bit Fields */\r\n#define MPU_RGDAAC_M0UM_MASK                     0x7u\r\n#define MPU_RGDAAC_M0UM_SHIFT                    0u\r\n#define MPU_RGDAAC_M0UM_WIDTH                    3u\r\n#define MPU_RGDAAC_M0UM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M0UM_SHIFT))&MPU_RGDAAC_M0UM_MASK)\r\n#define MPU_RGDAAC_M0SM_MASK                     0x18u\r\n#define MPU_RGDAAC_M0SM_SHIFT                    3u\r\n#define MPU_RGDAAC_M0SM_WIDTH                    2u\r\n#define MPU_RGDAAC_M0SM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M0SM_SHIFT))&MPU_RGDAAC_M0SM_MASK)\r\n#define MPU_RGDAAC_M0PE_MASK                     0x20u\r\n#define MPU_RGDAAC_M0PE_SHIFT                    5u\r\n#define MPU_RGDAAC_M0PE_WIDTH                    1u\r\n#define MPU_RGDAAC_M0PE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M0PE_SHIFT))&MPU_RGDAAC_M0PE_MASK)\r\n#define MPU_RGDAAC_M1UM_MASK                     0x1C0u\r\n#define MPU_RGDAAC_M1UM_SHIFT                    6u\r\n#define MPU_RGDAAC_M1UM_WIDTH                    3u\r\n#define MPU_RGDAAC_M1UM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M1UM_SHIFT))&MPU_RGDAAC_M1UM_MASK)\r\n#define MPU_RGDAAC_M1SM_MASK                     0x600u\r\n#define MPU_RGDAAC_M1SM_SHIFT                    9u\r\n#define MPU_RGDAAC_M1SM_WIDTH                    2u\r\n#define MPU_RGDAAC_M1SM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M1SM_SHIFT))&MPU_RGDAAC_M1SM_MASK)\r\n#define MPU_RGDAAC_M1PE_MASK                     0x800u\r\n#define MPU_RGDAAC_M1PE_SHIFT                    11u\r\n#define MPU_RGDAAC_M1PE_WIDTH                    1u\r\n#define MPU_RGDAAC_M1PE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M1PE_SHIFT))&MPU_RGDAAC_M1PE_MASK)\r\n#define MPU_RGDAAC_M2UM_MASK                     0x7000u\r\n#define MPU_RGDAAC_M2UM_SHIFT                    12u\r\n#define MPU_RGDAAC_M2UM_WIDTH                    3u\r\n#define MPU_RGDAAC_M2UM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M2UM_SHIFT))&MPU_RGDAAC_M2UM_MASK)\r\n#define MPU_RGDAAC_M2SM_MASK                     0x18000u\r\n#define MPU_RGDAAC_M2SM_SHIFT                    15u\r\n#define MPU_RGDAAC_M2SM_WIDTH                    2u\r\n#define MPU_RGDAAC_M2SM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M2SM_SHIFT))&MPU_RGDAAC_M2SM_MASK)\r\n#define MPU_RGDAAC_M3UM_MASK                     0x1C0000u\r\n#define MPU_RGDAAC_M3UM_SHIFT                    18u\r\n#define MPU_RGDAAC_M3UM_WIDTH                    3u\r\n#define MPU_RGDAAC_M3UM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M3UM_SHIFT))&MPU_RGDAAC_M3UM_MASK)\r\n#define MPU_RGDAAC_M3SM_MASK                     0x600000u\r\n#define MPU_RGDAAC_M3SM_SHIFT                    21u\r\n#define MPU_RGDAAC_M3SM_WIDTH                    2u\r\n#define MPU_RGDAAC_M3SM(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M3SM_SHIFT))&MPU_RGDAAC_M3SM_MASK)\r\n#define MPU_RGDAAC_M4WE_MASK                     0x1000000u\r\n#define MPU_RGDAAC_M4WE_SHIFT                    24u\r\n#define MPU_RGDAAC_M4WE_WIDTH                    1u\r\n#define MPU_RGDAAC_M4WE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M4WE_SHIFT))&MPU_RGDAAC_M4WE_MASK)\r\n#define MPU_RGDAAC_M4RE_MASK                     0x2000000u\r\n#define MPU_RGDAAC_M4RE_SHIFT                    25u\r\n#define MPU_RGDAAC_M4RE_WIDTH                    1u\r\n#define MPU_RGDAAC_M4RE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M4RE_SHIFT))&MPU_RGDAAC_M4RE_MASK)\r\n#define MPU_RGDAAC_M5WE_MASK                     0x4000000u\r\n#define MPU_RGDAAC_M5WE_SHIFT                    26u\r\n#define MPU_RGDAAC_M5WE_WIDTH                    1u\r\n#define MPU_RGDAAC_M5WE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M5WE_SHIFT))&MPU_RGDAAC_M5WE_MASK)\r\n#define MPU_RGDAAC_M5RE_MASK                     0x8000000u\r\n#define MPU_RGDAAC_M5RE_SHIFT                    27u\r\n#define MPU_RGDAAC_M5RE_WIDTH                    1u\r\n#define MPU_RGDAAC_M5RE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M5RE_SHIFT))&MPU_RGDAAC_M5RE_MASK)\r\n#define MPU_RGDAAC_M6WE_MASK                     0x10000000u\r\n#define MPU_RGDAAC_M6WE_SHIFT                    28u\r\n#define MPU_RGDAAC_M6WE_WIDTH                    1u\r\n#define MPU_RGDAAC_M6WE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M6WE_SHIFT))&MPU_RGDAAC_M6WE_MASK)\r\n#define MPU_RGDAAC_M6RE_MASK                     0x20000000u\r\n#define MPU_RGDAAC_M6RE_SHIFT                    29u\r\n#define MPU_RGDAAC_M6RE_WIDTH                    1u\r\n#define MPU_RGDAAC_M6RE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M6RE_SHIFT))&MPU_RGDAAC_M6RE_MASK)\r\n#define MPU_RGDAAC_M7WE_MASK                     0x40000000u\r\n#define MPU_RGDAAC_M7WE_SHIFT                    30u\r\n#define MPU_RGDAAC_M7WE_WIDTH                    1u\r\n#define MPU_RGDAAC_M7WE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M7WE_SHIFT))&MPU_RGDAAC_M7WE_MASK)\r\n#define MPU_RGDAAC_M7RE_MASK                     0x80000000u\r\n#define MPU_RGDAAC_M7RE_SHIFT                    31u\r\n#define MPU_RGDAAC_M7RE_WIDTH                    1u\r\n#define MPU_RGDAAC_M7RE(x)                       (((uint32_t)(((uint32_t)(x))<<MPU_RGDAAC_M7RE_SHIFT))&MPU_RGDAAC_M7RE_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group MPU_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group MPU_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MSCM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup MSCM_Peripheral_Access_Layer MSCM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** MSCM - Size of Registers Arrays */\r\n#define MSCM_OCMDR_COUNT                         3u\r\n\r\n/** MSCM - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t CPxTYPE;                           /**< Processor X Type Register, offset: 0x0 */\r\n  __I  uint32_t CPxNUM;                            /**< Processor X Number Register, offset: 0x4 */\r\n  __I  uint32_t CPxMASTER;                         /**< Processor X Master Register, offset: 0x8 */\r\n  __I  uint32_t CPxCOUNT;                          /**< Processor X Count Register, offset: 0xC */\r\n  __I  uint32_t CPxCFG0;                           /**< Processor X Configuration Register 0, offset: 0x10 */\r\n  __I  uint32_t CPxCFG1;                           /**< Processor X Configuration Register 1, offset: 0x14 */\r\n  __I  uint32_t CPxCFG2;                           /**< Processor X Configuration Register 2, offset: 0x18 */\r\n  __I  uint32_t CPxCFG3;                           /**< Processor X Configuration Register 3, offset: 0x1C */\r\n  __I  uint32_t CP0TYPE;                           /**< Processor 0 Type Register, offset: 0x20 */\r\n  __I  uint32_t CP0NUM;                            /**< Processor 0 Number Register, offset: 0x24 */\r\n  __I  uint32_t CP0MASTER;                         /**< Processor 0 Master Register, offset: 0x28 */\r\n  __I  uint32_t CP0COUNT;                          /**< Processor 0 Count Register, offset: 0x2C */\r\n  __I  uint32_t CP0CFG0;                           /**< Processor 0 Configuration Register 0, offset: 0x30 */\r\n  __I  uint32_t CP0CFG1;                           /**< Processor 0 Configuration Register 1, offset: 0x34 */\r\n  __I  uint32_t CP0CFG2;                           /**< Processor 0 Configuration Register 2, offset: 0x38 */\r\n  __I  uint32_t CP0CFG3;                           /**< Processor 0 Configuration Register 3, offset: 0x3C */\r\n       uint8_t RESERVED_0[960];\r\n  __IO uint32_t OCMDR[MSCM_OCMDR_COUNT];           /**< On-Chip Memory Descriptor Register, array offset: 0x400, array step: 0x4 */\r\n} MSCM_Type, *MSCM_MemMapPtr;\r\n\r\n /** Number of instances of the MSCM module. */\r\n#define MSCM_INSTANCE_COUNT                      (1u)\r\n\r\n\r\n/* MSCM - Peripheral instance base addresses */\r\n/** Peripheral MSCM base address */\r\n#define MSCM_BASE                                (0x40001000u)\r\n/** Peripheral MSCM base pointer */\r\n#define MSCM                                     ((MSCM_Type *)MSCM_BASE)\r\n/** Array initializer of MSCM peripheral base addresses */\r\n#define MSCM_BASE_ADDRS                          { MSCM_BASE }\r\n/** Array initializer of MSCM peripheral base pointers */\r\n#define MSCM_BASE_PTRS                           { MSCM }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- MSCM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup MSCM_Register_Masks MSCM Register Masks\r\n * @{\r\n */\r\n\r\n/* CPxTYPE Bit Fields */\r\n#define MSCM_CPxTYPE_RYPZ_MASK                   0xFFu\r\n#define MSCM_CPxTYPE_RYPZ_SHIFT                  0u\r\n#define MSCM_CPxTYPE_RYPZ_WIDTH                  8u\r\n#define MSCM_CPxTYPE_RYPZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxTYPE_RYPZ_SHIFT))&MSCM_CPxTYPE_RYPZ_MASK)\r\n#define MSCM_CPxTYPE_PERSONALITY_MASK            0xFFFFFF00u\r\n#define MSCM_CPxTYPE_PERSONALITY_SHIFT           8u\r\n#define MSCM_CPxTYPE_PERSONALITY_WIDTH           24u\r\n#define MSCM_CPxTYPE_PERSONALITY(x)              (((uint32_t)(((uint32_t)(x))<<MSCM_CPxTYPE_PERSONALITY_SHIFT))&MSCM_CPxTYPE_PERSONALITY_MASK)\r\n/* CPxNUM Bit Fields */\r\n#define MSCM_CPxNUM_CPN_MASK                     0x1u\r\n#define MSCM_CPxNUM_CPN_SHIFT                    0u\r\n#define MSCM_CPxNUM_CPN_WIDTH                    1u\r\n#define MSCM_CPxNUM_CPN(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_CPxNUM_CPN_SHIFT))&MSCM_CPxNUM_CPN_MASK)\r\n/* CPxMASTER Bit Fields */\r\n#define MSCM_CPxMASTER_PPMN_MASK                 0x3Fu\r\n#define MSCM_CPxMASTER_PPMN_SHIFT                0u\r\n#define MSCM_CPxMASTER_PPMN_WIDTH                6u\r\n#define MSCM_CPxMASTER_PPMN(x)                   (((uint32_t)(((uint32_t)(x))<<MSCM_CPxMASTER_PPMN_SHIFT))&MSCM_CPxMASTER_PPMN_MASK)\r\n/* CPxCOUNT Bit Fields */\r\n#define MSCM_CPxCOUNT_PCNT_MASK                  0x3u\r\n#define MSCM_CPxCOUNT_PCNT_SHIFT                 0u\r\n#define MSCM_CPxCOUNT_PCNT_WIDTH                 2u\r\n#define MSCM_CPxCOUNT_PCNT(x)                    (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCOUNT_PCNT_SHIFT))&MSCM_CPxCOUNT_PCNT_MASK)\r\n/* CPxCFG0 Bit Fields */\r\n#define MSCM_CPxCFG0_DCWY_MASK                   0xFFu\r\n#define MSCM_CPxCFG0_DCWY_SHIFT                  0u\r\n#define MSCM_CPxCFG0_DCWY_WIDTH                  8u\r\n#define MSCM_CPxCFG0_DCWY(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG0_DCWY_SHIFT))&MSCM_CPxCFG0_DCWY_MASK)\r\n#define MSCM_CPxCFG0_DCSZ_MASK                   0xFF00u\r\n#define MSCM_CPxCFG0_DCSZ_SHIFT                  8u\r\n#define MSCM_CPxCFG0_DCSZ_WIDTH                  8u\r\n#define MSCM_CPxCFG0_DCSZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG0_DCSZ_SHIFT))&MSCM_CPxCFG0_DCSZ_MASK)\r\n#define MSCM_CPxCFG0_ICWY_MASK                   0xFF0000u\r\n#define MSCM_CPxCFG0_ICWY_SHIFT                  16u\r\n#define MSCM_CPxCFG0_ICWY_WIDTH                  8u\r\n#define MSCM_CPxCFG0_ICWY(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG0_ICWY_SHIFT))&MSCM_CPxCFG0_ICWY_MASK)\r\n#define MSCM_CPxCFG0_ICSZ_MASK                   0xFF000000u\r\n#define MSCM_CPxCFG0_ICSZ_SHIFT                  24u\r\n#define MSCM_CPxCFG0_ICSZ_WIDTH                  8u\r\n#define MSCM_CPxCFG0_ICSZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG0_ICSZ_SHIFT))&MSCM_CPxCFG0_ICSZ_MASK)\r\n/* CPxCFG1 Bit Fields */\r\n#define MSCM_CPxCFG1_L2WY_MASK                   0xFF0000u\r\n#define MSCM_CPxCFG1_L2WY_SHIFT                  16u\r\n#define MSCM_CPxCFG1_L2WY_WIDTH                  8u\r\n#define MSCM_CPxCFG1_L2WY(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG1_L2WY_SHIFT))&MSCM_CPxCFG1_L2WY_MASK)\r\n#define MSCM_CPxCFG1_L2SZ_MASK                   0xFF000000u\r\n#define MSCM_CPxCFG1_L2SZ_SHIFT                  24u\r\n#define MSCM_CPxCFG1_L2SZ_WIDTH                  8u\r\n#define MSCM_CPxCFG1_L2SZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG1_L2SZ_SHIFT))&MSCM_CPxCFG1_L2SZ_MASK)\r\n/* CPxCFG2 Bit Fields */\r\n#define MSCM_CPxCFG2_TMUSZ_MASK                  0xFF00u\r\n#define MSCM_CPxCFG2_TMUSZ_SHIFT                 8u\r\n#define MSCM_CPxCFG2_TMUSZ_WIDTH                 8u\r\n#define MSCM_CPxCFG2_TMUSZ(x)                    (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG2_TMUSZ_SHIFT))&MSCM_CPxCFG2_TMUSZ_MASK)\r\n#define MSCM_CPxCFG2_TMLSZ_MASK                  0xFF000000u\r\n#define MSCM_CPxCFG2_TMLSZ_SHIFT                 24u\r\n#define MSCM_CPxCFG2_TMLSZ_WIDTH                 8u\r\n#define MSCM_CPxCFG2_TMLSZ(x)                    (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG2_TMLSZ_SHIFT))&MSCM_CPxCFG2_TMLSZ_MASK)\r\n/* CPxCFG3 Bit Fields */\r\n#define MSCM_CPxCFG3_FPU_MASK                    0x1u\r\n#define MSCM_CPxCFG3_FPU_SHIFT                   0u\r\n#define MSCM_CPxCFG3_FPU_WIDTH                   1u\r\n#define MSCM_CPxCFG3_FPU(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_FPU_SHIFT))&MSCM_CPxCFG3_FPU_MASK)\r\n#define MSCM_CPxCFG3_SIMD_MASK                   0x2u\r\n#define MSCM_CPxCFG3_SIMD_SHIFT                  1u\r\n#define MSCM_CPxCFG3_SIMD_WIDTH                  1u\r\n#define MSCM_CPxCFG3_SIMD(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_SIMD_SHIFT))&MSCM_CPxCFG3_SIMD_MASK)\r\n#define MSCM_CPxCFG3_JAZ_MASK                    0x4u\r\n#define MSCM_CPxCFG3_JAZ_SHIFT                   2u\r\n#define MSCM_CPxCFG3_JAZ_WIDTH                   1u\r\n#define MSCM_CPxCFG3_JAZ(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_JAZ_SHIFT))&MSCM_CPxCFG3_JAZ_MASK)\r\n#define MSCM_CPxCFG3_MMU_MASK                    0x8u\r\n#define MSCM_CPxCFG3_MMU_SHIFT                   3u\r\n#define MSCM_CPxCFG3_MMU_WIDTH                   1u\r\n#define MSCM_CPxCFG3_MMU(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_MMU_SHIFT))&MSCM_CPxCFG3_MMU_MASK)\r\n#define MSCM_CPxCFG3_TZ_MASK                     0x10u\r\n#define MSCM_CPxCFG3_TZ_SHIFT                    4u\r\n#define MSCM_CPxCFG3_TZ_WIDTH                    1u\r\n#define MSCM_CPxCFG3_TZ(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_TZ_SHIFT))&MSCM_CPxCFG3_TZ_MASK)\r\n#define MSCM_CPxCFG3_CMP_MASK                    0x20u\r\n#define MSCM_CPxCFG3_CMP_SHIFT                   5u\r\n#define MSCM_CPxCFG3_CMP_WIDTH                   1u\r\n#define MSCM_CPxCFG3_CMP(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_CMP_SHIFT))&MSCM_CPxCFG3_CMP_MASK)\r\n#define MSCM_CPxCFG3_BB_MASK                     0x40u\r\n#define MSCM_CPxCFG3_BB_SHIFT                    6u\r\n#define MSCM_CPxCFG3_BB_WIDTH                    1u\r\n#define MSCM_CPxCFG3_BB(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_BB_SHIFT))&MSCM_CPxCFG3_BB_MASK)\r\n#define MSCM_CPxCFG3_SBP_MASK                    0x300u\r\n#define MSCM_CPxCFG3_SBP_SHIFT                   8u\r\n#define MSCM_CPxCFG3_SBP_WIDTH                   2u\r\n#define MSCM_CPxCFG3_SBP(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CPxCFG3_SBP_SHIFT))&MSCM_CPxCFG3_SBP_MASK)\r\n/* CP0TYPE Bit Fields */\r\n#define MSCM_CP0TYPE_RYPZ_MASK                   0xFFu\r\n#define MSCM_CP0TYPE_RYPZ_SHIFT                  0u\r\n#define MSCM_CP0TYPE_RYPZ_WIDTH                  8u\r\n#define MSCM_CP0TYPE_RYPZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0TYPE_RYPZ_SHIFT))&MSCM_CP0TYPE_RYPZ_MASK)\r\n#define MSCM_CP0TYPE_PERSONALITY_MASK            0xFFFFFF00u\r\n#define MSCM_CP0TYPE_PERSONALITY_SHIFT           8u\r\n#define MSCM_CP0TYPE_PERSONALITY_WIDTH           24u\r\n#define MSCM_CP0TYPE_PERSONALITY(x)              (((uint32_t)(((uint32_t)(x))<<MSCM_CP0TYPE_PERSONALITY_SHIFT))&MSCM_CP0TYPE_PERSONALITY_MASK)\r\n/* CP0NUM Bit Fields */\r\n#define MSCM_CP0NUM_CPN_MASK                     0x1u\r\n#define MSCM_CP0NUM_CPN_SHIFT                    0u\r\n#define MSCM_CP0NUM_CPN_WIDTH                    1u\r\n#define MSCM_CP0NUM_CPN(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_CP0NUM_CPN_SHIFT))&MSCM_CP0NUM_CPN_MASK)\r\n/* CP0MASTER Bit Fields */\r\n#define MSCM_CP0MASTER_PPMN_MASK                 0x3Fu\r\n#define MSCM_CP0MASTER_PPMN_SHIFT                0u\r\n#define MSCM_CP0MASTER_PPMN_WIDTH                6u\r\n#define MSCM_CP0MASTER_PPMN(x)                   (((uint32_t)(((uint32_t)(x))<<MSCM_CP0MASTER_PPMN_SHIFT))&MSCM_CP0MASTER_PPMN_MASK)\r\n/* CP0COUNT Bit Fields */\r\n#define MSCM_CP0COUNT_PCNT_MASK                  0x3u\r\n#define MSCM_CP0COUNT_PCNT_SHIFT                 0u\r\n#define MSCM_CP0COUNT_PCNT_WIDTH                 2u\r\n#define MSCM_CP0COUNT_PCNT(x)                    (((uint32_t)(((uint32_t)(x))<<MSCM_CP0COUNT_PCNT_SHIFT))&MSCM_CP0COUNT_PCNT_MASK)\r\n/* CP0CFG0 Bit Fields */\r\n#define MSCM_CP0CFG0_DCWY_MASK                   0xFFu\r\n#define MSCM_CP0CFG0_DCWY_SHIFT                  0u\r\n#define MSCM_CP0CFG0_DCWY_WIDTH                  8u\r\n#define MSCM_CP0CFG0_DCWY(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG0_DCWY_SHIFT))&MSCM_CP0CFG0_DCWY_MASK)\r\n#define MSCM_CP0CFG0_DCSZ_MASK                   0xFF00u\r\n#define MSCM_CP0CFG0_DCSZ_SHIFT                  8u\r\n#define MSCM_CP0CFG0_DCSZ_WIDTH                  8u\r\n#define MSCM_CP0CFG0_DCSZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG0_DCSZ_SHIFT))&MSCM_CP0CFG0_DCSZ_MASK)\r\n#define MSCM_CP0CFG0_ICWY_MASK                   0xFF0000u\r\n#define MSCM_CP0CFG0_ICWY_SHIFT                  16u\r\n#define MSCM_CP0CFG0_ICWY_WIDTH                  8u\r\n#define MSCM_CP0CFG0_ICWY(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG0_ICWY_SHIFT))&MSCM_CP0CFG0_ICWY_MASK)\r\n#define MSCM_CP0CFG0_ICSZ_MASK                   0xFF000000u\r\n#define MSCM_CP0CFG0_ICSZ_SHIFT                  24u\r\n#define MSCM_CP0CFG0_ICSZ_WIDTH                  8u\r\n#define MSCM_CP0CFG0_ICSZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG0_ICSZ_SHIFT))&MSCM_CP0CFG0_ICSZ_MASK)\r\n/* CP0CFG1 Bit Fields */\r\n#define MSCM_CP0CFG1_L2WY_MASK                   0xFF0000u\r\n#define MSCM_CP0CFG1_L2WY_SHIFT                  16u\r\n#define MSCM_CP0CFG1_L2WY_WIDTH                  8u\r\n#define MSCM_CP0CFG1_L2WY(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG1_L2WY_SHIFT))&MSCM_CP0CFG1_L2WY_MASK)\r\n#define MSCM_CP0CFG1_L2SZ_MASK                   0xFF000000u\r\n#define MSCM_CP0CFG1_L2SZ_SHIFT                  24u\r\n#define MSCM_CP0CFG1_L2SZ_WIDTH                  8u\r\n#define MSCM_CP0CFG1_L2SZ(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG1_L2SZ_SHIFT))&MSCM_CP0CFG1_L2SZ_MASK)\r\n/* CP0CFG2 Bit Fields */\r\n#define MSCM_CP0CFG2_TMUSZ_MASK                  0xFF00u\r\n#define MSCM_CP0CFG2_TMUSZ_SHIFT                 8u\r\n#define MSCM_CP0CFG2_TMUSZ_WIDTH                 8u\r\n#define MSCM_CP0CFG2_TMUSZ(x)                    (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG2_TMUSZ_SHIFT))&MSCM_CP0CFG2_TMUSZ_MASK)\r\n#define MSCM_CP0CFG2_TMLSZ_MASK                  0xFF000000u\r\n#define MSCM_CP0CFG2_TMLSZ_SHIFT                 24u\r\n#define MSCM_CP0CFG2_TMLSZ_WIDTH                 8u\r\n#define MSCM_CP0CFG2_TMLSZ(x)                    (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG2_TMLSZ_SHIFT))&MSCM_CP0CFG2_TMLSZ_MASK)\r\n/* CP0CFG3 Bit Fields */\r\n#define MSCM_CP0CFG3_FPU_MASK                    0x1u\r\n#define MSCM_CP0CFG3_FPU_SHIFT                   0u\r\n#define MSCM_CP0CFG3_FPU_WIDTH                   1u\r\n#define MSCM_CP0CFG3_FPU(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_FPU_SHIFT))&MSCM_CP0CFG3_FPU_MASK)\r\n#define MSCM_CP0CFG3_SIMD_MASK                   0x2u\r\n#define MSCM_CP0CFG3_SIMD_SHIFT                  1u\r\n#define MSCM_CP0CFG3_SIMD_WIDTH                  1u\r\n#define MSCM_CP0CFG3_SIMD(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_SIMD_SHIFT))&MSCM_CP0CFG3_SIMD_MASK)\r\n#define MSCM_CP0CFG3_JAZ_MASK                    0x4u\r\n#define MSCM_CP0CFG3_JAZ_SHIFT                   2u\r\n#define MSCM_CP0CFG3_JAZ_WIDTH                   1u\r\n#define MSCM_CP0CFG3_JAZ(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_JAZ_SHIFT))&MSCM_CP0CFG3_JAZ_MASK)\r\n#define MSCM_CP0CFG3_MMU_MASK                    0x8u\r\n#define MSCM_CP0CFG3_MMU_SHIFT                   3u\r\n#define MSCM_CP0CFG3_MMU_WIDTH                   1u\r\n#define MSCM_CP0CFG3_MMU(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_MMU_SHIFT))&MSCM_CP0CFG3_MMU_MASK)\r\n#define MSCM_CP0CFG3_TZ_MASK                     0x10u\r\n#define MSCM_CP0CFG3_TZ_SHIFT                    4u\r\n#define MSCM_CP0CFG3_TZ_WIDTH                    1u\r\n#define MSCM_CP0CFG3_TZ(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_TZ_SHIFT))&MSCM_CP0CFG3_TZ_MASK)\r\n#define MSCM_CP0CFG3_CMP_MASK                    0x20u\r\n#define MSCM_CP0CFG3_CMP_SHIFT                   5u\r\n#define MSCM_CP0CFG3_CMP_WIDTH                   1u\r\n#define MSCM_CP0CFG3_CMP(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_CMP_SHIFT))&MSCM_CP0CFG3_CMP_MASK)\r\n#define MSCM_CP0CFG3_BB_MASK                     0x40u\r\n#define MSCM_CP0CFG3_BB_SHIFT                    6u\r\n#define MSCM_CP0CFG3_BB_WIDTH                    1u\r\n#define MSCM_CP0CFG3_BB(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_BB_SHIFT))&MSCM_CP0CFG3_BB_MASK)\r\n#define MSCM_CP0CFG3_SBP_MASK                    0x300u\r\n#define MSCM_CP0CFG3_SBP_SHIFT                   8u\r\n#define MSCM_CP0CFG3_SBP_WIDTH                   2u\r\n#define MSCM_CP0CFG3_SBP(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_CP0CFG3_SBP_SHIFT))&MSCM_CP0CFG3_SBP_MASK)\r\n/* OCMDR Bit Fields */\r\n#define MSCM_OCMDR_OCM1_MASK                     0x30u\r\n#define MSCM_OCMDR_OCM1_SHIFT                    4u\r\n#define MSCM_OCMDR_OCM1_WIDTH                    2u\r\n#define MSCM_OCMDR_OCM1(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_OCM1_SHIFT))&MSCM_OCMDR_OCM1_MASK)\r\n#define MSCM_OCMDR_OCMPU_MASK                    0x1000u\r\n#define MSCM_OCMDR_OCMPU_SHIFT                   12u\r\n#define MSCM_OCMDR_OCMPU_WIDTH                   1u\r\n#define MSCM_OCMDR_OCMPU(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_OCMPU_SHIFT))&MSCM_OCMDR_OCMPU_MASK)\r\n#define MSCM_OCMDR_OCMT_MASK                     0xE000u\r\n#define MSCM_OCMDR_OCMT_SHIFT                    13u\r\n#define MSCM_OCMDR_OCMT_WIDTH                    3u\r\n#define MSCM_OCMDR_OCMT(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_OCMT_SHIFT))&MSCM_OCMDR_OCMT_MASK)\r\n#define MSCM_OCMDR_RO_MASK                       0x10000u\r\n#define MSCM_OCMDR_RO_SHIFT                      16u\r\n#define MSCM_OCMDR_RO_WIDTH                      1u\r\n#define MSCM_OCMDR_RO(x)                         (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_RO_SHIFT))&MSCM_OCMDR_RO_MASK)\r\n#define MSCM_OCMDR_OCMW_MASK                     0xE0000u\r\n#define MSCM_OCMDR_OCMW_SHIFT                    17u\r\n#define MSCM_OCMDR_OCMW_WIDTH                    3u\r\n#define MSCM_OCMDR_OCMW(x)                       (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_OCMW_SHIFT))&MSCM_OCMDR_OCMW_MASK)\r\n#define MSCM_OCMDR_OCMSZ_MASK                    0xF000000u\r\n#define MSCM_OCMDR_OCMSZ_SHIFT                   24u\r\n#define MSCM_OCMDR_OCMSZ_WIDTH                   4u\r\n#define MSCM_OCMDR_OCMSZ(x)                      (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_OCMSZ_SHIFT))&MSCM_OCMDR_OCMSZ_MASK)\r\n#define MSCM_OCMDR_OCMSZH_MASK                   0x10000000u\r\n#define MSCM_OCMDR_OCMSZH_SHIFT                  28u\r\n#define MSCM_OCMDR_OCMSZH_WIDTH                  1u\r\n#define MSCM_OCMDR_OCMSZH(x)                     (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_OCMSZH_SHIFT))&MSCM_OCMDR_OCMSZH_MASK)\r\n#define MSCM_OCMDR_V_MASK                        0x80000000u\r\n#define MSCM_OCMDR_V_SHIFT                       31u\r\n#define MSCM_OCMDR_V_WIDTH                       1u\r\n#define MSCM_OCMDR_V(x)                          (((uint32_t)(((uint32_t)(x))<<MSCM_OCMDR_V_SHIFT))&MSCM_OCMDR_V_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group MSCM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group MSCM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PCC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PCC_Peripheral_Access_Layer PCC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** PCC - Size of Registers Arrays */\r\n#define PCC_PCCn_COUNT                           116u\r\n\r\n/** PCC - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t PCCn[PCC_PCCn_COUNT];              /**< PCC Reserved Register 0..PCC CMP0 Register, array offset: 0x0, array step: 0x4 */\r\n} PCC_Type, *PCC_MemMapPtr;\r\n\r\n /** Number of instances of the PCC module. */\r\n#define PCC_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* PCC - Peripheral instance base addresses */\r\n/** Peripheral PCC base address */\r\n#define PCC_BASE                                 (0x40065000u)\r\n/** Peripheral PCC base pointer */\r\n#define PCC                                      ((PCC_Type *)PCC_BASE)\r\n/** Array initializer of PCC peripheral base addresses */\r\n#define PCC_BASE_ADDRS                           { PCC_BASE }\r\n/** Array initializer of PCC peripheral base pointers */\r\n#define PCC_BASE_PTRS                            { PCC }\r\n\r\n/* PCC index offsets */\r\n#define PCC_FTFC_INDEX                           32\r\n#define PCC_DMAMUX_INDEX                         33\r\n#define PCC_FlexCAN0_INDEX                       36\r\n#define PCC_FlexCAN1_INDEX                       37\r\n#define PCC_FTM3_INDEX                           38\r\n#define PCC_ADC1_INDEX                           39\r\n#define PCC_FlexCAN2_INDEX                       43\r\n#define PCC_LPSPI0_INDEX                         44\r\n#define PCC_LPSPI1_INDEX                         45\r\n#define PCC_LPSPI2_INDEX                         46\r\n#define PCC_PDB1_INDEX                           49\r\n#define PCC_CRC_INDEX                            50\r\n#define PCC_PDB0_INDEX                           54\r\n#define PCC_LPIT_INDEX                           55\r\n#define PCC_FTM0_INDEX                           56\r\n#define PCC_FTM1_INDEX                           57\r\n#define PCC_FTM2_INDEX                           58\r\n#define PCC_ADC0_INDEX                           59\r\n#define PCC_RTC_INDEX                            61\r\n#define PCC_LPTMR0_INDEX                         64\r\n#define PCC_PORTA_INDEX                          73\r\n#define PCC_PORTB_INDEX                          74\r\n#define PCC_PORTC_INDEX                          75\r\n#define PCC_PORTD_INDEX                          76\r\n#define PCC_PORTE_INDEX                          77\r\n#define PCC_FlexIO_INDEX                         90\r\n#define PCC_EWM_INDEX                            97\r\n#define PCC_LPI2C0_INDEX                         102\r\n#define PCC_LPUART0_INDEX                        106\r\n#define PCC_LPUART1_INDEX                        107\r\n#define PCC_LPUART2_INDEX                        108\r\n#define PCC_CMP0_INDEX                           115\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PCC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PCC_Register_Masks PCC Register Masks\r\n * @{\r\n */\r\n\r\n/* PCCn Bit Fields */\r\n#define PCC_PCCn_PCD_MASK                        0x7u\r\n#define PCC_PCCn_PCD_SHIFT                       0u\r\n#define PCC_PCCn_PCD_WIDTH                       3u\r\n#define PCC_PCCn_PCD(x)                          (((uint32_t)(((uint32_t)(x))<<PCC_PCCn_PCD_SHIFT))&PCC_PCCn_PCD_MASK)\r\n#define PCC_PCCn_FRAC_MASK                       0x8u\r\n#define PCC_PCCn_FRAC_SHIFT                      3u\r\n#define PCC_PCCn_FRAC_WIDTH                      1u\r\n#define PCC_PCCn_FRAC(x)                         (((uint32_t)(((uint32_t)(x))<<PCC_PCCn_FRAC_SHIFT))&PCC_PCCn_FRAC_MASK)\r\n#define PCC_PCCn_PCS_MASK                        0x7000000u\r\n#define PCC_PCCn_PCS_SHIFT                       24u\r\n#define PCC_PCCn_PCS_WIDTH                       3u\r\n#define PCC_PCCn_PCS(x)                          (((uint32_t)(((uint32_t)(x))<<PCC_PCCn_PCS_SHIFT))&PCC_PCCn_PCS_MASK)\r\n#define PCC_PCCn_CGC_MASK                        0x40000000u\r\n#define PCC_PCCn_CGC_SHIFT                       30u\r\n#define PCC_PCCn_CGC_WIDTH                       1u\r\n#define PCC_PCCn_CGC(x)                          (((uint32_t)(((uint32_t)(x))<<PCC_PCCn_CGC_SHIFT))&PCC_PCCn_CGC_MASK)\r\n#define PCC_PCCn_PR_MASK                         0x80000000u\r\n#define PCC_PCCn_PR_SHIFT                        31u\r\n#define PCC_PCCn_PR_WIDTH                        1u\r\n#define PCC_PCCn_PR(x)                           (((uint32_t)(((uint32_t)(x))<<PCC_PCCn_PR_SHIFT))&PCC_PCCn_PR_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PCC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PCC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PDB Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PDB_Peripheral_Access_Layer PDB Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** PDB - Size of Registers Arrays */\r\n#define PDB_CH_COUNT                             2u\r\n#define PDB_DLY_COUNT                            8u\r\n#define PDB_POnDLY_COUNT                         1u\r\n\r\n/** PDB - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t SC;                                /**< Status and Control register, offset: 0x0 */\r\n  __IO uint32_t MOD;                               /**< Modulus register, offset: 0x4 */\r\n  __I  uint32_t CNT;                               /**< Counter register, offset: 0x8 */\r\n  __IO uint32_t IDLY;                              /**< Interrupt Delay register, offset: 0xC */\r\n  struct {                                         /* offset: 0x10, array step: 0x28 */\r\n    __IO uint32_t C1;                                /**< Channel n Control register 1, array offset: 0x10, array step: 0x28 */\r\n    __IO uint32_t S;                                 /**< Channel n Status register, array offset: 0x14, array step: 0x28 */\r\n    __IO uint32_t DLY[PDB_DLY_COUNT];                /**< Channel n Delay 0 register..Channel n Delay 7 register, array offset: 0x18, array step: index*0x28, index2*0x4 */\r\n  } CH[PDB_CH_COUNT];\r\n       uint8_t RESERVED_0[304];\r\n  __IO uint32_t POEN;                              /**< Pulse-Out n Enable register, offset: 0x190 */\r\n  union {                                          /* offset: 0x194, array step: 0x4 */\r\n    __IO uint32_t PODLY;                             /**< Pulse-Out n Delay register, array offset: 0x194, array step: 0x4 */\r\n    struct {                                         /* offset: 0x194, array step: 0x4 */\r\n      __IO uint16_t DLY2;                              /**< PDB1_DLY2 register...PDB0_DLY2 register., array offset: 0x194, array step: 0x4 */\r\n      __IO uint16_t DLY1;                              /**< PDB1_DLY1 register...PDB0_DLY1 register., array offset: 0x196, array step: 0x4 */\r\n    } ACCESS16BIT;\r\n  } POnDLY[PDB_POnDLY_COUNT];\r\n} PDB_Type, *PDB_MemMapPtr;\r\n\r\n /** Number of instances of the PDB module. */\r\n#define PDB_INSTANCE_COUNT                       (2u)\r\n\r\n\r\n/* PDB - Peripheral instance base addresses */\r\n/** Peripheral PDB0 base address */\r\n#define PDB0_BASE                                (0x40036000u)\r\n/** Peripheral PDB0 base pointer */\r\n#define PDB0                                     ((PDB_Type *)PDB0_BASE)\r\n/** Peripheral PDB1 base address */\r\n#define PDB1_BASE                                (0x40031000u)\r\n/** Peripheral PDB1 base pointer */\r\n#define PDB1                                     ((PDB_Type *)PDB1_BASE)\r\n/** Array initializer of PDB peripheral base addresses */\r\n#define PDB_BASE_ADDRS                           { PDB0_BASE, PDB1_BASE }\r\n/** Array initializer of PDB peripheral base pointers */\r\n#define PDB_BASE_PTRS                            { PDB0, PDB1 }\r\n /** Number of interrupt vector arrays for the PDB module. */\r\n#define PDB_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the PDB module. */\r\n#define PDB_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the PDB peripheral type */\r\n#define PDB_IRQS                                 { PDB0_IRQn, PDB1_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PDB Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PDB_Register_Masks PDB Register Masks\r\n * @{\r\n */\r\n\r\n/* SC Bit Fields */\r\n#define PDB_SC_LDOK_MASK                         0x1u\r\n#define PDB_SC_LDOK_SHIFT                        0u\r\n#define PDB_SC_LDOK_WIDTH                        1u\r\n#define PDB_SC_LDOK(x)                           (((uint32_t)(((uint32_t)(x))<<PDB_SC_LDOK_SHIFT))&PDB_SC_LDOK_MASK)\r\n#define PDB_SC_CONT_MASK                         0x2u\r\n#define PDB_SC_CONT_SHIFT                        1u\r\n#define PDB_SC_CONT_WIDTH                        1u\r\n#define PDB_SC_CONT(x)                           (((uint32_t)(((uint32_t)(x))<<PDB_SC_CONT_SHIFT))&PDB_SC_CONT_MASK)\r\n#define PDB_SC_MULT_MASK                         0xCu\r\n#define PDB_SC_MULT_SHIFT                        2u\r\n#define PDB_SC_MULT_WIDTH                        2u\r\n#define PDB_SC_MULT(x)                           (((uint32_t)(((uint32_t)(x))<<PDB_SC_MULT_SHIFT))&PDB_SC_MULT_MASK)\r\n#define PDB_SC_PDBIE_MASK                        0x20u\r\n#define PDB_SC_PDBIE_SHIFT                       5u\r\n#define PDB_SC_PDBIE_WIDTH                       1u\r\n#define PDB_SC_PDBIE(x)                          (((uint32_t)(((uint32_t)(x))<<PDB_SC_PDBIE_SHIFT))&PDB_SC_PDBIE_MASK)\r\n#define PDB_SC_PDBIF_MASK                        0x40u\r\n#define PDB_SC_PDBIF_SHIFT                       6u\r\n#define PDB_SC_PDBIF_WIDTH                       1u\r\n#define PDB_SC_PDBIF(x)                          (((uint32_t)(((uint32_t)(x))<<PDB_SC_PDBIF_SHIFT))&PDB_SC_PDBIF_MASK)\r\n#define PDB_SC_PDBEN_MASK                        0x80u\r\n#define PDB_SC_PDBEN_SHIFT                       7u\r\n#define PDB_SC_PDBEN_WIDTH                       1u\r\n#define PDB_SC_PDBEN(x)                          (((uint32_t)(((uint32_t)(x))<<PDB_SC_PDBEN_SHIFT))&PDB_SC_PDBEN_MASK)\r\n#define PDB_SC_TRGSEL_MASK                       0xF00u\r\n#define PDB_SC_TRGSEL_SHIFT                      8u\r\n#define PDB_SC_TRGSEL_WIDTH                      4u\r\n#define PDB_SC_TRGSEL(x)                         (((uint32_t)(((uint32_t)(x))<<PDB_SC_TRGSEL_SHIFT))&PDB_SC_TRGSEL_MASK)\r\n#define PDB_SC_PRESCALER_MASK                    0x7000u\r\n#define PDB_SC_PRESCALER_SHIFT                   12u\r\n#define PDB_SC_PRESCALER_WIDTH                   3u\r\n#define PDB_SC_PRESCALER(x)                      (((uint32_t)(((uint32_t)(x))<<PDB_SC_PRESCALER_SHIFT))&PDB_SC_PRESCALER_MASK)\r\n#define PDB_SC_DMAEN_MASK                        0x8000u\r\n#define PDB_SC_DMAEN_SHIFT                       15u\r\n#define PDB_SC_DMAEN_WIDTH                       1u\r\n#define PDB_SC_DMAEN(x)                          (((uint32_t)(((uint32_t)(x))<<PDB_SC_DMAEN_SHIFT))&PDB_SC_DMAEN_MASK)\r\n#define PDB_SC_SWTRIG_MASK                       0x10000u\r\n#define PDB_SC_SWTRIG_SHIFT                      16u\r\n#define PDB_SC_SWTRIG_WIDTH                      1u\r\n#define PDB_SC_SWTRIG(x)                         (((uint32_t)(((uint32_t)(x))<<PDB_SC_SWTRIG_SHIFT))&PDB_SC_SWTRIG_MASK)\r\n#define PDB_SC_PDBEIE_MASK                       0x20000u\r\n#define PDB_SC_PDBEIE_SHIFT                      17u\r\n#define PDB_SC_PDBEIE_WIDTH                      1u\r\n#define PDB_SC_PDBEIE(x)                         (((uint32_t)(((uint32_t)(x))<<PDB_SC_PDBEIE_SHIFT))&PDB_SC_PDBEIE_MASK)\r\n#define PDB_SC_LDMOD_MASK                        0xC0000u\r\n#define PDB_SC_LDMOD_SHIFT                       18u\r\n#define PDB_SC_LDMOD_WIDTH                       2u\r\n#define PDB_SC_LDMOD(x)                          (((uint32_t)(((uint32_t)(x))<<PDB_SC_LDMOD_SHIFT))&PDB_SC_LDMOD_MASK)\r\n/* MOD Bit Fields */\r\n#define PDB_MOD_MOD_MASK                         0xFFFFu\r\n#define PDB_MOD_MOD_SHIFT                        0u\r\n#define PDB_MOD_MOD_WIDTH                        16u\r\n#define PDB_MOD_MOD(x)                           (((uint32_t)(((uint32_t)(x))<<PDB_MOD_MOD_SHIFT))&PDB_MOD_MOD_MASK)\r\n/* CNT Bit Fields */\r\n#define PDB_CNT_CNT_MASK                         0xFFFFu\r\n#define PDB_CNT_CNT_SHIFT                        0u\r\n#define PDB_CNT_CNT_WIDTH                        16u\r\n#define PDB_CNT_CNT(x)                           (((uint32_t)(((uint32_t)(x))<<PDB_CNT_CNT_SHIFT))&PDB_CNT_CNT_MASK)\r\n/* IDLY Bit Fields */\r\n#define PDB_IDLY_IDLY_MASK                       0xFFFFu\r\n#define PDB_IDLY_IDLY_SHIFT                      0u\r\n#define PDB_IDLY_IDLY_WIDTH                      16u\r\n#define PDB_IDLY_IDLY(x)                         (((uint32_t)(((uint32_t)(x))<<PDB_IDLY_IDLY_SHIFT))&PDB_IDLY_IDLY_MASK)\r\n/* C1 Bit Fields */\r\n#define PDB_C1_EN_MASK                           0xFFu\r\n#define PDB_C1_EN_SHIFT                          0u\r\n#define PDB_C1_EN_WIDTH                          8u\r\n#define PDB_C1_EN(x)                             (((uint32_t)(((uint32_t)(x))<<PDB_C1_EN_SHIFT))&PDB_C1_EN_MASK)\r\n#define PDB_C1_TOS_MASK                          0xFF00u\r\n#define PDB_C1_TOS_SHIFT                         8u\r\n#define PDB_C1_TOS_WIDTH                         8u\r\n#define PDB_C1_TOS(x)                            (((uint32_t)(((uint32_t)(x))<<PDB_C1_TOS_SHIFT))&PDB_C1_TOS_MASK)\r\n#define PDB_C1_BB_MASK                           0xFF0000u\r\n#define PDB_C1_BB_SHIFT                          16u\r\n#define PDB_C1_BB_WIDTH                          8u\r\n#define PDB_C1_BB(x)                             (((uint32_t)(((uint32_t)(x))<<PDB_C1_BB_SHIFT))&PDB_C1_BB_MASK)\r\n/* S Bit Fields */\r\n#define PDB_S_ERR_MASK                           0xFFu\r\n#define PDB_S_ERR_SHIFT                          0u\r\n#define PDB_S_ERR_WIDTH                          8u\r\n#define PDB_S_ERR(x)                             (((uint32_t)(((uint32_t)(x))<<PDB_S_ERR_SHIFT))&PDB_S_ERR_MASK)\r\n#define PDB_S_CF_MASK                            0xFF0000u\r\n#define PDB_S_CF_SHIFT                           16u\r\n#define PDB_S_CF_WIDTH                           8u\r\n#define PDB_S_CF(x)                              (((uint32_t)(((uint32_t)(x))<<PDB_S_CF_SHIFT))&PDB_S_CF_MASK)\r\n/* DLY Bit Fields */\r\n#define PDB_DLY_DLY_MASK                         0xFFFFu\r\n#define PDB_DLY_DLY_SHIFT                        0u\r\n#define PDB_DLY_DLY_WIDTH                        16u\r\n#define PDB_DLY_DLY(x)                           (((uint32_t)(((uint32_t)(x))<<PDB_DLY_DLY_SHIFT))&PDB_DLY_DLY_MASK)\r\n/* POEN Bit Fields */\r\n#define PDB_POEN_POEN_MASK                       0xFFu\r\n#define PDB_POEN_POEN_SHIFT                      0u\r\n#define PDB_POEN_POEN_WIDTH                      8u\r\n#define PDB_POEN_POEN(x)                         (((uint32_t)(((uint32_t)(x))<<PDB_POEN_POEN_SHIFT))&PDB_POEN_POEN_MASK)\r\n/* POnDLY_PODLY Bit Fields */\r\n#define PDB_POnDLY_PODLY_DLY2_MASK               0xFFFFu\r\n#define PDB_POnDLY_PODLY_DLY2_SHIFT              0u\r\n#define PDB_POnDLY_PODLY_DLY2_WIDTH              16u\r\n#define PDB_POnDLY_PODLY_DLY2(x)                 (((uint32_t)(((uint32_t)(x))<<PDB_POnDLY_PODLY_DLY2_SHIFT))&PDB_POnDLY_PODLY_DLY2_MASK)\r\n#define PDB_POnDLY_PODLY_DLY1_MASK               0xFFFF0000u\r\n#define PDB_POnDLY_PODLY_DLY1_SHIFT              16u\r\n#define PDB_POnDLY_PODLY_DLY1_WIDTH              16u\r\n#define PDB_POnDLY_PODLY_DLY1(x)                 (((uint32_t)(((uint32_t)(x))<<PDB_POnDLY_PODLY_DLY1_SHIFT))&PDB_POnDLY_PODLY_DLY1_MASK)\r\n/* POnDLY_ACCESS16BIT_DLY2 Bit Fields */\r\n#define PDB_POnDLY_ACCESS16BIT_DLY2_DLY2_MASK    0xFFFFu\r\n#define PDB_POnDLY_ACCESS16BIT_DLY2_DLY2_SHIFT   0u\r\n#define PDB_POnDLY_ACCESS16BIT_DLY2_DLY2_WIDTH   16u\r\n#define PDB_POnDLY_ACCESS16BIT_DLY2_DLY2(x)      (((uint16_t)(((uint16_t)(x))<<PDB_POnDLY_ACCESS16BIT_DLY2_DLY2_SHIFT))&PDB_POnDLY_ACCESS16BIT_DLY2_DLY2_MASK)\r\n/* POnDLY_ACCESS16BIT_DLY1 Bit Fields */\r\n#define PDB_POnDLY_ACCESS16BIT_DLY1_DLY1_MASK    0xFFFFu\r\n#define PDB_POnDLY_ACCESS16BIT_DLY1_DLY1_SHIFT   0u\r\n#define PDB_POnDLY_ACCESS16BIT_DLY1_DLY1_WIDTH   16u\r\n#define PDB_POnDLY_ACCESS16BIT_DLY1_DLY1(x)      (((uint16_t)(((uint16_t)(x))<<PDB_POnDLY_ACCESS16BIT_DLY1_DLY1_SHIFT))&PDB_POnDLY_ACCESS16BIT_DLY1_DLY1_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PDB_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PDB_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PMC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PMC_Peripheral_Access_Layer PMC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** PMC - Size of Registers Arrays */\r\n\r\n/** PMC - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint8_t LVDSC1;                             /**< Low Voltage Detect Status and Control 1 Register, offset: 0x0 */\r\n  __IO uint8_t LVDSC2;                             /**< Low Voltage Detect Status and Control 2 Register, offset: 0x1 */\r\n  __IO uint8_t REGSC;                              /**< Regulator Status and Control Register, offset: 0x2 */\r\n       uint8_t RESERVED_0[1];\r\n  __IO uint8_t LPOTRIM;                            /**< Low Power Oscillator Trim Register, offset: 0x4 */\r\n} PMC_Type, *PMC_MemMapPtr;\r\n\r\n /** Number of instances of the PMC module. */\r\n#define PMC_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* PMC - Peripheral instance base addresses */\r\n/** Peripheral PMC base address */\r\n#define PMC_BASE                                 (0x4007D000u)\r\n/** Peripheral PMC base pointer */\r\n#define PMC                                      ((PMC_Type *)PMC_BASE)\r\n/** Array initializer of PMC peripheral base addresses */\r\n#define PMC_BASE_ADDRS                           { PMC_BASE }\r\n/** Array initializer of PMC peripheral base pointers */\r\n#define PMC_BASE_PTRS                            { PMC }\r\n /** Number of interrupt vector arrays for the PMC module. */\r\n#define PMC_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the PMC module. */\r\n#define PMC_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the PMC peripheral type */\r\n#define PMC_IRQS                                 { LVD_LVW_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PMC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PMC_Register_Masks PMC Register Masks\r\n * @{\r\n */\r\n\r\n/* LVDSC1 Bit Fields */\r\n#define PMC_LVDSC1_LVDRE_MASK                    0x10u\r\n#define PMC_LVDSC1_LVDRE_SHIFT                   4u\r\n#define PMC_LVDSC1_LVDRE_WIDTH                   1u\r\n#define PMC_LVDSC1_LVDRE(x)                      (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC1_LVDRE_SHIFT))&PMC_LVDSC1_LVDRE_MASK)\r\n#define PMC_LVDSC1_LVDIE_MASK                    0x20u\r\n#define PMC_LVDSC1_LVDIE_SHIFT                   5u\r\n#define PMC_LVDSC1_LVDIE_WIDTH                   1u\r\n#define PMC_LVDSC1_LVDIE(x)                      (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC1_LVDIE_SHIFT))&PMC_LVDSC1_LVDIE_MASK)\r\n#define PMC_LVDSC1_LVDACK_MASK                   0x40u\r\n#define PMC_LVDSC1_LVDACK_SHIFT                  6u\r\n#define PMC_LVDSC1_LVDACK_WIDTH                  1u\r\n#define PMC_LVDSC1_LVDACK(x)                     (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC1_LVDACK_SHIFT))&PMC_LVDSC1_LVDACK_MASK)\r\n#define PMC_LVDSC1_LVDF_MASK                     0x80u\r\n#define PMC_LVDSC1_LVDF_SHIFT                    7u\r\n#define PMC_LVDSC1_LVDF_WIDTH                    1u\r\n#define PMC_LVDSC1_LVDF(x)                       (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC1_LVDF_SHIFT))&PMC_LVDSC1_LVDF_MASK)\r\n/* LVDSC2 Bit Fields */\r\n#define PMC_LVDSC2_LVWIE_MASK                    0x20u\r\n#define PMC_LVDSC2_LVWIE_SHIFT                   5u\r\n#define PMC_LVDSC2_LVWIE_WIDTH                   1u\r\n#define PMC_LVDSC2_LVWIE(x)                      (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC2_LVWIE_SHIFT))&PMC_LVDSC2_LVWIE_MASK)\r\n#define PMC_LVDSC2_LVWACK_MASK                   0x40u\r\n#define PMC_LVDSC2_LVWACK_SHIFT                  6u\r\n#define PMC_LVDSC2_LVWACK_WIDTH                  1u\r\n#define PMC_LVDSC2_LVWACK(x)                     (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC2_LVWACK_SHIFT))&PMC_LVDSC2_LVWACK_MASK)\r\n#define PMC_LVDSC2_LVWF_MASK                     0x80u\r\n#define PMC_LVDSC2_LVWF_SHIFT                    7u\r\n#define PMC_LVDSC2_LVWF_WIDTH                    1u\r\n#define PMC_LVDSC2_LVWF(x)                       (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC2_LVWF_SHIFT))&PMC_LVDSC2_LVWF_MASK)\r\n/* REGSC Bit Fields */\r\n#define PMC_REGSC_BIASEN_MASK                    0x1u\r\n#define PMC_REGSC_BIASEN_SHIFT                   0u\r\n#define PMC_REGSC_BIASEN_WIDTH                   1u\r\n#define PMC_REGSC_BIASEN(x)                      (((uint8_t)(((uint8_t)(x))<<PMC_REGSC_BIASEN_SHIFT))&PMC_REGSC_BIASEN_MASK)\r\n#define PMC_REGSC_CLKBIASDIS_MASK                0x2u\r\n#define PMC_REGSC_CLKBIASDIS_SHIFT               1u\r\n#define PMC_REGSC_CLKBIASDIS_WIDTH               1u\r\n#define PMC_REGSC_CLKBIASDIS(x)                  (((uint8_t)(((uint8_t)(x))<<PMC_REGSC_CLKBIASDIS_SHIFT))&PMC_REGSC_CLKBIASDIS_MASK)\r\n#define PMC_REGSC_REGFPM_MASK                    0x4u\r\n#define PMC_REGSC_REGFPM_SHIFT                   2u\r\n#define PMC_REGSC_REGFPM_WIDTH                   1u\r\n#define PMC_REGSC_REGFPM(x)                      (((uint8_t)(((uint8_t)(x))<<PMC_REGSC_REGFPM_SHIFT))&PMC_REGSC_REGFPM_MASK)\r\n#define PMC_REGSC_LPOSTAT_MASK                   0x40u\r\n#define PMC_REGSC_LPOSTAT_SHIFT                  6u\r\n#define PMC_REGSC_LPOSTAT_WIDTH                  1u\r\n#define PMC_REGSC_LPOSTAT(x)                     (((uint8_t)(((uint8_t)(x))<<PMC_REGSC_LPOSTAT_SHIFT))&PMC_REGSC_LPOSTAT_MASK)\r\n#define PMC_REGSC_LPODIS_MASK                    0x80u\r\n#define PMC_REGSC_LPODIS_SHIFT                   7u\r\n#define PMC_REGSC_LPODIS_WIDTH                   1u\r\n#define PMC_REGSC_LPODIS(x)                      (((uint8_t)(((uint8_t)(x))<<PMC_REGSC_LPODIS_SHIFT))&PMC_REGSC_LPODIS_MASK)\r\n/* LPOTRIM Bit Fields */\r\n#define PMC_LPOTRIM_LPOTRIM_MASK                 0x1Fu\r\n#define PMC_LPOTRIM_LPOTRIM_SHIFT                0u\r\n#define PMC_LPOTRIM_LPOTRIM_WIDTH                5u\r\n#define PMC_LPOTRIM_LPOTRIM(x)                   (((uint8_t)(((uint8_t)(x))<<PMC_LPOTRIM_LPOTRIM_SHIFT))&PMC_LPOTRIM_LPOTRIM_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PMC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PMC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PORT Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PORT_Peripheral_Access_Layer PORT Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** PORT - Size of Registers Arrays */\r\n#define PORT_PCR_COUNT                           32u\r\n\r\n/** PORT - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t PCR[PORT_PCR_COUNT];               /**< Pin Control Register n, array offset: 0x0, array step: 0x4 */\r\n  __O  uint32_t GPCLR;                             /**< Global Pin Control Low Register, offset: 0x80 */\r\n  __O  uint32_t GPCHR;                             /**< Global Pin Control High Register, offset: 0x84 */\r\n  __O  uint32_t GICLR;                             /**< Global Interrupt Control Low Register, offset: 0x88 */\r\n  __O  uint32_t GICHR;                             /**< Global Interrupt Control High Register, offset: 0x8C */\r\n       uint8_t RESERVED_0[16];\r\n  __IO uint32_t ISFR;                              /**< Interrupt Status Flag Register, offset: 0xA0 */\r\n       uint8_t RESERVED_1[28];\r\n  __IO uint32_t DFER;                              /**< Digital Filter Enable Register, offset: 0xC0 */\r\n  __IO uint32_t DFCR;                              /**< Digital Filter Clock Register, offset: 0xC4 */\r\n  __IO uint32_t DFWR;                              /**< Digital Filter Width Register, offset: 0xC8 */\r\n} PORT_Type, *PORT_MemMapPtr;\r\n\r\n /** Number of instances of the PORT module. */\r\n#define PORT_INSTANCE_COUNT                      (5u)\r\n\r\n\r\n/* PORT - Peripheral instance base addresses */\r\n/** Peripheral PORTA base address */\r\n#define PORTA_BASE                               (0x40049000u)\r\n/** Peripheral PORTA base pointer */\r\n#define PORTA                                    ((PORT_Type *)PORTA_BASE)\r\n/** Peripheral PORTB base address */\r\n#define PORTB_BASE                               (0x4004A000u)\r\n/** Peripheral PORTB base pointer */\r\n#define PORTB                                    ((PORT_Type *)PORTB_BASE)\r\n/** Peripheral PORTC base address */\r\n#define PORTC_BASE                               (0x4004B000u)\r\n/** Peripheral PORTC base pointer */\r\n#define PORTC                                    ((PORT_Type *)PORTC_BASE)\r\n/** Peripheral PORTD base address */\r\n#define PORTD_BASE                               (0x4004C000u)\r\n/** Peripheral PORTD base pointer */\r\n#define PORTD                                    ((PORT_Type *)PORTD_BASE)\r\n/** Peripheral PORTE base address */\r\n#define PORTE_BASE                               (0x4004D000u)\r\n/** Peripheral PORTE base pointer */\r\n#define PORTE                                    ((PORT_Type *)PORTE_BASE)\r\n/** Array initializer of PORT peripheral base addresses */\r\n#define PORT_BASE_ADDRS                          { PORTA_BASE, PORTB_BASE, PORTC_BASE, PORTD_BASE, PORTE_BASE }\r\n/** Array initializer of PORT peripheral base pointers */\r\n#define PORT_BASE_PTRS                           { PORTA, PORTB, PORTC, PORTD, PORTE }\r\n /** Number of interrupt vector arrays for the PORT module. */\r\n#define PORT_IRQS_ARR_COUNT                      (1u)\r\n /** Number of interrupt channels for the PORT module. */\r\n#define PORT_IRQS_CH_COUNT                       (1u)\r\n/** Interrupt vectors for the PORT peripheral type */\r\n#define PORT_IRQS                                { PORTA_IRQn, PORTB_IRQn, PORTC_IRQn, PORTD_IRQn, PORTE_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- PORT Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup PORT_Register_Masks PORT Register Masks\r\n * @{\r\n */\r\n\r\n/* PCR Bit Fields */\r\n#define PORT_PCR_PS_MASK                         0x1u\r\n#define PORT_PCR_PS_SHIFT                        0u\r\n#define PORT_PCR_PS_WIDTH                        1u\r\n#define PORT_PCR_PS(x)                           (((uint32_t)(((uint32_t)(x))<<PORT_PCR_PS_SHIFT))&PORT_PCR_PS_MASK)\r\n#define PORT_PCR_PE_MASK                         0x2u\r\n#define PORT_PCR_PE_SHIFT                        1u\r\n#define PORT_PCR_PE_WIDTH                        1u\r\n#define PORT_PCR_PE(x)                           (((uint32_t)(((uint32_t)(x))<<PORT_PCR_PE_SHIFT))&PORT_PCR_PE_MASK)\r\n#define PORT_PCR_PFE_MASK                        0x10u\r\n#define PORT_PCR_PFE_SHIFT                       4u\r\n#define PORT_PCR_PFE_WIDTH                       1u\r\n#define PORT_PCR_PFE(x)                          (((uint32_t)(((uint32_t)(x))<<PORT_PCR_PFE_SHIFT))&PORT_PCR_PFE_MASK)\r\n#define PORT_PCR_DSE_MASK                        0x40u\r\n#define PORT_PCR_DSE_SHIFT                       6u\r\n#define PORT_PCR_DSE_WIDTH                       1u\r\n#define PORT_PCR_DSE(x)                          (((uint32_t)(((uint32_t)(x))<<PORT_PCR_DSE_SHIFT))&PORT_PCR_DSE_MASK)\r\n#define PORT_PCR_MUX_MASK                        0x700u\r\n#define PORT_PCR_MUX_SHIFT                       8u\r\n#define PORT_PCR_MUX_WIDTH                       3u\r\n#define PORT_PCR_MUX(x)                          (((uint32_t)(((uint32_t)(x))<<PORT_PCR_MUX_SHIFT))&PORT_PCR_MUX_MASK)\r\n#define PORT_PCR_LK_MASK                         0x8000u\r\n#define PORT_PCR_LK_SHIFT                        15u\r\n#define PORT_PCR_LK_WIDTH                        1u\r\n#define PORT_PCR_LK(x)                           (((uint32_t)(((uint32_t)(x))<<PORT_PCR_LK_SHIFT))&PORT_PCR_LK_MASK)\r\n#define PORT_PCR_IRQC_MASK                       0xF0000u\r\n#define PORT_PCR_IRQC_SHIFT                      16u\r\n#define PORT_PCR_IRQC_WIDTH                      4u\r\n#define PORT_PCR_IRQC(x)                         (((uint32_t)(((uint32_t)(x))<<PORT_PCR_IRQC_SHIFT))&PORT_PCR_IRQC_MASK)\r\n#define PORT_PCR_ISF_MASK                        0x1000000u\r\n#define PORT_PCR_ISF_SHIFT                       24u\r\n#define PORT_PCR_ISF_WIDTH                       1u\r\n#define PORT_PCR_ISF(x)                          (((uint32_t)(((uint32_t)(x))<<PORT_PCR_ISF_SHIFT))&PORT_PCR_ISF_MASK)\r\n/* GPCLR Bit Fields */\r\n#define PORT_GPCLR_GPWD_MASK                     0xFFFFu\r\n#define PORT_GPCLR_GPWD_SHIFT                    0u\r\n#define PORT_GPCLR_GPWD_WIDTH                    16u\r\n#define PORT_GPCLR_GPWD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCLR_GPWD_SHIFT))&PORT_GPCLR_GPWD_MASK)\r\n#define PORT_GPCLR_GPWE_MASK                     0xFFFF0000u\r\n#define PORT_GPCLR_GPWE_SHIFT                    16u\r\n#define PORT_GPCLR_GPWE_WIDTH                    16u\r\n#define PORT_GPCLR_GPWE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCLR_GPWE_SHIFT))&PORT_GPCLR_GPWE_MASK)\r\n/* GPCHR Bit Fields */\r\n#define PORT_GPCHR_GPWD_MASK                     0xFFFFu\r\n#define PORT_GPCHR_GPWD_SHIFT                    0u\r\n#define PORT_GPCHR_GPWD_WIDTH                    16u\r\n#define PORT_GPCHR_GPWD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCHR_GPWD_SHIFT))&PORT_GPCHR_GPWD_MASK)\r\n#define PORT_GPCHR_GPWE_MASK                     0xFFFF0000u\r\n#define PORT_GPCHR_GPWE_SHIFT                    16u\r\n#define PORT_GPCHR_GPWE_WIDTH                    16u\r\n#define PORT_GPCHR_GPWE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCHR_GPWE_SHIFT))&PORT_GPCHR_GPWE_MASK)\r\n/* GICLR Bit Fields */\r\n#define PORT_GICLR_GIWE_MASK                     0xFFFFu\r\n#define PORT_GICLR_GIWE_SHIFT                    0u\r\n#define PORT_GICLR_GIWE_WIDTH                    16u\r\n#define PORT_GICLR_GIWE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GICLR_GIWE_SHIFT))&PORT_GICLR_GIWE_MASK)\r\n#define PORT_GICLR_GIWD_MASK                     0xFFFF0000u\r\n#define PORT_GICLR_GIWD_SHIFT                    16u\r\n#define PORT_GICLR_GIWD_WIDTH                    16u\r\n#define PORT_GICLR_GIWD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GICLR_GIWD_SHIFT))&PORT_GICLR_GIWD_MASK)\r\n/* GICHR Bit Fields */\r\n#define PORT_GICHR_GIWE_MASK                     0xFFFFu\r\n#define PORT_GICHR_GIWE_SHIFT                    0u\r\n#define PORT_GICHR_GIWE_WIDTH                    16u\r\n#define PORT_GICHR_GIWE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GICHR_GIWE_SHIFT))&PORT_GICHR_GIWE_MASK)\r\n#define PORT_GICHR_GIWD_MASK                     0xFFFF0000u\r\n#define PORT_GICHR_GIWD_SHIFT                    16u\r\n#define PORT_GICHR_GIWD_WIDTH                    16u\r\n#define PORT_GICHR_GIWD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GICHR_GIWD_SHIFT))&PORT_GICHR_GIWD_MASK)\r\n/* ISFR Bit Fields */\r\n#define PORT_ISFR_ISF_MASK                       0xFFFFFFFFu\r\n#define PORT_ISFR_ISF_SHIFT                      0u\r\n#define PORT_ISFR_ISF_WIDTH                      32u\r\n#define PORT_ISFR_ISF(x)                         (((uint32_t)(((uint32_t)(x))<<PORT_ISFR_ISF_SHIFT))&PORT_ISFR_ISF_MASK)\r\n/* DFER Bit Fields */\r\n#define PORT_DFER_DFE_MASK                       0xFFFFFFFFu\r\n#define PORT_DFER_DFE_SHIFT                      0u\r\n#define PORT_DFER_DFE_WIDTH                      32u\r\n#define PORT_DFER_DFE(x)                         (((uint32_t)(((uint32_t)(x))<<PORT_DFER_DFE_SHIFT))&PORT_DFER_DFE_MASK)\r\n/* DFCR Bit Fields */\r\n#define PORT_DFCR_CS_MASK                        0x1u\r\n#define PORT_DFCR_CS_SHIFT                       0u\r\n#define PORT_DFCR_CS_WIDTH                       1u\r\n#define PORT_DFCR_CS(x)                          (((uint32_t)(((uint32_t)(x))<<PORT_DFCR_CS_SHIFT))&PORT_DFCR_CS_MASK)\r\n/* DFWR Bit Fields */\r\n#define PORT_DFWR_FILT_MASK                      0x1Fu\r\n#define PORT_DFWR_FILT_SHIFT                     0u\r\n#define PORT_DFWR_FILT_WIDTH                     5u\r\n#define PORT_DFWR_FILT(x)                        (((uint32_t)(((uint32_t)(x))<<PORT_DFWR_FILT_SHIFT))&PORT_DFWR_FILT_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PORT_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group PORT_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- RCM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup RCM_Peripheral_Access_Layer RCM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** RCM - Size of Registers Arrays */\r\n\r\n/** RCM - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n  __I  uint32_t SRS;                               /**< System Reset Status Register, offset: 0x8 */\r\n  __IO uint32_t RPC;                               /**< Reset Pin Control register, offset: 0xC */\r\n       uint8_t RESERVED_0[8];\r\n  __IO uint32_t SSRS;                              /**< Sticky System Reset Status Register, offset: 0x18 */\r\n  __IO uint32_t SRIE;                              /**< System Reset Interrupt Enable Register, offset: 0x1C */\r\n} RCM_Type, *RCM_MemMapPtr;\r\n\r\n /** Number of instances of the RCM module. */\r\n#define RCM_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* RCM - Peripheral instance base addresses */\r\n/** Peripheral RCM base address */\r\n#define RCM_BASE                                 (0x4007F000u)\r\n/** Peripheral RCM base pointer */\r\n#define RCM                                      ((RCM_Type *)RCM_BASE)\r\n/** Array initializer of RCM peripheral base addresses */\r\n#define RCM_BASE_ADDRS                           { RCM_BASE }\r\n/** Array initializer of RCM peripheral base pointers */\r\n#define RCM_BASE_PTRS                            { RCM }\r\n /** Number of interrupt vector arrays for the RCM module. */\r\n#define RCM_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the RCM module. */\r\n#define RCM_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the RCM peripheral type */\r\n#define RCM_IRQS                                 { RCM_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- RCM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup RCM_Register_Masks RCM Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define RCM_VERID_FEATURE_MASK                   0xFFFFu\r\n#define RCM_VERID_FEATURE_SHIFT                  0u\r\n#define RCM_VERID_FEATURE_WIDTH                  16u\r\n#define RCM_VERID_FEATURE(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_VERID_FEATURE_SHIFT))&RCM_VERID_FEATURE_MASK)\r\n#define RCM_VERID_MINOR_MASK                     0xFF0000u\r\n#define RCM_VERID_MINOR_SHIFT                    16u\r\n#define RCM_VERID_MINOR_WIDTH                    8u\r\n#define RCM_VERID_MINOR(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_VERID_MINOR_SHIFT))&RCM_VERID_MINOR_MASK)\r\n#define RCM_VERID_MAJOR_MASK                     0xFF000000u\r\n#define RCM_VERID_MAJOR_SHIFT                    24u\r\n#define RCM_VERID_MAJOR_WIDTH                    8u\r\n#define RCM_VERID_MAJOR(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_VERID_MAJOR_SHIFT))&RCM_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define RCM_PARAM_EWAKEUP_MASK                   0x1u\r\n#define RCM_PARAM_EWAKEUP_SHIFT                  0u\r\n#define RCM_PARAM_EWAKEUP_WIDTH                  1u\r\n#define RCM_PARAM_EWAKEUP(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_EWAKEUP_SHIFT))&RCM_PARAM_EWAKEUP_MASK)\r\n#define RCM_PARAM_ELVD_MASK                      0x2u\r\n#define RCM_PARAM_ELVD_SHIFT                     1u\r\n#define RCM_PARAM_ELVD_WIDTH                     1u\r\n#define RCM_PARAM_ELVD(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ELVD_SHIFT))&RCM_PARAM_ELVD_MASK)\r\n#define RCM_PARAM_ELOC_MASK                      0x4u\r\n#define RCM_PARAM_ELOC_SHIFT                     2u\r\n#define RCM_PARAM_ELOC_WIDTH                     1u\r\n#define RCM_PARAM_ELOC(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ELOC_SHIFT))&RCM_PARAM_ELOC_MASK)\r\n#define RCM_PARAM_ELOL_MASK                      0x8u\r\n#define RCM_PARAM_ELOL_SHIFT                     3u\r\n#define RCM_PARAM_ELOL_WIDTH                     1u\r\n#define RCM_PARAM_ELOL(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ELOL_SHIFT))&RCM_PARAM_ELOL_MASK)\r\n#define RCM_PARAM_EWDOG_MASK                     0x20u\r\n#define RCM_PARAM_EWDOG_SHIFT                    5u\r\n#define RCM_PARAM_EWDOG_WIDTH                    1u\r\n#define RCM_PARAM_EWDOG(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_EWDOG_SHIFT))&RCM_PARAM_EWDOG_MASK)\r\n#define RCM_PARAM_EPIN_MASK                      0x40u\r\n#define RCM_PARAM_EPIN_SHIFT                     6u\r\n#define RCM_PARAM_EPIN_WIDTH                     1u\r\n#define RCM_PARAM_EPIN(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_EPIN_SHIFT))&RCM_PARAM_EPIN_MASK)\r\n#define RCM_PARAM_EPOR_MASK                      0x80u\r\n#define RCM_PARAM_EPOR_SHIFT                     7u\r\n#define RCM_PARAM_EPOR_WIDTH                     1u\r\n#define RCM_PARAM_EPOR(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_EPOR_SHIFT))&RCM_PARAM_EPOR_MASK)\r\n#define RCM_PARAM_EJTAG_MASK                     0x100u\r\n#define RCM_PARAM_EJTAG_SHIFT                    8u\r\n#define RCM_PARAM_EJTAG_WIDTH                    1u\r\n#define RCM_PARAM_EJTAG(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_EJTAG_SHIFT))&RCM_PARAM_EJTAG_MASK)\r\n#define RCM_PARAM_ELOCKUP_MASK                   0x200u\r\n#define RCM_PARAM_ELOCKUP_SHIFT                  9u\r\n#define RCM_PARAM_ELOCKUP_WIDTH                  1u\r\n#define RCM_PARAM_ELOCKUP(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ELOCKUP_SHIFT))&RCM_PARAM_ELOCKUP_MASK)\r\n#define RCM_PARAM_ESW_MASK                       0x400u\r\n#define RCM_PARAM_ESW_SHIFT                      10u\r\n#define RCM_PARAM_ESW_WIDTH                      1u\r\n#define RCM_PARAM_ESW(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ESW_SHIFT))&RCM_PARAM_ESW_MASK)\r\n#define RCM_PARAM_EMDM_AP_MASK                   0x800u\r\n#define RCM_PARAM_EMDM_AP_SHIFT                  11u\r\n#define RCM_PARAM_EMDM_AP_WIDTH                  1u\r\n#define RCM_PARAM_EMDM_AP(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_EMDM_AP_SHIFT))&RCM_PARAM_EMDM_AP_MASK)\r\n#define RCM_PARAM_ESACKERR_MASK                  0x2000u\r\n#define RCM_PARAM_ESACKERR_SHIFT                 13u\r\n#define RCM_PARAM_ESACKERR_WIDTH                 1u\r\n#define RCM_PARAM_ESACKERR(x)                    (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ESACKERR_SHIFT))&RCM_PARAM_ESACKERR_MASK)\r\n#define RCM_PARAM_ETAMPER_MASK                   0x8000u\r\n#define RCM_PARAM_ETAMPER_SHIFT                  15u\r\n#define RCM_PARAM_ETAMPER_WIDTH                  1u\r\n#define RCM_PARAM_ETAMPER(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ETAMPER_SHIFT))&RCM_PARAM_ETAMPER_MASK)\r\n#define RCM_PARAM_ECORE1_MASK                    0x10000u\r\n#define RCM_PARAM_ECORE1_SHIFT                   16u\r\n#define RCM_PARAM_ECORE1_WIDTH                   1u\r\n#define RCM_PARAM_ECORE1(x)                      (((uint32_t)(((uint32_t)(x))<<RCM_PARAM_ECORE1_SHIFT))&RCM_PARAM_ECORE1_MASK)\r\n/* SRS Bit Fields */\r\n#define RCM_SRS_LVD_MASK                         0x2u\r\n#define RCM_SRS_LVD_SHIFT                        1u\r\n#define RCM_SRS_LVD_WIDTH                        1u\r\n#define RCM_SRS_LVD(x)                           (((uint32_t)(((uint32_t)(x))<<RCM_SRS_LVD_SHIFT))&RCM_SRS_LVD_MASK)\r\n#define RCM_SRS_LOC_MASK                         0x4u\r\n#define RCM_SRS_LOC_SHIFT                        2u\r\n#define RCM_SRS_LOC_WIDTH                        1u\r\n#define RCM_SRS_LOC(x)                           (((uint32_t)(((uint32_t)(x))<<RCM_SRS_LOC_SHIFT))&RCM_SRS_LOC_MASK)\r\n#define RCM_SRS_LOL_MASK                         0x8u\r\n#define RCM_SRS_LOL_SHIFT                        3u\r\n#define RCM_SRS_LOL_WIDTH                        1u\r\n#define RCM_SRS_LOL(x)                           (((uint32_t)(((uint32_t)(x))<<RCM_SRS_LOL_SHIFT))&RCM_SRS_LOL_MASK)\r\n#define RCM_SRS_WDOG_MASK                        0x20u\r\n#define RCM_SRS_WDOG_SHIFT                       5u\r\n#define RCM_SRS_WDOG_WIDTH                       1u\r\n#define RCM_SRS_WDOG(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SRS_WDOG_SHIFT))&RCM_SRS_WDOG_MASK)\r\n#define RCM_SRS_PIN_MASK                         0x40u\r\n#define RCM_SRS_PIN_SHIFT                        6u\r\n#define RCM_SRS_PIN_WIDTH                        1u\r\n#define RCM_SRS_PIN(x)                           (((uint32_t)(((uint32_t)(x))<<RCM_SRS_PIN_SHIFT))&RCM_SRS_PIN_MASK)\r\n#define RCM_SRS_POR_MASK                         0x80u\r\n#define RCM_SRS_POR_SHIFT                        7u\r\n#define RCM_SRS_POR_WIDTH                        1u\r\n#define RCM_SRS_POR(x)                           (((uint32_t)(((uint32_t)(x))<<RCM_SRS_POR_SHIFT))&RCM_SRS_POR_MASK)\r\n#define RCM_SRS_JTAG_MASK                        0x100u\r\n#define RCM_SRS_JTAG_SHIFT                       8u\r\n#define RCM_SRS_JTAG_WIDTH                       1u\r\n#define RCM_SRS_JTAG(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SRS_JTAG_SHIFT))&RCM_SRS_JTAG_MASK)\r\n#define RCM_SRS_LOCKUP_MASK                      0x200u\r\n#define RCM_SRS_LOCKUP_SHIFT                     9u\r\n#define RCM_SRS_LOCKUP_WIDTH                     1u\r\n#define RCM_SRS_LOCKUP(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_SRS_LOCKUP_SHIFT))&RCM_SRS_LOCKUP_MASK)\r\n#define RCM_SRS_SW_MASK                          0x400u\r\n#define RCM_SRS_SW_SHIFT                         10u\r\n#define RCM_SRS_SW_WIDTH                         1u\r\n#define RCM_SRS_SW(x)                            (((uint32_t)(((uint32_t)(x))<<RCM_SRS_SW_SHIFT))&RCM_SRS_SW_MASK)\r\n#define RCM_SRS_MDM_AP_MASK                      0x800u\r\n#define RCM_SRS_MDM_AP_SHIFT                     11u\r\n#define RCM_SRS_MDM_AP_WIDTH                     1u\r\n#define RCM_SRS_MDM_AP(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_SRS_MDM_AP_SHIFT))&RCM_SRS_MDM_AP_MASK)\r\n#define RCM_SRS_SACKERR_MASK                     0x2000u\r\n#define RCM_SRS_SACKERR_SHIFT                    13u\r\n#define RCM_SRS_SACKERR_WIDTH                    1u\r\n#define RCM_SRS_SACKERR(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_SRS_SACKERR_SHIFT))&RCM_SRS_SACKERR_MASK)\r\n/* RPC Bit Fields */\r\n#define RCM_RPC_RSTFLTSRW_MASK                   0x3u\r\n#define RCM_RPC_RSTFLTSRW_SHIFT                  0u\r\n#define RCM_RPC_RSTFLTSRW_WIDTH                  2u\r\n#define RCM_RPC_RSTFLTSRW(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_RPC_RSTFLTSRW_SHIFT))&RCM_RPC_RSTFLTSRW_MASK)\r\n#define RCM_RPC_RSTFLTSS_MASK                    0x4u\r\n#define RCM_RPC_RSTFLTSS_SHIFT                   2u\r\n#define RCM_RPC_RSTFLTSS_WIDTH                   1u\r\n#define RCM_RPC_RSTFLTSS(x)                      (((uint32_t)(((uint32_t)(x))<<RCM_RPC_RSTFLTSS_SHIFT))&RCM_RPC_RSTFLTSS_MASK)\r\n#define RCM_RPC_RSTFLTSEL_MASK                   0x1F00u\r\n#define RCM_RPC_RSTFLTSEL_SHIFT                  8u\r\n#define RCM_RPC_RSTFLTSEL_WIDTH                  5u\r\n#define RCM_RPC_RSTFLTSEL(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_RPC_RSTFLTSEL_SHIFT))&RCM_RPC_RSTFLTSEL_MASK)\r\n/* SSRS Bit Fields */\r\n#define RCM_SSRS_SLVD_MASK                       0x2u\r\n#define RCM_SSRS_SLVD_SHIFT                      1u\r\n#define RCM_SSRS_SLVD_WIDTH                      1u\r\n#define RCM_SSRS_SLVD(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SLVD_SHIFT))&RCM_SSRS_SLVD_MASK)\r\n#define RCM_SSRS_SLOC_MASK                       0x4u\r\n#define RCM_SSRS_SLOC_SHIFT                      2u\r\n#define RCM_SSRS_SLOC_WIDTH                      1u\r\n#define RCM_SSRS_SLOC(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SLOC_SHIFT))&RCM_SSRS_SLOC_MASK)\r\n#define RCM_SSRS_SLOL_MASK                       0x8u\r\n#define RCM_SSRS_SLOL_SHIFT                      3u\r\n#define RCM_SSRS_SLOL_WIDTH                      1u\r\n#define RCM_SSRS_SLOL(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SLOL_SHIFT))&RCM_SSRS_SLOL_MASK)\r\n#define RCM_SSRS_SWDOG_MASK                      0x20u\r\n#define RCM_SSRS_SWDOG_SHIFT                     5u\r\n#define RCM_SSRS_SWDOG_WIDTH                     1u\r\n#define RCM_SSRS_SWDOG(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SWDOG_SHIFT))&RCM_SSRS_SWDOG_MASK)\r\n#define RCM_SSRS_SPIN_MASK                       0x40u\r\n#define RCM_SSRS_SPIN_SHIFT                      6u\r\n#define RCM_SSRS_SPIN_WIDTH                      1u\r\n#define RCM_SSRS_SPIN(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SPIN_SHIFT))&RCM_SSRS_SPIN_MASK)\r\n#define RCM_SSRS_SPOR_MASK                       0x80u\r\n#define RCM_SSRS_SPOR_SHIFT                      7u\r\n#define RCM_SSRS_SPOR_WIDTH                      1u\r\n#define RCM_SSRS_SPOR(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SPOR_SHIFT))&RCM_SSRS_SPOR_MASK)\r\n#define RCM_SSRS_SJTAG_MASK                      0x100u\r\n#define RCM_SSRS_SJTAG_SHIFT                     8u\r\n#define RCM_SSRS_SJTAG_WIDTH                     1u\r\n#define RCM_SSRS_SJTAG(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SJTAG_SHIFT))&RCM_SSRS_SJTAG_MASK)\r\n#define RCM_SSRS_SLOCKUP_MASK                    0x200u\r\n#define RCM_SSRS_SLOCKUP_SHIFT                   9u\r\n#define RCM_SSRS_SLOCKUP_WIDTH                   1u\r\n#define RCM_SSRS_SLOCKUP(x)                      (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SLOCKUP_SHIFT))&RCM_SSRS_SLOCKUP_MASK)\r\n#define RCM_SSRS_SSW_MASK                        0x400u\r\n#define RCM_SSRS_SSW_SHIFT                       10u\r\n#define RCM_SSRS_SSW_WIDTH                       1u\r\n#define RCM_SSRS_SSW(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SSW_SHIFT))&RCM_SSRS_SSW_MASK)\r\n#define RCM_SSRS_SMDM_AP_MASK                    0x800u\r\n#define RCM_SSRS_SMDM_AP_SHIFT                   11u\r\n#define RCM_SSRS_SMDM_AP_WIDTH                   1u\r\n#define RCM_SSRS_SMDM_AP(x)                      (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SMDM_AP_SHIFT))&RCM_SSRS_SMDM_AP_MASK)\r\n#define RCM_SSRS_SSACKERR_MASK                   0x2000u\r\n#define RCM_SSRS_SSACKERR_SHIFT                  13u\r\n#define RCM_SSRS_SSACKERR_WIDTH                  1u\r\n#define RCM_SSRS_SSACKERR(x)                     (((uint32_t)(((uint32_t)(x))<<RCM_SSRS_SSACKERR_SHIFT))&RCM_SSRS_SSACKERR_MASK)\r\n/* SRIE Bit Fields */\r\n#define RCM_SRIE_DELAY_MASK                      0x3u\r\n#define RCM_SRIE_DELAY_SHIFT                     0u\r\n#define RCM_SRIE_DELAY_WIDTH                     2u\r\n#define RCM_SRIE_DELAY(x)                        (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_DELAY_SHIFT))&RCM_SRIE_DELAY_MASK)\r\n#define RCM_SRIE_LOC_MASK                        0x4u\r\n#define RCM_SRIE_LOC_SHIFT                       2u\r\n#define RCM_SRIE_LOC_WIDTH                       1u\r\n#define RCM_SRIE_LOC(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_LOC_SHIFT))&RCM_SRIE_LOC_MASK)\r\n#define RCM_SRIE_LOL_MASK                        0x8u\r\n#define RCM_SRIE_LOL_SHIFT                       3u\r\n#define RCM_SRIE_LOL_WIDTH                       1u\r\n#define RCM_SRIE_LOL(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_LOL_SHIFT))&RCM_SRIE_LOL_MASK)\r\n#define RCM_SRIE_WDOG_MASK                       0x20u\r\n#define RCM_SRIE_WDOG_SHIFT                      5u\r\n#define RCM_SRIE_WDOG_WIDTH                      1u\r\n#define RCM_SRIE_WDOG(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_WDOG_SHIFT))&RCM_SRIE_WDOG_MASK)\r\n#define RCM_SRIE_PIN_MASK                        0x40u\r\n#define RCM_SRIE_PIN_SHIFT                       6u\r\n#define RCM_SRIE_PIN_WIDTH                       1u\r\n#define RCM_SRIE_PIN(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_PIN_SHIFT))&RCM_SRIE_PIN_MASK)\r\n#define RCM_SRIE_GIE_MASK                        0x80u\r\n#define RCM_SRIE_GIE_SHIFT                       7u\r\n#define RCM_SRIE_GIE_WIDTH                       1u\r\n#define RCM_SRIE_GIE(x)                          (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_GIE_SHIFT))&RCM_SRIE_GIE_MASK)\r\n#define RCM_SRIE_JTAG_MASK                       0x100u\r\n#define RCM_SRIE_JTAG_SHIFT                      8u\r\n#define RCM_SRIE_JTAG_WIDTH                      1u\r\n#define RCM_SRIE_JTAG(x)                         (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_JTAG_SHIFT))&RCM_SRIE_JTAG_MASK)\r\n#define RCM_SRIE_LOCKUP_MASK                     0x200u\r\n#define RCM_SRIE_LOCKUP_SHIFT                    9u\r\n#define RCM_SRIE_LOCKUP_WIDTH                    1u\r\n#define RCM_SRIE_LOCKUP(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_LOCKUP_SHIFT))&RCM_SRIE_LOCKUP_MASK)\r\n#define RCM_SRIE_SW_MASK                         0x400u\r\n#define RCM_SRIE_SW_SHIFT                        10u\r\n#define RCM_SRIE_SW_WIDTH                        1u\r\n#define RCM_SRIE_SW(x)                           (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_SW_SHIFT))&RCM_SRIE_SW_MASK)\r\n#define RCM_SRIE_MDM_AP_MASK                     0x800u\r\n#define RCM_SRIE_MDM_AP_SHIFT                    11u\r\n#define RCM_SRIE_MDM_AP_WIDTH                    1u\r\n#define RCM_SRIE_MDM_AP(x)                       (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_MDM_AP_SHIFT))&RCM_SRIE_MDM_AP_MASK)\r\n#define RCM_SRIE_SACKERR_MASK                    0x2000u\r\n#define RCM_SRIE_SACKERR_SHIFT                   13u\r\n#define RCM_SRIE_SACKERR_WIDTH                   1u\r\n#define RCM_SRIE_SACKERR(x)                      (((uint32_t)(((uint32_t)(x))<<RCM_SRIE_SACKERR_SHIFT))&RCM_SRIE_SACKERR_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group RCM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group RCM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- RTC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup RTC_Peripheral_Access_Layer RTC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** RTC - Size of Registers Arrays */\r\n\r\n/** RTC - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t TSR;                               /**< RTC Time Seconds Register, offset: 0x0 */\r\n  __IO uint32_t TPR;                               /**< RTC Time Prescaler Register, offset: 0x4 */\r\n  __IO uint32_t TAR;                               /**< RTC Time Alarm Register, offset: 0x8 */\r\n  __IO uint32_t TCR;                               /**< RTC Time Compensation Register, offset: 0xC */\r\n  __IO uint32_t CR;                                /**< RTC Control Register, offset: 0x10 */\r\n  __IO uint32_t SR;                                /**< RTC Status Register, offset: 0x14 */\r\n  __IO uint32_t LR;                                /**< RTC Lock Register, offset: 0x18 */\r\n  __IO uint32_t IER;                               /**< RTC Interrupt Enable Register, offset: 0x1C */\r\n} RTC_Type, *RTC_MemMapPtr;\r\n\r\n /** Number of instances of the RTC module. */\r\n#define RTC_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* RTC - Peripheral instance base addresses */\r\n/** Peripheral RTC base address */\r\n#define RTC_BASE                                 (0x4003D000u)\r\n/** Peripheral RTC base pointer */\r\n#define RTC                                      ((RTC_Type *)RTC_BASE)\r\n/** Array initializer of RTC peripheral base addresses */\r\n#define RTC_BASE_ADDRS                           { RTC_BASE }\r\n/** Array initializer of RTC peripheral base pointers */\r\n#define RTC_BASE_PTRS                            { RTC }\r\n /** Number of interrupt vector arrays for the RTC module. */\r\n#define RTC_IRQS_ARR_COUNT                       (2u)\r\n /** Number of interrupt channels for the RTC module. */\r\n#define RTC_IRQS_CH_COUNT                        (1u)\r\n /** Number of interrupt channels for the SECONDS type of RTC module. */\r\n#define RTC_SECONDS_IRQS_CH_COUNT                (1u)\r\n/** Interrupt vectors for the RTC peripheral type */\r\n#define RTC_IRQS                                 { RTC_IRQn }\r\n#define RTC_SECONDS_IRQS                         { RTC_Seconds_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- RTC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup RTC_Register_Masks RTC Register Masks\r\n * @{\r\n */\r\n\r\n/* TSR Bit Fields */\r\n#define RTC_TSR_TSR_MASK                         0xFFFFFFFFu\r\n#define RTC_TSR_TSR_SHIFT                        0u\r\n#define RTC_TSR_TSR_WIDTH                        32u\r\n#define RTC_TSR_TSR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TSR_TSR_SHIFT))&RTC_TSR_TSR_MASK)\r\n/* TPR Bit Fields */\r\n#define RTC_TPR_TPR_MASK                         0xFFFFu\r\n#define RTC_TPR_TPR_SHIFT                        0u\r\n#define RTC_TPR_TPR_WIDTH                        16u\r\n#define RTC_TPR_TPR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TPR_TPR_SHIFT))&RTC_TPR_TPR_MASK)\r\n/* TAR Bit Fields */\r\n#define RTC_TAR_TAR_MASK                         0xFFFFFFFFu\r\n#define RTC_TAR_TAR_SHIFT                        0u\r\n#define RTC_TAR_TAR_WIDTH                        32u\r\n#define RTC_TAR_TAR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TAR_TAR_SHIFT))&RTC_TAR_TAR_MASK)\r\n/* TCR Bit Fields */\r\n#define RTC_TCR_TCR_MASK                         0xFFu\r\n#define RTC_TCR_TCR_SHIFT                        0u\r\n#define RTC_TCR_TCR_WIDTH                        8u\r\n#define RTC_TCR_TCR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_TCR_SHIFT))&RTC_TCR_TCR_MASK)\r\n#define RTC_TCR_CIR_MASK                         0xFF00u\r\n#define RTC_TCR_CIR_SHIFT                        8u\r\n#define RTC_TCR_CIR_WIDTH                        8u\r\n#define RTC_TCR_CIR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_CIR_SHIFT))&RTC_TCR_CIR_MASK)\r\n#define RTC_TCR_TCV_MASK                         0xFF0000u\r\n#define RTC_TCR_TCV_SHIFT                        16u\r\n#define RTC_TCR_TCV_WIDTH                        8u\r\n#define RTC_TCR_TCV(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_TCV_SHIFT))&RTC_TCR_TCV_MASK)\r\n#define RTC_TCR_CIC_MASK                         0xFF000000u\r\n#define RTC_TCR_CIC_SHIFT                        24u\r\n#define RTC_TCR_CIC_WIDTH                        8u\r\n#define RTC_TCR_CIC(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_CIC_SHIFT))&RTC_TCR_CIC_MASK)\r\n/* CR Bit Fields */\r\n#define RTC_CR_SWR_MASK                          0x1u\r\n#define RTC_CR_SWR_SHIFT                         0u\r\n#define RTC_CR_SWR_WIDTH                         1u\r\n#define RTC_CR_SWR(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_CR_SWR_SHIFT))&RTC_CR_SWR_MASK)\r\n#define RTC_CR_SUP_MASK                          0x4u\r\n#define RTC_CR_SUP_SHIFT                         2u\r\n#define RTC_CR_SUP_WIDTH                         1u\r\n#define RTC_CR_SUP(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_CR_SUP_SHIFT))&RTC_CR_SUP_MASK)\r\n#define RTC_CR_UM_MASK                           0x8u\r\n#define RTC_CR_UM_SHIFT                          3u\r\n#define RTC_CR_UM_WIDTH                          1u\r\n#define RTC_CR_UM(x)                             (((uint32_t)(((uint32_t)(x))<<RTC_CR_UM_SHIFT))&RTC_CR_UM_MASK)\r\n#define RTC_CR_CPS_MASK                          0x20u\r\n#define RTC_CR_CPS_SHIFT                         5u\r\n#define RTC_CR_CPS_WIDTH                         1u\r\n#define RTC_CR_CPS(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_CR_CPS_SHIFT))&RTC_CR_CPS_MASK)\r\n#define RTC_CR_LPOS_MASK                         0x80u\r\n#define RTC_CR_LPOS_SHIFT                        7u\r\n#define RTC_CR_LPOS_WIDTH                        1u\r\n#define RTC_CR_LPOS(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_CR_LPOS_SHIFT))&RTC_CR_LPOS_MASK)\r\n#define RTC_CR_CLKO_MASK                         0x200u\r\n#define RTC_CR_CLKO_SHIFT                        9u\r\n#define RTC_CR_CLKO_WIDTH                        1u\r\n#define RTC_CR_CLKO(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_CR_CLKO_SHIFT))&RTC_CR_CLKO_MASK)\r\n#define RTC_CR_CPE_MASK                          0x1000000u\r\n#define RTC_CR_CPE_SHIFT                         24u\r\n#define RTC_CR_CPE_WIDTH                         1u\r\n#define RTC_CR_CPE(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_CR_CPE_SHIFT))&RTC_CR_CPE_MASK)\r\n/* SR Bit Fields */\r\n#define RTC_SR_TIF_MASK                          0x1u\r\n#define RTC_SR_TIF_SHIFT                         0u\r\n#define RTC_SR_TIF_WIDTH                         1u\r\n#define RTC_SR_TIF(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_SR_TIF_SHIFT))&RTC_SR_TIF_MASK)\r\n#define RTC_SR_TOF_MASK                          0x2u\r\n#define RTC_SR_TOF_SHIFT                         1u\r\n#define RTC_SR_TOF_WIDTH                         1u\r\n#define RTC_SR_TOF(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_SR_TOF_SHIFT))&RTC_SR_TOF_MASK)\r\n#define RTC_SR_TAF_MASK                          0x4u\r\n#define RTC_SR_TAF_SHIFT                         2u\r\n#define RTC_SR_TAF_WIDTH                         1u\r\n#define RTC_SR_TAF(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_SR_TAF_SHIFT))&RTC_SR_TAF_MASK)\r\n#define RTC_SR_TCE_MASK                          0x10u\r\n#define RTC_SR_TCE_SHIFT                         4u\r\n#define RTC_SR_TCE_WIDTH                         1u\r\n#define RTC_SR_TCE(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_SR_TCE_SHIFT))&RTC_SR_TCE_MASK)\r\n/* LR Bit Fields */\r\n#define RTC_LR_TCL_MASK                          0x8u\r\n#define RTC_LR_TCL_SHIFT                         3u\r\n#define RTC_LR_TCL_WIDTH                         1u\r\n#define RTC_LR_TCL(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_LR_TCL_SHIFT))&RTC_LR_TCL_MASK)\r\n#define RTC_LR_CRL_MASK                          0x10u\r\n#define RTC_LR_CRL_SHIFT                         4u\r\n#define RTC_LR_CRL_WIDTH                         1u\r\n#define RTC_LR_CRL(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_LR_CRL_SHIFT))&RTC_LR_CRL_MASK)\r\n#define RTC_LR_SRL_MASK                          0x20u\r\n#define RTC_LR_SRL_SHIFT                         5u\r\n#define RTC_LR_SRL_WIDTH                         1u\r\n#define RTC_LR_SRL(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_LR_SRL_SHIFT))&RTC_LR_SRL_MASK)\r\n#define RTC_LR_LRL_MASK                          0x40u\r\n#define RTC_LR_LRL_SHIFT                         6u\r\n#define RTC_LR_LRL_WIDTH                         1u\r\n#define RTC_LR_LRL(x)                            (((uint32_t)(((uint32_t)(x))<<RTC_LR_LRL_SHIFT))&RTC_LR_LRL_MASK)\r\n/* IER Bit Fields */\r\n#define RTC_IER_TIIE_MASK                        0x1u\r\n#define RTC_IER_TIIE_SHIFT                       0u\r\n#define RTC_IER_TIIE_WIDTH                       1u\r\n#define RTC_IER_TIIE(x)                          (((uint32_t)(((uint32_t)(x))<<RTC_IER_TIIE_SHIFT))&RTC_IER_TIIE_MASK)\r\n#define RTC_IER_TOIE_MASK                        0x2u\r\n#define RTC_IER_TOIE_SHIFT                       1u\r\n#define RTC_IER_TOIE_WIDTH                       1u\r\n#define RTC_IER_TOIE(x)                          (((uint32_t)(((uint32_t)(x))<<RTC_IER_TOIE_SHIFT))&RTC_IER_TOIE_MASK)\r\n#define RTC_IER_TAIE_MASK                        0x4u\r\n#define RTC_IER_TAIE_SHIFT                       2u\r\n#define RTC_IER_TAIE_WIDTH                       1u\r\n#define RTC_IER_TAIE(x)                          (((uint32_t)(((uint32_t)(x))<<RTC_IER_TAIE_SHIFT))&RTC_IER_TAIE_MASK)\r\n#define RTC_IER_TSIE_MASK                        0x10u\r\n#define RTC_IER_TSIE_SHIFT                       4u\r\n#define RTC_IER_TSIE_WIDTH                       1u\r\n#define RTC_IER_TSIE(x)                          (((uint32_t)(((uint32_t)(x))<<RTC_IER_TSIE_SHIFT))&RTC_IER_TSIE_MASK)\r\n#define RTC_IER_TSIC_MASK                        0x70000u\r\n#define RTC_IER_TSIC_SHIFT                       16u\r\n#define RTC_IER_TSIC_WIDTH                       3u\r\n#define RTC_IER_TSIC(x)                          (((uint32_t)(((uint32_t)(x))<<RTC_IER_TSIC_SHIFT))&RTC_IER_TSIC_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group RTC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group RTC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- S32_NVIC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup S32_NVIC_Peripheral_Access_Layer S32_NVIC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** S32_NVIC - Size of Registers Arrays */\r\n#define S32_NVIC_ISER_COUNT                      8u\r\n#define S32_NVIC_ICER_COUNT                      8u\r\n#define S32_NVIC_ISPR_COUNT                      8u\r\n#define S32_NVIC_ICPR_COUNT                      8u\r\n#define S32_NVIC_IABR_COUNT                      8u\r\n#define S32_NVIC_IP_COUNT                        240u\r\n\r\n/** S32_NVIC - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t ISER[S32_NVIC_ISER_COUNT];         /**< Interrupt Set Enable Register n, array offset: 0x0, array step: 0x4 */\r\n       uint8_t RESERVED_0[96];\r\n  __IO uint32_t ICER[S32_NVIC_ICER_COUNT];         /**< Interrupt Clear Enable Register n, array offset: 0x80, array step: 0x4 */\r\n       uint8_t RESERVED_1[96];\r\n  __IO uint32_t ISPR[S32_NVIC_ISPR_COUNT];         /**< Interrupt Set Pending Register n, array offset: 0x100, array step: 0x4 */\r\n       uint8_t RESERVED_2[96];\r\n  __IO uint32_t ICPR[S32_NVIC_ICPR_COUNT];         /**< Interrupt Clear Pending Register n, array offset: 0x180, array step: 0x4 */\r\n       uint8_t RESERVED_3[96];\r\n  __IO uint32_t IABR[S32_NVIC_IABR_COUNT];         /**< Interrupt Active bit Register n, array offset: 0x200, array step: 0x4 */\r\n       uint8_t RESERVED_4[224];\r\n  __IO uint8_t IP[S32_NVIC_IP_COUNT];              /**< Interrupt Priority Register n, array offset: 0x300, array step: 0x1 */\r\n       uint8_t RESERVED_5[2576];\r\n  __O  uint32_t STIR;                              /**< Software Trigger Interrupt Register, offset: 0xE00 */\r\n} S32_NVIC_Type, *S32_NVIC_MemMapPtr;\r\n\r\n /** Number of instances of the S32_NVIC module. */\r\n#define S32_NVIC_INSTANCE_COUNT                  (1u)\r\n\r\n\r\n/* S32_NVIC - Peripheral instance base addresses */\r\n/** Peripheral S32_NVIC base address */\r\n#define S32_NVIC_BASE                            (0xE000E100u)\r\n/** Peripheral S32_NVIC base pointer */\r\n#define S32_NVIC                                 ((S32_NVIC_Type *)S32_NVIC_BASE)\r\n/** Array initializer of S32_NVIC peripheral base addresses */\r\n#define S32_NVIC_BASE_ADDRS                      { S32_NVIC_BASE }\r\n/** Array initializer of S32_NVIC peripheral base pointers */\r\n#define S32_NVIC_BASE_PTRS                       { S32_NVIC }\r\n /** Number of interrupt vector arrays for the S32_NVIC module. */\r\n#define S32_NVIC_IRQS_ARR_COUNT                  (1u)\r\n /** Number of interrupt channels for the S32_NVIC module. */\r\n#define S32_NVIC_IRQS_CH_COUNT                   (1u)\r\n/** Interrupt vectors for the S32_NVIC peripheral type */\r\n#define S32_NVIC_IRQS                            { SWI_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- S32_NVIC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup S32_NVIC_Register_Masks S32_NVIC Register Masks\r\n * @{\r\n */\r\n\r\n/* ISER Bit Fields */\r\n#define S32_NVIC_ISER_SETENA_MASK                0xFFFFFFFFu\r\n#define S32_NVIC_ISER_SETENA_SHIFT               0u\r\n#define S32_NVIC_ISER_SETENA_WIDTH               32u\r\n#define S32_NVIC_ISER_SETENA(x)                  (((uint32_t)(((uint32_t)(x))<<S32_NVIC_ISER_SETENA_SHIFT))&S32_NVIC_ISER_SETENA_MASK)\r\n/* ICER Bit Fields */\r\n#define S32_NVIC_ICER_CLRENA_MASK                0xFFFFFFFFu\r\n#define S32_NVIC_ICER_CLRENA_SHIFT               0u\r\n#define S32_NVIC_ICER_CLRENA_WIDTH               32u\r\n#define S32_NVIC_ICER_CLRENA(x)                  (((uint32_t)(((uint32_t)(x))<<S32_NVIC_ICER_CLRENA_SHIFT))&S32_NVIC_ICER_CLRENA_MASK)\r\n/* ISPR Bit Fields */\r\n#define S32_NVIC_ISPR_SETPEND_MASK               0xFFFFFFFFu\r\n#define S32_NVIC_ISPR_SETPEND_SHIFT              0u\r\n#define S32_NVIC_ISPR_SETPEND_WIDTH              32u\r\n#define S32_NVIC_ISPR_SETPEND(x)                 (((uint32_t)(((uint32_t)(x))<<S32_NVIC_ISPR_SETPEND_SHIFT))&S32_NVIC_ISPR_SETPEND_MASK)\r\n/* ICPR Bit Fields */\r\n#define S32_NVIC_ICPR_CLRPEND_MASK               0xFFFFFFFFu\r\n#define S32_NVIC_ICPR_CLRPEND_SHIFT              0u\r\n#define S32_NVIC_ICPR_CLRPEND_WIDTH              32u\r\n#define S32_NVIC_ICPR_CLRPEND(x)                 (((uint32_t)(((uint32_t)(x))<<S32_NVIC_ICPR_CLRPEND_SHIFT))&S32_NVIC_ICPR_CLRPEND_MASK)\r\n/* IABR Bit Fields */\r\n#define S32_NVIC_IABR_ACTIVE_MASK                0xFFFFFFFFu\r\n#define S32_NVIC_IABR_ACTIVE_SHIFT               0u\r\n#define S32_NVIC_IABR_ACTIVE_WIDTH               32u\r\n#define S32_NVIC_IABR_ACTIVE(x)                  (((uint32_t)(((uint32_t)(x))<<S32_NVIC_IABR_ACTIVE_SHIFT))&S32_NVIC_IABR_ACTIVE_MASK)\r\n/* IP Bit Fields */\r\n#define S32_NVIC_IP_PRI0_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI0_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI0_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI0(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI0_SHIFT))&S32_NVIC_IP_PRI0_MASK)\r\n#define S32_NVIC_IP_PRI1_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI1_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI1_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI1(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI1_SHIFT))&S32_NVIC_IP_PRI1_MASK)\r\n#define S32_NVIC_IP_PRI2_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI2_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI2_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI2(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI2_SHIFT))&S32_NVIC_IP_PRI2_MASK)\r\n#define S32_NVIC_IP_PRI3_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI3_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI3_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI3(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI3_SHIFT))&S32_NVIC_IP_PRI3_MASK)\r\n#define S32_NVIC_IP_PRI4_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI4_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI4_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI4(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI4_SHIFT))&S32_NVIC_IP_PRI4_MASK)\r\n#define S32_NVIC_IP_PRI5_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI5_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI5_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI5(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI5_SHIFT))&S32_NVIC_IP_PRI5_MASK)\r\n#define S32_NVIC_IP_PRI6_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI6_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI6_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI6(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI6_SHIFT))&S32_NVIC_IP_PRI6_MASK)\r\n#define S32_NVIC_IP_PRI7_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI7_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI7_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI7(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI7_SHIFT))&S32_NVIC_IP_PRI7_MASK)\r\n#define S32_NVIC_IP_PRI8_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI8_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI8_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI8(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI8_SHIFT))&S32_NVIC_IP_PRI8_MASK)\r\n#define S32_NVIC_IP_PRI9_MASK                    0xFFu\r\n#define S32_NVIC_IP_PRI9_SHIFT                   0u\r\n#define S32_NVIC_IP_PRI9_WIDTH                   8u\r\n#define S32_NVIC_IP_PRI9(x)                      (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI9_SHIFT))&S32_NVIC_IP_PRI9_MASK)\r\n#define S32_NVIC_IP_PRI10_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI10_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI10_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI10(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI10_SHIFT))&S32_NVIC_IP_PRI10_MASK)\r\n#define S32_NVIC_IP_PRI11_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI11_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI11_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI11(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI11_SHIFT))&S32_NVIC_IP_PRI11_MASK)\r\n#define S32_NVIC_IP_PRI12_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI12_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI12_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI12(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI12_SHIFT))&S32_NVIC_IP_PRI12_MASK)\r\n#define S32_NVIC_IP_PRI13_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI13_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI13_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI13(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI13_SHIFT))&S32_NVIC_IP_PRI13_MASK)\r\n#define S32_NVIC_IP_PRI14_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI14_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI14_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI14(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI14_SHIFT))&S32_NVIC_IP_PRI14_MASK)\r\n#define S32_NVIC_IP_PRI15_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI15_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI15_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI15(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI15_SHIFT))&S32_NVIC_IP_PRI15_MASK)\r\n#define S32_NVIC_IP_PRI16_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI16_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI16_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI16(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI16_SHIFT))&S32_NVIC_IP_PRI16_MASK)\r\n#define S32_NVIC_IP_PRI17_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI17_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI17_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI17(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI17_SHIFT))&S32_NVIC_IP_PRI17_MASK)\r\n#define S32_NVIC_IP_PRI18_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI18_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI18_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI18(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI18_SHIFT))&S32_NVIC_IP_PRI18_MASK)\r\n#define S32_NVIC_IP_PRI19_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI19_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI19_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI19(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI19_SHIFT))&S32_NVIC_IP_PRI19_MASK)\r\n#define S32_NVIC_IP_PRI20_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI20_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI20_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI20(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI20_SHIFT))&S32_NVIC_IP_PRI20_MASK)\r\n#define S32_NVIC_IP_PRI21_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI21_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI21_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI21(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI21_SHIFT))&S32_NVIC_IP_PRI21_MASK)\r\n#define S32_NVIC_IP_PRI22_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI22_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI22_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI22(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI22_SHIFT))&S32_NVIC_IP_PRI22_MASK)\r\n#define S32_NVIC_IP_PRI23_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI23_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI23_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI23(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI23_SHIFT))&S32_NVIC_IP_PRI23_MASK)\r\n#define S32_NVIC_IP_PRI24_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI24_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI24_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI24(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI24_SHIFT))&S32_NVIC_IP_PRI24_MASK)\r\n#define S32_NVIC_IP_PRI25_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI25_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI25_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI25(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI25_SHIFT))&S32_NVIC_IP_PRI25_MASK)\r\n#define S32_NVIC_IP_PRI26_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI26_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI26_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI26(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI26_SHIFT))&S32_NVIC_IP_PRI26_MASK)\r\n#define S32_NVIC_IP_PRI27_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI27_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI27_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI27(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI27_SHIFT))&S32_NVIC_IP_PRI27_MASK)\r\n#define S32_NVIC_IP_PRI28_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI28_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI28_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI28(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI28_SHIFT))&S32_NVIC_IP_PRI28_MASK)\r\n#define S32_NVIC_IP_PRI29_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI29_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI29_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI29(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI29_SHIFT))&S32_NVIC_IP_PRI29_MASK)\r\n#define S32_NVIC_IP_PRI30_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI30_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI30_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI30(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI30_SHIFT))&S32_NVIC_IP_PRI30_MASK)\r\n#define S32_NVIC_IP_PRI31_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI31_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI31_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI31(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI31_SHIFT))&S32_NVIC_IP_PRI31_MASK)\r\n#define S32_NVIC_IP_PRI32_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI32_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI32_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI32(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI32_SHIFT))&S32_NVIC_IP_PRI32_MASK)\r\n#define S32_NVIC_IP_PRI33_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI33_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI33_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI33(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI33_SHIFT))&S32_NVIC_IP_PRI33_MASK)\r\n#define S32_NVIC_IP_PRI34_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI34_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI34_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI34(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI34_SHIFT))&S32_NVIC_IP_PRI34_MASK)\r\n#define S32_NVIC_IP_PRI35_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI35_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI35_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI35(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI35_SHIFT))&S32_NVIC_IP_PRI35_MASK)\r\n#define S32_NVIC_IP_PRI36_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI36_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI36_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI36(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI36_SHIFT))&S32_NVIC_IP_PRI36_MASK)\r\n#define S32_NVIC_IP_PRI37_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI37_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI37_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI37(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI37_SHIFT))&S32_NVIC_IP_PRI37_MASK)\r\n#define S32_NVIC_IP_PRI38_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI38_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI38_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI38(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI38_SHIFT))&S32_NVIC_IP_PRI38_MASK)\r\n#define S32_NVIC_IP_PRI39_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI39_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI39_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI39(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI39_SHIFT))&S32_NVIC_IP_PRI39_MASK)\r\n#define S32_NVIC_IP_PRI40_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI40_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI40_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI40(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI40_SHIFT))&S32_NVIC_IP_PRI40_MASK)\r\n#define S32_NVIC_IP_PRI41_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI41_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI41_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI41(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI41_SHIFT))&S32_NVIC_IP_PRI41_MASK)\r\n#define S32_NVIC_IP_PRI42_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI42_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI42_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI42(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI42_SHIFT))&S32_NVIC_IP_PRI42_MASK)\r\n#define S32_NVIC_IP_PRI43_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI43_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI43_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI43(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI43_SHIFT))&S32_NVIC_IP_PRI43_MASK)\r\n#define S32_NVIC_IP_PRI44_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI44_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI44_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI44(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI44_SHIFT))&S32_NVIC_IP_PRI44_MASK)\r\n#define S32_NVIC_IP_PRI45_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI45_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI45_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI45(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI45_SHIFT))&S32_NVIC_IP_PRI45_MASK)\r\n#define S32_NVIC_IP_PRI46_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI46_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI46_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI46(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI46_SHIFT))&S32_NVIC_IP_PRI46_MASK)\r\n#define S32_NVIC_IP_PRI47_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI47_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI47_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI47(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI47_SHIFT))&S32_NVIC_IP_PRI47_MASK)\r\n#define S32_NVIC_IP_PRI48_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI48_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI48_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI48(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI48_SHIFT))&S32_NVIC_IP_PRI48_MASK)\r\n#define S32_NVIC_IP_PRI49_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI49_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI49_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI49(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI49_SHIFT))&S32_NVIC_IP_PRI49_MASK)\r\n#define S32_NVIC_IP_PRI50_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI50_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI50_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI50(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI50_SHIFT))&S32_NVIC_IP_PRI50_MASK)\r\n#define S32_NVIC_IP_PRI51_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI51_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI51_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI51(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI51_SHIFT))&S32_NVIC_IP_PRI51_MASK)\r\n#define S32_NVIC_IP_PRI52_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI52_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI52_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI52(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI52_SHIFT))&S32_NVIC_IP_PRI52_MASK)\r\n#define S32_NVIC_IP_PRI53_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI53_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI53_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI53(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI53_SHIFT))&S32_NVIC_IP_PRI53_MASK)\r\n#define S32_NVIC_IP_PRI54_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI54_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI54_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI54(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI54_SHIFT))&S32_NVIC_IP_PRI54_MASK)\r\n#define S32_NVIC_IP_PRI55_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI55_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI55_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI55(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI55_SHIFT))&S32_NVIC_IP_PRI55_MASK)\r\n#define S32_NVIC_IP_PRI56_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI56_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI56_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI56(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI56_SHIFT))&S32_NVIC_IP_PRI56_MASK)\r\n#define S32_NVIC_IP_PRI57_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI57_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI57_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI57(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI57_SHIFT))&S32_NVIC_IP_PRI57_MASK)\r\n#define S32_NVIC_IP_PRI58_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI58_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI58_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI58(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI58_SHIFT))&S32_NVIC_IP_PRI58_MASK)\r\n#define S32_NVIC_IP_PRI59_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI59_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI59_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI59(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI59_SHIFT))&S32_NVIC_IP_PRI59_MASK)\r\n#define S32_NVIC_IP_PRI60_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI60_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI60_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI60(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI60_SHIFT))&S32_NVIC_IP_PRI60_MASK)\r\n#define S32_NVIC_IP_PRI61_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI61_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI61_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI61(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI61_SHIFT))&S32_NVIC_IP_PRI61_MASK)\r\n#define S32_NVIC_IP_PRI62_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI62_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI62_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI62(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI62_SHIFT))&S32_NVIC_IP_PRI62_MASK)\r\n#define S32_NVIC_IP_PRI63_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI63_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI63_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI63(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI63_SHIFT))&S32_NVIC_IP_PRI63_MASK)\r\n#define S32_NVIC_IP_PRI64_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI64_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI64_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI64(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI64_SHIFT))&S32_NVIC_IP_PRI64_MASK)\r\n#define S32_NVIC_IP_PRI65_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI65_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI65_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI65(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI65_SHIFT))&S32_NVIC_IP_PRI65_MASK)\r\n#define S32_NVIC_IP_PRI66_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI66_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI66_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI66(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI66_SHIFT))&S32_NVIC_IP_PRI66_MASK)\r\n#define S32_NVIC_IP_PRI67_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI67_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI67_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI67(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI67_SHIFT))&S32_NVIC_IP_PRI67_MASK)\r\n#define S32_NVIC_IP_PRI68_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI68_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI68_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI68(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI68_SHIFT))&S32_NVIC_IP_PRI68_MASK)\r\n#define S32_NVIC_IP_PRI69_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI69_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI69_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI69(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI69_SHIFT))&S32_NVIC_IP_PRI69_MASK)\r\n#define S32_NVIC_IP_PRI70_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI70_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI70_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI70(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI70_SHIFT))&S32_NVIC_IP_PRI70_MASK)\r\n#define S32_NVIC_IP_PRI71_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI71_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI71_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI71(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI71_SHIFT))&S32_NVIC_IP_PRI71_MASK)\r\n#define S32_NVIC_IP_PRI72_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI72_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI72_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI72(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI72_SHIFT))&S32_NVIC_IP_PRI72_MASK)\r\n#define S32_NVIC_IP_PRI73_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI73_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI73_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI73(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI73_SHIFT))&S32_NVIC_IP_PRI73_MASK)\r\n#define S32_NVIC_IP_PRI74_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI74_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI74_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI74(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI74_SHIFT))&S32_NVIC_IP_PRI74_MASK)\r\n#define S32_NVIC_IP_PRI75_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI75_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI75_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI75(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI75_SHIFT))&S32_NVIC_IP_PRI75_MASK)\r\n#define S32_NVIC_IP_PRI76_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI76_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI76_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI76(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI76_SHIFT))&S32_NVIC_IP_PRI76_MASK)\r\n#define S32_NVIC_IP_PRI77_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI77_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI77_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI77(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI77_SHIFT))&S32_NVIC_IP_PRI77_MASK)\r\n#define S32_NVIC_IP_PRI78_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI78_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI78_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI78(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI78_SHIFT))&S32_NVIC_IP_PRI78_MASK)\r\n#define S32_NVIC_IP_PRI79_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI79_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI79_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI79(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI79_SHIFT))&S32_NVIC_IP_PRI79_MASK)\r\n#define S32_NVIC_IP_PRI80_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI80_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI80_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI80(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI80_SHIFT))&S32_NVIC_IP_PRI80_MASK)\r\n#define S32_NVIC_IP_PRI81_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI81_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI81_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI81(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI81_SHIFT))&S32_NVIC_IP_PRI81_MASK)\r\n#define S32_NVIC_IP_PRI82_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI82_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI82_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI82(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI82_SHIFT))&S32_NVIC_IP_PRI82_MASK)\r\n#define S32_NVIC_IP_PRI83_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI83_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI83_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI83(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI83_SHIFT))&S32_NVIC_IP_PRI83_MASK)\r\n#define S32_NVIC_IP_PRI84_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI84_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI84_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI84(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI84_SHIFT))&S32_NVIC_IP_PRI84_MASK)\r\n#define S32_NVIC_IP_PRI85_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI85_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI85_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI85(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI85_SHIFT))&S32_NVIC_IP_PRI85_MASK)\r\n#define S32_NVIC_IP_PRI86_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI86_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI86_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI86(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI86_SHIFT))&S32_NVIC_IP_PRI86_MASK)\r\n#define S32_NVIC_IP_PRI87_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI87_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI87_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI87(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI87_SHIFT))&S32_NVIC_IP_PRI87_MASK)\r\n#define S32_NVIC_IP_PRI88_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI88_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI88_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI88(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI88_SHIFT))&S32_NVIC_IP_PRI88_MASK)\r\n#define S32_NVIC_IP_PRI89_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI89_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI89_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI89(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI89_SHIFT))&S32_NVIC_IP_PRI89_MASK)\r\n#define S32_NVIC_IP_PRI90_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI90_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI90_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI90(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI90_SHIFT))&S32_NVIC_IP_PRI90_MASK)\r\n#define S32_NVIC_IP_PRI91_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI91_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI91_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI91(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI91_SHIFT))&S32_NVIC_IP_PRI91_MASK)\r\n#define S32_NVIC_IP_PRI92_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI92_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI92_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI92(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI92_SHIFT))&S32_NVIC_IP_PRI92_MASK)\r\n#define S32_NVIC_IP_PRI93_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI93_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI93_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI93(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI93_SHIFT))&S32_NVIC_IP_PRI93_MASK)\r\n#define S32_NVIC_IP_PRI94_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI94_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI94_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI94(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI94_SHIFT))&S32_NVIC_IP_PRI94_MASK)\r\n#define S32_NVIC_IP_PRI95_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI95_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI95_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI95(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI95_SHIFT))&S32_NVIC_IP_PRI95_MASK)\r\n#define S32_NVIC_IP_PRI96_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI96_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI96_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI96(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI96_SHIFT))&S32_NVIC_IP_PRI96_MASK)\r\n#define S32_NVIC_IP_PRI97_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI97_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI97_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI97(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI97_SHIFT))&S32_NVIC_IP_PRI97_MASK)\r\n#define S32_NVIC_IP_PRI98_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI98_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI98_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI98(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI98_SHIFT))&S32_NVIC_IP_PRI98_MASK)\r\n#define S32_NVIC_IP_PRI99_MASK                   0xFFu\r\n#define S32_NVIC_IP_PRI99_SHIFT                  0u\r\n#define S32_NVIC_IP_PRI99_WIDTH                  8u\r\n#define S32_NVIC_IP_PRI99(x)                     (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI99_SHIFT))&S32_NVIC_IP_PRI99_MASK)\r\n#define S32_NVIC_IP_PRI100_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI100_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI100_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI100(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI100_SHIFT))&S32_NVIC_IP_PRI100_MASK)\r\n#define S32_NVIC_IP_PRI101_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI101_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI101_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI101(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI101_SHIFT))&S32_NVIC_IP_PRI101_MASK)\r\n#define S32_NVIC_IP_PRI102_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI102_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI102_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI102(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI102_SHIFT))&S32_NVIC_IP_PRI102_MASK)\r\n#define S32_NVIC_IP_PRI103_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI103_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI103_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI103(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI103_SHIFT))&S32_NVIC_IP_PRI103_MASK)\r\n#define S32_NVIC_IP_PRI104_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI104_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI104_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI104(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI104_SHIFT))&S32_NVIC_IP_PRI104_MASK)\r\n#define S32_NVIC_IP_PRI105_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI105_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI105_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI105(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI105_SHIFT))&S32_NVIC_IP_PRI105_MASK)\r\n#define S32_NVIC_IP_PRI106_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI106_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI106_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI106(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI106_SHIFT))&S32_NVIC_IP_PRI106_MASK)\r\n#define S32_NVIC_IP_PRI107_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI107_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI107_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI107(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI107_SHIFT))&S32_NVIC_IP_PRI107_MASK)\r\n#define S32_NVIC_IP_PRI108_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI108_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI108_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI108(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI108_SHIFT))&S32_NVIC_IP_PRI108_MASK)\r\n#define S32_NVIC_IP_PRI109_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI109_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI109_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI109(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI109_SHIFT))&S32_NVIC_IP_PRI109_MASK)\r\n#define S32_NVIC_IP_PRI110_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI110_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI110_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI110(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI110_SHIFT))&S32_NVIC_IP_PRI110_MASK)\r\n#define S32_NVIC_IP_PRI111_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI111_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI111_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI111(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI111_SHIFT))&S32_NVIC_IP_PRI111_MASK)\r\n#define S32_NVIC_IP_PRI112_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI112_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI112_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI112(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI112_SHIFT))&S32_NVIC_IP_PRI112_MASK)\r\n#define S32_NVIC_IP_PRI113_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI113_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI113_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI113(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI113_SHIFT))&S32_NVIC_IP_PRI113_MASK)\r\n#define S32_NVIC_IP_PRI114_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI114_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI114_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI114(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI114_SHIFT))&S32_NVIC_IP_PRI114_MASK)\r\n#define S32_NVIC_IP_PRI115_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI115_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI115_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI115(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI115_SHIFT))&S32_NVIC_IP_PRI115_MASK)\r\n#define S32_NVIC_IP_PRI116_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI116_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI116_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI116(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI116_SHIFT))&S32_NVIC_IP_PRI116_MASK)\r\n#define S32_NVIC_IP_PRI117_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI117_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI117_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI117(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI117_SHIFT))&S32_NVIC_IP_PRI117_MASK)\r\n#define S32_NVIC_IP_PRI118_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI118_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI118_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI118(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI118_SHIFT))&S32_NVIC_IP_PRI118_MASK)\r\n#define S32_NVIC_IP_PRI119_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI119_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI119_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI119(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI119_SHIFT))&S32_NVIC_IP_PRI119_MASK)\r\n#define S32_NVIC_IP_PRI120_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI120_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI120_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI120(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI120_SHIFT))&S32_NVIC_IP_PRI120_MASK)\r\n#define S32_NVIC_IP_PRI121_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI121_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI121_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI121(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI121_SHIFT))&S32_NVIC_IP_PRI121_MASK)\r\n#define S32_NVIC_IP_PRI122_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI122_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI122_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI122(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI122_SHIFT))&S32_NVIC_IP_PRI122_MASK)\r\n#define S32_NVIC_IP_PRI123_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI123_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI123_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI123(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI123_SHIFT))&S32_NVIC_IP_PRI123_MASK)\r\n#define S32_NVIC_IP_PRI124_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI124_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI124_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI124(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI124_SHIFT))&S32_NVIC_IP_PRI124_MASK)\r\n#define S32_NVIC_IP_PRI125_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI125_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI125_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI125(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI125_SHIFT))&S32_NVIC_IP_PRI125_MASK)\r\n#define S32_NVIC_IP_PRI126_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI126_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI126_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI126(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI126_SHIFT))&S32_NVIC_IP_PRI126_MASK)\r\n#define S32_NVIC_IP_PRI127_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI127_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI127_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI127(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI127_SHIFT))&S32_NVIC_IP_PRI127_MASK)\r\n#define S32_NVIC_IP_PRI128_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI128_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI128_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI128(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI128_SHIFT))&S32_NVIC_IP_PRI128_MASK)\r\n#define S32_NVIC_IP_PRI129_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI129_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI129_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI129(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI129_SHIFT))&S32_NVIC_IP_PRI129_MASK)\r\n#define S32_NVIC_IP_PRI130_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI130_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI130_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI130(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI130_SHIFT))&S32_NVIC_IP_PRI130_MASK)\r\n#define S32_NVIC_IP_PRI131_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI131_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI131_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI131(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI131_SHIFT))&S32_NVIC_IP_PRI131_MASK)\r\n#define S32_NVIC_IP_PRI132_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI132_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI132_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI132(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI132_SHIFT))&S32_NVIC_IP_PRI132_MASK)\r\n#define S32_NVIC_IP_PRI133_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI133_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI133_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI133(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI133_SHIFT))&S32_NVIC_IP_PRI133_MASK)\r\n#define S32_NVIC_IP_PRI134_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI134_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI134_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI134(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI134_SHIFT))&S32_NVIC_IP_PRI134_MASK)\r\n#define S32_NVIC_IP_PRI135_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI135_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI135_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI135(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI135_SHIFT))&S32_NVIC_IP_PRI135_MASK)\r\n#define S32_NVIC_IP_PRI136_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI136_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI136_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI136(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI136_SHIFT))&S32_NVIC_IP_PRI136_MASK)\r\n#define S32_NVIC_IP_PRI137_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI137_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI137_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI137(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI137_SHIFT))&S32_NVIC_IP_PRI137_MASK)\r\n#define S32_NVIC_IP_PRI138_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI138_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI138_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI138(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI138_SHIFT))&S32_NVIC_IP_PRI138_MASK)\r\n#define S32_NVIC_IP_PRI139_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI139_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI139_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI139(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI139_SHIFT))&S32_NVIC_IP_PRI139_MASK)\r\n#define S32_NVIC_IP_PRI140_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI140_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI140_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI140(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI140_SHIFT))&S32_NVIC_IP_PRI140_MASK)\r\n#define S32_NVIC_IP_PRI141_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI141_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI141_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI141(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI141_SHIFT))&S32_NVIC_IP_PRI141_MASK)\r\n#define S32_NVIC_IP_PRI142_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI142_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI142_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI142(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI142_SHIFT))&S32_NVIC_IP_PRI142_MASK)\r\n#define S32_NVIC_IP_PRI143_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI143_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI143_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI143(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI143_SHIFT))&S32_NVIC_IP_PRI143_MASK)\r\n#define S32_NVIC_IP_PRI144_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI144_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI144_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI144(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI144_SHIFT))&S32_NVIC_IP_PRI144_MASK)\r\n#define S32_NVIC_IP_PRI145_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI145_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI145_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI145(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI145_SHIFT))&S32_NVIC_IP_PRI145_MASK)\r\n#define S32_NVIC_IP_PRI146_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI146_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI146_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI146(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI146_SHIFT))&S32_NVIC_IP_PRI146_MASK)\r\n#define S32_NVIC_IP_PRI147_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI147_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI147_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI147(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI147_SHIFT))&S32_NVIC_IP_PRI147_MASK)\r\n#define S32_NVIC_IP_PRI148_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI148_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI148_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI148(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI148_SHIFT))&S32_NVIC_IP_PRI148_MASK)\r\n#define S32_NVIC_IP_PRI149_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI149_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI149_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI149(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI149_SHIFT))&S32_NVIC_IP_PRI149_MASK)\r\n#define S32_NVIC_IP_PRI150_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI150_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI150_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI150(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI150_SHIFT))&S32_NVIC_IP_PRI150_MASK)\r\n#define S32_NVIC_IP_PRI151_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI151_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI151_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI151(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI151_SHIFT))&S32_NVIC_IP_PRI151_MASK)\r\n#define S32_NVIC_IP_PRI152_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI152_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI152_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI152(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI152_SHIFT))&S32_NVIC_IP_PRI152_MASK)\r\n#define S32_NVIC_IP_PRI153_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI153_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI153_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI153(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI153_SHIFT))&S32_NVIC_IP_PRI153_MASK)\r\n#define S32_NVIC_IP_PRI154_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI154_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI154_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI154(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI154_SHIFT))&S32_NVIC_IP_PRI154_MASK)\r\n#define S32_NVIC_IP_PRI155_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI155_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI155_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI155(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI155_SHIFT))&S32_NVIC_IP_PRI155_MASK)\r\n#define S32_NVIC_IP_PRI156_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI156_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI156_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI156(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI156_SHIFT))&S32_NVIC_IP_PRI156_MASK)\r\n#define S32_NVIC_IP_PRI157_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI157_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI157_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI157(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI157_SHIFT))&S32_NVIC_IP_PRI157_MASK)\r\n#define S32_NVIC_IP_PRI158_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI158_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI158_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI158(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI158_SHIFT))&S32_NVIC_IP_PRI158_MASK)\r\n#define S32_NVIC_IP_PRI159_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI159_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI159_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI159(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI159_SHIFT))&S32_NVIC_IP_PRI159_MASK)\r\n#define S32_NVIC_IP_PRI160_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI160_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI160_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI160(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI160_SHIFT))&S32_NVIC_IP_PRI160_MASK)\r\n#define S32_NVIC_IP_PRI161_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI161_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI161_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI161(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI161_SHIFT))&S32_NVIC_IP_PRI161_MASK)\r\n#define S32_NVIC_IP_PRI162_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI162_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI162_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI162(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI162_SHIFT))&S32_NVIC_IP_PRI162_MASK)\r\n#define S32_NVIC_IP_PRI163_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI163_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI163_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI163(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI163_SHIFT))&S32_NVIC_IP_PRI163_MASK)\r\n#define S32_NVIC_IP_PRI164_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI164_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI164_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI164(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI164_SHIFT))&S32_NVIC_IP_PRI164_MASK)\r\n#define S32_NVIC_IP_PRI165_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI165_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI165_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI165(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI165_SHIFT))&S32_NVIC_IP_PRI165_MASK)\r\n#define S32_NVIC_IP_PRI166_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI166_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI166_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI166(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI166_SHIFT))&S32_NVIC_IP_PRI166_MASK)\r\n#define S32_NVIC_IP_PRI167_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI167_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI167_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI167(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI167_SHIFT))&S32_NVIC_IP_PRI167_MASK)\r\n#define S32_NVIC_IP_PRI168_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI168_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI168_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI168(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI168_SHIFT))&S32_NVIC_IP_PRI168_MASK)\r\n#define S32_NVIC_IP_PRI169_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI169_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI169_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI169(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI169_SHIFT))&S32_NVIC_IP_PRI169_MASK)\r\n#define S32_NVIC_IP_PRI170_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI170_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI170_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI170(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI170_SHIFT))&S32_NVIC_IP_PRI170_MASK)\r\n#define S32_NVIC_IP_PRI171_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI171_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI171_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI171(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI171_SHIFT))&S32_NVIC_IP_PRI171_MASK)\r\n#define S32_NVIC_IP_PRI172_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI172_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI172_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI172(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI172_SHIFT))&S32_NVIC_IP_PRI172_MASK)\r\n#define S32_NVIC_IP_PRI173_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI173_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI173_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI173(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI173_SHIFT))&S32_NVIC_IP_PRI173_MASK)\r\n#define S32_NVIC_IP_PRI174_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI174_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI174_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI174(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI174_SHIFT))&S32_NVIC_IP_PRI174_MASK)\r\n#define S32_NVIC_IP_PRI175_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI175_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI175_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI175(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI175_SHIFT))&S32_NVIC_IP_PRI175_MASK)\r\n#define S32_NVIC_IP_PRI176_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI176_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI176_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI176(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI176_SHIFT))&S32_NVIC_IP_PRI176_MASK)\r\n#define S32_NVIC_IP_PRI177_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI177_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI177_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI177(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI177_SHIFT))&S32_NVIC_IP_PRI177_MASK)\r\n#define S32_NVIC_IP_PRI178_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI178_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI178_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI178(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI178_SHIFT))&S32_NVIC_IP_PRI178_MASK)\r\n#define S32_NVIC_IP_PRI179_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI179_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI179_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI179(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI179_SHIFT))&S32_NVIC_IP_PRI179_MASK)\r\n#define S32_NVIC_IP_PRI180_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI180_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI180_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI180(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI180_SHIFT))&S32_NVIC_IP_PRI180_MASK)\r\n#define S32_NVIC_IP_PRI181_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI181_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI181_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI181(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI181_SHIFT))&S32_NVIC_IP_PRI181_MASK)\r\n#define S32_NVIC_IP_PRI182_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI182_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI182_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI182(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI182_SHIFT))&S32_NVIC_IP_PRI182_MASK)\r\n#define S32_NVIC_IP_PRI183_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI183_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI183_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI183(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI183_SHIFT))&S32_NVIC_IP_PRI183_MASK)\r\n#define S32_NVIC_IP_PRI184_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI184_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI184_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI184(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI184_SHIFT))&S32_NVIC_IP_PRI184_MASK)\r\n#define S32_NVIC_IP_PRI185_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI185_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI185_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI185(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI185_SHIFT))&S32_NVIC_IP_PRI185_MASK)\r\n#define S32_NVIC_IP_PRI186_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI186_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI186_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI186(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI186_SHIFT))&S32_NVIC_IP_PRI186_MASK)\r\n#define S32_NVIC_IP_PRI187_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI187_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI187_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI187(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI187_SHIFT))&S32_NVIC_IP_PRI187_MASK)\r\n#define S32_NVIC_IP_PRI188_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI188_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI188_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI188(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI188_SHIFT))&S32_NVIC_IP_PRI188_MASK)\r\n#define S32_NVIC_IP_PRI189_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI189_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI189_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI189(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI189_SHIFT))&S32_NVIC_IP_PRI189_MASK)\r\n#define S32_NVIC_IP_PRI190_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI190_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI190_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI190(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI190_SHIFT))&S32_NVIC_IP_PRI190_MASK)\r\n#define S32_NVIC_IP_PRI191_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI191_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI191_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI191(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI191_SHIFT))&S32_NVIC_IP_PRI191_MASK)\r\n#define S32_NVIC_IP_PRI192_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI192_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI192_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI192(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI192_SHIFT))&S32_NVIC_IP_PRI192_MASK)\r\n#define S32_NVIC_IP_PRI193_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI193_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI193_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI193(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI193_SHIFT))&S32_NVIC_IP_PRI193_MASK)\r\n#define S32_NVIC_IP_PRI194_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI194_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI194_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI194(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI194_SHIFT))&S32_NVIC_IP_PRI194_MASK)\r\n#define S32_NVIC_IP_PRI195_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI195_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI195_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI195(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI195_SHIFT))&S32_NVIC_IP_PRI195_MASK)\r\n#define S32_NVIC_IP_PRI196_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI196_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI196_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI196(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI196_SHIFT))&S32_NVIC_IP_PRI196_MASK)\r\n#define S32_NVIC_IP_PRI197_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI197_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI197_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI197(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI197_SHIFT))&S32_NVIC_IP_PRI197_MASK)\r\n#define S32_NVIC_IP_PRI198_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI198_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI198_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI198(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI198_SHIFT))&S32_NVIC_IP_PRI198_MASK)\r\n#define S32_NVIC_IP_PRI199_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI199_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI199_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI199(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI199_SHIFT))&S32_NVIC_IP_PRI199_MASK)\r\n#define S32_NVIC_IP_PRI200_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI200_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI200_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI200(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI200_SHIFT))&S32_NVIC_IP_PRI200_MASK)\r\n#define S32_NVIC_IP_PRI201_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI201_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI201_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI201(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI201_SHIFT))&S32_NVIC_IP_PRI201_MASK)\r\n#define S32_NVIC_IP_PRI202_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI202_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI202_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI202(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI202_SHIFT))&S32_NVIC_IP_PRI202_MASK)\r\n#define S32_NVIC_IP_PRI203_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI203_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI203_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI203(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI203_SHIFT))&S32_NVIC_IP_PRI203_MASK)\r\n#define S32_NVIC_IP_PRI204_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI204_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI204_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI204(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI204_SHIFT))&S32_NVIC_IP_PRI204_MASK)\r\n#define S32_NVIC_IP_PRI205_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI205_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI205_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI205(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI205_SHIFT))&S32_NVIC_IP_PRI205_MASK)\r\n#define S32_NVIC_IP_PRI206_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI206_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI206_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI206(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI206_SHIFT))&S32_NVIC_IP_PRI206_MASK)\r\n#define S32_NVIC_IP_PRI207_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI207_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI207_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI207(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI207_SHIFT))&S32_NVIC_IP_PRI207_MASK)\r\n#define S32_NVIC_IP_PRI208_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI208_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI208_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI208(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI208_SHIFT))&S32_NVIC_IP_PRI208_MASK)\r\n#define S32_NVIC_IP_PRI209_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI209_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI209_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI209(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI209_SHIFT))&S32_NVIC_IP_PRI209_MASK)\r\n#define S32_NVIC_IP_PRI210_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI210_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI210_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI210(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI210_SHIFT))&S32_NVIC_IP_PRI210_MASK)\r\n#define S32_NVIC_IP_PRI211_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI211_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI211_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI211(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI211_SHIFT))&S32_NVIC_IP_PRI211_MASK)\r\n#define S32_NVIC_IP_PRI212_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI212_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI212_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI212(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI212_SHIFT))&S32_NVIC_IP_PRI212_MASK)\r\n#define S32_NVIC_IP_PRI213_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI213_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI213_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI213(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI213_SHIFT))&S32_NVIC_IP_PRI213_MASK)\r\n#define S32_NVIC_IP_PRI214_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI214_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI214_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI214(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI214_SHIFT))&S32_NVIC_IP_PRI214_MASK)\r\n#define S32_NVIC_IP_PRI215_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI215_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI215_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI215(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI215_SHIFT))&S32_NVIC_IP_PRI215_MASK)\r\n#define S32_NVIC_IP_PRI216_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI216_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI216_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI216(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI216_SHIFT))&S32_NVIC_IP_PRI216_MASK)\r\n#define S32_NVIC_IP_PRI217_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI217_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI217_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI217(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI217_SHIFT))&S32_NVIC_IP_PRI217_MASK)\r\n#define S32_NVIC_IP_PRI218_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI218_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI218_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI218(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI218_SHIFT))&S32_NVIC_IP_PRI218_MASK)\r\n#define S32_NVIC_IP_PRI219_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI219_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI219_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI219(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI219_SHIFT))&S32_NVIC_IP_PRI219_MASK)\r\n#define S32_NVIC_IP_PRI220_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI220_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI220_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI220(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI220_SHIFT))&S32_NVIC_IP_PRI220_MASK)\r\n#define S32_NVIC_IP_PRI221_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI221_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI221_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI221(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI221_SHIFT))&S32_NVIC_IP_PRI221_MASK)\r\n#define S32_NVIC_IP_PRI222_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI222_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI222_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI222(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI222_SHIFT))&S32_NVIC_IP_PRI222_MASK)\r\n#define S32_NVIC_IP_PRI223_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI223_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI223_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI223(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI223_SHIFT))&S32_NVIC_IP_PRI223_MASK)\r\n#define S32_NVIC_IP_PRI224_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI224_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI224_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI224(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI224_SHIFT))&S32_NVIC_IP_PRI224_MASK)\r\n#define S32_NVIC_IP_PRI225_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI225_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI225_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI225(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI225_SHIFT))&S32_NVIC_IP_PRI225_MASK)\r\n#define S32_NVIC_IP_PRI226_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI226_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI226_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI226(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI226_SHIFT))&S32_NVIC_IP_PRI226_MASK)\r\n#define S32_NVIC_IP_PRI227_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI227_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI227_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI227(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI227_SHIFT))&S32_NVIC_IP_PRI227_MASK)\r\n#define S32_NVIC_IP_PRI228_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI228_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI228_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI228(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI228_SHIFT))&S32_NVIC_IP_PRI228_MASK)\r\n#define S32_NVIC_IP_PRI229_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI229_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI229_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI229(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI229_SHIFT))&S32_NVIC_IP_PRI229_MASK)\r\n#define S32_NVIC_IP_PRI230_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI230_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI230_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI230(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI230_SHIFT))&S32_NVIC_IP_PRI230_MASK)\r\n#define S32_NVIC_IP_PRI231_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI231_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI231_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI231(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI231_SHIFT))&S32_NVIC_IP_PRI231_MASK)\r\n#define S32_NVIC_IP_PRI232_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI232_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI232_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI232(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI232_SHIFT))&S32_NVIC_IP_PRI232_MASK)\r\n#define S32_NVIC_IP_PRI233_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI233_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI233_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI233(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI233_SHIFT))&S32_NVIC_IP_PRI233_MASK)\r\n#define S32_NVIC_IP_PRI234_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI234_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI234_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI234(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI234_SHIFT))&S32_NVIC_IP_PRI234_MASK)\r\n#define S32_NVIC_IP_PRI235_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI235_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI235_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI235(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI235_SHIFT))&S32_NVIC_IP_PRI235_MASK)\r\n#define S32_NVIC_IP_PRI236_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI236_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI236_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI236(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI236_SHIFT))&S32_NVIC_IP_PRI236_MASK)\r\n#define S32_NVIC_IP_PRI237_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI237_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI237_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI237(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI237_SHIFT))&S32_NVIC_IP_PRI237_MASK)\r\n#define S32_NVIC_IP_PRI238_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI238_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI238_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI238(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI238_SHIFT))&S32_NVIC_IP_PRI238_MASK)\r\n#define S32_NVIC_IP_PRI239_MASK                  0xFFu\r\n#define S32_NVIC_IP_PRI239_SHIFT                 0u\r\n#define S32_NVIC_IP_PRI239_WIDTH                 8u\r\n#define S32_NVIC_IP_PRI239(x)                    (((uint8_t)(((uint8_t)(x))<<S32_NVIC_IP_PRI239_SHIFT))&S32_NVIC_IP_PRI239_MASK)\r\n/* STIR Bit Fields */\r\n#define S32_NVIC_STIR_INTID_MASK                 0x1FFu\r\n#define S32_NVIC_STIR_INTID_SHIFT                0u\r\n#define S32_NVIC_STIR_INTID_WIDTH                9u\r\n#define S32_NVIC_STIR_INTID(x)                   (((uint32_t)(((uint32_t)(x))<<S32_NVIC_STIR_INTID_SHIFT))&S32_NVIC_STIR_INTID_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group S32_NVIC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group S32_NVIC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- S32_SCB Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup S32_SCB_Peripheral_Access_Layer S32_SCB Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** S32_SCB - Size of Registers Arrays */\r\n\r\n/** S32_SCB - Register Layout Typedef */\r\ntypedef struct {\r\n       uint8_t RESERVED_0[8];\r\n  __IO uint32_t ACTLR;                             /**< Auxiliary Control Register,, offset: 0x8 */\r\n       uint8_t RESERVED_1[3316];\r\n  __I  uint32_t CPUID;                             /**< CPUID Base Register, offset: 0xD00 */\r\n  __IO uint32_t ICSR;                              /**< Interrupt Control and State Register, offset: 0xD04 */\r\n  __IO uint32_t VTOR;                              /**< Vector Table Offset Register, offset: 0xD08 */\r\n  __IO uint32_t AIRCR;                             /**< Application Interrupt and Reset Control Register, offset: 0xD0C */\r\n  __IO uint32_t SCR;                               /**< System Control Register, offset: 0xD10 */\r\n  __IO uint32_t CCR;                               /**< Configuration and Control Register, offset: 0xD14 */\r\n  __IO uint32_t SHPR1;                             /**< System Handler Priority Register 1, offset: 0xD18 */\r\n  __IO uint32_t SHPR2;                             /**< System Handler Priority Register 2, offset: 0xD1C */\r\n  __IO uint32_t SHPR3;                             /**< System Handler Priority Register 3, offset: 0xD20 */\r\n  __IO uint32_t SHCSR;                             /**< System Handler Control and State Register, offset: 0xD24 */\r\n  __IO uint32_t CFSR;                              /**< Configurable Fault Status Registers, offset: 0xD28 */\r\n  __IO uint32_t HFSR;                              /**< HardFault Status register, offset: 0xD2C */\r\n  __IO uint32_t DFSR;                              /**< Debug Fault Status Register, offset: 0xD30 */\r\n  __IO uint32_t MMFAR;                             /**< MemManage Address Register, offset: 0xD34 */\r\n  __IO uint32_t BFAR;                              /**< BusFault Address Register, offset: 0xD38 */\r\n  __IO uint32_t AFSR;                              /**< Auxiliary Fault Status Register, offset: 0xD3C */\r\n       uint8_t RESERVED_2[72];\r\n  __IO uint32_t CPACR;                             /**< Coprocessor Access Control Register, offset: 0xD88 */\r\n       uint8_t RESERVED_3[424];\r\n  __IO uint32_t FPCCR;                             /**< Floating-point Context Control Register, offset: 0xF34 */\r\n  __IO uint32_t FPCAR;                             /**< Floating-point Context Address Register, offset: 0xF38 */\r\n  __IO uint32_t FPDSCR;                            /**< Floating-point Default Status Control Register, offset: 0xF3C */\r\n} S32_SCB_Type, *S32_SCB_MemMapPtr;\r\n\r\n /** Number of instances of the S32_SCB module. */\r\n#define S32_SCB_INSTANCE_COUNT                   (1u)\r\n\r\n\r\n/* S32_SCB - Peripheral instance base addresses */\r\n/** Peripheral S32_SCB base address */\r\n#define S32_SCB_BASE                             (0xE000E000u)\r\n/** Peripheral S32_SCB base pointer */\r\n#define S32_SCB                                  ((S32_SCB_Type *)S32_SCB_BASE)\r\n/** Array initializer of S32_SCB peripheral base addresses */\r\n#define S32_SCB_BASE_ADDRS                       { S32_SCB_BASE }\r\n/** Array initializer of S32_SCB peripheral base pointers */\r\n#define S32_SCB_BASE_PTRS                        { S32_SCB }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- S32_SCB Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup S32_SCB_Register_Masks S32_SCB Register Masks\r\n * @{\r\n */\r\n\r\n/* ACTLR Bit Fields */\r\n#define S32_SCB_ACTLR_DISMCYCINT_MASK            0x1u\r\n#define S32_SCB_ACTLR_DISMCYCINT_SHIFT           0u\r\n#define S32_SCB_ACTLR_DISMCYCINT_WIDTH           1u\r\n#define S32_SCB_ACTLR_DISMCYCINT(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_ACTLR_DISMCYCINT_SHIFT))&S32_SCB_ACTLR_DISMCYCINT_MASK)\r\n#define S32_SCB_ACTLR_DISDEFWBUF_MASK            0x2u\r\n#define S32_SCB_ACTLR_DISDEFWBUF_SHIFT           1u\r\n#define S32_SCB_ACTLR_DISDEFWBUF_WIDTH           1u\r\n#define S32_SCB_ACTLR_DISDEFWBUF(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_ACTLR_DISDEFWBUF_SHIFT))&S32_SCB_ACTLR_DISDEFWBUF_MASK)\r\n#define S32_SCB_ACTLR_DISFOLD_MASK               0x4u\r\n#define S32_SCB_ACTLR_DISFOLD_SHIFT              2u\r\n#define S32_SCB_ACTLR_DISFOLD_WIDTH              1u\r\n#define S32_SCB_ACTLR_DISFOLD(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_ACTLR_DISFOLD_SHIFT))&S32_SCB_ACTLR_DISFOLD_MASK)\r\n#define S32_SCB_ACTLR_DISFPCA_MASK               0x100u\r\n#define S32_SCB_ACTLR_DISFPCA_SHIFT              8u\r\n#define S32_SCB_ACTLR_DISFPCA_WIDTH              1u\r\n#define S32_SCB_ACTLR_DISFPCA(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_ACTLR_DISFPCA_SHIFT))&S32_SCB_ACTLR_DISFPCA_MASK)\r\n#define S32_SCB_ACTLR_DISOOFP_MASK               0x200u\r\n#define S32_SCB_ACTLR_DISOOFP_SHIFT              9u\r\n#define S32_SCB_ACTLR_DISOOFP_WIDTH              1u\r\n#define S32_SCB_ACTLR_DISOOFP(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_ACTLR_DISOOFP_SHIFT))&S32_SCB_ACTLR_DISOOFP_MASK)\r\n/* CPUID Bit Fields */\r\n#define S32_SCB_CPUID_REVISION_MASK              0xFu\r\n#define S32_SCB_CPUID_REVISION_SHIFT             0u\r\n#define S32_SCB_CPUID_REVISION_WIDTH             4u\r\n#define S32_SCB_CPUID_REVISION(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CPUID_REVISION_SHIFT))&S32_SCB_CPUID_REVISION_MASK)\r\n#define S32_SCB_CPUID_PARTNO_MASK                0xFFF0u\r\n#define S32_SCB_CPUID_PARTNO_SHIFT               4u\r\n#define S32_SCB_CPUID_PARTNO_WIDTH               12u\r\n#define S32_SCB_CPUID_PARTNO(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_CPUID_PARTNO_SHIFT))&S32_SCB_CPUID_PARTNO_MASK)\r\n#define S32_SCB_CPUID_VARIANT_MASK               0xF00000u\r\n#define S32_SCB_CPUID_VARIANT_SHIFT              20u\r\n#define S32_SCB_CPUID_VARIANT_WIDTH              4u\r\n#define S32_SCB_CPUID_VARIANT(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CPUID_VARIANT_SHIFT))&S32_SCB_CPUID_VARIANT_MASK)\r\n#define S32_SCB_CPUID_IMPLEMENTER_MASK           0xFF000000u\r\n#define S32_SCB_CPUID_IMPLEMENTER_SHIFT          24u\r\n#define S32_SCB_CPUID_IMPLEMENTER_WIDTH          8u\r\n#define S32_SCB_CPUID_IMPLEMENTER(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_CPUID_IMPLEMENTER_SHIFT))&S32_SCB_CPUID_IMPLEMENTER_MASK)\r\n/* ICSR Bit Fields */\r\n#define S32_SCB_ICSR_VECTACTIVE_MASK             0x1FFu\r\n#define S32_SCB_ICSR_VECTACTIVE_SHIFT            0u\r\n#define S32_SCB_ICSR_VECTACTIVE_WIDTH            9u\r\n#define S32_SCB_ICSR_VECTACTIVE(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_VECTACTIVE_SHIFT))&S32_SCB_ICSR_VECTACTIVE_MASK)\r\n#define S32_SCB_ICSR_RETTOBASE_MASK              0x800u\r\n#define S32_SCB_ICSR_RETTOBASE_SHIFT             11u\r\n#define S32_SCB_ICSR_RETTOBASE_WIDTH             1u\r\n#define S32_SCB_ICSR_RETTOBASE(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_RETTOBASE_SHIFT))&S32_SCB_ICSR_RETTOBASE_MASK)\r\n#define S32_SCB_ICSR_VECTPENDING_MASK            0x3F000u\r\n#define S32_SCB_ICSR_VECTPENDING_SHIFT           12u\r\n#define S32_SCB_ICSR_VECTPENDING_WIDTH           6u\r\n#define S32_SCB_ICSR_VECTPENDING(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_VECTPENDING_SHIFT))&S32_SCB_ICSR_VECTPENDING_MASK)\r\n#define S32_SCB_ICSR_ISRPENDING_MASK             0x400000u\r\n#define S32_SCB_ICSR_ISRPENDING_SHIFT            22u\r\n#define S32_SCB_ICSR_ISRPENDING_WIDTH            1u\r\n#define S32_SCB_ICSR_ISRPENDING(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_ISRPENDING_SHIFT))&S32_SCB_ICSR_ISRPENDING_MASK)\r\n#define S32_SCB_ICSR_ISRPREEMPT_MASK             0x800000u\r\n#define S32_SCB_ICSR_ISRPREEMPT_SHIFT            23u\r\n#define S32_SCB_ICSR_ISRPREEMPT_WIDTH            1u\r\n#define S32_SCB_ICSR_ISRPREEMPT(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_ISRPREEMPT_SHIFT))&S32_SCB_ICSR_ISRPREEMPT_MASK)\r\n#define S32_SCB_ICSR_PENDSTCLR_MASK              0x2000000u\r\n#define S32_SCB_ICSR_PENDSTCLR_SHIFT             25u\r\n#define S32_SCB_ICSR_PENDSTCLR_WIDTH             1u\r\n#define S32_SCB_ICSR_PENDSTCLR(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_PENDSTCLR_SHIFT))&S32_SCB_ICSR_PENDSTCLR_MASK)\r\n#define S32_SCB_ICSR_PENDSTSET_MASK              0x4000000u\r\n#define S32_SCB_ICSR_PENDSTSET_SHIFT             26u\r\n#define S32_SCB_ICSR_PENDSTSET_WIDTH             1u\r\n#define S32_SCB_ICSR_PENDSTSET(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_PENDSTSET_SHIFT))&S32_SCB_ICSR_PENDSTSET_MASK)\r\n#define S32_SCB_ICSR_PENDSVCLR_MASK              0x8000000u\r\n#define S32_SCB_ICSR_PENDSVCLR_SHIFT             27u\r\n#define S32_SCB_ICSR_PENDSVCLR_WIDTH             1u\r\n#define S32_SCB_ICSR_PENDSVCLR(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_PENDSVCLR_SHIFT))&S32_SCB_ICSR_PENDSVCLR_MASK)\r\n#define S32_SCB_ICSR_PENDSVSET_MASK              0x10000000u\r\n#define S32_SCB_ICSR_PENDSVSET_SHIFT             28u\r\n#define S32_SCB_ICSR_PENDSVSET_WIDTH             1u\r\n#define S32_SCB_ICSR_PENDSVSET(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_PENDSVSET_SHIFT))&S32_SCB_ICSR_PENDSVSET_MASK)\r\n#define S32_SCB_ICSR_NMIPENDSET_MASK             0x80000000u\r\n#define S32_SCB_ICSR_NMIPENDSET_SHIFT            31u\r\n#define S32_SCB_ICSR_NMIPENDSET_WIDTH            1u\r\n#define S32_SCB_ICSR_NMIPENDSET(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_ICSR_NMIPENDSET_SHIFT))&S32_SCB_ICSR_NMIPENDSET_MASK)\r\n/* VTOR Bit Fields */\r\n#define S32_SCB_VTOR_TBLOFF_MASK                 0xFFFFFF80u\r\n#define S32_SCB_VTOR_TBLOFF_SHIFT                7u\r\n#define S32_SCB_VTOR_TBLOFF_WIDTH                25u\r\n#define S32_SCB_VTOR_TBLOFF(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_VTOR_TBLOFF_SHIFT))&S32_SCB_VTOR_TBLOFF_MASK)\r\n/* AIRCR Bit Fields */\r\n#define S32_SCB_AIRCR_VECTRESET_MASK             0x1u\r\n#define S32_SCB_AIRCR_VECTRESET_SHIFT            0u\r\n#define S32_SCB_AIRCR_VECTRESET_WIDTH            1u\r\n#define S32_SCB_AIRCR_VECTRESET(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_AIRCR_VECTRESET_SHIFT))&S32_SCB_AIRCR_VECTRESET_MASK)\r\n#define S32_SCB_AIRCR_VECTCLRACTIVE_MASK         0x2u\r\n#define S32_SCB_AIRCR_VECTCLRACTIVE_SHIFT        1u\r\n#define S32_SCB_AIRCR_VECTCLRACTIVE_WIDTH        1u\r\n#define S32_SCB_AIRCR_VECTCLRACTIVE(x)           (((uint32_t)(((uint32_t)(x))<<S32_SCB_AIRCR_VECTCLRACTIVE_SHIFT))&S32_SCB_AIRCR_VECTCLRACTIVE_MASK)\r\n#define S32_SCB_AIRCR_SYSRESETREQ_MASK           0x4u\r\n#define S32_SCB_AIRCR_SYSRESETREQ_SHIFT          2u\r\n#define S32_SCB_AIRCR_SYSRESETREQ_WIDTH          1u\r\n#define S32_SCB_AIRCR_SYSRESETREQ(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_AIRCR_SYSRESETREQ_SHIFT))&S32_SCB_AIRCR_SYSRESETREQ_MASK)\r\n#define S32_SCB_AIRCR_PRIGROUP_MASK              0x700u\r\n#define S32_SCB_AIRCR_PRIGROUP_SHIFT             8u\r\n#define S32_SCB_AIRCR_PRIGROUP_WIDTH             3u\r\n#define S32_SCB_AIRCR_PRIGROUP(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_AIRCR_PRIGROUP_SHIFT))&S32_SCB_AIRCR_PRIGROUP_MASK)\r\n#define S32_SCB_AIRCR_ENDIANNESS_MASK            0x8000u\r\n#define S32_SCB_AIRCR_ENDIANNESS_SHIFT           15u\r\n#define S32_SCB_AIRCR_ENDIANNESS_WIDTH           1u\r\n#define S32_SCB_AIRCR_ENDIANNESS(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_AIRCR_ENDIANNESS_SHIFT))&S32_SCB_AIRCR_ENDIANNESS_MASK)\r\n#define S32_SCB_AIRCR_VECTKEY_MASK               0xFFFF0000u\r\n#define S32_SCB_AIRCR_VECTKEY_SHIFT              16u\r\n#define S32_SCB_AIRCR_VECTKEY_WIDTH              16u\r\n#define S32_SCB_AIRCR_VECTKEY(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_AIRCR_VECTKEY_SHIFT))&S32_SCB_AIRCR_VECTKEY_MASK)\r\n/* SCR Bit Fields */\r\n#define S32_SCB_SCR_SLEEPONEXIT_MASK             0x2u\r\n#define S32_SCB_SCR_SLEEPONEXIT_SHIFT            1u\r\n#define S32_SCB_SCR_SLEEPONEXIT_WIDTH            1u\r\n#define S32_SCB_SCR_SLEEPONEXIT(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_SCR_SLEEPONEXIT_SHIFT))&S32_SCB_SCR_SLEEPONEXIT_MASK)\r\n#define S32_SCB_SCR_SLEEPDEEP_MASK               0x4u\r\n#define S32_SCB_SCR_SLEEPDEEP_SHIFT              2u\r\n#define S32_SCB_SCR_SLEEPDEEP_WIDTH              1u\r\n#define S32_SCB_SCR_SLEEPDEEP(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_SCR_SLEEPDEEP_SHIFT))&S32_SCB_SCR_SLEEPDEEP_MASK)\r\n#define S32_SCB_SCR_SEVONPEND_MASK               0x10u\r\n#define S32_SCB_SCR_SEVONPEND_SHIFT              4u\r\n#define S32_SCB_SCR_SEVONPEND_WIDTH              1u\r\n#define S32_SCB_SCR_SEVONPEND(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_SCR_SEVONPEND_SHIFT))&S32_SCB_SCR_SEVONPEND_MASK)\r\n/* CCR Bit Fields */\r\n#define S32_SCB_CCR_NONBASETHRDENA_MASK          0x1u\r\n#define S32_SCB_CCR_NONBASETHRDENA_SHIFT         0u\r\n#define S32_SCB_CCR_NONBASETHRDENA_WIDTH         1u\r\n#define S32_SCB_CCR_NONBASETHRDENA(x)            (((uint32_t)(((uint32_t)(x))<<S32_SCB_CCR_NONBASETHRDENA_SHIFT))&S32_SCB_CCR_NONBASETHRDENA_MASK)\r\n#define S32_SCB_CCR_USERSETMPEND_MASK            0x2u\r\n#define S32_SCB_CCR_USERSETMPEND_SHIFT           1u\r\n#define S32_SCB_CCR_USERSETMPEND_WIDTH           1u\r\n#define S32_SCB_CCR_USERSETMPEND(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_CCR_USERSETMPEND_SHIFT))&S32_SCB_CCR_USERSETMPEND_MASK)\r\n#define S32_SCB_CCR_UNALIGN_TRP_MASK             0x8u\r\n#define S32_SCB_CCR_UNALIGN_TRP_SHIFT            3u\r\n#define S32_SCB_CCR_UNALIGN_TRP_WIDTH            1u\r\n#define S32_SCB_CCR_UNALIGN_TRP(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_CCR_UNALIGN_TRP_SHIFT))&S32_SCB_CCR_UNALIGN_TRP_MASK)\r\n#define S32_SCB_CCR_DIV_0_TRP_MASK               0x10u\r\n#define S32_SCB_CCR_DIV_0_TRP_SHIFT              4u\r\n#define S32_SCB_CCR_DIV_0_TRP_WIDTH              1u\r\n#define S32_SCB_CCR_DIV_0_TRP(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CCR_DIV_0_TRP_SHIFT))&S32_SCB_CCR_DIV_0_TRP_MASK)\r\n#define S32_SCB_CCR_BFHFNMIGN_MASK               0x100u\r\n#define S32_SCB_CCR_BFHFNMIGN_SHIFT              8u\r\n#define S32_SCB_CCR_BFHFNMIGN_WIDTH              1u\r\n#define S32_SCB_CCR_BFHFNMIGN(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CCR_BFHFNMIGN_SHIFT))&S32_SCB_CCR_BFHFNMIGN_MASK)\r\n#define S32_SCB_CCR_STKALIGN_MASK                0x200u\r\n#define S32_SCB_CCR_STKALIGN_SHIFT               9u\r\n#define S32_SCB_CCR_STKALIGN_WIDTH               1u\r\n#define S32_SCB_CCR_STKALIGN(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_CCR_STKALIGN_SHIFT))&S32_SCB_CCR_STKALIGN_MASK)\r\n/* SHPR1 Bit Fields */\r\n#define S32_SCB_SHPR1_PRI_4_MASK                 0xFFu\r\n#define S32_SCB_SHPR1_PRI_4_SHIFT                0u\r\n#define S32_SCB_SHPR1_PRI_4_WIDTH                8u\r\n#define S32_SCB_SHPR1_PRI_4(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR1_PRI_4_SHIFT))&S32_SCB_SHPR1_PRI_4_MASK)\r\n#define S32_SCB_SHPR1_PRI_5_MASK                 0xFF00u\r\n#define S32_SCB_SHPR1_PRI_5_SHIFT                8u\r\n#define S32_SCB_SHPR1_PRI_5_WIDTH                8u\r\n#define S32_SCB_SHPR1_PRI_5(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR1_PRI_5_SHIFT))&S32_SCB_SHPR1_PRI_5_MASK)\r\n#define S32_SCB_SHPR1_PRI_6_MASK                 0xFF0000u\r\n#define S32_SCB_SHPR1_PRI_6_SHIFT                16u\r\n#define S32_SCB_SHPR1_PRI_6_WIDTH                8u\r\n#define S32_SCB_SHPR1_PRI_6(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR1_PRI_6_SHIFT))&S32_SCB_SHPR1_PRI_6_MASK)\r\n/* SHPR2 Bit Fields */\r\n#define S32_SCB_SHPR2_PRI_11_MASK                0xFF000000u\r\n#define S32_SCB_SHPR2_PRI_11_SHIFT               24u\r\n#define S32_SCB_SHPR2_PRI_11_WIDTH               8u\r\n#define S32_SCB_SHPR2_PRI_11(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR2_PRI_11_SHIFT))&S32_SCB_SHPR2_PRI_11_MASK)\r\n/* SHPR3 Bit Fields */\r\n#define S32_SCB_SHPR3_PRI_12_MASK                0xFFu\r\n#define S32_SCB_SHPR3_PRI_12_SHIFT               0u\r\n#define S32_SCB_SHPR3_PRI_12_WIDTH               8u\r\n#define S32_SCB_SHPR3_PRI_12(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR3_PRI_12_SHIFT))&S32_SCB_SHPR3_PRI_12_MASK)\r\n#define S32_SCB_SHPR3_PRI_14_MASK                0xFF0000u\r\n#define S32_SCB_SHPR3_PRI_14_SHIFT               16u\r\n#define S32_SCB_SHPR3_PRI_14_WIDTH               8u\r\n#define S32_SCB_SHPR3_PRI_14(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR3_PRI_14_SHIFT))&S32_SCB_SHPR3_PRI_14_MASK)\r\n#define S32_SCB_SHPR3_PRI_15_MASK                0xFF000000u\r\n#define S32_SCB_SHPR3_PRI_15_SHIFT               24u\r\n#define S32_SCB_SHPR3_PRI_15_WIDTH               8u\r\n#define S32_SCB_SHPR3_PRI_15(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHPR3_PRI_15_SHIFT))&S32_SCB_SHPR3_PRI_15_MASK)\r\n/* SHCSR Bit Fields */\r\n#define S32_SCB_SHCSR_MEMFAULTACT_MASK           0x1u\r\n#define S32_SCB_SHCSR_MEMFAULTACT_SHIFT          0u\r\n#define S32_SCB_SHCSR_MEMFAULTACT_WIDTH          1u\r\n#define S32_SCB_SHCSR_MEMFAULTACT(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_MEMFAULTACT_SHIFT))&S32_SCB_SHCSR_MEMFAULTACT_MASK)\r\n#define S32_SCB_SHCSR_BUSFAULTACT_MASK           0x2u\r\n#define S32_SCB_SHCSR_BUSFAULTACT_SHIFT          1u\r\n#define S32_SCB_SHCSR_BUSFAULTACT_WIDTH          1u\r\n#define S32_SCB_SHCSR_BUSFAULTACT(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_BUSFAULTACT_SHIFT))&S32_SCB_SHCSR_BUSFAULTACT_MASK)\r\n#define S32_SCB_SHCSR_USGFAULTACT_MASK           0x8u\r\n#define S32_SCB_SHCSR_USGFAULTACT_SHIFT          3u\r\n#define S32_SCB_SHCSR_USGFAULTACT_WIDTH          1u\r\n#define S32_SCB_SHCSR_USGFAULTACT(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_USGFAULTACT_SHIFT))&S32_SCB_SHCSR_USGFAULTACT_MASK)\r\n#define S32_SCB_SHCSR_SVCALLACT_MASK             0x80u\r\n#define S32_SCB_SHCSR_SVCALLACT_SHIFT            7u\r\n#define S32_SCB_SHCSR_SVCALLACT_WIDTH            1u\r\n#define S32_SCB_SHCSR_SVCALLACT(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_SVCALLACT_SHIFT))&S32_SCB_SHCSR_SVCALLACT_MASK)\r\n#define S32_SCB_SHCSR_MONITORACT_MASK            0x100u\r\n#define S32_SCB_SHCSR_MONITORACT_SHIFT           8u\r\n#define S32_SCB_SHCSR_MONITORACT_WIDTH           1u\r\n#define S32_SCB_SHCSR_MONITORACT(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_MONITORACT_SHIFT))&S32_SCB_SHCSR_MONITORACT_MASK)\r\n#define S32_SCB_SHCSR_PENDSVACT_MASK             0x400u\r\n#define S32_SCB_SHCSR_PENDSVACT_SHIFT            10u\r\n#define S32_SCB_SHCSR_PENDSVACT_WIDTH            1u\r\n#define S32_SCB_SHCSR_PENDSVACT(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_PENDSVACT_SHIFT))&S32_SCB_SHCSR_PENDSVACT_MASK)\r\n#define S32_SCB_SHCSR_SYSTICKACT_MASK            0x800u\r\n#define S32_SCB_SHCSR_SYSTICKACT_SHIFT           11u\r\n#define S32_SCB_SHCSR_SYSTICKACT_WIDTH           1u\r\n#define S32_SCB_SHCSR_SYSTICKACT(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_SYSTICKACT_SHIFT))&S32_SCB_SHCSR_SYSTICKACT_MASK)\r\n#define S32_SCB_SHCSR_USGFAULTPENDED_MASK        0x1000u\r\n#define S32_SCB_SHCSR_USGFAULTPENDED_SHIFT       12u\r\n#define S32_SCB_SHCSR_USGFAULTPENDED_WIDTH       1u\r\n#define S32_SCB_SHCSR_USGFAULTPENDED(x)          (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_USGFAULTPENDED_SHIFT))&S32_SCB_SHCSR_USGFAULTPENDED_MASK)\r\n#define S32_SCB_SHCSR_MEMFAULTPENDED_MASK        0x2000u\r\n#define S32_SCB_SHCSR_MEMFAULTPENDED_SHIFT       13u\r\n#define S32_SCB_SHCSR_MEMFAULTPENDED_WIDTH       1u\r\n#define S32_SCB_SHCSR_MEMFAULTPENDED(x)          (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_MEMFAULTPENDED_SHIFT))&S32_SCB_SHCSR_MEMFAULTPENDED_MASK)\r\n#define S32_SCB_SHCSR_BUSFAULTPENDED_MASK        0x4000u\r\n#define S32_SCB_SHCSR_BUSFAULTPENDED_SHIFT       14u\r\n#define S32_SCB_SHCSR_BUSFAULTPENDED_WIDTH       1u\r\n#define S32_SCB_SHCSR_BUSFAULTPENDED(x)          (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_BUSFAULTPENDED_SHIFT))&S32_SCB_SHCSR_BUSFAULTPENDED_MASK)\r\n#define S32_SCB_SHCSR_SVCALLPENDED_MASK          0x8000u\r\n#define S32_SCB_SHCSR_SVCALLPENDED_SHIFT         15u\r\n#define S32_SCB_SHCSR_SVCALLPENDED_WIDTH         1u\r\n#define S32_SCB_SHCSR_SVCALLPENDED(x)            (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_SVCALLPENDED_SHIFT))&S32_SCB_SHCSR_SVCALLPENDED_MASK)\r\n#define S32_SCB_SHCSR_MEMFAULTENA_MASK           0x10000u\r\n#define S32_SCB_SHCSR_MEMFAULTENA_SHIFT          16u\r\n#define S32_SCB_SHCSR_MEMFAULTENA_WIDTH          1u\r\n#define S32_SCB_SHCSR_MEMFAULTENA(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_MEMFAULTENA_SHIFT))&S32_SCB_SHCSR_MEMFAULTENA_MASK)\r\n#define S32_SCB_SHCSR_BUSFAULTENA_MASK           0x20000u\r\n#define S32_SCB_SHCSR_BUSFAULTENA_SHIFT          17u\r\n#define S32_SCB_SHCSR_BUSFAULTENA_WIDTH          1u\r\n#define S32_SCB_SHCSR_BUSFAULTENA(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_BUSFAULTENA_SHIFT))&S32_SCB_SHCSR_BUSFAULTENA_MASK)\r\n#define S32_SCB_SHCSR_USGFAULTENA_MASK           0x40000u\r\n#define S32_SCB_SHCSR_USGFAULTENA_SHIFT          18u\r\n#define S32_SCB_SHCSR_USGFAULTENA_WIDTH          1u\r\n#define S32_SCB_SHCSR_USGFAULTENA(x)             (((uint32_t)(((uint32_t)(x))<<S32_SCB_SHCSR_USGFAULTENA_SHIFT))&S32_SCB_SHCSR_USGFAULTENA_MASK)\r\n/* CFSR Bit Fields */\r\n#define S32_SCB_CFSR_IACCVIOL_MASK               0x1u\r\n#define S32_SCB_CFSR_IACCVIOL_SHIFT              0u\r\n#define S32_SCB_CFSR_IACCVIOL_WIDTH              1u\r\n#define S32_SCB_CFSR_IACCVIOL(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_IACCVIOL_SHIFT))&S32_SCB_CFSR_IACCVIOL_MASK)\r\n#define S32_SCB_CFSR_DACCVIOL_MASK               0x2u\r\n#define S32_SCB_CFSR_DACCVIOL_SHIFT              1u\r\n#define S32_SCB_CFSR_DACCVIOL_WIDTH              1u\r\n#define S32_SCB_CFSR_DACCVIOL(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_DACCVIOL_SHIFT))&S32_SCB_CFSR_DACCVIOL_MASK)\r\n#define S32_SCB_CFSR_MUNSTKERR_MASK              0x8u\r\n#define S32_SCB_CFSR_MUNSTKERR_SHIFT             3u\r\n#define S32_SCB_CFSR_MUNSTKERR_WIDTH             1u\r\n#define S32_SCB_CFSR_MUNSTKERR(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_MUNSTKERR_SHIFT))&S32_SCB_CFSR_MUNSTKERR_MASK)\r\n#define S32_SCB_CFSR_MSTKERR_MASK                0x10u\r\n#define S32_SCB_CFSR_MSTKERR_SHIFT               4u\r\n#define S32_SCB_CFSR_MSTKERR_WIDTH               1u\r\n#define S32_SCB_CFSR_MSTKERR(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_MSTKERR_SHIFT))&S32_SCB_CFSR_MSTKERR_MASK)\r\n#define S32_SCB_CFSR_MLSPERR_MASK                0x20u\r\n#define S32_SCB_CFSR_MLSPERR_SHIFT               5u\r\n#define S32_SCB_CFSR_MLSPERR_WIDTH               1u\r\n#define S32_SCB_CFSR_MLSPERR(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_MLSPERR_SHIFT))&S32_SCB_CFSR_MLSPERR_MASK)\r\n#define S32_SCB_CFSR_MMARVALID_MASK              0x80u\r\n#define S32_SCB_CFSR_MMARVALID_SHIFT             7u\r\n#define S32_SCB_CFSR_MMARVALID_WIDTH             1u\r\n#define S32_SCB_CFSR_MMARVALID(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_MMARVALID_SHIFT))&S32_SCB_CFSR_MMARVALID_MASK)\r\n#define S32_SCB_CFSR_IBUSERR_MASK                0x100u\r\n#define S32_SCB_CFSR_IBUSERR_SHIFT               8u\r\n#define S32_SCB_CFSR_IBUSERR_WIDTH               1u\r\n#define S32_SCB_CFSR_IBUSERR(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_IBUSERR_SHIFT))&S32_SCB_CFSR_IBUSERR_MASK)\r\n#define S32_SCB_CFSR_PRECISERR_MASK              0x200u\r\n#define S32_SCB_CFSR_PRECISERR_SHIFT             9u\r\n#define S32_SCB_CFSR_PRECISERR_WIDTH             1u\r\n#define S32_SCB_CFSR_PRECISERR(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_PRECISERR_SHIFT))&S32_SCB_CFSR_PRECISERR_MASK)\r\n#define S32_SCB_CFSR_IMPRECISERR_MASK            0x400u\r\n#define S32_SCB_CFSR_IMPRECISERR_SHIFT           10u\r\n#define S32_SCB_CFSR_IMPRECISERR_WIDTH           1u\r\n#define S32_SCB_CFSR_IMPRECISERR(x)              (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_IMPRECISERR_SHIFT))&S32_SCB_CFSR_IMPRECISERR_MASK)\r\n#define S32_SCB_CFSR_UNSTKERR_MASK               0x800u\r\n#define S32_SCB_CFSR_UNSTKERR_SHIFT              11u\r\n#define S32_SCB_CFSR_UNSTKERR_WIDTH              1u\r\n#define S32_SCB_CFSR_UNSTKERR(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_UNSTKERR_SHIFT))&S32_SCB_CFSR_UNSTKERR_MASK)\r\n#define S32_SCB_CFSR_STKERR_MASK                 0x1000u\r\n#define S32_SCB_CFSR_STKERR_SHIFT                12u\r\n#define S32_SCB_CFSR_STKERR_WIDTH                1u\r\n#define S32_SCB_CFSR_STKERR(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_STKERR_SHIFT))&S32_SCB_CFSR_STKERR_MASK)\r\n#define S32_SCB_CFSR_LSPERR_MASK                 0x2000u\r\n#define S32_SCB_CFSR_LSPERR_SHIFT                13u\r\n#define S32_SCB_CFSR_LSPERR_WIDTH                1u\r\n#define S32_SCB_CFSR_LSPERR(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_LSPERR_SHIFT))&S32_SCB_CFSR_LSPERR_MASK)\r\n#define S32_SCB_CFSR_BFARVALID_MASK              0x8000u\r\n#define S32_SCB_CFSR_BFARVALID_SHIFT             15u\r\n#define S32_SCB_CFSR_BFARVALID_WIDTH             1u\r\n#define S32_SCB_CFSR_BFARVALID(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_BFARVALID_SHIFT))&S32_SCB_CFSR_BFARVALID_MASK)\r\n#define S32_SCB_CFSR_UNDEFINSTR_MASK             0x10000u\r\n#define S32_SCB_CFSR_UNDEFINSTR_SHIFT            16u\r\n#define S32_SCB_CFSR_UNDEFINSTR_WIDTH            1u\r\n#define S32_SCB_CFSR_UNDEFINSTR(x)               (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_UNDEFINSTR_SHIFT))&S32_SCB_CFSR_UNDEFINSTR_MASK)\r\n#define S32_SCB_CFSR_INVSTATE_MASK               0x20000u\r\n#define S32_SCB_CFSR_INVSTATE_SHIFT              17u\r\n#define S32_SCB_CFSR_INVSTATE_WIDTH              1u\r\n#define S32_SCB_CFSR_INVSTATE(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_INVSTATE_SHIFT))&S32_SCB_CFSR_INVSTATE_MASK)\r\n#define S32_SCB_CFSR_INVPC_MASK                  0x40000u\r\n#define S32_SCB_CFSR_INVPC_SHIFT                 18u\r\n#define S32_SCB_CFSR_INVPC_WIDTH                 1u\r\n#define S32_SCB_CFSR_INVPC(x)                    (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_INVPC_SHIFT))&S32_SCB_CFSR_INVPC_MASK)\r\n#define S32_SCB_CFSR_NOCP_MASK                   0x80000u\r\n#define S32_SCB_CFSR_NOCP_SHIFT                  19u\r\n#define S32_SCB_CFSR_NOCP_WIDTH                  1u\r\n#define S32_SCB_CFSR_NOCP(x)                     (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_NOCP_SHIFT))&S32_SCB_CFSR_NOCP_MASK)\r\n#define S32_SCB_CFSR_UNALIGNED_MASK              0x1000000u\r\n#define S32_SCB_CFSR_UNALIGNED_SHIFT             24u\r\n#define S32_SCB_CFSR_UNALIGNED_WIDTH             1u\r\n#define S32_SCB_CFSR_UNALIGNED(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_UNALIGNED_SHIFT))&S32_SCB_CFSR_UNALIGNED_MASK)\r\n#define S32_SCB_CFSR_DIVBYZERO_MASK              0x2000000u\r\n#define S32_SCB_CFSR_DIVBYZERO_SHIFT             25u\r\n#define S32_SCB_CFSR_DIVBYZERO_WIDTH             1u\r\n#define S32_SCB_CFSR_DIVBYZERO(x)                (((uint32_t)(((uint32_t)(x))<<S32_SCB_CFSR_DIVBYZERO_SHIFT))&S32_SCB_CFSR_DIVBYZERO_MASK)\r\n/* HFSR Bit Fields */\r\n#define S32_SCB_HFSR_VECTTBL_MASK                0x2u\r\n#define S32_SCB_HFSR_VECTTBL_SHIFT               1u\r\n#define S32_SCB_HFSR_VECTTBL_WIDTH               1u\r\n#define S32_SCB_HFSR_VECTTBL(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_HFSR_VECTTBL_SHIFT))&S32_SCB_HFSR_VECTTBL_MASK)\r\n#define S32_SCB_HFSR_FORCED_MASK                 0x40000000u\r\n#define S32_SCB_HFSR_FORCED_SHIFT                30u\r\n#define S32_SCB_HFSR_FORCED_WIDTH                1u\r\n#define S32_SCB_HFSR_FORCED(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_HFSR_FORCED_SHIFT))&S32_SCB_HFSR_FORCED_MASK)\r\n#define S32_SCB_HFSR_DEBUGEVT_MASK               0x80000000u\r\n#define S32_SCB_HFSR_DEBUGEVT_SHIFT              31u\r\n#define S32_SCB_HFSR_DEBUGEVT_WIDTH              1u\r\n#define S32_SCB_HFSR_DEBUGEVT(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_HFSR_DEBUGEVT_SHIFT))&S32_SCB_HFSR_DEBUGEVT_MASK)\r\n/* DFSR Bit Fields */\r\n#define S32_SCB_DFSR_HALTED_MASK                 0x1u\r\n#define S32_SCB_DFSR_HALTED_SHIFT                0u\r\n#define S32_SCB_DFSR_HALTED_WIDTH                1u\r\n#define S32_SCB_DFSR_HALTED(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_DFSR_HALTED_SHIFT))&S32_SCB_DFSR_HALTED_MASK)\r\n#define S32_SCB_DFSR_BKPT_MASK                   0x2u\r\n#define S32_SCB_DFSR_BKPT_SHIFT                  1u\r\n#define S32_SCB_DFSR_BKPT_WIDTH                  1u\r\n#define S32_SCB_DFSR_BKPT(x)                     (((uint32_t)(((uint32_t)(x))<<S32_SCB_DFSR_BKPT_SHIFT))&S32_SCB_DFSR_BKPT_MASK)\r\n#define S32_SCB_DFSR_DWTTRAP_MASK                0x4u\r\n#define S32_SCB_DFSR_DWTTRAP_SHIFT               2u\r\n#define S32_SCB_DFSR_DWTTRAP_WIDTH               1u\r\n#define S32_SCB_DFSR_DWTTRAP(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_DFSR_DWTTRAP_SHIFT))&S32_SCB_DFSR_DWTTRAP_MASK)\r\n#define S32_SCB_DFSR_VCATCH_MASK                 0x8u\r\n#define S32_SCB_DFSR_VCATCH_SHIFT                3u\r\n#define S32_SCB_DFSR_VCATCH_WIDTH                1u\r\n#define S32_SCB_DFSR_VCATCH(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_DFSR_VCATCH_SHIFT))&S32_SCB_DFSR_VCATCH_MASK)\r\n#define S32_SCB_DFSR_EXTERNAL_MASK               0x10u\r\n#define S32_SCB_DFSR_EXTERNAL_SHIFT              4u\r\n#define S32_SCB_DFSR_EXTERNAL_WIDTH              1u\r\n#define S32_SCB_DFSR_EXTERNAL(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_DFSR_EXTERNAL_SHIFT))&S32_SCB_DFSR_EXTERNAL_MASK)\r\n/* MMFAR Bit Fields */\r\n#define S32_SCB_MMFAR_ADDRESS_MASK               0xFFFFFFFFu\r\n#define S32_SCB_MMFAR_ADDRESS_SHIFT              0u\r\n#define S32_SCB_MMFAR_ADDRESS_WIDTH              32u\r\n#define S32_SCB_MMFAR_ADDRESS(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_MMFAR_ADDRESS_SHIFT))&S32_SCB_MMFAR_ADDRESS_MASK)\r\n/* BFAR Bit Fields */\r\n#define S32_SCB_BFAR_ADDRESS_MASK                0xFFFFFFFFu\r\n#define S32_SCB_BFAR_ADDRESS_SHIFT               0u\r\n#define S32_SCB_BFAR_ADDRESS_WIDTH               32u\r\n#define S32_SCB_BFAR_ADDRESS(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_BFAR_ADDRESS_SHIFT))&S32_SCB_BFAR_ADDRESS_MASK)\r\n/* AFSR Bit Fields */\r\n#define S32_SCB_AFSR_AUXFAULT_MASK               0xFFFFFFFFu\r\n#define S32_SCB_AFSR_AUXFAULT_SHIFT              0u\r\n#define S32_SCB_AFSR_AUXFAULT_WIDTH              32u\r\n#define S32_SCB_AFSR_AUXFAULT(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_AFSR_AUXFAULT_SHIFT))&S32_SCB_AFSR_AUXFAULT_MASK)\r\n/* CPACR Bit Fields */\r\n#define S32_SCB_CPACR_CP10_MASK                  0x300000u\r\n#define S32_SCB_CPACR_CP10_SHIFT                 20u\r\n#define S32_SCB_CPACR_CP10_WIDTH                 2u\r\n#define S32_SCB_CPACR_CP10(x)                    (((uint32_t)(((uint32_t)(x))<<S32_SCB_CPACR_CP10_SHIFT))&S32_SCB_CPACR_CP10_MASK)\r\n#define S32_SCB_CPACR_CP11_MASK                  0xC00000u\r\n#define S32_SCB_CPACR_CP11_SHIFT                 22u\r\n#define S32_SCB_CPACR_CP11_WIDTH                 2u\r\n#define S32_SCB_CPACR_CP11(x)                    (((uint32_t)(((uint32_t)(x))<<S32_SCB_CPACR_CP11_SHIFT))&S32_SCB_CPACR_CP11_MASK)\r\n/* FPCCR Bit Fields */\r\n#define S32_SCB_FPCCR_LSPACT_MASK                0x1u\r\n#define S32_SCB_FPCCR_LSPACT_SHIFT               0u\r\n#define S32_SCB_FPCCR_LSPACT_WIDTH               1u\r\n#define S32_SCB_FPCCR_LSPACT(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_LSPACT_SHIFT))&S32_SCB_FPCCR_LSPACT_MASK)\r\n#define S32_SCB_FPCCR_USER_MASK                  0x2u\r\n#define S32_SCB_FPCCR_USER_SHIFT                 1u\r\n#define S32_SCB_FPCCR_USER_WIDTH                 1u\r\n#define S32_SCB_FPCCR_USER(x)                    (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_USER_SHIFT))&S32_SCB_FPCCR_USER_MASK)\r\n#define S32_SCB_FPCCR_THREAD_MASK                0x8u\r\n#define S32_SCB_FPCCR_THREAD_SHIFT               3u\r\n#define S32_SCB_FPCCR_THREAD_WIDTH               1u\r\n#define S32_SCB_FPCCR_THREAD(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_THREAD_SHIFT))&S32_SCB_FPCCR_THREAD_MASK)\r\n#define S32_SCB_FPCCR_HFRDY_MASK                 0x10u\r\n#define S32_SCB_FPCCR_HFRDY_SHIFT                4u\r\n#define S32_SCB_FPCCR_HFRDY_WIDTH                1u\r\n#define S32_SCB_FPCCR_HFRDY(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_HFRDY_SHIFT))&S32_SCB_FPCCR_HFRDY_MASK)\r\n#define S32_SCB_FPCCR_MMRDY_MASK                 0x20u\r\n#define S32_SCB_FPCCR_MMRDY_SHIFT                5u\r\n#define S32_SCB_FPCCR_MMRDY_WIDTH                1u\r\n#define S32_SCB_FPCCR_MMRDY(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_MMRDY_SHIFT))&S32_SCB_FPCCR_MMRDY_MASK)\r\n#define S32_SCB_FPCCR_BFRDY_MASK                 0x40u\r\n#define S32_SCB_FPCCR_BFRDY_SHIFT                6u\r\n#define S32_SCB_FPCCR_BFRDY_WIDTH                1u\r\n#define S32_SCB_FPCCR_BFRDY(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_BFRDY_SHIFT))&S32_SCB_FPCCR_BFRDY_MASK)\r\n#define S32_SCB_FPCCR_MONRDY_MASK                0x100u\r\n#define S32_SCB_FPCCR_MONRDY_SHIFT               8u\r\n#define S32_SCB_FPCCR_MONRDY_WIDTH               1u\r\n#define S32_SCB_FPCCR_MONRDY(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_MONRDY_SHIFT))&S32_SCB_FPCCR_MONRDY_MASK)\r\n#define S32_SCB_FPCCR_LSPEN_MASK                 0x40000000u\r\n#define S32_SCB_FPCCR_LSPEN_SHIFT                30u\r\n#define S32_SCB_FPCCR_LSPEN_WIDTH                1u\r\n#define S32_SCB_FPCCR_LSPEN(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_LSPEN_SHIFT))&S32_SCB_FPCCR_LSPEN_MASK)\r\n#define S32_SCB_FPCCR_ASPEN_MASK                 0x80000000u\r\n#define S32_SCB_FPCCR_ASPEN_SHIFT                31u\r\n#define S32_SCB_FPCCR_ASPEN_WIDTH                1u\r\n#define S32_SCB_FPCCR_ASPEN(x)                   (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCCR_ASPEN_SHIFT))&S32_SCB_FPCCR_ASPEN_MASK)\r\n/* FPCAR Bit Fields */\r\n#define S32_SCB_FPCAR_ADDRESS_MASK               0xFFFFFFF8u\r\n#define S32_SCB_FPCAR_ADDRESS_SHIFT              3u\r\n#define S32_SCB_FPCAR_ADDRESS_WIDTH              29u\r\n#define S32_SCB_FPCAR_ADDRESS(x)                 (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPCAR_ADDRESS_SHIFT))&S32_SCB_FPCAR_ADDRESS_MASK)\r\n/* FPDSCR Bit Fields */\r\n#define S32_SCB_FPDSCR_RMode_MASK                0xC00000u\r\n#define S32_SCB_FPDSCR_RMode_SHIFT               22u\r\n#define S32_SCB_FPDSCR_RMode_WIDTH               2u\r\n#define S32_SCB_FPDSCR_RMode(x)                  (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPDSCR_RMode_SHIFT))&S32_SCB_FPDSCR_RMode_MASK)\r\n#define S32_SCB_FPDSCR_FZ_MASK                   0x1000000u\r\n#define S32_SCB_FPDSCR_FZ_SHIFT                  24u\r\n#define S32_SCB_FPDSCR_FZ_WIDTH                  1u\r\n#define S32_SCB_FPDSCR_FZ(x)                     (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPDSCR_FZ_SHIFT))&S32_SCB_FPDSCR_FZ_MASK)\r\n#define S32_SCB_FPDSCR_DN_MASK                   0x2000000u\r\n#define S32_SCB_FPDSCR_DN_SHIFT                  25u\r\n#define S32_SCB_FPDSCR_DN_WIDTH                  1u\r\n#define S32_SCB_FPDSCR_DN(x)                     (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPDSCR_DN_SHIFT))&S32_SCB_FPDSCR_DN_MASK)\r\n#define S32_SCB_FPDSCR_AHP_MASK                  0x4000000u\r\n#define S32_SCB_FPDSCR_AHP_SHIFT                 26u\r\n#define S32_SCB_FPDSCR_AHP_WIDTH                 1u\r\n#define S32_SCB_FPDSCR_AHP(x)                    (((uint32_t)(((uint32_t)(x))<<S32_SCB_FPDSCR_AHP_SHIFT))&S32_SCB_FPDSCR_AHP_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group S32_SCB_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group S32_SCB_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- S32_SysTick Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup S32_SysTick_Peripheral_Access_Layer S32_SysTick Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** S32_SysTick - Size of Registers Arrays */\r\n\r\n/** S32_SysTick - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t CSR;                               /**< SysTick Control and Status Register, offset: 0x0 */\r\n  __IO uint32_t RVR;                               /**< SysTick Reload Value Register, offset: 0x4 */\r\n  __IO uint32_t CVR;                               /**< SysTick Current Value Register, offset: 0x8 */\r\n  __I  uint32_t CALIB;                             /**< SysTick Calibration Value Register, offset: 0xC */\r\n} S32_SysTick_Type, *S32_SysTick_MemMapPtr;\r\n\r\n /** Number of instances of the S32_SysTick module. */\r\n#define S32_SysTick_INSTANCE_COUNT               (1u)\r\n\r\n\r\n/* S32_SysTick - Peripheral instance base addresses */\r\n/** Peripheral S32_SysTick base address */\r\n#define S32_SysTick_BASE                         (0xE000E010u)\r\n/** Peripheral S32_SysTick base pointer */\r\n#define S32_SysTick                              ((S32_SysTick_Type *)S32_SysTick_BASE)\r\n/** Array initializer of S32_SysTick peripheral base addresses */\r\n#define S32_SysTick_BASE_ADDRS                   { S32_SysTick_BASE }\r\n/** Array initializer of S32_SysTick peripheral base pointers */\r\n#define S32_SysTick_BASE_PTRS                    { S32_SysTick }\r\n /** Number of interrupt vector arrays for the S32_SysTick module. */\r\n#define S32_SysTick_IRQS_ARR_COUNT               (1u)\r\n /** Number of interrupt channels for the S32_SysTick module. */\r\n#define S32_SysTick_IRQS_CH_COUNT                (1u)\r\n/** Interrupt vectors for the S32_SysTick peripheral type */\r\n#define S32_SysTick_IRQS                         { SysTick_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- S32_SysTick Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup S32_SysTick_Register_Masks S32_SysTick Register Masks\r\n * @{\r\n */\r\n\r\n/* CSR Bit Fields */\r\n#define S32_SysTick_CSR_ENABLE_MASK              0x1u\r\n#define S32_SysTick_CSR_ENABLE_SHIFT             0u\r\n#define S32_SysTick_CSR_ENABLE_WIDTH             1u\r\n#define S32_SysTick_CSR_ENABLE(x)                (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CSR_ENABLE_SHIFT))&S32_SysTick_CSR_ENABLE_MASK)\r\n#define S32_SysTick_CSR_TICKINT_MASK             0x2u\r\n#define S32_SysTick_CSR_TICKINT_SHIFT            1u\r\n#define S32_SysTick_CSR_TICKINT_WIDTH            1u\r\n#define S32_SysTick_CSR_TICKINT(x)               (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CSR_TICKINT_SHIFT))&S32_SysTick_CSR_TICKINT_MASK)\r\n#define S32_SysTick_CSR_CLKSOURCE_MASK           0x4u\r\n#define S32_SysTick_CSR_CLKSOURCE_SHIFT          2u\r\n#define S32_SysTick_CSR_CLKSOURCE_WIDTH          1u\r\n#define S32_SysTick_CSR_CLKSOURCE(x)             (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CSR_CLKSOURCE_SHIFT))&S32_SysTick_CSR_CLKSOURCE_MASK)\r\n#define S32_SysTick_CSR_COUNTFLAG_MASK           0x10000u\r\n#define S32_SysTick_CSR_COUNTFLAG_SHIFT          16u\r\n#define S32_SysTick_CSR_COUNTFLAG_WIDTH          1u\r\n#define S32_SysTick_CSR_COUNTFLAG(x)             (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CSR_COUNTFLAG_SHIFT))&S32_SysTick_CSR_COUNTFLAG_MASK)\r\n/* RVR Bit Fields */\r\n#define S32_SysTick_RVR_RELOAD_MASK              0xFFFFFFu\r\n#define S32_SysTick_RVR_RELOAD_SHIFT             0u\r\n#define S32_SysTick_RVR_RELOAD_WIDTH             24u\r\n#define S32_SysTick_RVR_RELOAD(x)                (((uint32_t)(((uint32_t)(x))<<S32_SysTick_RVR_RELOAD_SHIFT))&S32_SysTick_RVR_RELOAD_MASK)\r\n/* CVR Bit Fields */\r\n#define S32_SysTick_CVR_CURRENT_MASK             0xFFFFFFu\r\n#define S32_SysTick_CVR_CURRENT_SHIFT            0u\r\n#define S32_SysTick_CVR_CURRENT_WIDTH            24u\r\n#define S32_SysTick_CVR_CURRENT(x)               (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CVR_CURRENT_SHIFT))&S32_SysTick_CVR_CURRENT_MASK)\r\n/* CALIB Bit Fields */\r\n#define S32_SysTick_CALIB_TENMS_MASK             0xFFFFFFu\r\n#define S32_SysTick_CALIB_TENMS_SHIFT            0u\r\n#define S32_SysTick_CALIB_TENMS_WIDTH            24u\r\n#define S32_SysTick_CALIB_TENMS(x)               (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CALIB_TENMS_SHIFT))&S32_SysTick_CALIB_TENMS_MASK)\r\n#define S32_SysTick_CALIB_SKEW_MASK              0x40000000u\r\n#define S32_SysTick_CALIB_SKEW_SHIFT             30u\r\n#define S32_SysTick_CALIB_SKEW_WIDTH             1u\r\n#define S32_SysTick_CALIB_SKEW(x)                (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CALIB_SKEW_SHIFT))&S32_SysTick_CALIB_SKEW_MASK)\r\n#define S32_SysTick_CALIB_NOREF_MASK             0x80000000u\r\n#define S32_SysTick_CALIB_NOREF_SHIFT            31u\r\n#define S32_SysTick_CALIB_NOREF_WIDTH            1u\r\n#define S32_SysTick_CALIB_NOREF(x)               (((uint32_t)(((uint32_t)(x))<<S32_SysTick_CALIB_NOREF_SHIFT))&S32_SysTick_CALIB_NOREF_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group S32_SysTick_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group S32_SysTick_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- SCG Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup SCG_Peripheral_Access_Layer SCG Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** SCG - Size of Registers Arrays */\r\n\r\n/** SCG - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< Parameter Register, offset: 0x4 */\r\n       uint8_t RESERVED_0[8];\r\n  __I  uint32_t CSR;                               /**< Clock Status Register, offset: 0x10 */\r\n  __IO uint32_t RCCR;                              /**< Run Clock Control Register, offset: 0x14 */\r\n  __IO uint32_t VCCR;                              /**< VLPR Clock Control Register, offset: 0x18 */\r\n  __IO uint32_t HCCR;                              /**< HSRUN Clock Control Register, offset: 0x1C */\r\n  __IO uint32_t CLKOUTCNFG;                        /**< SCG CLKOUT Configuration Register, offset: 0x20 */\r\n       uint8_t RESERVED_1[220];\r\n  __IO uint32_t SOSCCSR;                           /**< System OSC Control Status Register, offset: 0x100 */\r\n  __IO uint32_t SOSCDIV;                           /**< System OSC Divide Register, offset: 0x104 */\r\n  __IO uint32_t SOSCCFG;                           /**< System Oscillator Configuration Register, offset: 0x108 */\r\n       uint8_t RESERVED_2[244];\r\n  __IO uint32_t SIRCCSR;                           /**< Slow IRC Control Status Register, offset: 0x200 */\r\n  __IO uint32_t SIRCDIV;                           /**< Slow IRC Divide Register, offset: 0x204 */\r\n  __IO uint32_t SIRCCFG;                           /**< Slow IRC Configuration Register, offset: 0x208 */\r\n       uint8_t RESERVED_3[244];\r\n  __IO uint32_t FIRCCSR;                           /**< Fast IRC Control Status Register, offset: 0x300 */\r\n  __IO uint32_t FIRCDIV;                           /**< Fast IRC Divide Register, offset: 0x304 */\r\n  __IO uint32_t FIRCCFG;                           /**< Fast IRC Configuration Register, offset: 0x308 */\r\n       uint8_t RESERVED_4[756];\r\n  __IO uint32_t SPLLCSR;                           /**< System PLL Control Status Register, offset: 0x600 */\r\n  __IO uint32_t SPLLDIV;                           /**< System PLL Divide Register, offset: 0x604 */\r\n  __IO uint32_t SPLLCFG;                           /**< System PLL Configuration Register, offset: 0x608 */\r\n} SCG_Type, *SCG_MemMapPtr;\r\n\r\n /** Number of instances of the SCG module. */\r\n#define SCG_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* SCG - Peripheral instance base addresses */\r\n/** Peripheral SCG base address */\r\n#define SCG_BASE                                 (0x40064000u)\r\n/** Peripheral SCG base pointer */\r\n#define SCG                                      ((SCG_Type *)SCG_BASE)\r\n/** Array initializer of SCG peripheral base addresses */\r\n#define SCG_BASE_ADDRS                           { SCG_BASE }\r\n/** Array initializer of SCG peripheral base pointers */\r\n#define SCG_BASE_PTRS                            { SCG }\r\n /** Number of interrupt vector arrays for the SCG module. */\r\n#define SCG_IRQS_ARR_COUNT                       (1u)\r\n /** Number of interrupt channels for the SCG module. */\r\n#define SCG_IRQS_CH_COUNT                        (1u)\r\n/** Interrupt vectors for the SCG peripheral type */\r\n#define SCG_IRQS                                 { SCG_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- SCG Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup SCG_Register_Masks SCG Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define SCG_VERID_VERSION_MASK                   0xFFFFFFFFu\r\n#define SCG_VERID_VERSION_SHIFT                  0u\r\n#define SCG_VERID_VERSION_WIDTH                  32u\r\n#define SCG_VERID_VERSION(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_VERID_VERSION_SHIFT))&SCG_VERID_VERSION_MASK)\r\n/* PARAM Bit Fields */\r\n#define SCG_PARAM_CLKPRES_MASK                   0xFFu\r\n#define SCG_PARAM_CLKPRES_SHIFT                  0u\r\n#define SCG_PARAM_CLKPRES_WIDTH                  8u\r\n#define SCG_PARAM_CLKPRES(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_PARAM_CLKPRES_SHIFT))&SCG_PARAM_CLKPRES_MASK)\r\n#define SCG_PARAM_DIVPRES_MASK                   0xF8000000u\r\n#define SCG_PARAM_DIVPRES_SHIFT                  27u\r\n#define SCG_PARAM_DIVPRES_WIDTH                  5u\r\n#define SCG_PARAM_DIVPRES(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_PARAM_DIVPRES_SHIFT))&SCG_PARAM_DIVPRES_MASK)\r\n/* CSR Bit Fields */\r\n#define SCG_CSR_DIVSLOW_MASK                     0xFu\r\n#define SCG_CSR_DIVSLOW_SHIFT                    0u\r\n#define SCG_CSR_DIVSLOW_WIDTH                    4u\r\n#define SCG_CSR_DIVSLOW(x)                       (((uint32_t)(((uint32_t)(x))<<SCG_CSR_DIVSLOW_SHIFT))&SCG_CSR_DIVSLOW_MASK)\r\n#define SCG_CSR_DIVBUS_MASK                      0xF0u\r\n#define SCG_CSR_DIVBUS_SHIFT                     4u\r\n#define SCG_CSR_DIVBUS_WIDTH                     4u\r\n#define SCG_CSR_DIVBUS(x)                        (((uint32_t)(((uint32_t)(x))<<SCG_CSR_DIVBUS_SHIFT))&SCG_CSR_DIVBUS_MASK)\r\n#define SCG_CSR_DIVCORE_MASK                     0xF0000u\r\n#define SCG_CSR_DIVCORE_SHIFT                    16u\r\n#define SCG_CSR_DIVCORE_WIDTH                    4u\r\n#define SCG_CSR_DIVCORE(x)                       (((uint32_t)(((uint32_t)(x))<<SCG_CSR_DIVCORE_SHIFT))&SCG_CSR_DIVCORE_MASK)\r\n#define SCG_CSR_SCS_MASK                         0xF000000u\r\n#define SCG_CSR_SCS_SHIFT                        24u\r\n#define SCG_CSR_SCS_WIDTH                        4u\r\n#define SCG_CSR_SCS(x)                           (((uint32_t)(((uint32_t)(x))<<SCG_CSR_SCS_SHIFT))&SCG_CSR_SCS_MASK)\r\n/* RCCR Bit Fields */\r\n#define SCG_RCCR_DIVSLOW_MASK                    0xFu\r\n#define SCG_RCCR_DIVSLOW_SHIFT                   0u\r\n#define SCG_RCCR_DIVSLOW_WIDTH                   4u\r\n#define SCG_RCCR_DIVSLOW(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_RCCR_DIVSLOW_SHIFT))&SCG_RCCR_DIVSLOW_MASK)\r\n#define SCG_RCCR_DIVBUS_MASK                     0xF0u\r\n#define SCG_RCCR_DIVBUS_SHIFT                    4u\r\n#define SCG_RCCR_DIVBUS_WIDTH                    4u\r\n#define SCG_RCCR_DIVBUS(x)                       (((uint32_t)(((uint32_t)(x))<<SCG_RCCR_DIVBUS_SHIFT))&SCG_RCCR_DIVBUS_MASK)\r\n#define SCG_RCCR_DIVCORE_MASK                    0xF0000u\r\n#define SCG_RCCR_DIVCORE_SHIFT                   16u\r\n#define SCG_RCCR_DIVCORE_WIDTH                   4u\r\n#define SCG_RCCR_DIVCORE(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_RCCR_DIVCORE_SHIFT))&SCG_RCCR_DIVCORE_MASK)\r\n#define SCG_RCCR_SCS_MASK                        0xF000000u\r\n#define SCG_RCCR_SCS_SHIFT                       24u\r\n#define SCG_RCCR_SCS_WIDTH                       4u\r\n#define SCG_RCCR_SCS(x)                          (((uint32_t)(((uint32_t)(x))<<SCG_RCCR_SCS_SHIFT))&SCG_RCCR_SCS_MASK)\r\n/* VCCR Bit Fields */\r\n#define SCG_VCCR_DIVSLOW_MASK                    0xFu\r\n#define SCG_VCCR_DIVSLOW_SHIFT                   0u\r\n#define SCG_VCCR_DIVSLOW_WIDTH                   4u\r\n#define SCG_VCCR_DIVSLOW(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_VCCR_DIVSLOW_SHIFT))&SCG_VCCR_DIVSLOW_MASK)\r\n#define SCG_VCCR_DIVBUS_MASK                     0xF0u\r\n#define SCG_VCCR_DIVBUS_SHIFT                    4u\r\n#define SCG_VCCR_DIVBUS_WIDTH                    4u\r\n#define SCG_VCCR_DIVBUS(x)                       (((uint32_t)(((uint32_t)(x))<<SCG_VCCR_DIVBUS_SHIFT))&SCG_VCCR_DIVBUS_MASK)\r\n#define SCG_VCCR_DIVCORE_MASK                    0xF0000u\r\n#define SCG_VCCR_DIVCORE_SHIFT                   16u\r\n#define SCG_VCCR_DIVCORE_WIDTH                   4u\r\n#define SCG_VCCR_DIVCORE(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_VCCR_DIVCORE_SHIFT))&SCG_VCCR_DIVCORE_MASK)\r\n#define SCG_VCCR_SCS_MASK                        0xF000000u\r\n#define SCG_VCCR_SCS_SHIFT                       24u\r\n#define SCG_VCCR_SCS_WIDTH                       4u\r\n#define SCG_VCCR_SCS(x)                          (((uint32_t)(((uint32_t)(x))<<SCG_VCCR_SCS_SHIFT))&SCG_VCCR_SCS_MASK)\r\n/* HCCR Bit Fields */\r\n#define SCG_HCCR_DIVSLOW_MASK                    0xFu\r\n#define SCG_HCCR_DIVSLOW_SHIFT                   0u\r\n#define SCG_HCCR_DIVSLOW_WIDTH                   4u\r\n#define SCG_HCCR_DIVSLOW(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_HCCR_DIVSLOW_SHIFT))&SCG_HCCR_DIVSLOW_MASK)\r\n#define SCG_HCCR_DIVBUS_MASK                     0xF0u\r\n#define SCG_HCCR_DIVBUS_SHIFT                    4u\r\n#define SCG_HCCR_DIVBUS_WIDTH                    4u\r\n#define SCG_HCCR_DIVBUS(x)                       (((uint32_t)(((uint32_t)(x))<<SCG_HCCR_DIVBUS_SHIFT))&SCG_HCCR_DIVBUS_MASK)\r\n#define SCG_HCCR_DIVCORE_MASK                    0xF0000u\r\n#define SCG_HCCR_DIVCORE_SHIFT                   16u\r\n#define SCG_HCCR_DIVCORE_WIDTH                   4u\r\n#define SCG_HCCR_DIVCORE(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_HCCR_DIVCORE_SHIFT))&SCG_HCCR_DIVCORE_MASK)\r\n#define SCG_HCCR_SCS_MASK                        0xF000000u\r\n#define SCG_HCCR_SCS_SHIFT                       24u\r\n#define SCG_HCCR_SCS_WIDTH                       4u\r\n#define SCG_HCCR_SCS(x)                          (((uint32_t)(((uint32_t)(x))<<SCG_HCCR_SCS_SHIFT))&SCG_HCCR_SCS_MASK)\r\n/* CLKOUTCNFG Bit Fields */\r\n#define SCG_CLKOUTCNFG_CLKOUTSEL_MASK            0xF000000u\r\n#define SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT           24u\r\n#define SCG_CLKOUTCNFG_CLKOUTSEL_WIDTH           4u\r\n#define SCG_CLKOUTCNFG_CLKOUTSEL(x)              (((uint32_t)(((uint32_t)(x))<<SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT))&SCG_CLKOUTCNFG_CLKOUTSEL_MASK)\r\n/* SOSCCSR Bit Fields */\r\n#define SCG_SOSCCSR_SOSCEN_MASK                  0x1u\r\n#define SCG_SOSCCSR_SOSCEN_SHIFT                 0u\r\n#define SCG_SOSCCSR_SOSCEN_WIDTH                 1u\r\n#define SCG_SOSCCSR_SOSCEN(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_SOSCEN_SHIFT))&SCG_SOSCCSR_SOSCEN_MASK)\r\n#define SCG_SOSCCSR_SOSCCM_MASK                  0x10000u\r\n#define SCG_SOSCCSR_SOSCCM_SHIFT                 16u\r\n#define SCG_SOSCCSR_SOSCCM_WIDTH                 1u\r\n#define SCG_SOSCCSR_SOSCCM(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_SOSCCM_SHIFT))&SCG_SOSCCSR_SOSCCM_MASK)\r\n#define SCG_SOSCCSR_SOSCCMRE_MASK                0x20000u\r\n#define SCG_SOSCCSR_SOSCCMRE_SHIFT               17u\r\n#define SCG_SOSCCSR_SOSCCMRE_WIDTH               1u\r\n#define SCG_SOSCCSR_SOSCCMRE(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_SOSCCMRE_SHIFT))&SCG_SOSCCSR_SOSCCMRE_MASK)\r\n#define SCG_SOSCCSR_LK_MASK                      0x800000u\r\n#define SCG_SOSCCSR_LK_SHIFT                     23u\r\n#define SCG_SOSCCSR_LK_WIDTH                     1u\r\n#define SCG_SOSCCSR_LK(x)                        (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_LK_SHIFT))&SCG_SOSCCSR_LK_MASK)\r\n#define SCG_SOSCCSR_SOSCVLD_MASK                 0x1000000u\r\n#define SCG_SOSCCSR_SOSCVLD_SHIFT                24u\r\n#define SCG_SOSCCSR_SOSCVLD_WIDTH                1u\r\n#define SCG_SOSCCSR_SOSCVLD(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_SOSCVLD_SHIFT))&SCG_SOSCCSR_SOSCVLD_MASK)\r\n#define SCG_SOSCCSR_SOSCSEL_MASK                 0x2000000u\r\n#define SCG_SOSCCSR_SOSCSEL_SHIFT                25u\r\n#define SCG_SOSCCSR_SOSCSEL_WIDTH                1u\r\n#define SCG_SOSCCSR_SOSCSEL(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_SOSCSEL_SHIFT))&SCG_SOSCCSR_SOSCSEL_MASK)\r\n#define SCG_SOSCCSR_SOSCERR_MASK                 0x4000000u\r\n#define SCG_SOSCCSR_SOSCERR_SHIFT                26u\r\n#define SCG_SOSCCSR_SOSCERR_WIDTH                1u\r\n#define SCG_SOSCCSR_SOSCERR(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCSR_SOSCERR_SHIFT))&SCG_SOSCCSR_SOSCERR_MASK)\r\n/* SOSCDIV Bit Fields */\r\n#define SCG_SOSCDIV_SOSCDIV1_MASK                0x7u\r\n#define SCG_SOSCDIV_SOSCDIV1_SHIFT               0u\r\n#define SCG_SOSCDIV_SOSCDIV1_WIDTH               3u\r\n#define SCG_SOSCDIV_SOSCDIV1(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SOSCDIV_SOSCDIV1_SHIFT))&SCG_SOSCDIV_SOSCDIV1_MASK)\r\n#define SCG_SOSCDIV_SOSCDIV2_MASK                0x700u\r\n#define SCG_SOSCDIV_SOSCDIV2_SHIFT               8u\r\n#define SCG_SOSCDIV_SOSCDIV2_WIDTH               3u\r\n#define SCG_SOSCDIV_SOSCDIV2(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SOSCDIV_SOSCDIV2_SHIFT))&SCG_SOSCDIV_SOSCDIV2_MASK)\r\n/* SOSCCFG Bit Fields */\r\n#define SCG_SOSCCFG_EREFS_MASK                   0x4u\r\n#define SCG_SOSCCFG_EREFS_SHIFT                  2u\r\n#define SCG_SOSCCFG_EREFS_WIDTH                  1u\r\n#define SCG_SOSCCFG_EREFS(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCFG_EREFS_SHIFT))&SCG_SOSCCFG_EREFS_MASK)\r\n#define SCG_SOSCCFG_HGO_MASK                     0x8u\r\n#define SCG_SOSCCFG_HGO_SHIFT                    3u\r\n#define SCG_SOSCCFG_HGO_WIDTH                    1u\r\n#define SCG_SOSCCFG_HGO(x)                       (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCFG_HGO_SHIFT))&SCG_SOSCCFG_HGO_MASK)\r\n#define SCG_SOSCCFG_RANGE_MASK                   0x30u\r\n#define SCG_SOSCCFG_RANGE_SHIFT                  4u\r\n#define SCG_SOSCCFG_RANGE_WIDTH                  2u\r\n#define SCG_SOSCCFG_RANGE(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_SOSCCFG_RANGE_SHIFT))&SCG_SOSCCFG_RANGE_MASK)\r\n/* SIRCCSR Bit Fields */\r\n#define SCG_SIRCCSR_SIRCEN_MASK                  0x1u\r\n#define SCG_SIRCCSR_SIRCEN_SHIFT                 0u\r\n#define SCG_SIRCCSR_SIRCEN_WIDTH                 1u\r\n#define SCG_SIRCCSR_SIRCEN(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCSR_SIRCEN_SHIFT))&SCG_SIRCCSR_SIRCEN_MASK)\r\n#define SCG_SIRCCSR_SIRCSTEN_MASK                0x2u\r\n#define SCG_SIRCCSR_SIRCSTEN_SHIFT               1u\r\n#define SCG_SIRCCSR_SIRCSTEN_WIDTH               1u\r\n#define SCG_SIRCCSR_SIRCSTEN(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCSR_SIRCSTEN_SHIFT))&SCG_SIRCCSR_SIRCSTEN_MASK)\r\n#define SCG_SIRCCSR_SIRCLPEN_MASK                0x4u\r\n#define SCG_SIRCCSR_SIRCLPEN_SHIFT               2u\r\n#define SCG_SIRCCSR_SIRCLPEN_WIDTH               1u\r\n#define SCG_SIRCCSR_SIRCLPEN(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCSR_SIRCLPEN_SHIFT))&SCG_SIRCCSR_SIRCLPEN_MASK)\r\n#define SCG_SIRCCSR_LK_MASK                      0x800000u\r\n#define SCG_SIRCCSR_LK_SHIFT                     23u\r\n#define SCG_SIRCCSR_LK_WIDTH                     1u\r\n#define SCG_SIRCCSR_LK(x)                        (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCSR_LK_SHIFT))&SCG_SIRCCSR_LK_MASK)\r\n#define SCG_SIRCCSR_SIRCVLD_MASK                 0x1000000u\r\n#define SCG_SIRCCSR_SIRCVLD_SHIFT                24u\r\n#define SCG_SIRCCSR_SIRCVLD_WIDTH                1u\r\n#define SCG_SIRCCSR_SIRCVLD(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCSR_SIRCVLD_SHIFT))&SCG_SIRCCSR_SIRCVLD_MASK)\r\n#define SCG_SIRCCSR_SIRCSEL_MASK                 0x2000000u\r\n#define SCG_SIRCCSR_SIRCSEL_SHIFT                25u\r\n#define SCG_SIRCCSR_SIRCSEL_WIDTH                1u\r\n#define SCG_SIRCCSR_SIRCSEL(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCSR_SIRCSEL_SHIFT))&SCG_SIRCCSR_SIRCSEL_MASK)\r\n/* SIRCDIV Bit Fields */\r\n#define SCG_SIRCDIV_SIRCDIV1_MASK                0x7u\r\n#define SCG_SIRCDIV_SIRCDIV1_SHIFT               0u\r\n#define SCG_SIRCDIV_SIRCDIV1_WIDTH               3u\r\n#define SCG_SIRCDIV_SIRCDIV1(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SIRCDIV_SIRCDIV1_SHIFT))&SCG_SIRCDIV_SIRCDIV1_MASK)\r\n#define SCG_SIRCDIV_SIRCDIV2_MASK                0x700u\r\n#define SCG_SIRCDIV_SIRCDIV2_SHIFT               8u\r\n#define SCG_SIRCDIV_SIRCDIV2_WIDTH               3u\r\n#define SCG_SIRCDIV_SIRCDIV2(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SIRCDIV_SIRCDIV2_SHIFT))&SCG_SIRCDIV_SIRCDIV2_MASK)\r\n/* SIRCCFG Bit Fields */\r\n#define SCG_SIRCCFG_RANGE_MASK                   0x1u\r\n#define SCG_SIRCCFG_RANGE_SHIFT                  0u\r\n#define SCG_SIRCCFG_RANGE_WIDTH                  1u\r\n#define SCG_SIRCCFG_RANGE(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_SIRCCFG_RANGE_SHIFT))&SCG_SIRCCFG_RANGE_MASK)\r\n/* FIRCCSR Bit Fields */\r\n#define SCG_FIRCCSR_FIRCEN_MASK                  0x1u\r\n#define SCG_FIRCCSR_FIRCEN_SHIFT                 0u\r\n#define SCG_FIRCCSR_FIRCEN_WIDTH                 1u\r\n#define SCG_FIRCCSR_FIRCEN(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCSR_FIRCEN_SHIFT))&SCG_FIRCCSR_FIRCEN_MASK)\r\n#define SCG_FIRCCSR_FIRCREGOFF_MASK              0x8u\r\n#define SCG_FIRCCSR_FIRCREGOFF_SHIFT             3u\r\n#define SCG_FIRCCSR_FIRCREGOFF_WIDTH             1u\r\n#define SCG_FIRCCSR_FIRCREGOFF(x)                (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCSR_FIRCREGOFF_SHIFT))&SCG_FIRCCSR_FIRCREGOFF_MASK)\r\n#define SCG_FIRCCSR_LK_MASK                      0x800000u\r\n#define SCG_FIRCCSR_LK_SHIFT                     23u\r\n#define SCG_FIRCCSR_LK_WIDTH                     1u\r\n#define SCG_FIRCCSR_LK(x)                        (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCSR_LK_SHIFT))&SCG_FIRCCSR_LK_MASK)\r\n#define SCG_FIRCCSR_FIRCVLD_MASK                 0x1000000u\r\n#define SCG_FIRCCSR_FIRCVLD_SHIFT                24u\r\n#define SCG_FIRCCSR_FIRCVLD_WIDTH                1u\r\n#define SCG_FIRCCSR_FIRCVLD(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCSR_FIRCVLD_SHIFT))&SCG_FIRCCSR_FIRCVLD_MASK)\r\n#define SCG_FIRCCSR_FIRCSEL_MASK                 0x2000000u\r\n#define SCG_FIRCCSR_FIRCSEL_SHIFT                25u\r\n#define SCG_FIRCCSR_FIRCSEL_WIDTH                1u\r\n#define SCG_FIRCCSR_FIRCSEL(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCSR_FIRCSEL_SHIFT))&SCG_FIRCCSR_FIRCSEL_MASK)\r\n#define SCG_FIRCCSR_FIRCERR_MASK                 0x4000000u\r\n#define SCG_FIRCCSR_FIRCERR_SHIFT                26u\r\n#define SCG_FIRCCSR_FIRCERR_WIDTH                1u\r\n#define SCG_FIRCCSR_FIRCERR(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCSR_FIRCERR_SHIFT))&SCG_FIRCCSR_FIRCERR_MASK)\r\n/* FIRCDIV Bit Fields */\r\n#define SCG_FIRCDIV_FIRCDIV1_MASK                0x7u\r\n#define SCG_FIRCDIV_FIRCDIV1_SHIFT               0u\r\n#define SCG_FIRCDIV_FIRCDIV1_WIDTH               3u\r\n#define SCG_FIRCDIV_FIRCDIV1(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_FIRCDIV_FIRCDIV1_SHIFT))&SCG_FIRCDIV_FIRCDIV1_MASK)\r\n#define SCG_FIRCDIV_FIRCDIV2_MASK                0x700u\r\n#define SCG_FIRCDIV_FIRCDIV2_SHIFT               8u\r\n#define SCG_FIRCDIV_FIRCDIV2_WIDTH               3u\r\n#define SCG_FIRCDIV_FIRCDIV2(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_FIRCDIV_FIRCDIV2_SHIFT))&SCG_FIRCDIV_FIRCDIV2_MASK)\r\n/* FIRCCFG Bit Fields */\r\n#define SCG_FIRCCFG_RANGE_MASK                   0x3u\r\n#define SCG_FIRCCFG_RANGE_SHIFT                  0u\r\n#define SCG_FIRCCFG_RANGE_WIDTH                  2u\r\n#define SCG_FIRCCFG_RANGE(x)                     (((uint32_t)(((uint32_t)(x))<<SCG_FIRCCFG_RANGE_SHIFT))&SCG_FIRCCFG_RANGE_MASK)\r\n/* SPLLCSR Bit Fields */\r\n#define SCG_SPLLCSR_SPLLEN_MASK                  0x1u\r\n#define SCG_SPLLCSR_SPLLEN_SHIFT                 0u\r\n#define SCG_SPLLCSR_SPLLEN_WIDTH                 1u\r\n#define SCG_SPLLCSR_SPLLEN(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_SPLLEN_SHIFT))&SCG_SPLLCSR_SPLLEN_MASK)\r\n#define SCG_SPLLCSR_SPLLCM_MASK                  0x10000u\r\n#define SCG_SPLLCSR_SPLLCM_SHIFT                 16u\r\n#define SCG_SPLLCSR_SPLLCM_WIDTH                 1u\r\n#define SCG_SPLLCSR_SPLLCM(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_SPLLCM_SHIFT))&SCG_SPLLCSR_SPLLCM_MASK)\r\n#define SCG_SPLLCSR_SPLLCMRE_MASK                0x20000u\r\n#define SCG_SPLLCSR_SPLLCMRE_SHIFT               17u\r\n#define SCG_SPLLCSR_SPLLCMRE_WIDTH               1u\r\n#define SCG_SPLLCSR_SPLLCMRE(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_SPLLCMRE_SHIFT))&SCG_SPLLCSR_SPLLCMRE_MASK)\r\n#define SCG_SPLLCSR_LK_MASK                      0x800000u\r\n#define SCG_SPLLCSR_LK_SHIFT                     23u\r\n#define SCG_SPLLCSR_LK_WIDTH                     1u\r\n#define SCG_SPLLCSR_LK(x)                        (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_LK_SHIFT))&SCG_SPLLCSR_LK_MASK)\r\n#define SCG_SPLLCSR_SPLLVLD_MASK                 0x1000000u\r\n#define SCG_SPLLCSR_SPLLVLD_SHIFT                24u\r\n#define SCG_SPLLCSR_SPLLVLD_WIDTH                1u\r\n#define SCG_SPLLCSR_SPLLVLD(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_SPLLVLD_SHIFT))&SCG_SPLLCSR_SPLLVLD_MASK)\r\n#define SCG_SPLLCSR_SPLLSEL_MASK                 0x2000000u\r\n#define SCG_SPLLCSR_SPLLSEL_SHIFT                25u\r\n#define SCG_SPLLCSR_SPLLSEL_WIDTH                1u\r\n#define SCG_SPLLCSR_SPLLSEL(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_SPLLSEL_SHIFT))&SCG_SPLLCSR_SPLLSEL_MASK)\r\n#define SCG_SPLLCSR_SPLLERR_MASK                 0x4000000u\r\n#define SCG_SPLLCSR_SPLLERR_SHIFT                26u\r\n#define SCG_SPLLCSR_SPLLERR_WIDTH                1u\r\n#define SCG_SPLLCSR_SPLLERR(x)                   (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCSR_SPLLERR_SHIFT))&SCG_SPLLCSR_SPLLERR_MASK)\r\n/* SPLLDIV Bit Fields */\r\n#define SCG_SPLLDIV_SPLLDIV1_MASK                0x7u\r\n#define SCG_SPLLDIV_SPLLDIV1_SHIFT               0u\r\n#define SCG_SPLLDIV_SPLLDIV1_WIDTH               3u\r\n#define SCG_SPLLDIV_SPLLDIV1(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SPLLDIV_SPLLDIV1_SHIFT))&SCG_SPLLDIV_SPLLDIV1_MASK)\r\n#define SCG_SPLLDIV_SPLLDIV2_MASK                0x700u\r\n#define SCG_SPLLDIV_SPLLDIV2_SHIFT               8u\r\n#define SCG_SPLLDIV_SPLLDIV2_WIDTH               3u\r\n#define SCG_SPLLDIV_SPLLDIV2(x)                  (((uint32_t)(((uint32_t)(x))<<SCG_SPLLDIV_SPLLDIV2_SHIFT))&SCG_SPLLDIV_SPLLDIV2_MASK)\r\n/* SPLLCFG Bit Fields */\r\n#define SCG_SPLLCFG_PREDIV_MASK                  0x700u\r\n#define SCG_SPLLCFG_PREDIV_SHIFT                 8u\r\n#define SCG_SPLLCFG_PREDIV_WIDTH                 3u\r\n#define SCG_SPLLCFG_PREDIV(x)                    (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCFG_PREDIV_SHIFT))&SCG_SPLLCFG_PREDIV_MASK)\r\n#define SCG_SPLLCFG_MULT_MASK                    0x1F0000u\r\n#define SCG_SPLLCFG_MULT_SHIFT                   16u\r\n#define SCG_SPLLCFG_MULT_WIDTH                   5u\r\n#define SCG_SPLLCFG_MULT(x)                      (((uint32_t)(((uint32_t)(x))<<SCG_SPLLCFG_MULT_SHIFT))&SCG_SPLLCFG_MULT_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group SCG_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group SCG_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- SIM Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup SIM_Peripheral_Access_Layer SIM Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** SIM - Size of Registers Arrays */\r\n\r\n/** SIM - Register Layout Typedef */\r\ntypedef struct {\r\n       uint8_t RESERVED_0[4];\r\n  __IO uint32_t CHIPCTL;                           /**< Chip Control register, offset: 0x4 */\r\n       uint8_t RESERVED_1[4];\r\n  __IO uint32_t FTMOPT0;                           /**< FTM Option Register 0, offset: 0xC */\r\n  __IO uint32_t LPOCLKS;                           /**< LPO Clock Select Register, offset: 0x10 */\r\n       uint8_t RESERVED_2[4];\r\n  __IO uint32_t ADCOPT;                            /**< ADC Options Register, offset: 0x18 */\r\n  __IO uint32_t FTMOPT1;                           /**< FTM Option Register 1, offset: 0x1C */\r\n  __IO uint32_t MISCTRL0;                          /**< Miscellaneous control register 0, offset: 0x20 */\r\n  __I  uint32_t SDID;                              /**< System Device Identification Register, offset: 0x24 */\r\n       uint8_t RESERVED_3[24];\r\n  __IO uint32_t PLATCGC;                           /**< Platform Clock Gating Control Register, offset: 0x40 */\r\n       uint8_t RESERVED_4[8];\r\n  __IO uint32_t FCFG1;                             /**< Flash Configuration Register 1, offset: 0x4C */\r\n       uint8_t RESERVED_5[4];\r\n  __I  uint32_t UIDH;                              /**< Unique Identification Register High, offset: 0x54 */\r\n  __I  uint32_t UIDMH;                             /**< Unique Identification Register Mid-High, offset: 0x58 */\r\n  __I  uint32_t UIDML;                             /**< Unique Identification Register Mid Low, offset: 0x5C */\r\n  __I  uint32_t UIDL;                              /**< Unique Identification Register Low, offset: 0x60 */\r\n       uint8_t RESERVED_6[4];\r\n  __IO uint32_t CLKDIV4;                           /**< System Clock Divider Register 4, offset: 0x68 */\r\n  __IO uint32_t MISCTRL1;                          /**< Miscellaneous Control register 1, offset: 0x6C */\r\n} SIM_Type, *SIM_MemMapPtr;\r\n\r\n /** Number of instances of the SIM module. */\r\n#define SIM_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* SIM - Peripheral instance base addresses */\r\n/** Peripheral SIM base address */\r\n#define SIM_BASE                                 (0x40048000u)\r\n/** Peripheral SIM base pointer */\r\n#define SIM                                      ((SIM_Type *)SIM_BASE)\r\n/** Array initializer of SIM peripheral base addresses */\r\n#define SIM_BASE_ADDRS                           { SIM_BASE }\r\n/** Array initializer of SIM peripheral base pointers */\r\n#define SIM_BASE_PTRS                            { SIM }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- SIM Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup SIM_Register_Masks SIM Register Masks\r\n * @{\r\n */\r\n\r\n/* CHIPCTL Bit Fields */\r\n#define SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK       0xFu\r\n#define SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT      0u\r\n#define SIM_CHIPCTL_ADC_INTERLEAVE_EN_WIDTH      4u\r\n#define SIM_CHIPCTL_ADC_INTERLEAVE_EN(x)         (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT))&SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK)\r\n#define SIM_CHIPCTL_CLKOUTSEL_MASK               0xF0u\r\n#define SIM_CHIPCTL_CLKOUTSEL_SHIFT              4u\r\n#define SIM_CHIPCTL_CLKOUTSEL_WIDTH              4u\r\n#define SIM_CHIPCTL_CLKOUTSEL(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_CLKOUTSEL_SHIFT))&SIM_CHIPCTL_CLKOUTSEL_MASK)\r\n#define SIM_CHIPCTL_CLKOUTDIV_MASK               0x700u\r\n#define SIM_CHIPCTL_CLKOUTDIV_SHIFT              8u\r\n#define SIM_CHIPCTL_CLKOUTDIV_WIDTH              3u\r\n#define SIM_CHIPCTL_CLKOUTDIV(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_CLKOUTDIV_SHIFT))&SIM_CHIPCTL_CLKOUTDIV_MASK)\r\n#define SIM_CHIPCTL_CLKOUTEN_MASK                0x800u\r\n#define SIM_CHIPCTL_CLKOUTEN_SHIFT               11u\r\n#define SIM_CHIPCTL_CLKOUTEN_WIDTH               1u\r\n#define SIM_CHIPCTL_CLKOUTEN(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_CLKOUTEN_SHIFT))&SIM_CHIPCTL_CLKOUTEN_MASK)\r\n#define SIM_CHIPCTL_TRACECLK_SEL_MASK            0x1000u\r\n#define SIM_CHIPCTL_TRACECLK_SEL_SHIFT           12u\r\n#define SIM_CHIPCTL_TRACECLK_SEL_WIDTH           1u\r\n#define SIM_CHIPCTL_TRACECLK_SEL(x)              (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_TRACECLK_SEL_SHIFT))&SIM_CHIPCTL_TRACECLK_SEL_MASK)\r\n#define SIM_CHIPCTL_PDB_BB_SEL_MASK              0x2000u\r\n#define SIM_CHIPCTL_PDB_BB_SEL_SHIFT             13u\r\n#define SIM_CHIPCTL_PDB_BB_SEL_WIDTH             1u\r\n#define SIM_CHIPCTL_PDB_BB_SEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_PDB_BB_SEL_SHIFT))&SIM_CHIPCTL_PDB_BB_SEL_MASK)\r\n#define SIM_CHIPCTL_ADC_SUPPLY_MASK              0x70000u\r\n#define SIM_CHIPCTL_ADC_SUPPLY_SHIFT             16u\r\n#define SIM_CHIPCTL_ADC_SUPPLY_WIDTH             3u\r\n#define SIM_CHIPCTL_ADC_SUPPLY(x)                (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_ADC_SUPPLY_SHIFT))&SIM_CHIPCTL_ADC_SUPPLY_MASK)\r\n#define SIM_CHIPCTL_ADC_SUPPLYEN_MASK            0x80000u\r\n#define SIM_CHIPCTL_ADC_SUPPLYEN_SHIFT           19u\r\n#define SIM_CHIPCTL_ADC_SUPPLYEN_WIDTH           1u\r\n#define SIM_CHIPCTL_ADC_SUPPLYEN(x)              (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_ADC_SUPPLYEN_SHIFT))&SIM_CHIPCTL_ADC_SUPPLYEN_MASK)\r\n#define SIM_CHIPCTL_SRAMU_RETEN_MASK             0x100000u\r\n#define SIM_CHIPCTL_SRAMU_RETEN_SHIFT            20u\r\n#define SIM_CHIPCTL_SRAMU_RETEN_WIDTH            1u\r\n#define SIM_CHIPCTL_SRAMU_RETEN(x)               (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_SRAMU_RETEN_SHIFT))&SIM_CHIPCTL_SRAMU_RETEN_MASK)\r\n#define SIM_CHIPCTL_SRAML_RETEN_MASK             0x200000u\r\n#define SIM_CHIPCTL_SRAML_RETEN_SHIFT            21u\r\n#define SIM_CHIPCTL_SRAML_RETEN_WIDTH            1u\r\n#define SIM_CHIPCTL_SRAML_RETEN(x)               (((uint32_t)(((uint32_t)(x))<<SIM_CHIPCTL_SRAML_RETEN_SHIFT))&SIM_CHIPCTL_SRAML_RETEN_MASK)\r\n/* FTMOPT0 Bit Fields */\r\n#define SIM_FTMOPT0_FTM0FLTxSEL_MASK             0x7u\r\n#define SIM_FTMOPT0_FTM0FLTxSEL_SHIFT            0u\r\n#define SIM_FTMOPT0_FTM0FLTxSEL_WIDTH            3u\r\n#define SIM_FTMOPT0_FTM0FLTxSEL(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM0FLTxSEL_SHIFT))&SIM_FTMOPT0_FTM0FLTxSEL_MASK)\r\n#define SIM_FTMOPT0_FTM1FLTxSEL_MASK             0x70u\r\n#define SIM_FTMOPT0_FTM1FLTxSEL_SHIFT            4u\r\n#define SIM_FTMOPT0_FTM1FLTxSEL_WIDTH            3u\r\n#define SIM_FTMOPT0_FTM1FLTxSEL(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM1FLTxSEL_SHIFT))&SIM_FTMOPT0_FTM1FLTxSEL_MASK)\r\n#define SIM_FTMOPT0_FTM2FLTxSEL_MASK             0x700u\r\n#define SIM_FTMOPT0_FTM2FLTxSEL_SHIFT            8u\r\n#define SIM_FTMOPT0_FTM2FLTxSEL_WIDTH            3u\r\n#define SIM_FTMOPT0_FTM2FLTxSEL(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM2FLTxSEL_SHIFT))&SIM_FTMOPT0_FTM2FLTxSEL_MASK)\r\n#define SIM_FTMOPT0_FTM3FLTxSEL_MASK             0x7000u\r\n#define SIM_FTMOPT0_FTM3FLTxSEL_SHIFT            12u\r\n#define SIM_FTMOPT0_FTM3FLTxSEL_WIDTH            3u\r\n#define SIM_FTMOPT0_FTM3FLTxSEL(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM3FLTxSEL_SHIFT))&SIM_FTMOPT0_FTM3FLTxSEL_MASK)\r\n#define SIM_FTMOPT0_FTM0CLKSEL_MASK              0x3000000u\r\n#define SIM_FTMOPT0_FTM0CLKSEL_SHIFT             24u\r\n#define SIM_FTMOPT0_FTM0CLKSEL_WIDTH             2u\r\n#define SIM_FTMOPT0_FTM0CLKSEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM0CLKSEL_SHIFT))&SIM_FTMOPT0_FTM0CLKSEL_MASK)\r\n#define SIM_FTMOPT0_FTM1CLKSEL_MASK              0xC000000u\r\n#define SIM_FTMOPT0_FTM1CLKSEL_SHIFT             26u\r\n#define SIM_FTMOPT0_FTM1CLKSEL_WIDTH             2u\r\n#define SIM_FTMOPT0_FTM1CLKSEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM1CLKSEL_SHIFT))&SIM_FTMOPT0_FTM1CLKSEL_MASK)\r\n#define SIM_FTMOPT0_FTM2CLKSEL_MASK              0x30000000u\r\n#define SIM_FTMOPT0_FTM2CLKSEL_SHIFT             28u\r\n#define SIM_FTMOPT0_FTM2CLKSEL_WIDTH             2u\r\n#define SIM_FTMOPT0_FTM2CLKSEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM2CLKSEL_SHIFT))&SIM_FTMOPT0_FTM2CLKSEL_MASK)\r\n#define SIM_FTMOPT0_FTM3CLKSEL_MASK              0xC0000000u\r\n#define SIM_FTMOPT0_FTM3CLKSEL_SHIFT             30u\r\n#define SIM_FTMOPT0_FTM3CLKSEL_WIDTH             2u\r\n#define SIM_FTMOPT0_FTM3CLKSEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT0_FTM3CLKSEL_SHIFT))&SIM_FTMOPT0_FTM3CLKSEL_MASK)\r\n/* LPOCLKS Bit Fields */\r\n#define SIM_LPOCLKS_LPO1KCLKEN_MASK              0x1u\r\n#define SIM_LPOCLKS_LPO1KCLKEN_SHIFT             0u\r\n#define SIM_LPOCLKS_LPO1KCLKEN_WIDTH             1u\r\n#define SIM_LPOCLKS_LPO1KCLKEN(x)                (((uint32_t)(((uint32_t)(x))<<SIM_LPOCLKS_LPO1KCLKEN_SHIFT))&SIM_LPOCLKS_LPO1KCLKEN_MASK)\r\n#define SIM_LPOCLKS_LPO32KCLKEN_MASK             0x2u\r\n#define SIM_LPOCLKS_LPO32KCLKEN_SHIFT            1u\r\n#define SIM_LPOCLKS_LPO32KCLKEN_WIDTH            1u\r\n#define SIM_LPOCLKS_LPO32KCLKEN(x)               (((uint32_t)(((uint32_t)(x))<<SIM_LPOCLKS_LPO32KCLKEN_SHIFT))&SIM_LPOCLKS_LPO32KCLKEN_MASK)\r\n#define SIM_LPOCLKS_LPOCLKSEL_MASK               0xCu\r\n#define SIM_LPOCLKS_LPOCLKSEL_SHIFT              2u\r\n#define SIM_LPOCLKS_LPOCLKSEL_WIDTH              2u\r\n#define SIM_LPOCLKS_LPOCLKSEL(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_LPOCLKS_LPOCLKSEL_SHIFT))&SIM_LPOCLKS_LPOCLKSEL_MASK)\r\n#define SIM_LPOCLKS_RTCCLKSEL_MASK               0x30u\r\n#define SIM_LPOCLKS_RTCCLKSEL_SHIFT              4u\r\n#define SIM_LPOCLKS_RTCCLKSEL_WIDTH              2u\r\n#define SIM_LPOCLKS_RTCCLKSEL(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_LPOCLKS_RTCCLKSEL_SHIFT))&SIM_LPOCLKS_RTCCLKSEL_MASK)\r\n/* ADCOPT Bit Fields */\r\n#define SIM_ADCOPT_ADC0TRGSEL_MASK               0x1u\r\n#define SIM_ADCOPT_ADC0TRGSEL_SHIFT              0u\r\n#define SIM_ADCOPT_ADC0TRGSEL_WIDTH              1u\r\n#define SIM_ADCOPT_ADC0TRGSEL(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_ADCOPT_ADC0TRGSEL_SHIFT))&SIM_ADCOPT_ADC0TRGSEL_MASK)\r\n#define SIM_ADCOPT_ADC0SWPRETRG_MASK             0xEu\r\n#define SIM_ADCOPT_ADC0SWPRETRG_SHIFT            1u\r\n#define SIM_ADCOPT_ADC0SWPRETRG_WIDTH            3u\r\n#define SIM_ADCOPT_ADC0SWPRETRG(x)               (((uint32_t)(((uint32_t)(x))<<SIM_ADCOPT_ADC0SWPRETRG_SHIFT))&SIM_ADCOPT_ADC0SWPRETRG_MASK)\r\n#define SIM_ADCOPT_ADC0PRETRGSEL_MASK            0x30u\r\n#define SIM_ADCOPT_ADC0PRETRGSEL_SHIFT           4u\r\n#define SIM_ADCOPT_ADC0PRETRGSEL_WIDTH           2u\r\n#define SIM_ADCOPT_ADC0PRETRGSEL(x)              (((uint32_t)(((uint32_t)(x))<<SIM_ADCOPT_ADC0PRETRGSEL_SHIFT))&SIM_ADCOPT_ADC0PRETRGSEL_MASK)\r\n#define SIM_ADCOPT_ADC1TRGSEL_MASK               0x100u\r\n#define SIM_ADCOPT_ADC1TRGSEL_SHIFT              8u\r\n#define SIM_ADCOPT_ADC1TRGSEL_WIDTH              1u\r\n#define SIM_ADCOPT_ADC1TRGSEL(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_ADCOPT_ADC1TRGSEL_SHIFT))&SIM_ADCOPT_ADC1TRGSEL_MASK)\r\n#define SIM_ADCOPT_ADC1SWPRETRG_MASK             0xE00u\r\n#define SIM_ADCOPT_ADC1SWPRETRG_SHIFT            9u\r\n#define SIM_ADCOPT_ADC1SWPRETRG_WIDTH            3u\r\n#define SIM_ADCOPT_ADC1SWPRETRG(x)               (((uint32_t)(((uint32_t)(x))<<SIM_ADCOPT_ADC1SWPRETRG_SHIFT))&SIM_ADCOPT_ADC1SWPRETRG_MASK)\r\n#define SIM_ADCOPT_ADC1PRETRGSEL_MASK            0x3000u\r\n#define SIM_ADCOPT_ADC1PRETRGSEL_SHIFT           12u\r\n#define SIM_ADCOPT_ADC1PRETRGSEL_WIDTH           2u\r\n#define SIM_ADCOPT_ADC1PRETRGSEL(x)              (((uint32_t)(((uint32_t)(x))<<SIM_ADCOPT_ADC1PRETRGSEL_SHIFT))&SIM_ADCOPT_ADC1PRETRGSEL_MASK)\r\n/* FTMOPT1 Bit Fields */\r\n#define SIM_FTMOPT1_FTM0SYNCBIT_MASK             0x1u\r\n#define SIM_FTMOPT1_FTM0SYNCBIT_SHIFT            0u\r\n#define SIM_FTMOPT1_FTM0SYNCBIT_WIDTH            1u\r\n#define SIM_FTMOPT1_FTM0SYNCBIT(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM0SYNCBIT_SHIFT))&SIM_FTMOPT1_FTM0SYNCBIT_MASK)\r\n#define SIM_FTMOPT1_FTM1SYNCBIT_MASK             0x2u\r\n#define SIM_FTMOPT1_FTM1SYNCBIT_SHIFT            1u\r\n#define SIM_FTMOPT1_FTM1SYNCBIT_WIDTH            1u\r\n#define SIM_FTMOPT1_FTM1SYNCBIT(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM1SYNCBIT_SHIFT))&SIM_FTMOPT1_FTM1SYNCBIT_MASK)\r\n#define SIM_FTMOPT1_FTM2SYNCBIT_MASK             0x4u\r\n#define SIM_FTMOPT1_FTM2SYNCBIT_SHIFT            2u\r\n#define SIM_FTMOPT1_FTM2SYNCBIT_WIDTH            1u\r\n#define SIM_FTMOPT1_FTM2SYNCBIT(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM2SYNCBIT_SHIFT))&SIM_FTMOPT1_FTM2SYNCBIT_MASK)\r\n#define SIM_FTMOPT1_FTM3SYNCBIT_MASK             0x8u\r\n#define SIM_FTMOPT1_FTM3SYNCBIT_SHIFT            3u\r\n#define SIM_FTMOPT1_FTM3SYNCBIT_WIDTH            1u\r\n#define SIM_FTMOPT1_FTM3SYNCBIT(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM3SYNCBIT_SHIFT))&SIM_FTMOPT1_FTM3SYNCBIT_MASK)\r\n#define SIM_FTMOPT1_FTM1CH0SEL_MASK              0x30u\r\n#define SIM_FTMOPT1_FTM1CH0SEL_SHIFT             4u\r\n#define SIM_FTMOPT1_FTM1CH0SEL_WIDTH             2u\r\n#define SIM_FTMOPT1_FTM1CH0SEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM1CH0SEL_SHIFT))&SIM_FTMOPT1_FTM1CH0SEL_MASK)\r\n#define SIM_FTMOPT1_FTM2CH0SEL_MASK              0xC0u\r\n#define SIM_FTMOPT1_FTM2CH0SEL_SHIFT             6u\r\n#define SIM_FTMOPT1_FTM2CH0SEL_WIDTH             2u\r\n#define SIM_FTMOPT1_FTM2CH0SEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM2CH0SEL_SHIFT))&SIM_FTMOPT1_FTM2CH0SEL_MASK)\r\n#define SIM_FTMOPT1_FTM2CH1SEL_MASK              0x100u\r\n#define SIM_FTMOPT1_FTM2CH1SEL_SHIFT             8u\r\n#define SIM_FTMOPT1_FTM2CH1SEL_WIDTH             1u\r\n#define SIM_FTMOPT1_FTM2CH1SEL(x)                (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM2CH1SEL_SHIFT))&SIM_FTMOPT1_FTM2CH1SEL_MASK)\r\n#define SIM_FTMOPT1_FTMGLDOK_MASK                0x8000u\r\n#define SIM_FTMOPT1_FTMGLDOK_SHIFT               15u\r\n#define SIM_FTMOPT1_FTMGLDOK_WIDTH               1u\r\n#define SIM_FTMOPT1_FTMGLDOK(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTMGLDOK_SHIFT))&SIM_FTMOPT1_FTMGLDOK_MASK)\r\n#define SIM_FTMOPT1_FTM0_OUTSEL_MASK             0xFF0000u\r\n#define SIM_FTMOPT1_FTM0_OUTSEL_SHIFT            16u\r\n#define SIM_FTMOPT1_FTM0_OUTSEL_WIDTH            8u\r\n#define SIM_FTMOPT1_FTM0_OUTSEL(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM0_OUTSEL_SHIFT))&SIM_FTMOPT1_FTM0_OUTSEL_MASK)\r\n#define SIM_FTMOPT1_FTM3_OUTSEL_MASK             0xFF000000u\r\n#define SIM_FTMOPT1_FTM3_OUTSEL_SHIFT            24u\r\n#define SIM_FTMOPT1_FTM3_OUTSEL_WIDTH            8u\r\n#define SIM_FTMOPT1_FTM3_OUTSEL(x)               (((uint32_t)(((uint32_t)(x))<<SIM_FTMOPT1_FTM3_OUTSEL_SHIFT))&SIM_FTMOPT1_FTM3_OUTSEL_MASK)\r\n/* MISCTRL0 Bit Fields */\r\n#define SIM_MISCTRL0_STOP1_MONITOR_MASK          0x200u\r\n#define SIM_MISCTRL0_STOP1_MONITOR_SHIFT         9u\r\n#define SIM_MISCTRL0_STOP1_MONITOR_WIDTH         1u\r\n#define SIM_MISCTRL0_STOP1_MONITOR(x)            (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL0_STOP1_MONITOR_SHIFT))&SIM_MISCTRL0_STOP1_MONITOR_MASK)\r\n#define SIM_MISCTRL0_STOP2_MONITOR_MASK          0x400u\r\n#define SIM_MISCTRL0_STOP2_MONITOR_SHIFT         10u\r\n#define SIM_MISCTRL0_STOP2_MONITOR_WIDTH         1u\r\n#define SIM_MISCTRL0_STOP2_MONITOR(x)            (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL0_STOP2_MONITOR_SHIFT))&SIM_MISCTRL0_STOP2_MONITOR_MASK)\r\n#define SIM_MISCTRL0_FTM0_OBE_CTRL_MASK          0x10000u\r\n#define SIM_MISCTRL0_FTM0_OBE_CTRL_SHIFT         16u\r\n#define SIM_MISCTRL0_FTM0_OBE_CTRL_WIDTH         1u\r\n#define SIM_MISCTRL0_FTM0_OBE_CTRL(x)            (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL0_FTM0_OBE_CTRL_SHIFT))&SIM_MISCTRL0_FTM0_OBE_CTRL_MASK)\r\n#define SIM_MISCTRL0_FTM1_OBE_CTRL_MASK          0x20000u\r\n#define SIM_MISCTRL0_FTM1_OBE_CTRL_SHIFT         17u\r\n#define SIM_MISCTRL0_FTM1_OBE_CTRL_WIDTH         1u\r\n#define SIM_MISCTRL0_FTM1_OBE_CTRL(x)            (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL0_FTM1_OBE_CTRL_SHIFT))&SIM_MISCTRL0_FTM1_OBE_CTRL_MASK)\r\n#define SIM_MISCTRL0_FTM2_OBE_CTRL_MASK          0x40000u\r\n#define SIM_MISCTRL0_FTM2_OBE_CTRL_SHIFT         18u\r\n#define SIM_MISCTRL0_FTM2_OBE_CTRL_WIDTH         1u\r\n#define SIM_MISCTRL0_FTM2_OBE_CTRL(x)            (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL0_FTM2_OBE_CTRL_SHIFT))&SIM_MISCTRL0_FTM2_OBE_CTRL_MASK)\r\n#define SIM_MISCTRL0_FTM3_OBE_CTRL_MASK          0x80000u\r\n#define SIM_MISCTRL0_FTM3_OBE_CTRL_SHIFT         19u\r\n#define SIM_MISCTRL0_FTM3_OBE_CTRL_WIDTH         1u\r\n#define SIM_MISCTRL0_FTM3_OBE_CTRL(x)            (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL0_FTM3_OBE_CTRL_SHIFT))&SIM_MISCTRL0_FTM3_OBE_CTRL_MASK)\r\n/* SDID Bit Fields */\r\n#define SIM_SDID_FEATURES_MASK                   0xFFu\r\n#define SIM_SDID_FEATURES_SHIFT                  0u\r\n#define SIM_SDID_FEATURES_WIDTH                  8u\r\n#define SIM_SDID_FEATURES(x)                     (((uint32_t)(((uint32_t)(x))<<SIM_SDID_FEATURES_SHIFT))&SIM_SDID_FEATURES_MASK)\r\n#define SIM_SDID_PACKAGE_MASK                    0xF00u\r\n#define SIM_SDID_PACKAGE_SHIFT                   8u\r\n#define SIM_SDID_PACKAGE_WIDTH                   4u\r\n#define SIM_SDID_PACKAGE(x)                      (((uint32_t)(((uint32_t)(x))<<SIM_SDID_PACKAGE_SHIFT))&SIM_SDID_PACKAGE_MASK)\r\n#define SIM_SDID_REVID_MASK                      0xF000u\r\n#define SIM_SDID_REVID_SHIFT                     12u\r\n#define SIM_SDID_REVID_WIDTH                     4u\r\n#define SIM_SDID_REVID(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SDID_REVID_SHIFT))&SIM_SDID_REVID_MASK)\r\n#define SIM_SDID_RAMSIZE_MASK                    0xF0000u\r\n#define SIM_SDID_RAMSIZE_SHIFT                   16u\r\n#define SIM_SDID_RAMSIZE_WIDTH                   4u\r\n#define SIM_SDID_RAMSIZE(x)                      (((uint32_t)(((uint32_t)(x))<<SIM_SDID_RAMSIZE_SHIFT))&SIM_SDID_RAMSIZE_MASK)\r\n#define SIM_SDID_DERIVATE_MASK                   0xF00000u\r\n#define SIM_SDID_DERIVATE_SHIFT                  20u\r\n#define SIM_SDID_DERIVATE_WIDTH                  4u\r\n#define SIM_SDID_DERIVATE(x)                     (((uint32_t)(((uint32_t)(x))<<SIM_SDID_DERIVATE_SHIFT))&SIM_SDID_DERIVATE_MASK)\r\n#define SIM_SDID_SUBSERIES_MASK                  0xF000000u\r\n#define SIM_SDID_SUBSERIES_SHIFT                 24u\r\n#define SIM_SDID_SUBSERIES_WIDTH                 4u\r\n#define SIM_SDID_SUBSERIES(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_SDID_SUBSERIES_SHIFT))&SIM_SDID_SUBSERIES_MASK)\r\n#define SIM_SDID_GENERATION_MASK                 0xF0000000u\r\n#define SIM_SDID_GENERATION_SHIFT                28u\r\n#define SIM_SDID_GENERATION_WIDTH                4u\r\n#define SIM_SDID_GENERATION(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_SDID_GENERATION_SHIFT))&SIM_SDID_GENERATION_MASK)\r\n/* PLATCGC Bit Fields */\r\n#define SIM_PLATCGC_CGCMSCM_MASK                 0x1u\r\n#define SIM_PLATCGC_CGCMSCM_SHIFT                0u\r\n#define SIM_PLATCGC_CGCMSCM_WIDTH                1u\r\n#define SIM_PLATCGC_CGCMSCM(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_PLATCGC_CGCMSCM_SHIFT))&SIM_PLATCGC_CGCMSCM_MASK)\r\n#define SIM_PLATCGC_CGCMPU_MASK                  0x2u\r\n#define SIM_PLATCGC_CGCMPU_SHIFT                 1u\r\n#define SIM_PLATCGC_CGCMPU_WIDTH                 1u\r\n#define SIM_PLATCGC_CGCMPU(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_PLATCGC_CGCMPU_SHIFT))&SIM_PLATCGC_CGCMPU_MASK)\r\n#define SIM_PLATCGC_CGCDMA_MASK                  0x4u\r\n#define SIM_PLATCGC_CGCDMA_SHIFT                 2u\r\n#define SIM_PLATCGC_CGCDMA_WIDTH                 1u\r\n#define SIM_PLATCGC_CGCDMA(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_PLATCGC_CGCDMA_SHIFT))&SIM_PLATCGC_CGCDMA_MASK)\r\n#define SIM_PLATCGC_CGCERM_MASK                  0x8u\r\n#define SIM_PLATCGC_CGCERM_SHIFT                 3u\r\n#define SIM_PLATCGC_CGCERM_WIDTH                 1u\r\n#define SIM_PLATCGC_CGCERM(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_PLATCGC_CGCERM_SHIFT))&SIM_PLATCGC_CGCERM_MASK)\r\n#define SIM_PLATCGC_CGCEIM_MASK                  0x10u\r\n#define SIM_PLATCGC_CGCEIM_SHIFT                 4u\r\n#define SIM_PLATCGC_CGCEIM_WIDTH                 1u\r\n#define SIM_PLATCGC_CGCEIM(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_PLATCGC_CGCEIM_SHIFT))&SIM_PLATCGC_CGCEIM_MASK)\r\n/* FCFG1 Bit Fields */\r\n#define SIM_FCFG1_DEPART_MASK                    0xF000u\r\n#define SIM_FCFG1_DEPART_SHIFT                   12u\r\n#define SIM_FCFG1_DEPART_WIDTH                   4u\r\n#define SIM_FCFG1_DEPART(x)                      (((uint32_t)(((uint32_t)(x))<<SIM_FCFG1_DEPART_SHIFT))&SIM_FCFG1_DEPART_MASK)\r\n#define SIM_FCFG1_EEERAMSIZE_MASK                0xF0000u\r\n#define SIM_FCFG1_EEERAMSIZE_SHIFT               16u\r\n#define SIM_FCFG1_EEERAMSIZE_WIDTH               4u\r\n#define SIM_FCFG1_EEERAMSIZE(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_FCFG1_EEERAMSIZE_SHIFT))&SIM_FCFG1_EEERAMSIZE_MASK)\r\n/* UIDH Bit Fields */\r\n#define SIM_UIDH_UID127_96_MASK                  0xFFFFFFFFu\r\n#define SIM_UIDH_UID127_96_SHIFT                 0u\r\n#define SIM_UIDH_UID127_96_WIDTH                 32u\r\n#define SIM_UIDH_UID127_96(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_UIDH_UID127_96_SHIFT))&SIM_UIDH_UID127_96_MASK)\r\n/* UIDMH Bit Fields */\r\n#define SIM_UIDMH_UID95_64_MASK                  0xFFFFFFFFu\r\n#define SIM_UIDMH_UID95_64_SHIFT                 0u\r\n#define SIM_UIDMH_UID95_64_WIDTH                 32u\r\n#define SIM_UIDMH_UID95_64(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_UIDMH_UID95_64_SHIFT))&SIM_UIDMH_UID95_64_MASK)\r\n/* UIDML Bit Fields */\r\n#define SIM_UIDML_UID63_32_MASK                  0xFFFFFFFFu\r\n#define SIM_UIDML_UID63_32_SHIFT                 0u\r\n#define SIM_UIDML_UID63_32_WIDTH                 32u\r\n#define SIM_UIDML_UID63_32(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_UIDML_UID63_32_SHIFT))&SIM_UIDML_UID63_32_MASK)\r\n/* UIDL Bit Fields */\r\n#define SIM_UIDL_UID31_0_MASK                    0xFFFFFFFFu\r\n#define SIM_UIDL_UID31_0_SHIFT                   0u\r\n#define SIM_UIDL_UID31_0_WIDTH                   32u\r\n#define SIM_UIDL_UID31_0(x)                      (((uint32_t)(((uint32_t)(x))<<SIM_UIDL_UID31_0_SHIFT))&SIM_UIDL_UID31_0_MASK)\r\n/* CLKDIV4 Bit Fields */\r\n#define SIM_CLKDIV4_TRACEFRAC_MASK               0x1u\r\n#define SIM_CLKDIV4_TRACEFRAC_SHIFT              0u\r\n#define SIM_CLKDIV4_TRACEFRAC_WIDTH              1u\r\n#define SIM_CLKDIV4_TRACEFRAC(x)                 (((uint32_t)(((uint32_t)(x))<<SIM_CLKDIV4_TRACEFRAC_SHIFT))&SIM_CLKDIV4_TRACEFRAC_MASK)\r\n#define SIM_CLKDIV4_TRACEDIV_MASK                0xEu\r\n#define SIM_CLKDIV4_TRACEDIV_SHIFT               1u\r\n#define SIM_CLKDIV4_TRACEDIV_WIDTH               3u\r\n#define SIM_CLKDIV4_TRACEDIV(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_CLKDIV4_TRACEDIV_SHIFT))&SIM_CLKDIV4_TRACEDIV_MASK)\r\n#define SIM_CLKDIV4_TRACEDIVEN_MASK              0x10000000u\r\n#define SIM_CLKDIV4_TRACEDIVEN_SHIFT             28u\r\n#define SIM_CLKDIV4_TRACEDIVEN_WIDTH             1u\r\n#define SIM_CLKDIV4_TRACEDIVEN(x)                (((uint32_t)(((uint32_t)(x))<<SIM_CLKDIV4_TRACEDIVEN_SHIFT))&SIM_CLKDIV4_TRACEDIVEN_MASK)\r\n/* MISCTRL1 Bit Fields */\r\n#define SIM_MISCTRL1_SW_TRG_MASK                 0x1u\r\n#define SIM_MISCTRL1_SW_TRG_SHIFT                0u\r\n#define SIM_MISCTRL1_SW_TRG_WIDTH                1u\r\n#define SIM_MISCTRL1_SW_TRG(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_MISCTRL1_SW_TRG_SHIFT))&SIM_MISCTRL1_SW_TRG_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group SIM_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group SIM_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- SMC Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup SMC_Peripheral_Access_Layer SMC Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** SMC - Size of Registers Arrays */\r\n\r\n/** SMC - Register Layout Typedef */\r\ntypedef struct {\r\n  __I  uint32_t VERID;                             /**< SMC Version ID Register, offset: 0x0 */\r\n  __I  uint32_t PARAM;                             /**< SMC Parameter Register, offset: 0x4 */\r\n  __IO uint32_t PMPROT;                            /**< Power Mode Protection register, offset: 0x8 */\r\n  __IO uint32_t PMCTRL;                            /**< Power Mode Control register, offset: 0xC */\r\n  __IO uint32_t STOPCTRL;                          /**< Stop Control Register, offset: 0x10 */\r\n  __I  uint32_t PMSTAT;                            /**< Power Mode Status register, offset: 0x14 */\r\n} SMC_Type, *SMC_MemMapPtr;\r\n\r\n /** Number of instances of the SMC module. */\r\n#define SMC_INSTANCE_COUNT                       (1u)\r\n\r\n\r\n/* SMC - Peripheral instance base addresses */\r\n/** Peripheral SMC base address */\r\n#define SMC_BASE                                 (0x4007E000u)\r\n/** Peripheral SMC base pointer */\r\n#define SMC                                      ((SMC_Type *)SMC_BASE)\r\n/** Array initializer of SMC peripheral base addresses */\r\n#define SMC_BASE_ADDRS                           { SMC_BASE }\r\n/** Array initializer of SMC peripheral base pointers */\r\n#define SMC_BASE_PTRS                            { SMC }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- SMC Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup SMC_Register_Masks SMC Register Masks\r\n * @{\r\n */\r\n\r\n/* VERID Bit Fields */\r\n#define SMC_VERID_FEATURE_MASK                   0xFFFFu\r\n#define SMC_VERID_FEATURE_SHIFT                  0u\r\n#define SMC_VERID_FEATURE_WIDTH                  16u\r\n#define SMC_VERID_FEATURE(x)                     (((uint32_t)(((uint32_t)(x))<<SMC_VERID_FEATURE_SHIFT))&SMC_VERID_FEATURE_MASK)\r\n#define SMC_VERID_MINOR_MASK                     0xFF0000u\r\n#define SMC_VERID_MINOR_SHIFT                    16u\r\n#define SMC_VERID_MINOR_WIDTH                    8u\r\n#define SMC_VERID_MINOR(x)                       (((uint32_t)(((uint32_t)(x))<<SMC_VERID_MINOR_SHIFT))&SMC_VERID_MINOR_MASK)\r\n#define SMC_VERID_MAJOR_MASK                     0xFF000000u\r\n#define SMC_VERID_MAJOR_SHIFT                    24u\r\n#define SMC_VERID_MAJOR_WIDTH                    8u\r\n#define SMC_VERID_MAJOR(x)                       (((uint32_t)(((uint32_t)(x))<<SMC_VERID_MAJOR_SHIFT))&SMC_VERID_MAJOR_MASK)\r\n/* PARAM Bit Fields */\r\n#define SMC_PARAM_EHSRUN_MASK                    0x1u\r\n#define SMC_PARAM_EHSRUN_SHIFT                   0u\r\n#define SMC_PARAM_EHSRUN_WIDTH                   1u\r\n#define SMC_PARAM_EHSRUN(x)                      (((uint32_t)(((uint32_t)(x))<<SMC_PARAM_EHSRUN_SHIFT))&SMC_PARAM_EHSRUN_MASK)\r\n#define SMC_PARAM_ELLS_MASK                      0x8u\r\n#define SMC_PARAM_ELLS_SHIFT                     3u\r\n#define SMC_PARAM_ELLS_WIDTH                     1u\r\n#define SMC_PARAM_ELLS(x)                        (((uint32_t)(((uint32_t)(x))<<SMC_PARAM_ELLS_SHIFT))&SMC_PARAM_ELLS_MASK)\r\n#define SMC_PARAM_ELLS2_MASK                     0x20u\r\n#define SMC_PARAM_ELLS2_SHIFT                    5u\r\n#define SMC_PARAM_ELLS2_WIDTH                    1u\r\n#define SMC_PARAM_ELLS2(x)                       (((uint32_t)(((uint32_t)(x))<<SMC_PARAM_ELLS2_SHIFT))&SMC_PARAM_ELLS2_MASK)\r\n#define SMC_PARAM_EVLLS0_MASK                    0x40u\r\n#define SMC_PARAM_EVLLS0_SHIFT                   6u\r\n#define SMC_PARAM_EVLLS0_WIDTH                   1u\r\n#define SMC_PARAM_EVLLS0(x)                      (((uint32_t)(((uint32_t)(x))<<SMC_PARAM_EVLLS0_SHIFT))&SMC_PARAM_EVLLS0_MASK)\r\n/* PMPROT Bit Fields */\r\n#define SMC_PMPROT_AVLP_MASK                     0x20u\r\n#define SMC_PMPROT_AVLP_SHIFT                    5u\r\n#define SMC_PMPROT_AVLP_WIDTH                    1u\r\n#define SMC_PMPROT_AVLP(x)                       (((uint32_t)(((uint32_t)(x))<<SMC_PMPROT_AVLP_SHIFT))&SMC_PMPROT_AVLP_MASK)\r\n#define SMC_PMPROT_AHSRUN_MASK                   0x80u\r\n#define SMC_PMPROT_AHSRUN_SHIFT                  7u\r\n#define SMC_PMPROT_AHSRUN_WIDTH                  1u\r\n#define SMC_PMPROT_AHSRUN(x)                     (((uint32_t)(((uint32_t)(x))<<SMC_PMPROT_AHSRUN_SHIFT))&SMC_PMPROT_AHSRUN_MASK)\r\n/* PMCTRL Bit Fields */\r\n#define SMC_PMCTRL_STOPM_MASK                    0x7u\r\n#define SMC_PMCTRL_STOPM_SHIFT                   0u\r\n#define SMC_PMCTRL_STOPM_WIDTH                   3u\r\n#define SMC_PMCTRL_STOPM(x)                      (((uint32_t)(((uint32_t)(x))<<SMC_PMCTRL_STOPM_SHIFT))&SMC_PMCTRL_STOPM_MASK)\r\n#define SMC_PMCTRL_VLPSA_MASK                    0x8u\r\n#define SMC_PMCTRL_VLPSA_SHIFT                   3u\r\n#define SMC_PMCTRL_VLPSA_WIDTH                   1u\r\n#define SMC_PMCTRL_VLPSA(x)                      (((uint32_t)(((uint32_t)(x))<<SMC_PMCTRL_VLPSA_SHIFT))&SMC_PMCTRL_VLPSA_MASK)\r\n#define SMC_PMCTRL_RUNM_MASK                     0x60u\r\n#define SMC_PMCTRL_RUNM_SHIFT                    5u\r\n#define SMC_PMCTRL_RUNM_WIDTH                    2u\r\n#define SMC_PMCTRL_RUNM(x)                       (((uint32_t)(((uint32_t)(x))<<SMC_PMCTRL_RUNM_SHIFT))&SMC_PMCTRL_RUNM_MASK)\r\n/* STOPCTRL Bit Fields */\r\n#define SMC_STOPCTRL_STOPO_MASK                  0xC0u\r\n#define SMC_STOPCTRL_STOPO_SHIFT                 6u\r\n#define SMC_STOPCTRL_STOPO_WIDTH                 2u\r\n#define SMC_STOPCTRL_STOPO(x)                    (((uint32_t)(((uint32_t)(x))<<SMC_STOPCTRL_STOPO_SHIFT))&SMC_STOPCTRL_STOPO_MASK)\r\n/* PMSTAT Bit Fields */\r\n#define SMC_PMSTAT_PMSTAT_MASK                   0xFFu\r\n#define SMC_PMSTAT_PMSTAT_SHIFT                  0u\r\n#define SMC_PMSTAT_PMSTAT_WIDTH                  8u\r\n#define SMC_PMSTAT_PMSTAT(x)                     (((uint32_t)(((uint32_t)(x))<<SMC_PMSTAT_PMSTAT_SHIFT))&SMC_PMSTAT_PMSTAT_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group SMC_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group SMC_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- TRGMUX Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup TRGMUX_Peripheral_Access_Layer TRGMUX Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** TRGMUX - Size of Registers Arrays */\r\n#define TRGMUX_TRGMUXn_COUNT                     26u\r\n\r\n/** TRGMUX - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t TRGMUXn[TRGMUX_TRGMUXn_COUNT];     /**< TRGMUX DMAMUX0 Register..TRGMUX LPTMR0 Register, array offset: 0x0, array step: 0x4 */\r\n} TRGMUX_Type, *TRGMUX_MemMapPtr;\r\n\r\n /** Number of instances of the TRGMUX module. */\r\n#define TRGMUX_INSTANCE_COUNT                    (1u)\r\n\r\n\r\n/* TRGMUX - Peripheral instance base addresses */\r\n/** Peripheral TRGMUX base address */\r\n#define TRGMUX_BASE                              (0x40063000u)\r\n/** Peripheral TRGMUX base pointer */\r\n#define TRGMUX                                   ((TRGMUX_Type *)TRGMUX_BASE)\r\n/** Array initializer of TRGMUX peripheral base addresses */\r\n#define TRGMUX_BASE_ADDRS                        { TRGMUX_BASE }\r\n/** Array initializer of TRGMUX peripheral base pointers */\r\n#define TRGMUX_BASE_PTRS                         { TRGMUX }\r\n\r\n/* TRGMUX index offsets */\r\n#define TRGMUX_DMAMUX0_INDEX                     0\r\n#define TRGMUX_EXTOUT0_INDEX                     1\r\n#define TRGMUX_EXTOUT1_INDEX                     2\r\n#define TRGMUX_ADC0_INDEX                        3\r\n#define TRGMUX_ADC1_INDEX                        4\r\n#define TRGMUX_CMP0_INDEX                        7\r\n#define TRGMUX_FTM0_INDEX                        10\r\n#define TRGMUX_FTM1_INDEX                        11\r\n#define TRGMUX_FTM2_INDEX                        12\r\n#define TRGMUX_FTM3_INDEX                        13\r\n#define TRGMUX_PDB0_INDEX                        14\r\n#define TRGMUX_PDB1_INDEX                        15\r\n#define TRGMUX_FLEXIO_INDEX                      17\r\n#define TRGMUX_LPIT0_INDEX                       18\r\n#define TRGMUX_LPUART0_INDEX                     19\r\n#define TRGMUX_LPUART1_INDEX                     20\r\n#define TRGMUX_LPI2C0_INDEX                      21\r\n#define TRGMUX_LPSPI0_INDEX                      23\r\n#define TRGMUX_LPSPI1_INDEX                      24\r\n#define TRGMUX_LPTMR0_INDEX                      25\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- TRGMUX Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup TRGMUX_Register_Masks TRGMUX Register Masks\r\n * @{\r\n */\r\n\r\n/* TRGMUXn Bit Fields */\r\n#define TRGMUX_TRGMUXn_SEL0_MASK                 0x3Fu\r\n#define TRGMUX_TRGMUXn_SEL0_SHIFT                0u\r\n#define TRGMUX_TRGMUXn_SEL0_WIDTH                6u\r\n#define TRGMUX_TRGMUXn_SEL0(x)                   (((uint32_t)(((uint32_t)(x))<<TRGMUX_TRGMUXn_SEL0_SHIFT))&TRGMUX_TRGMUXn_SEL0_MASK)\r\n#define TRGMUX_TRGMUXn_SEL1_MASK                 0x3F00u\r\n#define TRGMUX_TRGMUXn_SEL1_SHIFT                8u\r\n#define TRGMUX_TRGMUXn_SEL1_WIDTH                6u\r\n#define TRGMUX_TRGMUXn_SEL1(x)                   (((uint32_t)(((uint32_t)(x))<<TRGMUX_TRGMUXn_SEL1_SHIFT))&TRGMUX_TRGMUXn_SEL1_MASK)\r\n#define TRGMUX_TRGMUXn_SEL2_MASK                 0x3F0000u\r\n#define TRGMUX_TRGMUXn_SEL2_SHIFT                16u\r\n#define TRGMUX_TRGMUXn_SEL2_WIDTH                6u\r\n#define TRGMUX_TRGMUXn_SEL2(x)                   (((uint32_t)(((uint32_t)(x))<<TRGMUX_TRGMUXn_SEL2_SHIFT))&TRGMUX_TRGMUXn_SEL2_MASK)\r\n#define TRGMUX_TRGMUXn_SEL3_MASK                 0x3F000000u\r\n#define TRGMUX_TRGMUXn_SEL3_SHIFT                24u\r\n#define TRGMUX_TRGMUXn_SEL3_WIDTH                6u\r\n#define TRGMUX_TRGMUXn_SEL3(x)                   (((uint32_t)(((uint32_t)(x))<<TRGMUX_TRGMUXn_SEL3_SHIFT))&TRGMUX_TRGMUXn_SEL3_MASK)\r\n#define TRGMUX_TRGMUXn_LK_MASK                   0x80000000u\r\n#define TRGMUX_TRGMUXn_LK_SHIFT                  31u\r\n#define TRGMUX_TRGMUXn_LK_WIDTH                  1u\r\n#define TRGMUX_TRGMUXn_LK(x)                     (((uint32_t)(((uint32_t)(x))<<TRGMUX_TRGMUXn_LK_SHIFT))&TRGMUX_TRGMUXn_LK_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group TRGMUX_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group TRGMUX_Peripheral_Access_Layer */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- WDOG Peripheral Access Layer\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup WDOG_Peripheral_Access_Layer WDOG Peripheral Access Layer\r\n * @{\r\n */\r\n\r\n\r\n/** WDOG - Size of Registers Arrays */\r\n\r\n/** WDOG - Register Layout Typedef */\r\ntypedef struct {\r\n  __IO uint32_t CS;                                /**< Watchdog Control and Status Register, offset: 0x0 */\r\n  __IO uint32_t CNT;                               /**< Watchdog Counter Register, offset: 0x4 */\r\n  __IO uint32_t TOVAL;                             /**< Watchdog Timeout Value Register, offset: 0x8 */\r\n  __IO uint32_t WIN;                               /**< Watchdog Window Register, offset: 0xC */\r\n} WDOG_Type, *WDOG_MemMapPtr;\r\n\r\n /** Number of instances of the WDOG module. */\r\n#define WDOG_INSTANCE_COUNT                      (1u)\r\n\r\n\r\n/* WDOG - Peripheral instance base addresses */\r\n/** Peripheral WDOG base address */\r\n#define WDOG_BASE                                (0x40052000u)\r\n/** Peripheral WDOG base pointer */\r\n#define WDOG                                     ((WDOG_Type *)WDOG_BASE)\r\n/** Array initializer of WDOG peripheral base addresses */\r\n#define WDOG_BASE_ADDRS                          { WDOG_BASE }\r\n/** Array initializer of WDOG peripheral base pointers */\r\n#define WDOG_BASE_PTRS                           { WDOG }\r\n /** Number of interrupt vector arrays for the WDOG module. */\r\n#define WDOG_IRQS_ARR_COUNT                      (1u)\r\n /** Number of interrupt channels for the WDOG module. */\r\n#define WDOG_IRQS_CH_COUNT                       (1u)\r\n/** Interrupt vectors for the WDOG peripheral type */\r\n#define WDOG_IRQS                                { WDOG_EWM_IRQn }\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- WDOG Register Masks\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup WDOG_Register_Masks WDOG Register Masks\r\n * @{\r\n */\r\n\r\n/* CS Bit Fields */\r\n#define WDOG_CS_STOP_MASK                        0x1u\r\n#define WDOG_CS_STOP_SHIFT                       0u\r\n#define WDOG_CS_STOP_WIDTH                       1u\r\n#define WDOG_CS_STOP(x)                          (((uint32_t)(((uint32_t)(x))<<WDOG_CS_STOP_SHIFT))&WDOG_CS_STOP_MASK)\r\n#define WDOG_CS_WAIT_MASK                        0x2u\r\n#define WDOG_CS_WAIT_SHIFT                       1u\r\n#define WDOG_CS_WAIT_WIDTH                       1u\r\n#define WDOG_CS_WAIT(x)                          (((uint32_t)(((uint32_t)(x))<<WDOG_CS_WAIT_SHIFT))&WDOG_CS_WAIT_MASK)\r\n#define WDOG_CS_DBG_MASK                         0x4u\r\n#define WDOG_CS_DBG_SHIFT                        2u\r\n#define WDOG_CS_DBG_WIDTH                        1u\r\n#define WDOG_CS_DBG(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_DBG_SHIFT))&WDOG_CS_DBG_MASK)\r\n#define WDOG_CS_TST_MASK                         0x18u\r\n#define WDOG_CS_TST_SHIFT                        3u\r\n#define WDOG_CS_TST_WIDTH                        2u\r\n#define WDOG_CS_TST(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_TST_SHIFT))&WDOG_CS_TST_MASK)\r\n#define WDOG_CS_UPDATE_MASK                      0x20u\r\n#define WDOG_CS_UPDATE_SHIFT                     5u\r\n#define WDOG_CS_UPDATE_WIDTH                     1u\r\n#define WDOG_CS_UPDATE(x)                        (((uint32_t)(((uint32_t)(x))<<WDOG_CS_UPDATE_SHIFT))&WDOG_CS_UPDATE_MASK)\r\n#define WDOG_CS_INT_MASK                         0x40u\r\n#define WDOG_CS_INT_SHIFT                        6u\r\n#define WDOG_CS_INT_WIDTH                        1u\r\n#define WDOG_CS_INT(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_INT_SHIFT))&WDOG_CS_INT_MASK)\r\n#define WDOG_CS_EN_MASK                          0x80u\r\n#define WDOG_CS_EN_SHIFT                         7u\r\n#define WDOG_CS_EN_WIDTH                         1u\r\n#define WDOG_CS_EN(x)                            (((uint32_t)(((uint32_t)(x))<<WDOG_CS_EN_SHIFT))&WDOG_CS_EN_MASK)\r\n#define WDOG_CS_CLK_MASK                         0x300u\r\n#define WDOG_CS_CLK_SHIFT                        8u\r\n#define WDOG_CS_CLK_WIDTH                        2u\r\n#define WDOG_CS_CLK(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_CLK_SHIFT))&WDOG_CS_CLK_MASK)\r\n#define WDOG_CS_RCS_MASK                         0x400u\r\n#define WDOG_CS_RCS_SHIFT                        10u\r\n#define WDOG_CS_RCS_WIDTH                        1u\r\n#define WDOG_CS_RCS(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_RCS_SHIFT))&WDOG_CS_RCS_MASK)\r\n#define WDOG_CS_ULK_MASK                         0x800u\r\n#define WDOG_CS_ULK_SHIFT                        11u\r\n#define WDOG_CS_ULK_WIDTH                        1u\r\n#define WDOG_CS_ULK(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_ULK_SHIFT))&WDOG_CS_ULK_MASK)\r\n#define WDOG_CS_PRES_MASK                        0x1000u\r\n#define WDOG_CS_PRES_SHIFT                       12u\r\n#define WDOG_CS_PRES_WIDTH                       1u\r\n#define WDOG_CS_PRES(x)                          (((uint32_t)(((uint32_t)(x))<<WDOG_CS_PRES_SHIFT))&WDOG_CS_PRES_MASK)\r\n#define WDOG_CS_CMD32EN_MASK                     0x2000u\r\n#define WDOG_CS_CMD32EN_SHIFT                    13u\r\n#define WDOG_CS_CMD32EN_WIDTH                    1u\r\n#define WDOG_CS_CMD32EN(x)                       (((uint32_t)(((uint32_t)(x))<<WDOG_CS_CMD32EN_SHIFT))&WDOG_CS_CMD32EN_MASK)\r\n#define WDOG_CS_FLG_MASK                         0x4000u\r\n#define WDOG_CS_FLG_SHIFT                        14u\r\n#define WDOG_CS_FLG_WIDTH                        1u\r\n#define WDOG_CS_FLG(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_FLG_SHIFT))&WDOG_CS_FLG_MASK)\r\n#define WDOG_CS_WIN_MASK                         0x8000u\r\n#define WDOG_CS_WIN_SHIFT                        15u\r\n#define WDOG_CS_WIN_WIDTH                        1u\r\n#define WDOG_CS_WIN(x)                           (((uint32_t)(((uint32_t)(x))<<WDOG_CS_WIN_SHIFT))&WDOG_CS_WIN_MASK)\r\n/* CNT Bit Fields */\r\n#define WDOG_CNT_CNTLOW_MASK                     0xFFu\r\n#define WDOG_CNT_CNTLOW_SHIFT                    0u\r\n#define WDOG_CNT_CNTLOW_WIDTH                    8u\r\n#define WDOG_CNT_CNTLOW(x)                       (((uint32_t)(((uint32_t)(x))<<WDOG_CNT_CNTLOW_SHIFT))&WDOG_CNT_CNTLOW_MASK)\r\n#define WDOG_CNT_CNTHIGH_MASK                    0xFF00u\r\n#define WDOG_CNT_CNTHIGH_SHIFT                   8u\r\n#define WDOG_CNT_CNTHIGH_WIDTH                   8u\r\n#define WDOG_CNT_CNTHIGH(x)                      (((uint32_t)(((uint32_t)(x))<<WDOG_CNT_CNTHIGH_SHIFT))&WDOG_CNT_CNTHIGH_MASK)\r\n/* TOVAL Bit Fields */\r\n#define WDOG_TOVAL_TOVALLOW_MASK                 0xFFu\r\n#define WDOG_TOVAL_TOVALLOW_SHIFT                0u\r\n#define WDOG_TOVAL_TOVALLOW_WIDTH                8u\r\n#define WDOG_TOVAL_TOVALLOW(x)                   (((uint32_t)(((uint32_t)(x))<<WDOG_TOVAL_TOVALLOW_SHIFT))&WDOG_TOVAL_TOVALLOW_MASK)\r\n#define WDOG_TOVAL_TOVALHIGH_MASK                0xFF00u\r\n#define WDOG_TOVAL_TOVALHIGH_SHIFT               8u\r\n#define WDOG_TOVAL_TOVALHIGH_WIDTH               8u\r\n#define WDOG_TOVAL_TOVALHIGH(x)                  (((uint32_t)(((uint32_t)(x))<<WDOG_TOVAL_TOVALHIGH_SHIFT))&WDOG_TOVAL_TOVALHIGH_MASK)\r\n/* WIN Bit Fields */\r\n#define WDOG_WIN_WINLOW_MASK                     0xFFu\r\n#define WDOG_WIN_WINLOW_SHIFT                    0u\r\n#define WDOG_WIN_WINLOW_WIDTH                    8u\r\n#define WDOG_WIN_WINLOW(x)                       (((uint32_t)(((uint32_t)(x))<<WDOG_WIN_WINLOW_SHIFT))&WDOG_WIN_WINLOW_MASK)\r\n#define WDOG_WIN_WINHIGH_MASK                    0xFF00u\r\n#define WDOG_WIN_WINHIGH_SHIFT                   8u\r\n#define WDOG_WIN_WINHIGH_WIDTH                   8u\r\n#define WDOG_WIN_WINHIGH(x)                      (((uint32_t)(((uint32_t)(x))<<WDOG_WIN_WINHIGH_SHIFT))&WDOG_WIN_WINHIGH_MASK)\r\n\r\n/*!\r\n * @}\r\n */ /* end of group WDOG_Register_Masks */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group WDOG_Peripheral_Access_Layer */\r\n\r\n\r\n/*!\r\n * @}\r\n */ /* end of group Peripheral_access_layer_S32K144 */\r\n\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- Backward Compatibility for S32K144\r\n   ---------------------------------------------------------------------------- */\r\n\r\n/*!\r\n * @addtogroup Backward_Compatibility_Symbols_S32K144 Backward Compatibility for S32K144\r\n * @{\r\n */\r\n\r\n/* No backward compatibility issues. */\r\n\r\n/*!\r\n * @}\r\n */ /* end of group Backward_Compatibility_Symbols_S32K144 */\r\n\r\n\r\n#else /* #if !defined(S32K144_H_) */\r\n  /* There is already included the same memory map. Check if it is compatible (has the same major version) */\r\n  #if (MCU_MEM_MAP_VERSION != 0x0400u)\r\n    #if (!defined(MCU_MEM_MAP_SUPPRESS_VERSION_WARNING))\r\n      #warning There are included two not compatible versions of memory maps. Please check possible differences.\r\n    #endif /* (!defined(MCU_MEM_MAP_SUPPRESS_VERSION_WARNING)) */\r\n  #endif /* (MCU_MEM_MAP_VERSION != 0x0400u) */\r\n#endif  /* #if !defined(S32K144_H_) */\r\n\r\n/* S32K144.h, eof. */\r\n"},{"name":"S32K144_features.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\S32K144\\include","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015 Freescale Semiconductor, Inc.\r\n * Copyright 2016-2017 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file S32K144_features.h\r\n * @brief Chip specific module features\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, Global typedef not referenced.\r\n * Type used only in some modules of the SDK.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.4, tag unused outside of typedefs\r\n * Tag defined specifically for typedef\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macros defined are used to define features for each driver, so this might be reported\r\n * when the analysis is made only on one driver.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro\r\n * These are very simple macros used for abstracting hw implementation.\r\n * They help make the code easy to understand.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n */\r\n\r\n#if !defined(S32K144_FEATURES_H)\r\n#define S32K144_FEATURES_H\r\n\r\n/* ERRATA sections*/\r\n\r\n/* @brief ARM Errata 838869: Store immediate overlapping exception return operation might vector to\r\n * incorrect interrupt. */\r\n#define ERRATA_E9005\r\n\r\n/* @brief ARM Errata 709718: VDIV or VSQRT instructions might not complete correctly when very\r\n * short ISRs are used. */\r\n#define ERRATA_E6940\r\n\r\n/* @brief E10655: When using LPSPI in master mode and the SR[MBF] bit is read as a one, then, the\r\n * flag is set. If it is read as a zero, it must be read second time and this second read will be\r\n * the correct state of the bit. */\r\n#define ERRATA_E10655\r\n\r\n/* @brief E10792: LPI2C: Slave Transmit Data Flag may incorrectly read as one when TXCFG is zero.\r\n * Interrupts for transfer data should be enabled after the address valid event is detected and\r\n * disabled at the end of the transfer. */\r\n#define ERRATA_E10792\r\n\r\n/* @brief Errata workaround: System clock status register may be a erroneous status during the system clock switch.\r\n * Read system clock source twice. */\r\n#define ERRATA_E10777\r\n\r\n/* @brief E10856: FTM: Safe state is not removed from channel outputs after fault condition\r\n * ends if SWOCTRL is being used to control the pin */\r\n#define ERRATA_E10856\r\n\r\n/* @brief Number of cores. */\r\n#define NUMBER_OF_CORES (1u)\r\n\r\n/* @brief Number of alternative clocks available */\r\n#define NUMBER_OF_ALT_CLOCKS  ADC_CLK_ALT_1\r\n\r\n/* PCC module features */\r\n\r\n/* @brief Has InUse feature (register bit PCC[INUSE]). */\r\n#define FEATURE_PCC_HAS_IN_USE_FEATURE (0)\r\n\r\n/* PORT module features */\r\n/*! @brief PORT Used for setting Pins */\r\n#define FEATURE_PINS_DRIVER_USING_PORT (1)\r\n/* @brief Has control lock (register bit PCR[LK]). */\r\n#define FEATURE_PORT_HAS_PIN_CONTROL_LOCK (1)\r\n/* @brief Has open drain control (register bit PCR[ODE]). */\r\n#define FEATURE_PINS_HAS_OPEN_DRAIN (0)\r\n/* @brief Has digital filter (registers DFER, DFCR and DFWR). */\r\n#define FEATURE_PORT_HAS_DIGITAL_FILTER (1)\r\n/* @brief Has trigger output to trigger other peripherals (register bit field PCR[IRQC] values). */\r\n#define FEATURE_PORT_HAS_TRIGGER_OUT (0)\r\n/* @brief Has setting flag only (register bit field PCR[IRQC] values). */\r\n#define FEATURE_PORT_HAS_FLAG_SET_ONLY (0)\r\n/* @brief Has over-current feature (register bit field PCR[OCIE] values). */\r\n#define FEATURE_PINS_HAS_OVER_CURRENT (0)\r\n/* @brief Has pull resistor selection available. */\r\n#define FEATURE_PINS_HAS_PULL_SELECTION (1)\r\n/* @brief Has slew rate control (register bit PCR[SRE]). */\r\n#define FEATURE_PINS_HAS_SLEW_RATE (0)\r\n/* @brief Has passive filter (register bit field PCR[PFE]). */\r\n#define FEATURE_PORT_HAS_PASSIVE_FILTER (1)\r\n/* @brief Has drive strength (register bit PCR[DSE]). */\r\n#define FEATURE_PINS_HAS_DRIVE_STRENGTH (1)\r\n/* @brief Has drive strength control bits*/\r\n#define FEATURE_PINS_HAS_DRIVE_STRENGTH_CONTROL (0)\r\n/* @brief Has port input disable control bits*/\r\n#define FEATURE_PORT_HAS_INPUT_DISABLE (1)\r\n/* @brief SIM_CHIPCTL_ADC_INTERLEAVE_EN bit is available */\r\n#define FEATURE_PINS_HAS_ADC_INTERLEAVE_EN (1)\r\n\r\n/* SOC module features */\r\n\r\n/* @brief PORT availability on the SoC. */\r\n#define FEATURE_SOC_PORT_COUNT (5)\r\n\r\n#define FEATURE_SOC_SCG_COUNT (1)\r\n\r\n/* @brief Slow IRC high range clock frequency. */\r\n#define FEATURE_SCG_SIRC_HIGH_RANGE_FREQ (8000000U)\r\n\r\n/* @brief Fast IRC trimmed clock frequency(48MHz). */\r\n#define FEATURE_SCG_FIRC_FREQ0  (48000000U)\r\n\r\n/* CMP module features */\r\n\r\n/* @brief Comparator hard block offset control */\r\n#define FEATURE_CMP_HAS_HARD_BLOCK_OFFSET   (1)\r\n/* @brief Comparator fix DAC input to mux side */\r\n#define FEATURE_CMP_DAC_FIX_SELECTION       (0)\r\n/* @brief Comparator initialization delay */\r\n#define FEATURE_CMP_HAS_INIT_DELAY          (1)\r\n\r\n#define C0_RESET_VALUE (CMP_C0_DMAEN(0U) | CMP_C0_IER(0U) | CMP_C0_IEF(0U) | CMP_C0_CFR(1U) |                     \\\r\n                        CMP_C0_CFF(1U) | CMP_C0_FPR(0U) | CMP_C0_SE(0U) | CMP_C0_WE(0U) |                         \\\r\n                        CMP_C0_PMODE(0U) | CMP_C0_INVT(0U) | CMP_C0_COS(0U) | CMP_C0_OPE(0U) |                    \\\r\n                        CMP_C0_EN(0U) | CMP_C0_FILTER_CNT(0U) | CMP_C0_OFFSET(0U) | CMP_C0_HYSTCTR(0U))\r\n\r\n#define C1_RESET_VALUE (CMP_C1_INPSEL(0U) | CMP_C1_INNSEL(0U) | CMP_C1_CHN7(0U) | CMP_C1_CHN6(0U) |               \\\r\n                        CMP_C1_CHN5(0U) | CMP_C1_CHN4(0U) | CMP_C1_CHN3(0U) | CMP_C1_CHN2(0U) |                   \\\r\n                        CMP_C1_CHN1(0U) | CMP_C1_CHN0(0U) | CMP_C1_DACEN(0U) | CMP_C1_VRSEL(0U) |                 \\\r\n                        CMP_C1_PSEL(0U) | CMP_C1_MSEL(0U) |  CMP_C1_VOSEL(0U))\r\n\r\n#define C2_RESET_VALUE (CMP_C2_RRE(0U) | CMP_C2_RRIE(0U) | CMP_C2_FXMP(0U) | CMP_C2_FXMXCH(0U) | CMP_C2_CH7F(1U) |    \\\r\n                        CMP_C2_CH6F(1U) | CMP_C2_CH5F(1U) | CMP_C2_CH4F(1U) | CMP_C2_CH3F(1U) | CMP_C2_CH2F(1U) |     \\\r\n                        CMP_C2_CH1F(1U) | CMP_C2_CH0F(1U) | CMP_C2_NSAM(0U) | CMP_C2_NSAM(0U) | CMP_C2_INITMOD(0U) |  \\\r\n                        CMP_C2_ACOn(0U))\r\n\r\n#define CMP_DAC_SOURCE          0U\r\n#define CMP_MUX_SOURCE          1U\r\n#define CMP_DAC_RESOLUTION      255U\r\n\r\n/* FLASH module features */\r\n\r\n/* @brief Is of type FTFA. */\r\n#define FEATURE_FLS_IS_FTFA (0u)\r\n/* @brief Is of type FTFC. */\r\n#define FEATURE_FLS_IS_FTFC (1u)\r\n/* @brief Is of type FTFE. */\r\n#define FEATURE_FLS_IS_FTFE (0u)\r\n/* @brief Is of type FTFL. */\r\n#define FEATURE_FLS_IS_FTFL (0u)\r\n/* @brief Is of type FTFM. */\r\n#define FEATURE_FLS_IS_FTFM (0u)\r\n/* @brief Has flags indicating the status of the FlexRAM (register bits FCNFG[EEERDY], FCNFG[RAMRDY] and FCNFG[PFLSH]). */\r\n#define FEATURE_FLS_HAS_FLEX_RAM_FLAGS (1u)\r\n/* @brief Has program flash swapping status flag (register bit FCNFG[SWAP]). */\r\n#define FEATURE_FLS_HAS_PF_SWAPPING_STATUS_FLAG (0u)\r\n/* @brief Has EEPROM region protection (register FEPROT). */\r\n#define FEATURE_FLS_HAS_EEROM_REGION_PROTECTION (1u)\r\n/* @brief Has data flash region protection (register FDPROT). */\r\n#define FEATURE_FLS_HAS_DATA_FLS_REGION_PROTECTION (1u)\r\n/* @brief P-Flash block count. */\r\n#define FEATURE_FLS_PF_BLOCK_COUNT (1u)\r\n/* @brief P-Flash block size. */\r\n#define FEATURE_FLS_PF_BLOCK_SIZE (0x80000U)\r\n/* @brief P-Flash sector size. */\r\n#define FEATURE_FLS_PF_BLOCK_SECTOR_SIZE (4096u)\r\n/* @brief P-Flash write unit size. */\r\n#define FEATURE_FLS_PF_BLOCK_WRITE_UNIT_SIZE (8u)\r\n/* @brief P-Flash block swap feature. */\r\n#define FEATURE_FLS_HAS_PF_BLOCK_SWAP (0u)\r\n/* @brief Has FlexNVM memory. */\r\n#define FEATURE_FLS_HAS_FLEX_NVM (1u)\r\n/* @brief FlexNVM block count. */\r\n#define FEATURE_FLS_DF_BLOCK_COUNT (1u)\r\n/* @brief FlexNVM block size. */\r\n#define FEATURE_FLS_DF_BLOCK_SIZE (65536u)\r\n/* @brief FlexNVM sector size. */\r\n#define FEATURE_FLS_DF_BLOCK_SECTOR_SIZE (2048u)\r\n/* @brief FlexNVM write unit size. */\r\n#define FEATURE_FLS_DF_BLOCK_WRITE_UNIT_SIZE (8u)\r\n/* @brief FlexNVM start address. (Valid only if FlexNVM is available.) */\r\n#define FEATURE_FLS_DF_START_ADDRESS (0x10000000u)\r\n/* @brief Has FlexRAM memory. */\r\n#define FEATURE_FLS_HAS_FLEX_RAM (1u)\r\n/* @brief FlexRAM size. */\r\n#define FEATURE_FLS_FLEX_RAM_SIZE (4096u)\r\n/* @brief FlexRAM start address. (Valid only if FlexRAM is available.) */\r\n#define FEATURE_FLS_FLEX_RAM_START_ADDRESS (0x14000000u)\r\n/* @brief Has 0x00 Read 1s Block command. */\r\n#define FEATURE_FLS_HAS_READ_1S_BLOCK_CMD (1u)\r\n/* @brief Has 0x01 Read 1s Section command. */\r\n#define FEATURE_FLS_HAS_READ_1S_SECTION_CMD (1u)\r\n/* @brief Has 0x02 Program Check command. */\r\n#define FEATURE_FLS_HAS_PROGRAM_CHECK_CMD (1u)\r\n/* @brief Has 0x03 Read Resource command. */\r\n#define FEATURE_FLS_HAS_READ_RESOURCE_CMD (0u)\r\n/* @brief Has 0x06 Program Longword command. */\r\n#define FEATURE_FLS_HAS_PROGRAM_LONGWORD_CMD (0u)\r\n/* @brief Has 0x07 Program Phrase command. */\r\n#define FEATURE_FLS_HAS_PROGRAM_PHRASE_CMD (1u)\r\n/* @brief Has 0x08 Erase Flash Block command. */\r\n#define FEATURE_FLS_HAS_ERASE_BLOCK_CMD (1u)\r\n/* @brief Has 0x09 Erase Flash Sector command. */\r\n#define FEATURE_FLS_HAS_ERASE_SECTOR_CMD (1u)\r\n/* @brief Has 0x0B Program Section command. */\r\n#define FEATURE_FLS_HAS_PROGRAM_SECTION_CMD (1u)\r\n/* @brief Has 0x40 Read 1s All Blocks command. */\r\n#define FEATURE_FLS_HAS_READ_1S_ALL_BLOCKS_CMD (1u)\r\n/* @brief Has 0x41 Read Once command. */\r\n#define FEATURE_FLS_HAS_READ_ONCE_CMD (1u)\r\n/* @brief Has 0x43 Program Once command. */\r\n#define FEATURE_FLS_HAS_PROGRAM_ONCE_CMD (1u)\r\n/* @brief Has 0x44 Erase All Blocks command. */\r\n#define FEATURE_FLS_HAS_ERASE_ALL_CMD (1u)\r\n/* @brief Has 0x45 Verify Backdoor Access Key command. */\r\n#define FEATURE_FLS_HAS_VERIFY_BACKDOOR_ACCESS_KEY_CMD (1u)\r\n/* @brief Has 0x46 Swap Control command. */\r\n#define FEATURE_FLS_HAS_SWAP_CONTROL_CMD (0u)\r\n/* @brief Has 0x49 Erase All Blocks unsecure command. */\r\n#define FEATURE_FLS_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD (1u)\r\n/* @brief Has 0x80 Program Partition command. */\r\n#define FEATURE_FLS_HAS_PROGRAM_PARTITION_CMD (1u)\r\n/* @brief Has 0x81 Set FlexRAM Function command. */\r\n#define FEATURE_FLS_HAS_SET_FLEXRAM_FUNCTION_CMD (1u)\r\n/* @brief P-Flash Erase/Read 1st all block command address alignment. */\r\n#define FEATURE_FLS_PF_BLOCK_CMD_ADDRESS_ALIGMENT (16u)\r\n/* @brief P-Flash Erase sector command address alignment. */\r\n#define FEATURE_FLS_PF_SECTOR_CMD_ADDRESS_ALIGMENT (16u)\r\n/* @brief P-Flash Program/Verify section command address alignment. */\r\n#define FEATURE_FLS_PF_SECTION_CMD_ADDRESS_ALIGMENT (16u)\r\n/* @brief P-Flash Read resource command address alignment. */\r\n#define FEATURE_FLS_PF_RESOURCE_CMD_ADDRESS_ALIGMENT (8u)\r\n/* @brief P-Flash Program check command address alignment. */\r\n#define FEATURE_FLS_PF_CHECK_CMD_ADDRESS_ALIGMENT (4u)\r\n/* @brief P-Flash Program check command address alignment. */\r\n#define FEATURE_FLS_PF_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT (0u)\r\n/* @brief FlexNVM Erase/Read 1st all block command address alignment. */\r\n#define FEATURE_FLS_DF_BLOCK_CMD_ADDRESS_ALIGMENT (8u)\r\n/* @brief FlexNVM Erase sector command address alignment. */\r\n#define FEATURE_FLS_DF_SECTOR_CMD_ADDRESS_ALIGMENT (8u)\r\n/* @brief FlexNVM Program/Verify section command address alignment. */\r\n#define FEATURE_FLS_DF_SECTION_CMD_ADDRESS_ALIGMENT (8u)\r\n/* @brief FlexNVM Read resource command address alignment. */\r\n#define FEATURE_FLS_DF_RESOURCE_CMD_ADDRESS_ALIGMENT (8u)\r\n/* @brief FlexNVM Program check command address alignment. */\r\n#define FEATURE_FLS_DF_CHECK_CMD_ADDRESS_ALIGMENT (4u)\r\n/* @brief FlexNVM partition code 0000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0000 (0x00010000u)\r\n/* @brief FlexNVM partition code 0001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0001 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 0010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0010 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 0011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0011 (0x00008000u)\r\n/* @brief FlexNVM partition code 0100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0100 (0x00000000u)\r\n/* @brief FlexNVM partition code 0101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0101 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 0110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0110 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 0111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_0111 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 1000 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1000 (0x00000000u)\r\n/* @brief FlexNVM partition code 1001 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1001 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 1010 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1010 (0x00004000u)\r\n/* @brief FlexNVM partition code 1011 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1011 (0x00008000u)\r\n/* @brief FlexNVM partition code 1100 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1100 (0x00010000u)\r\n/* @brief FlexNVM partition code 1101 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1101 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 1110 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1110 (0xFFFFFFFFu)\r\n/* @brief FlexNVM partition code 1111 mapping to data flash size in bytes (0xFFFFFFFF = reserved). */\r\n#define FEATURE_FLS_DF_SIZE_1111 (0x00010000u)\r\n/* @brief Emulated EEPROM size code 0000 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0000 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 0001 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0001 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 0010 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0010 (0x1000u)\r\n/* @brief Emulated EEPROM size code 0011 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0011 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 0100 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0100 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 0101 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0101 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 0110 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0110 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 0111 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_0111 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1000 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1000 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1001 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1001 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1010 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1010 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1011 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1011 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1100 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1100 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1101 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1101 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1110 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1110 (0xFFFFu)\r\n/* @brief Emulated EEPROM size code 1111 mapping to emulated EEPROM size in bytes (0xFFFF = reserved). */\r\n#define FEATURE_FLS_EE_SIZE_1111 (0x0000u)\r\n/* @brief Has the detection of uncorrected ECC errors. */\r\n#define FEATURE_FLS_HAS_DETECT_ECC_ERROR (1)\r\n/* @brief Has the interrupt double bit fault detect. */\r\n#define FEATURE_FLS_HAS_INTERRUPT_DOUBLE_BIT_FAULT_IRQ (1)\r\n\r\n/* CAN module features */\r\n\r\n/* @brief Frames available in Rx FIFO flag shift */\r\n#define FEATURE_CAN_RXFIFO_FRAME_AVAILABLE  (5U)\r\n/* @brief Rx FIFO warning flag shift */\r\n#define FEATURE_CAN_RXFIFO_WARNING          (6U)\r\n/* @brief Rx FIFO overflow flag shift */\r\n#define FEATURE_CAN_RXFIFO_OVERFLOW         (7U)\r\n/* @brief The list contains definitions of the FD feature support on all instances */\r\n#define FEATURE_CAN_INSTANCES_HAS_FD        {true, false, false}\r\n/* @brief Has Flexible Data Rate for CAN0 */\r\n#define FEATURE_CAN0_HAS_FD                 (1)\r\n/* @brief Has Flexible Data Rate for CAN1 */\r\n#define FEATURE_CAN1_HAS_FD                 (0)\r\n/* @brief Has Flexible Data Rate for CAN2 */\r\n#define FEATURE_CAN2_HAS_FD                 (0)\r\n/* @brief Maximum number of Message Buffers supported for payload size 8 for CAN0 */\r\n#define FEATURE_CAN0_MAX_MB_NUM             (32U)\r\n/* @brief Maximum number of Message Buffers supported for payload size 8 for CAN1 */\r\n#define FEATURE_CAN1_MAX_MB_NUM             (16U)\r\n/* @brief Maximum number of Message Buffers supported for payload size 8 for CAN2 */\r\n#define FEATURE_CAN2_MAX_MB_NUM             (16U)\r\n/* @brief Has PE clock source select (bit field CAN_CTRL1[CLKSRC]). */\r\n#define FEATURE_CAN_HAS_PE_CLKSRC_SELECT    (1)\r\n/* @brief Has DMA enable (bit field MCR[DMA]). */\r\n#define FEATURE_CAN_HAS_DMA_ENABLE          (1)\r\n/* @brief Maximum number of Message Buffers supported for payload size 8 for any of the CAN instances */\r\n#define FEATURE_CAN_MAX_MB_NUM              (32U)\r\n/* @brief Maximum number of Message Buffers supported for payload size 8 for any of the CAN instances */\r\n#define FEATURE_CAN_MAX_MB_NUM_ARRAY        { FEATURE_CAN0_MAX_MB_NUM, \\\r\n                                              FEATURE_CAN1_MAX_MB_NUM, \\\r\n                                              FEATURE_CAN2_MAX_MB_NUM }\r\n/* @brief Has Pretending Networking mode */\r\n#define FEATURE_CAN_HAS_PRETENDED_NETWORKING    (1)\r\n/* @brief Has Stuff Bit Count Enable Bit */\r\n#define FEATURE_CAN_HAS_STFCNTEN_ENABLE         (0)\r\n/* @brief Has ISO CAN FD Enable Bit */\r\n#define FEATURE_CAN_HAS_ISOCANFDEN_ENABLE       (1)\r\n/* @brief Has Message Buffer Data Size Region 1 */\r\n#define FEATURE_CAN_HAS_MBDSR1                  (0)\r\n/* @brief Has Message Buffer Data Size Region 2 */\r\n#define FEATURE_CAN_HAS_MBDSR2                  (0)\r\n/* @brief DMA hardware requests for all FlexCAN instances */\r\n#define FEATURE_CAN_EDMA_REQUESTS              { EDMA_REQ_FLEXCAN0, \\\r\n                                                 EDMA_REQ_FLEXCAN1, \\\r\n                                                 EDMA_REQ_FLEXCAN2 }\r\n\r\n\r\n/* @brief Maximum number of Message Buffers IRQs */\r\n#define FEATURE_CAN_MB_IRQS_MAX_COUNT       (2U)\r\n/* @brief Message Buffers IRQs */\r\n#define FEATURE_CAN_MB_IRQS                 { CAN_ORed_0_15_MB_IRQS, \\\r\n                                              CAN_ORed_16_31_MB_IRQS }\r\n/* @brief Has Wake Up Irq channels (CAN_Wake_Up_IRQS_CH_COUNT > 0u) */\r\n#define FEATURE_CAN_HAS_WAKE_UP_IRQ         (1)\r\n/* @brief Has Self Wake Up mode */\r\n#define FEATURE_CAN_HAS_SELF_WAKE_UP        (0)\r\n/* @brief Has Flexible Data Rate */\r\n#define FEATURE_CAN_HAS_FD                  (1)\r\n/* @brief Clock name for the PE oscillator clock source */\r\n#define FEATURE_CAN_PE_OSC_CLK_NAME         SOSC_CLK\r\n/* @bried FlexCAN has Detection And Correction of Memory Errors */\r\n#define FEATURE_CAN_HAS_MEM_ERR_DET\t\t\t(0)\r\n\r\n/* LPUART module features */\r\n\r\n/* @brief Has extended data register ED. */\r\n#define FEATURE_LPUART_HAS_EXTENDED_DATA_REGISTER_FLAGS (1)\r\n/* @brief Hardware flow control (RTS, CTS) is supported. */\r\n#define FEATURE_LPUART_HAS_MODEM_SUPPORT (1)\r\n/* @brief Baud rate oversampling is available. */\r\n#define FEATURE_LPUART_HAS_BAUD_RATE_OVER_SAMPLING_SUPPORT (1)\r\n/* @brief Baud rate oversampling is available. */\r\n#define FEATURE_LPUART_HAS_BOTH_EDGE_SAMPLING_SUPPORT (1)\r\n/* @brief Capacity (number of entries) of the transmit/receive FIFO (or zero if no FIFO is available). */\r\n#define FEATURE_LPUART_FIFO_SIZE (4U)\r\n/* @brief Supports two match addresses to filter incoming frames. */\r\n#define FEATURE_LPUART_HAS_ADDRESS_MATCHING (1)\r\n/* @brief Has transmitter/receiver DMA enable bits. */\r\n#define FEATURE_LPUART_HAS_DMA_ENABLE (1)\r\n/* @brief Flag clearance mask for STAT register. */\r\n#define FEATURE_LPUART_STAT_REG_FLAGS_MASK (0xC01FC000U)\r\n/* @brief Flag clearance mask for FIFO register. */\r\n#define FEATURE_LPUART_FIFO_REG_FLAGS_MASK (0x00030000U)\r\n/* @brief Reset mask for FIFO register. */\r\n#define FEATURE_LPUART_FIFO_RESET_MASK (0x0003C000U)\r\n/* @brief Default oversampling ratio. */\r\n#define FEATURE_LPUART_DEFAULT_OSR (0x0FUL)\r\n/* @brief Default baud rate modulo divisor. */\r\n#define FEATURE_LPUART_DEFAULT_SBR (0x04UL)\r\n/* @brief Clock names for LPUART. */\r\n#define LPUART_CLOCK_NAMES {LPUART0_CLK, LPUART1_CLK, LPUART2_CLK}\r\n\r\n/* FlexIO module features */\r\n\r\n/* @brief Define the maximum number of shifters for any FlexIO instance. */\r\n#define FEATURE_FLEXIO_MAX_SHIFTER_COUNT  (4U)\r\n/* @brief Define DMA request names for Flexio. */\r\n#define FEATURE_FLEXIO_DMA_REQ_0    EDMA_REQ_FLEXIO_SHIFTER0\r\n#define FEATURE_FLEXIO_DMA_REQ_1    EDMA_REQ_FLEXIO_SHIFTER1\r\n#define FEATURE_FLEXIO_DMA_REQ_2    EDMA_REQ_FLEXIO_SHIFTER2\r\n#define FEATURE_FLEXIO_DMA_REQ_3    EDMA_REQ_FLEXIO_SHIFTER3\r\n\r\n/* LPSPI module features */\r\n\r\n/* @brief DMA instance used for LPSPI module */\r\n#define LPSPI_DMA_INSTANCE 0U\r\n\r\n/* LPI2C module features */\r\n\r\n/* @brief DMA instance used for LPI2C module */\r\n#define LPI2C_DMA_INSTANCE 0U\r\n\r\n/* @brief EDMA requests for LPI2C module. */\r\n#define LPI2C_EDMA_REQ                           {{(uint8_t)EDMA_REQ_LPI2C0_TX, (uint8_t)EDMA_REQ_LPI2C0_RX}}\r\n/* @brief PCC clocks for LPI2C module. */\r\n#define LPI2C_PCC_CLOCKS                         {LPI2C0_CLK}\r\n\r\n/* Interrupt module features */\r\n\r\n/* @brief Lowest interrupt request number. */\r\n#define FEATURE_INTERRUPT_IRQ_MIN         (NonMaskableInt_IRQn)\r\n/* @brief Highest interrupt request number. */\r\n#define FEATURE_INTERRUPT_IRQ_MAX         (FTM3_Ovf_Reload_IRQn)\r\n/**< Number of priority bits implemented in the NVIC */\r\n#define FEATURE_NVIC_PRIO_BITS            (4U)\r\n/* @brief Has software interrupt. */\r\n#define FEATURE_INTERRUPT_HAS_SOFTWARE_IRQ  (0u)\r\n/* @brief Has pending interrupt state. */\r\n#define FEATURE_INTERRUPT_HAS_PENDING_STATE (1u)\r\n/* @brief Has active interrupt state. */\r\n#define FEATURE_INTERRUPT_HAS_ACTIVE_STATE  (1u)\r\n/* @brief Multicore support for interrupts */\r\n#define FEATURE_INTERRUPT_MULTICORE_SUPPORT  (0u)\r\n/* @brief Registers in which the start of interrupt vector table needs to be configured */\r\n#define FEATURE_INTERRUPT_INT_VECTORS {&S32_SCB->VTOR}\r\n\r\n\r\n/* System Control Block module features */\r\n\r\n/* @brief VECTKEY value so that AIRCR register write is not ignored. */\r\n#define FEATURE_SCB_VECTKEY               (0x05FAU)\r\n\r\n\r\n/* SMC module features */\r\n\r\n/* @brief Has stop option (register bit STOPCTRL[STOPO]). */\r\n#define FEATURE_SMC_HAS_STOPO (1U)\r\n/* @brief Has partial stop option (register bit STOPCTRL[PSTOPO]). */\r\n#define FEATURE_SMC_HAS_PSTOPO (0U)\r\n/* @brief Has WAIT and VLPW options. */\r\n#define FEATURE_SMC_HAS_WAIT_VLPW (0U)\r\n/* @brief Has high speed run mode (register bit PMPROT[AHSRUN]). */\r\n#define FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE (1U)\r\n/* @brief Value of SPLL source clock in the SCG_HCCR register */\r\n#define FEATURE_SCG_SPLL_VALUE (6U)\r\n/* RCM module feature */\r\n\r\n/* @brief Has existence of CMU loss of clock as reset source */\r\n#define FEATURE_RCM_HAS_EXISTENCE_CMU_LOSS_OF_CLOCK (0)\r\n/* @brief Has CMU loss of clock as reset source */\r\n#define FEATURE_RCM_HAS_CMU_LOSS_OF_CLOCK (0)\r\n/* @brief Has sticky CMU loss of clock as reset source */\r\n#define FEATURE_RCM_HAS_STICKY_CMU_LOSS_OF_CLOCK (0)\r\n\r\n/* MPU module features */\r\n\r\n/* @brief Specifies hardware revision level. */\r\n#define FEATURE_MPU_HARDWARE_REVISION_LEVEL   (1U)\r\n/* @brief Has process identifier support. */\r\n#define FEATURE_MPU_HAS_PROCESS_IDENTIFIER    (1U)\r\n/* @brief The number of master has process identifier. */\r\n#define FEATURE_MPU_NUM_MASTER_HAS_PROCESS_IDENTIFIER    (2U)\r\n/* @brief Specifies total number of bus masters. */\r\n#define FEATURE_MPU_MASTER_COUNT              (3U)\r\n/* @brief Specifies maximum number of masters which have separated\r\nprivilege rights for user and supervisor mode accesses (e.g. master0~3 in S32K14x).\r\n*/\r\n#define FEATURE_MPU_MAX_LOW_MASTER_NUMBER     (3U)\r\n/* @brief Specifies maximum number of masters which have only\r\nread and write permissions (e.g. master4~7 in S32K14x).\r\n*/\r\n#define FEATURE_MPU_MAX_HIGH_MASTER_NUMBER    (7U)\r\n\r\n/* @brief Specifies number of set access control right bits for\r\n   masters which have separated privilege rights for user and\r\n   supervisor mode accesses (e.g. master0~3 in S32K14x).\r\n*/\r\n#define FEATURE_MPU_LOW_MASTER_CONTROL_WIDTH  (6U)\r\n/* @brief Specifies number of set access control right bits for\r\n   masters which have only read and write permissions(e.g. master4~7 in S32K14x).\r\n*/\r\n#define FEATURE_MPU_HIGH_MASTER_CONTROL_WIDTH (2U)\r\n\r\n/* @brief The MPU Logical Bus Master Number for core bus master. */\r\n#define FEATURE_MPU_MASTER_CORE               (0U)\r\n/* @brief The MPU Logical Bus Master Number for Debugger master. */\r\n#define FEATURE_MPU_MASTER_DEBUGGER           (1U)\r\n/* @brief The MPU Logical Bus Master Number for DMA master. */\r\n#define FEATURE_MPU_MASTER_DMA                (2U)\r\n/* @brief Specifies master number. */\r\n#define FEATURE_MPU_MASTER                        \\\r\n{                                                 \\\r\n    FEATURE_MPU_MASTER_CORE,     /*!< CORE */     \\\r\n    FEATURE_MPU_MASTER_DEBUGGER, /*!< DEBUGGER */ \\\r\n    FEATURE_MPU_MASTER_DMA,      /*!< DMA */      \\\r\n}\r\n\r\n/* @brief Specifies total number of slave ports. */\r\n#define FEATURE_MPU_SLAVE_COUNT               (4U)\r\n/* @brief The MPU Slave Port Assignment for Flash Controller and boot ROM. */\r\n#define FEATURE_MPU_SLAVE_FLASH_BOOTROM       (0U)\r\n/* @brief The MPU Slave Port Assignment for SRAM back door. */\r\n#define FEATURE_MPU_SLAVE_SRAM_BACKDOOR       (1U)\r\n/* @brief The MPU Slave Port Assignment for SRAM_L front door. */\r\n#define FEATURE_MPU_SLAVE_SRAM_L_FRONTDOOR    (2U)\r\n/* @brief The MPU Slave Port Assignment for SRAM_U front door. */\r\n#define FEATURE_MPU_SLAVE_SRAM_U_FRONTDOOR    (3U)\r\n/* @brief The MPU Slave Port mask. */\r\n#define FEATURE_MPU_SLAVE_MASK                (0xF0000000U)\r\n#define FEATURE_MPU_SLAVE_SHIFT               (28u)\r\n#define FEATURE_MPU_SLAVE_WIDTH               (4u)\r\n#define FEATURE_MPU_SLAVE(x)                  (((uint32_t)(((uint32_t)(x))<<FEATURE_MPU_SLAVE_SHIFT))&FEATURE_MPU_SLAVE_MASK)\r\n\r\n/* WDOG module features */\r\n\r\n/* @brief The 32-bit value used for unlocking the WDOG. */\r\n#define FEATURE_WDOG_UNLOCK_VALUE                       (0xD928C520U)\r\n/* @brief The 32-bit value used for resetting the WDOG counter. */\r\n#define FEATURE_WDOG_TRIGGER_VALUE                      (0xB480A602U)\r\n/* @brief The reset value of the timeout register. */\r\n#define FEATURE_WDOG_TO_RESET_VALUE                     (0x400U)\r\n/* @brief The value minimum of the timeout register. */\r\n#define FEATURE_WDOG_MINIMUM_TIMEOUT_VALUE              (0x0U)\r\n/* @brief The reset value of the window register. */\r\n#define FEATURE_WDOG_WIN_RESET_VALUE                    (0x0U)\r\n/* @brief The mask of the reserved bit in the CS register. */\r\n#define FEATURE_WDOG_CS_RESERVED_MASK                   (0x2000U)\r\n/* @brief The value used to set WDOG source clock from LPO. */\r\n#define FEATURE_WDOG_CLK_FROM_LPO                       (0x1UL)\r\n/* @brief The first 16-bit value used for unlocking the WDOG. */\r\n#define FEATURE_WDOG_UNLOCK16_FIRST_VALUE               (0xC520U)\r\n/* @brief The second 16-bit value used for unlocking the WDOG. */\r\n#define FEATURE_WDOG_UNLOCK16_SECOND_VALUE              (0xD928U)\r\n/* @brief The first 16-bit value used for resetting the WDOG counter. */\r\n#define FEATURE_WDOG_TRIGGER16_FIRST_VALUE              (0xA602U)\r\n/* @brief The second 16-bit value used for resetting the WDOG counter. */\r\n#define FEATURE_WDOG_TRIGGER16_SECOND_VALUE             (0xB480U)\r\n/* @brief Default reset value of the CS register. */\r\n#define FEATURE_WDOG_CS_RESET_VALUE                     (0x2520U)\r\n\r\n/* CRC module features */\r\n\r\n/* @brief CRC module use for S32K. */\r\n#define FEATURE_CRC_DRIVER_SOFT_POLYNOMIAL\r\n/* @brief Default CRC bit width */\r\n#define FEATURE_CRC_DEFAULT_WIDTH               CRC_BITS_16\r\n/* @brief Default CRC read transpose */\r\n#define FEATURE_CRC_DEFAULT_READ_TRANSPOSE      CRC_TRANSPOSE_NONE\r\n/* @brief Default CRC write transpose */\r\n#define FEATURE_CRC_DEFAULT_WRITE_TRANSPOSE     CRC_TRANSPOSE_NONE\r\n/* @brief Default polynomial 0x1021U */\r\n#define FEATURE_CRC_DEFAULT_POLYNOMIAL          (0x1021U)\r\n/* @brief Default seed value is 0xFFFFU */\r\n#define FEATURE_CRC_DEFAULT_SEED                (0xFFFFU)\r\n\r\n/* DMA module features */\r\n\r\n/* @brief Number of DMA channels. */\r\n#define FEATURE_DMA_CHANNELS (16U)\r\n/* @brief Number of DMA virtual channels. */\r\n#define FEATURE_DMA_VIRTUAL_CHANNELS (FEATURE_DMA_CHANNELS * DMA_INSTANCE_COUNT)\r\n/* @brief Number of DMA interrupt lines. */\r\n#define FEATURE_DMA_CHANNELS_INTERRUPT_LINES (16U)\r\n/* @brief Number of DMA virtual interrupt lines. */\r\n#define FEATURE_DMA_VIRTUAL_CHANNELS_INTERRUPT_LINES ((uint32_t)FEATURE_DMA_CHANNELS_INTERRUPT_LINES * (uint32_t)DMA_INSTANCE_COUNT)\r\n/* @brief Number of DMA error interrupt lines. */\r\n#define FEATURE_DMA_ERROR_INTERRUPT_LINES (1U)\r\n/* @brief Number of DMA virtual error interrupt lines. */\r\n#define FEATURE_DMA_VIRTUAL_ERROR_INTERRUPT_LINES ((uint32_t)FEATURE_DMA_ERROR_INTERRUPT_LINES * (uint32_t)DMA_INSTANCE_COUNT)\r\n/* @brief DMA module has error interrupt. */\r\n#define FEATURE_DMA_HAS_ERROR_IRQ\r\n/* @brief DMA module separate interrupt lines for each channel */\r\n#define FEATURE_DMA_SEPARATE_IRQ_LINES_PER_CHN\r\n/* @brief Conversion from channel index to DCHPRI index. */\r\n#define FEATURE_DMA_CHN_TO_DCHPRI_INDEX(x) ((x) ^ 3U)\r\n/* @brief DMA channel groups count. */\r\n#define FEATURE_DMA_CHANNEL_GROUP_COUNT (1U)\r\n/* @brief Clock name for DMA */\r\n#define FEATURE_DMA_CLOCK_NAMES {SIM_DMA_CLK}\r\n/* @brief DMA channel width based on number of TCDs: 2^N, N=4,5,... */\r\n#define FEATURE_DMA_CH_WIDTH (4U)\r\n/* @brief DMA channel to instance */\r\n#define FEATURE_DMA_VCH_TO_INSTANCE(x) \t((x) >> (uint32_t)FEATURE_DMA_CH_WIDTH)\r\n/* @brief DMA virtual channel to channel */\r\n#define FEATURE_DMA_VCH_TO_CH(x)        ((x) & ((uint32_t)FEATURE_DMA_CHANNELS - 1U))\r\n/* @brief DMA supports the following particular transfer size: */\r\n#define FEATURE_DMA_TRANSFER_SIZE_16B\r\n#define FEATURE_DMA_TRANSFER_SIZE_32B\r\n\r\n/* DMAMUX module features */\r\n\r\n/* @brief DMAMUX peripheral is available in silicon. */\r\n#define FEATURE_DMAMUX_AVAILABLE\r\n/* @brief Number of DMA channels. */\r\n#define FEATURE_DMAMUX_CHANNELS (16U)\r\n/* @brief Has the periodic trigger capability */\r\n#define FEATURE_DMAMUX_HAS_TRIG (1)\r\n/* @brief Conversion from request source to the actual DMAMUX channel */\r\n#define FEATURE_DMAMUX_REQ_SRC_TO_CH(x) (x)\r\n/* @brief Mapping between request source and DMAMUX instance */\r\n#define FEATURE_DMAMUX_REQ_SRC_TO_INSTANCE(x) (0U)\r\n/* @brief Conversion from eDMA channel index to DMAMUX channel. */\r\n#define FEATURE_DMAMUX_DMA_CH_TO_CH(x) (x)\r\n/* @brief Conversion from DMAMUX channel DMAMUX register index. */\r\n#define FEATURE_DMAMUX_CHN_REG_INDEX(x) (x)\r\n/* @brief Clock names for DMAMUX. */\r\n#define FEATURE_DMAMUX_CLOCK_NAMES {DMAMUX0_CLK}\r\n/*!\r\n * @brief Structure for the DMA hardware request\r\n *\r\n * Defines the structure for the DMA hardware request collections. The user can configure the\r\n * hardware request into DMAMUX to trigger the DMA transfer accordingly. The index\r\n * of the hardware request varies according  to the to SoC.\r\n */\r\n\r\ntypedef enum {\r\n    EDMA_REQ_DISABLED = 0U,\r\n    EDMA_REQ_LPUART0_RX = 2U,\r\n    EDMA_REQ_LPUART0_TX = 3U,\r\n    EDMA_REQ_LPUART1_RX = 4U,\r\n    EDMA_REQ_LPUART1_TX = 5U,\r\n    EDMA_REQ_LPUART2_RX = 6U,\r\n    EDMA_REQ_LPUART2_TX = 7U,\r\n    EDMA_REQ_FLEXIO_SHIFTER0 = 10U,\r\n    EDMA_REQ_FLEXIO_SHIFTER1 = 11U,\r\n    EDMA_REQ_FLEXIO_SHIFTER2 = 12U,\r\n    EDMA_REQ_FLEXIO_SHIFTER3 = 13U,\r\n    EDMA_REQ_LPSPI0_RX = 14U,\r\n    EDMA_REQ_LPSPI0_TX = 15U,\r\n    EDMA_REQ_LPSPI1_RX = 16U,\r\n    EDMA_REQ_LPSPI1_TX = 17U,\r\n    EDMA_REQ_LPSPI2_RX = 18U,\r\n    EDMA_REQ_LPSPI2_TX = 19U,\r\n    EDMA_REQ_FTM1_CHANNEL_0 = 20U,\r\n    EDMA_REQ_FTM1_CHANNEL_1 = 21U,\r\n    EDMA_REQ_FTM1_CHANNEL_2 = 22U,\r\n    EDMA_REQ_FTM1_CHANNEL_3 = 23U,\r\n    EDMA_REQ_FTM1_CHANNEL_4 = 24U,\r\n    EDMA_REQ_FTM1_CHANNEL_5 = 25U,\r\n    EDMA_REQ_FTM1_CHANNEL_6 = 26U,\r\n    EDMA_REQ_FTM1_CHANNEL_7 = 27U,\r\n    EDMA_REQ_FTM2_CHANNEL_0 = 28U,\r\n    EDMA_REQ_FTM2_CHANNEL_1 = 29U,\r\n    EDMA_REQ_FTM2_CHANNEL_2 = 30U,\r\n    EDMA_REQ_FTM2_CHANNEL_3 = 31U,\r\n    EDMA_REQ_FTM2_CHANNEL_4 = 32U,\r\n    EDMA_REQ_FTM2_CHANNEL_5 = 33U,\r\n    EDMA_REQ_FTM2_CHANNEL_6 = 34U,\r\n    EDMA_REQ_FTM2_CHANNEL_7 = 35U,\r\n    EDMA_REQ_FTM0_OR_CH0_CH7 = 36U,\r\n    EDMA_REQ_FTM3_OR_CH0_CH7 = 37U,\r\n    EDMA_REQ_ADC0 = 42U,\r\n    EDMA_REQ_ADC1 = 43U,\r\n    EDMA_REQ_LPI2C0_RX = 44U,\r\n    EDMA_REQ_LPI2C0_TX = 45U,\r\n    EDMA_REQ_PDB0 = 46U,\r\n    EDMA_REQ_PDB1 = 47U,\r\n    EDMA_REQ_CMP0 = 48U,\r\n    EDMA_REQ_PORTA = 49U,\r\n    EDMA_REQ_PORTB = 50U,\r\n    EDMA_REQ_PORTC = 51U,\r\n    EDMA_REQ_PORTD = 52U,\r\n    EDMA_REQ_PORTE = 53U,\r\n    EDMA_REQ_FLEXCAN0 = 54U,\r\n    EDMA_REQ_FLEXCAN1 = 55U,\r\n    EDMA_REQ_FLEXCAN2 = 56U,\r\n    EDMA_REQ_LPTMR0 = 59U,\r\n    EDMA_REQ_DMAMUX_ALWAYS_ENABLED0 = 62U,\r\n    EDMA_REQ_DMAMUX_ALWAYS_ENABLED1 = 63U\r\n} dma_request_source_t;\r\n\r\n/* LPI2C module features */\r\n\r\n/* @brief Disable high-speed and ultra-fast operating modes for S32K14x. */\r\n#define LPI2C_HAS_FAST_PLUS_MODE (0U)\r\n#define LPI2C_HAS_HIGH_SPEED_MODE (0U)\r\n#define LPI2C_HAS_ULTRA_FAST_MODE (0U)\r\n\r\n/* FTM module features */\r\n/* @brief Number of PWM channels */\r\n#define FEATURE_FTM_CHANNEL_COUNT               (8U)\r\n/* @brief Number of fault channels */\r\n#define FTM_FEATURE_FAULT_CHANNELS              (4U)\r\n/* @brief Width of control channel */\r\n#define FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH     (8U)\r\n/* @brief Output channel offset */\r\n#define FTM_FEATURE_OUTPUT_CHANNEL_OFFSET       (16U)\r\n/* @brief Max counter value */\r\n#define FTM_FEATURE_CNT_MAX_VALUE_U32           (0x0000FFFFU)\r\n/* @brief Input capture for single shot */\r\n#define FTM_FEATURE_INPUT_CAPTURE_SINGLE_SHOT   (2U)\r\n/* @brief Dithering has supported on the generated PWM signals */\r\n#define FEATURE_FTM_HAS_SUPPORTED_DITHERING     (0U)\r\n/*! @brief Number of interrupt vector for channels of the FTM module. */\r\n#define FEATURE_FTM_HAS_NUM_IRQS_CHANS          (4U)\r\n\r\n/* EWM module features */\r\n\r\n/* @brief First byte of the EWM Service key        */\r\n#define FEATURE_EWM_KEY_FIRST_BYTE      (0xB4U)\r\n/* @brief Second byte of the EWM Service key       */\r\n#define FEATURE_EWM_KEY_SECOND_BYTE     (0x2CU)\r\n/* @brief EWM Compare High register maximum value  */\r\n#define FEATURE_EWM_CMPH_MAX_VALUE      (0xFEU)\r\n/* @brief EWM Compare Low register minimum value  */\r\n#define FEATURE_EWM_CMPL_MIN_VALUE      (0x00U)\r\n\r\n/* @brief Supports high speed run mode. */\r\n#define FEATURE_HAS_HIGH_SPEED_RUN_MODE  (1U)\r\n/* @brief Supports SPLL clock source. */\r\n#define FEATURE_HAS_SPLL_CLK             (1U)\r\n/* @brief Supports LPO peripheral clock source. */\r\n#define FEATURE_HAS_LPO_PERIPHERAL_CLOCK_SOURCE (0U)\r\n\r\n/*! @brief Clock names. */\r\ntypedef enum {\r\n\r\n    /* Main clocks */\r\n    CORE_CLK                     = 0u,       /*!< Core clock                     */\r\n    BUS_CLK                      = 1u,       /*!< Bus clock                      */\r\n    SLOW_CLK                     = 2u,       /*!< Slow clock                     */\r\n    CLKOUT_CLK                   = 3u,       /*!< CLKOUT clock                   */\r\n\r\n    /* Other internal clocks used by peripherals. */\r\n    SIRC_CLK                     = 4u,       /*!< SIRC clock                     */\r\n    FIRC_CLK                     = 5u,       /*!< FIRC clock                     */\r\n    SOSC_CLK                     = 6u,       /*!< SOSC clock                     */\r\n    SPLL_CLK                     = 7u,       /*!< SPLL clock                     */\r\n    RTC_CLKIN_CLK                = 8u,       /*!< RTC_CLKIN clock                */\r\n    SCG_CLKOUT_CLK               = 9u,       /*!< SCG CLK_OUT clock              */\r\n\r\n    SIRCDIV1_CLK                 = 10u,      /*!< SIRCDIV1 functional clock      */\r\n    SIRCDIV2_CLK                 = 11u,      /*!< SIRCDIV2 functional clock      */\r\n    FIRCDIV1_CLK                 = 12u,      /*!< FIRCDIV1 functional clock      */\r\n    FIRCDIV2_CLK                 = 13u,      /*!< FIRCDIV2 functional clock      */\r\n    SOSCDIV1_CLK                 = 14u,      /*!< SOSCDIV1 functional clock      */\r\n    SOSCDIV2_CLK                 = 15u,      /*!< SOSCDIV2 functional clock      */\r\n    SPLLDIV1_CLK                 = 16u,      /*!< SPLLDIV1 functional clock      */\r\n    SPLLDIV2_CLK                 = 17u,      /*!< SPLLDIV2 functional clock      */\r\n\r\n    SCG_END_OF_CLOCKS            = 18u,      /*!< End of SCG clocks              */\r\n\r\n    /* SIM clocks */\r\n    SIM_FTM0_CLOCKSEL            = 21u,      /*!< FTM0 External Clock Pin Select */\r\n    SIM_FTM1_CLOCKSEL            = 22u,      /*!< FTM1 External Clock Pin Select */\r\n    SIM_FTM2_CLOCKSEL            = 23u,      /*!< FTM2 External Clock Pin Select */\r\n    SIM_FTM3_CLOCKSEL            = 24u,      /*!< FTM3 External Clock Pin Select */\r\n    SIM_CLKOUTSELL               = 25u,      /*!< CLKOUT Select                  */\r\n    SIM_RTCCLK_CLK               = 26u,      /*!< RTCCLK clock                   */\r\n    SIM_LPO_CLK                  = 27u,      /*!< LPO clock                      */\r\n    SIM_LPO_1K_CLK               = 28u,      /*!< LPO 1KHz clock                 */\r\n    SIM_LPO_32K_CLK              = 29u,      /*!< LPO 32KHz clock                */\r\n    SIM_LPO_128K_CLK             = 30u,      /*!< LPO 128KHz clock               */\r\n    SIM_EIM_CLK                  = 31u,      /*!< EIM clock source               */\r\n    SIM_ERM_CLK                  = 32u,      /*!< ERM clock source               */\r\n    SIM_DMA_CLK                  = 33u,      /*!< DMA clock source               */\r\n    SIM_MPU_CLK                  = 34u,      /*!< MPU clock source               */\r\n    SIM_MSCM_CLK                 = 35u,      /*!< MSCM clock source              */\r\n    SIM_END_OF_CLOCKS            = 36u,      /*!< End of SIM clocks              */\r\n\r\n    /* PCC clocks */\r\n    CMP0_CLK                     = 41u,      /*!< CMP0 clock source              */\r\n    CRC0_CLK                     = 42u,      /*!< CRC0 clock source              */\r\n    DMAMUX0_CLK                  = 43u,      /*!< DMAMUX0 clock source           */\r\n    EWM0_CLK                     = 44u,      /*!< EWM0 clock source              */\r\n    PORTA_CLK                    = 45u,      /*!< PORTA clock source             */\r\n    PORTB_CLK                    = 46u,      /*!< PORTB clock source             */\r\n    PORTC_CLK                    = 47u,      /*!< PORTC clock source             */\r\n    PORTD_CLK                    = 48u,      /*!< PORTD clock source             */\r\n    PORTE_CLK                    = 49u,      /*!< PORTE clock source             */\r\n    RTC0_CLK                     = 50u,      /*!< RTC0 clock source              */\r\n    PCC_END_OF_BUS_CLOCKS        = 51u,      /*!< End of BUS clocks              */\r\n    FlexCAN0_CLK                 = 52u,      /*!< FlexCAN0 clock source          */\r\n    FlexCAN1_CLK                 = 53u,      /*!< FlexCAN1 clock source          */\r\n    FlexCAN2_CLK                 = 54u,      /*!< FlexCAN2 clock source          */\r\n    PDB0_CLK                     = 55u,      /*!< PDB0 clock source              */\r\n    PDB1_CLK                     = 56u,      /*!< PDB1 clock source              */\r\n    PCC_END_OF_SYS_CLOCKS        = 57u,      /*!< End of SYS clocks              */\r\n    FTFC0_CLK                    = 58u,      /*!< FTFC0 clock source             */\r\n    PCC_END_OF_SLOW_CLOCKS       = 59u,      /*!< End of SLOW clocks             */\r\n    FTM0_CLK                     = 60u,      /*!< FTM0 clock source              */\r\n    FTM1_CLK                     = 61u,      /*!< FTM1 clock source              */\r\n    FTM2_CLK                     = 62u,      /*!< FTM2 clock source              */\r\n    FTM3_CLK                     = 63u,      /*!< FTM3 clock source              */\r\n    PCC_END_OF_ASYNCH_DIV1_CLOCKS= 64u,      /*!< End of ASYNCH DIV1 clocks      */\r\n    ADC0_CLK                     = 65u,      /*!< ADC0 clock source              */\r\n    ADC1_CLK                     = 66u,      /*!< ADC1 clock source              */\r\n    FLEXIO0_CLK                  = 67u,      /*!< FLEXIO0 clock source           */\r\n    LPI2C0_CLK                   = 68u,      /*!< LPI2C0 clock source            */\r\n    LPIT0_CLK                    = 69u,      /*!< LPIT0 clock source             */\r\n    LPSPI0_CLK                   = 70u,      /*!< LPSPI0 clock source            */\r\n    LPSPI1_CLK                   = 71u,      /*!< LPSPI1 clock source            */\r\n    LPSPI2_CLK                   = 72u,      /*!< LPSPI2 clock source            */\r\n    LPTMR0_CLK                   = 73u,      /*!< LPTMR0 clock source            */\r\n    LPUART0_CLK                  = 74u,      /*!< LPUART0 clock source           */\r\n    LPUART1_CLK                  = 75u,      /*!< LPUART1 clock source           */\r\n    LPUART2_CLK                  = 76u,      /*!< LPUART2 clock source           */\r\n    PCC_END_OF_ASYNCH_DIV2_CLOCKS= 77u,      /*!< End of ASYNCH DIV2 clocks      */\r\n    PCC_END_OF_CLOCKS            = 78u,      /*!< End of PCC clocks              */\r\n    CLOCK_NAME_COUNT             = 79u,      /*!< The total number of entries    */\r\n} clock_names_t;\r\n\r\n#define PCC_INVALID_INDEX  0\r\n\r\n  /*! @brief PCC clock name mappings\r\n   *  Mappings between clock names and peripheral clock control indexes.\r\n   *  If there is no peripheral clock control index for a clock name,\r\n   *  then the corresponding value is PCC_INVALID_INDEX.\r\n   */\r\n#define PCC_CLOCK_NAME_MAPPINGS \\\r\n{                                                                                \\\r\nPCC_INVALID_INDEX,                  /*!< Core clock                      0  */   \\\r\nPCC_INVALID_INDEX,                  /*!< Bus clock                       1  */   \\\r\nPCC_INVALID_INDEX,                  /*!< Slow clock                      2  */   \\\r\nPCC_INVALID_INDEX,                  /*!< CLKOUT clock                    3  */   \\\r\nPCC_INVALID_INDEX,                  /*!< SIRC clock                      4  */   \\\r\nPCC_INVALID_INDEX,                  /*!< FIRC clock                      5  */   \\\r\nPCC_INVALID_INDEX,                  /*!< SOSC clock                      6  */   \\\r\nPCC_INVALID_INDEX,                  /*!< SPLL clock                      7  */   \\\r\nPCC_INVALID_INDEX,                  /*!< RTC_CLKIN clock                 8  */   \\\r\nPCC_INVALID_INDEX,                  /*!< SCG CLK_OUT clock               9  */   \\\r\nPCC_INVALID_INDEX,                  /*!< SIRCDIV1 functional clock       10 */   \\\r\nPCC_INVALID_INDEX,                  /*!< SIRCDIV2 functional clock       11 */   \\\r\nPCC_INVALID_INDEX,                  /*!< FIRCDIV1 functional clock       12 */   \\\r\nPCC_INVALID_INDEX,                  /*!< FIRCDIV2 functional clock       13 */   \\\r\nPCC_INVALID_INDEX,                  /*!< SOSCDIV1 functional clock       14 */   \\\r\nPCC_INVALID_INDEX,                  /*!< SOSCDIV2 functional clock       15 */   \\\r\nPCC_INVALID_INDEX,                  /*!< SPLLDIV1 functional clock       16 */   \\\r\nPCC_INVALID_INDEX,                  /*!< SPLLDIV2 functional clock       17 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of SCG clocks               18 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 19 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 20 */   \\\r\nPCC_INVALID_INDEX,                  /*!< FTM0 External Clock Pin Select  21 */   \\\r\nPCC_INVALID_INDEX,                  /*!< FTM1 External Clock Pin Select  22 */   \\\r\nPCC_INVALID_INDEX,                  /*!< FTM2 External Clock Pin Select  23 */   \\\r\nPCC_INVALID_INDEX,                  /*!< FTM3 External Clock Pin Select  24 */   \\\r\nPCC_INVALID_INDEX,                  /*!< CLKOUT Select                   25 */   \\\r\nPCC_INVALID_INDEX,                  /*!< CLK32K clock                    26 */   \\\r\nPCC_INVALID_INDEX,                  /*!< LPO clock                       27 */   \\\r\nPCC_INVALID_INDEX,                  /*!< LPO 1KHz clock                  28 */   \\\r\nPCC_INVALID_INDEX,                  /*!< LPO 32KHz clock                 29 */   \\\r\nPCC_INVALID_INDEX,                  /*!< LPO 128KHz clock                30 */   \\\r\nPCC_INVALID_INDEX,                  /*!< EIM clock source                31 */   \\\r\nPCC_INVALID_INDEX,                  /*!< ERM clock source                32 */   \\\r\nPCC_INVALID_INDEX,                  /*!< DMA clock source                33 */   \\\r\nPCC_INVALID_INDEX,                  /*!< MPU clock source                34 */   \\\r\nPCC_INVALID_INDEX,                  /*!< MSCM clock source               35 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 36 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 37 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 38 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 39 */   \\\r\nPCC_INVALID_INDEX,                  /*!< No clock entry in clock_names_t 40 */   \\\r\nPCC_CMP0_INDEX,                     /*!< CMP0 clock source               41 */   \\\r\nPCC_CRC_INDEX,                      /*!< CRC clock source                42 */   \\\r\nPCC_DMAMUX_INDEX,                   /*!< DMAMUX clock source             43 */   \\\r\nPCC_EWM_INDEX,                      /*!< EWM clock source                44 */   \\\r\nPCC_PORTA_INDEX,                    /*!< PORTA clock source              45 */   \\\r\nPCC_PORTB_INDEX,                    /*!< PORTB clock source              46 */   \\\r\nPCC_PORTC_INDEX,                    /*!< PORTC clock source              47 */   \\\r\nPCC_PORTD_INDEX,                    /*!< PORTD clock source              48 */   \\\r\nPCC_PORTE_INDEX,                    /*!< PORTE clock source              49 */   \\\r\nPCC_RTC_INDEX,                      /*!< RTC clock source                50 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of BUS clocks               51 */   \\\r\nPCC_FlexCAN0_INDEX,                 /*!< FlexCAN0 clock source           52 */   \\\r\nPCC_FlexCAN1_INDEX,                 /*!< FlexCAN1 clock source           53 */   \\\r\nPCC_FlexCAN2_INDEX,                 /*!< FlexCAN2 clock source           54 */   \\\r\nPCC_PDB0_INDEX,                     /*!< PDB0 clock source               55 */   \\\r\nPCC_PDB1_INDEX,                     /*!< PDB1 clock source               56 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of SYS clocks               57 */   \\\r\nPCC_FTFC_INDEX,                     /*!< FTFC clock source               58 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of SLOW clocks              59 */   \\\r\nPCC_FTM0_INDEX,                     /*!< FTM0 clock source               60 */   \\\r\nPCC_FTM1_INDEX,                     /*!< FTM1 clock source               61 */   \\\r\nPCC_FTM2_INDEX,                     /*!< FTM2 clock source               62 */   \\\r\nPCC_FTM3_INDEX,                     /*!< FTM3 clock source               63 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of ASYNCH DIV1 clocks       64 */   \\\r\nPCC_ADC0_INDEX,                     /*!< ADC0 clock source               65 */   \\\r\nPCC_ADC1_INDEX,                     /*!< ADC1 clock source               66 */   \\\r\nPCC_FlexIO_INDEX,                   /*!< FLEXIO clock source             67 */   \\\r\nPCC_LPI2C0_INDEX,                   /*!< LPI2C0 clock source             68 */   \\\r\nPCC_LPIT_INDEX,                     /*!< LPIT clock source               69 */   \\\r\nPCC_LPSPI0_INDEX,                   /*!< LPSPI0 clock source             70 */   \\\r\nPCC_LPSPI1_INDEX,                   /*!< LPSPI1 clock source             71 */   \\\r\nPCC_LPSPI2_INDEX,                   /*!< LPSPI2 clock source             72 */   \\\r\nPCC_LPTMR0_INDEX,                   /*!< LPTMR0 clock source             73 */   \\\r\nPCC_LPUART0_INDEX,                  /*!< LPUART0 clock source            74 */   \\\r\nPCC_LPUART1_INDEX,                  /*!< LPUART1 clock source            75 */   \\\r\nPCC_LPUART2_INDEX,                  /*!< LPUART2 clock source            76 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of ASYNCH DIV2 clocks       77 */   \\\r\nPCC_INVALID_INDEX,                  /*!< End of PCC clocks               78 */   \\\r\n}\r\n\r\n/*! @brief Peripheral instance features\r\n *  List of features that are supported by a peripheral instance\r\n */\r\n#define NO_PERIPHERAL_FEATURE                   (0U)         /* It's not a peripheral instance, there is no peripheral feature. */\r\n#define HAS_CLOCK_GATING_IN_SIM                 (1U << 0U)   /* Clock gating is implemented in SIM (it's not in PCC) */\r\n#define HAS_MULTIPLIER                          (1U << 1U)   /* Multiplier is implemented in PCC */\r\n#define HAS_DIVIDER                             (1U << 2U)   /* Divider is implemented in PCC */\r\n#define HAS_PROTOCOL_CLOCK_FROM_ASYNC1          (1U << 3U)   /* Functional clock source is provided by the first asynchronous clock. */\r\n#define HAS_PROTOCOL_CLOCK_FROM_ASYNC2          (1U << 4U)   /* Functional clock source is provided by the second asynchronous clock. */\r\n#define HAS_INT_CLOCK_FROM_BUS_CLOCK            (1U << 5U)   /* Interface clock is provided by the bus clock. */\r\n#define HAS_INT_CLOCK_FROM_SYS_CLOCK            (1U << 6U)   /* Interface clock is provided by the sys clock. */\r\n#define HAS_INT_CLOCK_FROM_SLOW_CLOCK           (1U << 7U)   /* Interface clock is provided by the slow clock. */\r\n\r\n/*! @brief Peripheral features.\r\n*  List of features for each clock name. If a clock name is not\r\n*  a peripheral, no feature is supported.\r\n*/\r\n#define PERIPHERAL_FEATURES \\\r\n{                                                                                                                                                \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< Core clock                      0  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< Bus clock                       1  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< Slow clock                      2  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< CLKOUT clock                    3  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< SIRC clock                      4  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< FIRC clock                      5  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< SOSC clock                      6  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< SPLL clock                      7  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< RTC_CLKIN clock                 8  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< SCG CLK_OUT clock               9  */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of SCG clocks               10 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 11 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 12 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 13 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 14 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 15 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 16 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 17 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 18 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 19 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 20 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< FTM0 External Clock Pin Select  21 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< FTM1 External Clock Pin Select  22 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< FTM2 External Clock Pin Select  23 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< FTM3 External Clock Pin Select  24 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< CLKOUT Select                   25 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< CLK32K clock                    26 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< LPO clock                       27 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< LPO 1KHz clock                  28 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< LPO 32KHz clock                 29 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< LPO 128KHz clock                30 */   \\\r\n(HAS_CLOCK_GATING_IN_SIM | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                           /*!< EIM clock source                31 */   \\\r\n(HAS_CLOCK_GATING_IN_SIM | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                           /*!< ERM clock source                32 */   \\\r\n(HAS_CLOCK_GATING_IN_SIM | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                           /*!< DMA clock source                33 */   \\\r\n(HAS_CLOCK_GATING_IN_SIM | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                           /*!< MPU clock source                34 */   \\\r\n(HAS_CLOCK_GATING_IN_SIM | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                           /*!< MSCM clock source               35 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 36 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 37 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 38 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 39 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< No clock entry in clock_names_t 40 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< CMP0 clock source               41 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< CRC clock source                42 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< DMAMUX clock source             43 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< EWM clock source                44 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< PORTA clock source              45 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< PORTB clock source              46 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< PORTC clock source              47 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< PORTD clock source              48 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< PORTE clock source              49 */   \\\r\n(HAS_INT_CLOCK_FROM_BUS_CLOCK),                                                                     /*!< RTC clock source                50 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of BUS clocks               51 */   \\\r\n(HAS_INT_CLOCK_FROM_SYS_CLOCK),                                                                     /*!< FlexCAN0 clock source           52 */   \\\r\n(HAS_INT_CLOCK_FROM_SYS_CLOCK),                                                                     /*!< FlexCAN1 clock source           53 */   \\\r\n(HAS_INT_CLOCK_FROM_SYS_CLOCK),                                                                     /*!< FlexCAN2 clock source           54 */   \\\r\n(HAS_INT_CLOCK_FROM_SYS_CLOCK),                                                                     /*!< PDB0 clock source               55 */   \\\r\n(HAS_INT_CLOCK_FROM_SYS_CLOCK),                                                                     /*!< PDB1 clock source               56 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of SYS clocks               57 */   \\\r\n(HAS_INT_CLOCK_FROM_SLOW_CLOCK),                                                                    /*!< FTFC clock source               58 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of SLOW clocks              59 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                    /*!< FTM0 clock source               60 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                    /*!< FTM1 clock source               61 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                    /*!< FTM2 clock source               62 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_INT_CLOCK_FROM_SYS_CLOCK),                                    /*!< FTM3 clock source               63 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of ASYNCH DIV1 clocks       64 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< ADC0 clock source               65 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< ADC1 clock source               66 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< FLEXIO clock source             67 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPI2C0 clock source             68 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPIT clock source               69 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPSPI0 clock source             70 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPSPI1 clock source             71 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPSPI2 clock source             72 */   \\\r\n(HAS_MULTIPLIER | HAS_DIVIDER | HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),     /*!< LPTMR0 clock source             73 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPUART0 clock source            74 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPUART1 clock source            75 */   \\\r\n(HAS_PROTOCOL_CLOCK_FROM_ASYNC2 | HAS_INT_CLOCK_FROM_BUS_CLOCK),                                    /*!< LPUART2 clock source            76 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of ASYNCH DIV2 clocks       77 */   \\\r\n(NO_PERIPHERAL_FEATURE),                                                                            /*!< End of PCC clocks               78 */   \\\r\n}\r\n\r\n/* Time to wait for SIRC to stabilize (number of\r\n * cycles when core runs at maximum speed - 112 MHz */\r\n#define SIRC_STABILIZATION_TIMEOUT 100U\r\n\r\n/* Time to wait for FIRC to stabilize (number of\r\n * cycles when core runs at maximum speed - 112 MHz */\r\n#define FIRC_STABILIZATION_TIMEOUT 100U\r\n\r\n/* Time to wait for SOSC to stabilize (number of\r\n * cycles when core runs at maximum speed - 112 MHz */\r\n#define SOSC_STABILIZATION_TIMEOUT 3205000U;\r\n\r\n/* Time to wait for SPLL to stabilize (number of\r\n * cycles when core runs at maximum speed - 112 MHz */\r\n#define SPLL_STABILIZATION_TIMEOUT 1000U;\r\n\r\n\r\n/*! @brief Temporary system clock source configurations.\r\n *         Each line represents the SYS(CORE), BUS and SLOW(FLASH) dividers\r\n *         for SIRC, FIRC, SOSC and SPLL clock sources.\r\n  *\r\n *          SYS_CLK  BUS_CLK  SLOW_CLK\r\n *  SIRC       *        *         *\r\n *  FIRC       *        *         *\r\n *  SOSC       *        *         *\r\n *  SPLL       *        *         *\r\n */\r\n#define TMP_SIRC_CLK   0U\r\n#define TMP_FIRC_CLK   1U\r\n#define TMP_SOSC_CLK   2U\r\n#define TMP_SPLL_CLK   3U\r\n\r\n#define TMP_SYS_DIV    0U\r\n#define TMP_BUS_DIV    1U\r\n#define TMP_SLOW_DIV   2U\r\n\r\n#define TMP_SYS_CLK_NO 4U\r\n#define TMP_SYS_DIV_NO 3U\r\n\r\n#define TMP_SYSTEM_CLOCK_CONFIGS                                                                                \\\r\n{  /*       SYS_CLK                    BUS_CLK                  SLOW_CLK      */                                \\\r\n{  SCG_SYSTEM_CLOCK_DIV_BY_1, SCG_SYSTEM_CLOCK_DIV_BY_1, SCG_SYSTEM_CLOCK_DIV_BY_2},  /*!< Dividers for SIRC */ \\\r\n{  SCG_SYSTEM_CLOCK_DIV_BY_1, SCG_SYSTEM_CLOCK_DIV_BY_2, SCG_SYSTEM_CLOCK_DIV_BY_4},  /*!< Dividers for FIRC */ \\\r\n{  SCG_SYSTEM_CLOCK_DIV_BY_1, SCG_SYSTEM_CLOCK_DIV_BY_2, SCG_SYSTEM_CLOCK_DIV_BY_2},  /*!< Dividers for SOSC */ \\\r\n{  SCG_SYSTEM_CLOCK_DIV_BY_3, SCG_SYSTEM_CLOCK_DIV_BY_2, SCG_SYSTEM_CLOCK_DIV_BY_2},  /*!< Dividers for SPLL */ \\\r\n}\r\n/* @brief template system clock configuration in VLPR mode*/\r\n#define FEATURE_VLPR_SYS_CLK SCG_SYSTEM_CLOCK_DIV_BY_2\r\n#define FEATURE_VLPR_BUS_CLK SCG_SYSTEM_CLOCK_DIV_BY_1\r\n#define FEATURE_VLPR_SLOW_CLK SCG_SYSTEM_CLOCK_DIV_BY_4\r\n\r\n/* Do not use the old names of the renamed symbols */\r\n/* #define DO_NOT_USE_DEPRECATED_SYMBOLS */\r\n\r\n/*! START !DO_NOT_USE_DEPRECATED_SYMBOLS\r\n *  These symbols have been renamed.\r\n *  The old names (deprecated symbols)\r\n *  are defined for backward compatibility.\r\n */\r\n#if !defined(DO_NOT_USE_DEPRECATED_SYMBOLS)\r\n#define    CORE_CLOCK               CORE_CLK\r\n#define    BUS_CLOCK                BUS_CLK\r\n#define    SLOW_CLOCK               SLOW_CLK\r\n#define    CLKOUT_CLOCK             CLKOUT_CLK\r\n#define    SIRC_CLOCK               SIRC_CLK\r\n#define    FIRC_CLOCK               FIRC_CLK\r\n#define    SOSC_CLOCK               SOSC_CLK\r\n#define    SPLL_CLOCK               SPLL_CLK\r\n#define    RTC_CLKIN_CLOCK          RTC_CLKIN_CLK\r\n#define    SCG_CLKOUT_CLOCK         SCG_CLKOUT_CLK\r\n#define    SIM_RTCCLK_CLOCK         SIM_RTCCLK_CLK\r\n#define    SIM_LPO_CLOCK            SIM_LPO_CLK\r\n#define    SIM_LPO_1K_CLOCK         SIM_LPO_1K_CLK\r\n#define    SIM_LPO_32K_CLOCK        SIM_LPO_32K_CLK\r\n#define    SIM_LPO_128K_CLOCK       SIM_LPO_128K_CLK\r\n#define    SIM_EIM_CLOCK            SIM_EIM_CLK\r\n#define    SIM_ERM_CLOCK            SIM_ERM_CLK\r\n#define    SIM_DMA_CLOCK            SIM_DMA_CLK\r\n#define    SIM_MPU_CLOCK            SIM_MPU_CLK\r\n#define    SIM_MSCM_CLOCK           SIM_MSCM_CLK\r\n#define    PCC_DMAMUX0_CLOCK        DMAMUX0_CLK\r\n#define    PCC_CRC0_CLOCK           CRC0_CLK\r\n#define    PCC_RTC0_CLOCK           RTC0_CLK\r\n#define    PCC_PORTA_CLOCK          PORTA_CLK\r\n#define    PCC_PORTB_CLOCK          PORTB_CLK\r\n#define    PCC_PORTC_CLOCK          PORTC_CLK\r\n#define    PCC_PORTD_CLOCK          PORTD_CLK\r\n#define    PCC_PORTE_CLOCK          PORTE_CLK\r\n#define    PCC_EWM0_CLOCK           EWM0_CLK\r\n#define    PCC_CMP0_CLOCK           CMP0_CLK\r\n#define    PCC_FlexCAN0_CLOCK       FlexCAN0_CLK\r\n#define    PCC_FlexCAN1_CLOCK       FlexCAN1_CLK\r\n#define    PCC_FlexCAN2_CLOCK       FlexCAN2_CLK\r\n#define    PCC_PDB1_CLOCK           PDB1_CLK\r\n#define    PCC_PDB0_CLOCK           PDB0_CLK\r\n#define    PCC_FTFC0_CLOCK          FTFC0_CLK\r\n#define    PCC_FTM0_CLOCK           FTM0_CLK\r\n#define    PCC_FTM1_CLOCK           FTM1_CLK\r\n#define    PCC_FTM2_CLOCK           FTM2_CLK\r\n#define    PCC_FTM3_CLOCK           FTM3_CLK\r\n#define    PCC_ADC1_CLOCK           ADC1_CLK\r\n#define    PCC_LPSPI0_CLOCK         LPSPI0_CLK\r\n#define    PCC_LPSPI1_CLOCK         LPSPI1_CLK\r\n#define    PCC_LPSPI2_CLOCK         LPSPI2_CLK\r\n#define    PCC_LPIT0_CLOCK          LPIT0_CLK\r\n#define    PCC_ADC0_CLOCK           ADC0_CLK\r\n#define    PCC_LPTMR0_CLOCK         LPTMR0_CLK\r\n#define    PCC_FLEXIO0_CLOCK        FLEXIO0_CLK\r\n#define    PCC_LPI2C0_CLOCK         LPI2C0_CLK\r\n#define    PCC_LPUART0_CLOCK        LPUART0_CLK\r\n#define    PCC_LPUART1_CLOCK        LPUART1_CLK\r\n#define    PCC_LPUART2_CLOCK        LPUART2_CLK\r\n#endif /* !DO_NOT_USE_DEPRECATED_SYMBOLS */\r\n\r\n\r\n/* CSEc module features */\r\n\r\n/*! @brief CSE_PRAM offset of the page length parameter used by the following\r\ncommands: CMD_ENC_ECB, CMD_ENC_CBC, CMD_DEC_ECB, CMD_DEC_CBC, CMD_MP_COMPRESS */\r\n#define FEATURE_CSEC_PAGE_LENGTH_OFFSET                   (0xEU)\r\n/*! @brief CSE_PRAM offset of the message length parameter used by the following\r\ncommands: CMD_GENERATE_MAC, CMD_VERIFY_MAC (both copy and pointer methods) */\r\n#define FEATURE_CSEC_MESSAGE_LENGTH_OFFSET                (0xCU)\r\n/*! @brief CSE_PRAM offset of the MAC length parameter used by the following\r\ncommands: CMD_VERIFY_MAC (both copy and pointer methods) */\r\n#define FEATURE_CSEC_MAC_LENGTH_OFFSET                    (0x8U)\r\n/*! @brief CSE_PRAM offset of the boot size parameter used by the following\r\ncommands: CMD_BOOT_DEFINE */\r\n#define FEATURE_CSEC_BOOT_SIZE_OFFSET                     (0x1CU)\r\n/*! @brief CSE_PRAM offset of the boot flavor parameter used by the following\r\ncommands: CMD_BOOT_DEFINE */\r\n#define FEATURE_CSEC_BOOT_FLAVOR_OFFSET                   (0x1BU)\r\n/*! @brief CSE_PRAM offset of the Flash start address parameter used by the\r\nfollowing commands: CMD_GENERATE_MAC, CMD_VERIFY_MAC (pointer method) */\r\n#define FEATURE_CSEC_FLASH_START_ADDRESS_OFFSET           (0x10U)\r\n/*! @brief CSE_PRAM offset of the verification status parameter used by the\r\nfollowing commands: CMD_VERIFY_MAC (both copy and pointer methods) */\r\n#define FEATURE_CSEC_VERIFICATION_STATUS_OFFSET           (0x14U)\r\n/*! @brief CSE_PRAM offset of the error bits field contained by all commands */\r\n#define FEATURE_CSEC_ERROR_BITS_OFFSET                    (0x4U)\r\n/*! @brief CSE_PRAM offset of the SREG parameter used by the following commands:\r\nCMD_GET_ID */\r\n#define FEATURE_CSEC_SREG_OFFSET                          (0x2FU)\r\n\r\n/*! @brief Macro that enables the use of FTFM flash module on a platform */\r\n#define FEATURE_CSEC_HAS_FTFM_MODULE\t\t\t\t\t  (0U)\r\n\r\n/*! @brief CSE_PRAM offset of page 0 */\r\n#define FEATURE_CSEC_PAGE_0_OFFSET                        (0x0U)\r\n/*! @brief CSE_PRAM offset of page 1 */\r\n#define FEATURE_CSEC_PAGE_1_OFFSET                        (0x10U)\r\n/*! @brief CSE_PRAM offset of page 2 */\r\n#define FEATURE_CSEC_PAGE_2_OFFSET                        (0x20U)\r\n/*! @brief CSE_PRAM offset of page 3 */\r\n#define FEATURE_CSEC_PAGE_3_OFFSET                        (0x30U)\r\n/*! @brief CSE_PRAM offset of page 4 */\r\n#define FEATURE_CSEC_PAGE_4_OFFSET                        (0x40U)\r\n/*! @brief CSE_PRAM offset of page 5 */\r\n#define FEATURE_CSEC_PAGE_5_OFFSET                        (0x50U)\r\n/*! @brief CSE_PRAM offset of page 6 */\r\n#define FEATURE_CSEC_PAGE_6_OFFSET                        (0x60U)\r\n/*! @brief CSE_PRAM offset of page 7 */\r\n#define FEATURE_CSEC_PAGE_7_OFFSET                        (0x70U)\r\n\r\n\r\n/* ADC module features */\r\n\r\n/*! @brief ADC feature flag for extended number of SC1 and R registers,\r\n * generically named 'alias registers' */\r\n#define FEATURE_ADC_HAS_EXTRA_NUM_REGS                    (0)\r\n\r\n/*! @brief ADC feature flag for defining number of external ADC channels.\r\n * If each ADC instance has different number of external channels, then\r\n * this define is set with the maximum value. */\r\n#define FEATURE_ADC_MAX_NUM_EXT_CHANS                     (16)\r\n#define FEATURE_ADC_HAS_CHANNEL_2                         (1)\r\n#define FEATURE_ADC_HAS_CHANNEL_8                         (1)\r\n#define ADC_CLOCKS                                        {ADC0_CLK, ADC1_CLK}\r\n\r\n/*! @brief ADC number of control channels */\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n#define ADC_CTRL_CHANS_COUNT                              ADC_aSC1_COUNT\r\n#else\r\n#define ADC_CTRL_CHANS_COUNT                              ADC_SC1_COUNT\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n/*! @brief ADC default Sample Time from RM */\r\n#define ADC_DEFAULT_SAMPLE_TIME                           (0x0CU)\r\n/*! @brief ADC default User Gain from RM */\r\n#define ADC_DEFAULT_USER_GAIN                             (0x04U)\r\n/* @brief Max of adc clock frequency */\r\n#define ADC_CLOCK_FREQ_MAX_RUNTIME     (50000000u)\r\n/* @brief Min of adc clock frequency */\r\n#define ADC_CLOCK_FREQ_MIN_RUNTIME     (2000000u)\r\n\r\n/* LPIT module features */\r\n\r\n/*! @brief Number of interrupt vector for channels of the LPIT module. */\r\n#define FEATURE_LPIT_HAS_NUM_IRQS_CHANS                  (4U)\r\n/*! @brief Clock names for LPIT. */\r\n#define LPIT_CLOCK_NAMES    {LPIT0_CLK}\r\n\r\n/* MSCM module features */\r\n\r\n/* @brief Has interrupt router control registers (IRSPRCn). */\r\n#define FEATURE_MSCM_HAS_INTERRUPT_ROUTER                (0)\r\n/* @brief Has directed CPU interrupt routerregisters (IRCPxxx). */\r\n#define FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER            (0)\r\n\r\n/* OSIF module features */\r\n\r\n#define FEATURE_OSIF_USE_SYSTICK                         (1)\r\n#define FEATURE_OSIF_USE_PIT                             (0)\r\n#define FEATURE_OSIF_FREERTOS_ISR_CONTEXT_METHOD         (1) /* Cortex M device */\r\n\r\n/* LPSPI module features */\r\n/* @brief Initial value for state structure */\r\n#define FEATURE_LPSPI_STATE_STRUCTURES_NULL {NULL, NULL, NULL}\r\n/* @brief Clock indexes for LPSPI clock */\r\n#define FEATURE_LPSPI_CLOCKS_NAMES {LPSPI0_CLK, LPSPI1_CLK, LPSPI2_CLK};\r\n\r\n/* LPTMR module features */\r\n\r\n/* @brief LPTMR pulse counter input options */\r\n#define FEATURE_LPTMR_HAS_INPUT_ALT1_SELECTION           (1U)\r\n\r\n/* TRGMUX module features */\r\n/*!\r\n * @brief Enumeration for trigger source module of TRGMUX\r\n *\r\n * Describes all possible inputs (trigger sources) of the TRGMUX IP\r\n * This enumeration depends on the supported instances in device\r\n */\r\nenum trgmux_trigger_source_e\r\n{\r\n    TRGMUX_TRIG_SOURCE_DISABLED             = 0U,\r\n    TRGMUX_TRIG_SOURCE_VDD                  = 1U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN0           = 2U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN1           = 3U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN2           = 4U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN3           = 5U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN4           = 6U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN5           = 7U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN6           = 8U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN7           = 9U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN8           = 10U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN9           = 11U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN10          = 12U,\r\n    TRGMUX_TRIG_SOURCE_TRGMUX_IN11          = 13U,\r\n    TRGMUX_TRIG_SOURCE_CMP0_OUT             = 14U,\r\n    TRGMUX_TRIG_SOURCE_LPIT_CH0             = 17U,\r\n    TRGMUX_TRIG_SOURCE_LPIT_CH1             = 18U,\r\n    TRGMUX_TRIG_SOURCE_LPIT_CH2             = 19U,\r\n    TRGMUX_TRIG_SOURCE_LPIT_CH3             = 20U,\r\n    TRGMUX_TRIG_SOURCE_LPTMR0               = 21U,\r\n    TRGMUX_TRIG_SOURCE_FTM0_INIT_TRIG       = 22U,\r\n    TRGMUX_TRIG_SOURCE_FTM0_EXT_TRIG        = 23U,\r\n    TRGMUX_TRIG_SOURCE_FTM1_INIT_TRIG       = 24U,\r\n    TRGMUX_TRIG_SOURCE_FTM1_EXT_TRIG        = 25U,\r\n    TRGMUX_TRIG_SOURCE_FTM2_INIT_TRIG       = 26U,\r\n    TRGMUX_TRIG_SOURCE_FTM2_EXT_TRIG        = 27U,\r\n    TRGMUX_TRIG_SOURCE_FTM3_INIT_TRIG       = 28U,\r\n    TRGMUX_TRIG_SOURCE_FTM3_EXT_TRIG        = 29U,\r\n    TRGMUX_TRIG_SOURCE_ADC0_SC1A_COCO       = 30U,\r\n    TRGMUX_TRIG_SOURCE_ADC0_SC1B_COCO       = 31U,\r\n    TRGMUX_TRIG_SOURCE_ADC1_SC1A_COCO       = 32U,\r\n    TRGMUX_TRIG_SOURCE_ADC1_SC1B_COCO       = 33U,\r\n    TRGMUX_TRIG_SOURCE_PDB0_CH0_TRIG        = 34U,\r\n    TRGMUX_TRIG_SOURCE_PDB0_PULSE_OUT       = 36U,\r\n    TRGMUX_TRIG_SOURCE_PDB1_CH0_TRIG        = 37U,\r\n    TRGMUX_TRIG_SOURCE_PDB1_PULSE_OUT       = 39U,\r\n    TRGMUX_TRIG_SOURCE_RTC_ALARM            = 43U,\r\n    TRGMUX_TRIG_SOURCE_RTC_SECOND           = 44U,\r\n    TRGMUX_TRIG_SOURCE_FLEXIO_TRIG0         = 45U,\r\n    TRGMUX_TRIG_SOURCE_FLEXIO_TRIG1         = 46U,\r\n    TRGMUX_TRIG_SOURCE_FLEXIO_TRIG2         = 47U,\r\n    TRGMUX_TRIG_SOURCE_FLEXIO_TRIG3         = 48U,\r\n    TRGMUX_TRIG_SOURCE_LPUART0_RX_DATA      = 49U,\r\n    TRGMUX_TRIG_SOURCE_LPUART0_TX_DATA      = 50U,\r\n    TRGMUX_TRIG_SOURCE_LPUART0_RX_IDLE      = 51U,\r\n    TRGMUX_TRIG_SOURCE_LPUART1_RX_DATA      = 52U,\r\n    TRGMUX_TRIG_SOURCE_LPUART1_TX_DATA      = 53U,\r\n    TRGMUX_TRIG_SOURCE_LPUART1_RX_IDLE      = 54U,\r\n    TRGMUX_TRIG_SOURCE_LPI2C0_MASTER_TRIG   = 55U,\r\n    TRGMUX_TRIG_SOURCE_LPI2C0_SLAVE_TRIG    = 56U,\r\n    TRGMUX_TRIG_SOURCE_LPSPI0_FRAME         = 59U,\r\n    TRGMUX_TRIG_SOURCE_LPSPI0_RX_DATA       = 60U,\r\n    TRGMUX_TRIG_SOURCE_LPSPI1_FRAME         = 61U,\r\n    TRGMUX_TRIG_SOURCE_LPSPI1_RX_DATA       = 62U,\r\n    TRGMUX_TRIG_SOURCE_SIM_SW_TRIG          = 63U\r\n};\r\n\r\n/*!\r\n * @brief Enumeration for target module of TRGMUX\r\n *\r\n * Describes all possible outputs (target modules) of the TRGMUX IP\r\n * This enumeration depends on the supported instances in device\r\n */\r\nenum trgmux_target_module_e\r\n{\r\n    TRGMUX_TARGET_MODULE_DMA_CH0            = 0U,\r\n    TRGMUX_TARGET_MODULE_DMA_CH1            = 1U,\r\n    TRGMUX_TARGET_MODULE_DMA_CH2            = 2U,\r\n    TRGMUX_TARGET_MODULE_DMA_CH3            = 3U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT0        = 4U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT1        = 5U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT2        = 6U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT3        = 7U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT4        = 8U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT5        = 9U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT6        = 10U,\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT7        = 11U,\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA0    = 12U,\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA1    = 13U,\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA2    = 14U,\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA3    = 15U,\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA0    = 16U,\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA1    = 17U,\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA2    = 18U,\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA3    = 19U,\r\n    TRGMUX_TARGET_MODULE_CMP0_SAMPLE        = 28U,\r\n    TRGMUX_TARGET_MODULE_FTM0_HWTRIG0       = 40U,\r\n    TRGMUX_TARGET_MODULE_FTM0_FAULT0        = 41U,\r\n    TRGMUX_TARGET_MODULE_FTM0_FAULT1        = 42U,\r\n    TRGMUX_TARGET_MODULE_FTM0_FAULT2        = 43U,\r\n    TRGMUX_TARGET_MODULE_FTM1_HWTRIG0       = 44U,\r\n    TRGMUX_TARGET_MODULE_FTM1_FAULT0        = 45U,\r\n    TRGMUX_TARGET_MODULE_FTM1_FAULT1        = 46U,\r\n    TRGMUX_TARGET_MODULE_FTM1_FAULT2        = 47U,\r\n    TRGMUX_TARGET_MODULE_FTM2_HWTRIG0       = 48U,\r\n    TRGMUX_TARGET_MODULE_FTM2_FAULT0        = 49U,\r\n    TRGMUX_TARGET_MODULE_FTM2_FAULT1        = 50U,\r\n    TRGMUX_TARGET_MODULE_FTM2_FAULT2        = 51U,\r\n    TRGMUX_TARGET_MODULE_FTM3_HWTRIG0       = 52U,\r\n    TRGMUX_TARGET_MODULE_FTM3_FAULT0        = 53U,\r\n    TRGMUX_TARGET_MODULE_FTM3_FAULT1        = 54U,\r\n    TRGMUX_TARGET_MODULE_FTM3_FAULT2        = 55U,\r\n    TRGMUX_TARGET_MODULE_PDB0_TRG_IN        = 56U,\r\n    TRGMUX_TARGET_MODULE_PDB1_TRG_IN        = 60U,\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM0    = 68U,\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM1    = 69U,\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM2    = 70U,\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM3    = 71U,\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH0       = 72U,\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH1       = 73U,\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH2       = 74U,\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH3       = 75U,\r\n    TRGMUX_TARGET_MODULE_LPUART0_TRG        = 76U,\r\n    TRGMUX_TARGET_MODULE_LPUART1_TRG        = 80U,\r\n    TRGMUX_TARGET_MODULE_LPI2C0_TRG         = 84U,\r\n    TRGMUX_TARGET_MODULE_LPSPI0_TRG         = 92U,\r\n    TRGMUX_TARGET_MODULE_LPSPI1_TRG         = 96U,\r\n    TRGMUX_TARGET_MODULE_LPTMR0_ALT0        = 100U\r\n};\r\n\r\n/* @brief Constant array storing the value of all TRGMUX output(target module) identifiers */\r\n#define FEATURE_TRGMUX_TARGET_MODULE         \\\r\n{                                            \\\r\n    TRGMUX_TARGET_MODULE_DMA_CH0,            \\\r\n    TRGMUX_TARGET_MODULE_DMA_CH1,            \\\r\n    TRGMUX_TARGET_MODULE_DMA_CH2,            \\\r\n    TRGMUX_TARGET_MODULE_DMA_CH3,            \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT0,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT1,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT2,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT3,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT4,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT5,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT6,        \\\r\n    TRGMUX_TARGET_MODULE_TRGMUX_OUT7,        \\\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA0,    \\\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA1,    \\\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA2,    \\\r\n    TRGMUX_TARGET_MODULE_ADC0_ADHWT_TLA3,    \\\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA0,    \\\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA1,    \\\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA2,    \\\r\n    TRGMUX_TARGET_MODULE_ADC1_ADHWT_TLA3,    \\\r\n    TRGMUX_TARGET_MODULE_CMP0_SAMPLE,        \\\r\n    TRGMUX_TARGET_MODULE_FTM0_HWTRIG0,       \\\r\n    TRGMUX_TARGET_MODULE_FTM0_FAULT0,        \\\r\n    TRGMUX_TARGET_MODULE_FTM0_FAULT1,        \\\r\n    TRGMUX_TARGET_MODULE_FTM0_FAULT2,        \\\r\n    TRGMUX_TARGET_MODULE_FTM1_HWTRIG0,       \\\r\n    TRGMUX_TARGET_MODULE_FTM1_FAULT0,        \\\r\n    TRGMUX_TARGET_MODULE_FTM1_FAULT1,        \\\r\n    TRGMUX_TARGET_MODULE_FTM1_FAULT2,        \\\r\n    TRGMUX_TARGET_MODULE_FTM2_HWTRIG0,       \\\r\n    TRGMUX_TARGET_MODULE_FTM2_FAULT0,        \\\r\n    TRGMUX_TARGET_MODULE_FTM2_FAULT1,        \\\r\n    TRGMUX_TARGET_MODULE_FTM2_FAULT2,        \\\r\n    TRGMUX_TARGET_MODULE_FTM3_HWTRIG0,       \\\r\n    TRGMUX_TARGET_MODULE_FTM3_FAULT0,        \\\r\n    TRGMUX_TARGET_MODULE_FTM3_FAULT1,        \\\r\n    TRGMUX_TARGET_MODULE_FTM3_FAULT2,        \\\r\n    TRGMUX_TARGET_MODULE_PDB0_TRG_IN,        \\\r\n    TRGMUX_TARGET_MODULE_PDB1_TRG_IN,        \\\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM0,    \\\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM1,    \\\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM2,    \\\r\n    TRGMUX_TARGET_MODULE_FLEXIO_TRG_TIM3,    \\\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH0,       \\\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH1,       \\\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH2,       \\\r\n    TRGMUX_TARGET_MODULE_LPIT_TRG_CH3,       \\\r\n    TRGMUX_TARGET_MODULE_LPUART0_TRG,        \\\r\n    TRGMUX_TARGET_MODULE_LPUART1_TRG,        \\\r\n    TRGMUX_TARGET_MODULE_LPI2C0_TRG,         \\\r\n    TRGMUX_TARGET_MODULE_LPSPI0_TRG,         \\\r\n    TRGMUX_TARGET_MODULE_LPSPI1_TRG,         \\\r\n    TRGMUX_TARGET_MODULE_LPTMR0_ALT0         \\\r\n}\r\n\r\n/* ISELED Pins */\r\n\r\n#define ISELED_PIN_0     0    /*PTA10*/\r\n#define ISELED_PIN_1     1    /*PTD0*/\r\n#define ISELED_PIN_2     2    /*PTD9*/\r\n#define ISELED_PIN_3     3    /*PTA11*/\r\n#define ISELED_PIN_4     4    /*PTD1*/\r\n#define ISELED_PIN_5     5    /*PTD8*/\r\n#define ISELED_PIN_6     6    /*PTA0*/\r\n#define ISELED_PIN_7     7    /*PTE15*/\r\n#define ISELED_PIN_8     8    /*PTA1*/\r\n#define ISELED_PIN_9     9    /*PTE16*/\r\n#define ISELED_PIN_10    10    /*PTA2*/\r\n#define ISELED_PIN_11    11    /*PTD2*/\r\n#define ISELED_PIN_12    12    /*PTE10*/\r\n#define ISELED_PIN_13    13    /*PTA3*/\r\n#define ISELED_PIN_14    14    /*PTE11*/\r\n#define ISELED_PIN_15    15    /*PTD3*/\r\n#define ISELED_PIN_16    16    /*PTA8*/\r\n#define ISELED_PIN_17    17    /*PTE3*/\r\n#define ISELED_PIN_18    18    /*PTA9*/\r\n#define ISELED_PIN_19    19    /*PTE3*/\r\n\r\n#define ISELED_PIN_20    20    /*PTB2*/\r\n#define ISELED_PIN_21    21    /*PTB1*/\r\n#define ISELED_PIN_22    22    /*PTD15*/\r\n#define ISELED_PIN_23    23    /*PTB4*/\r\n#define ISELED_PIN_24    24    /*PTE0*/\r\n#define ISELED_PIN_25    25    /*PTE2*/\r\n#define ISELED_PIN_26    26    /*PTD0*/\r\n#define ISELED_PIN_27    27    /*PTD2*/\r\n#define ISELED_PIN_28    28    /*PTB14*/\r\n#define ISELED_PIN_29    29    /*PTB16*/\r\n#define ISELED_PIN_30    30    /*PTE15*/\r\n#define ISELED_PIN_31    31    /*PTA8*/\r\n#define ISELED_PIN_32    32    /*PTC15*/\r\n#define ISELED_PIN_33    33    /*PTC1*/\r\n\r\n#define ISELED_PIN_34    34    /*PTE1*/\r\n#define ISELED_PIN_35    35    /*PTB3*/\r\n#define ISELED_PIN_36    36    /*PTD16*/\r\n#define ISELED_PIN_37    37    /*PTB15*/\r\n#define ISELED_PIN_38    38    /*PTD1*/\r\n#define ISELED_PIN_39    39    /*PTC0*/\r\n\r\n\r\n#define MAX_NR_OF_STRIPS 13U\r\n\r\n\r\n/* PDB module features */\r\n\r\n/* @brief PDB has instance back to back mode between PDB0 CH0 and PDB1 CH0 pre-triggers */\r\n#define FEATURE_PDB_HAS_INSTANCE_BACKTOBACK     (1)\r\n\r\n/* @brief PDB has inter-channel back to back mode between PDBx CH0 and PDBx CH1 pre-triggers */\r\n#define FEATURE_PDB_HAS_INTERCHANNEL_BACKTOBACK (0)\r\n\r\n\r\n#endif /* S32K144_FEATURES_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"S32_core_cm4.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\common","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015-2016 Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n *\r\n */\r\n/*!\r\n * @file s32_core_cm4.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro\r\n * Function-like macros are used instead of inline functions in order to ensure\r\n * that the performance will not be decreased if the functions will not be\r\n * inlined by the compiler.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macros defined are used only on some of the drivers, so this might be reported\r\n * when the analysis is made only on one driver.\r\n */\r\n\r\n/*\r\n * Tool Chains:\r\n *   GNUC flag is defined also by ARM compiler - it shows the current major version of the compatible GCC version\r\n *   __GNUC__   : GNU Compiler Collection\r\n *   __ghs__    : Green Hills ARM Compiler\r\n *   __ICCARM__ : IAR ARM Compiler\r\n *   __DCC__    : Wind River Diab Compiler\r\n *   __ARMCC_VERSION:  ARM Compiler\r\n */\r\n\r\n#if !defined (CORE_CM4_H)\r\n#define CORE_CM4_H\r\n\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/** \\brief  BKPT_ASM\r\n *\r\n *   Macro to be used to trigger an debug interrupt\r\n */\r\n#define BKPT_ASM __asm(\"BKPT #0\\n\\t\")\r\n        \r\n\r\n/** \\brief  Enable FPU\r\n *\r\n *   ENABLE_FPU indicates whether SystemInit will enable the Floating point unit (FPU)\r\n */\r\n#if defined (__GNUC__) || defined (__ARMCC_VERSION)\r\n#if defined (__VFP_FP__) && !defined (__SOFTFP__)\r\n#define ENABLE_FPU\r\n#endif\r\n\r\n#elif defined (__ICCARM__)\r\n#if defined __ARMVFP__\r\n#define ENABLE_FPU\r\n#endif\r\n\r\n#elif defined (__ghs__) || defined (__DCC__)\r\n#if defined (__VFP__)\r\n#define ENABLE_FPU\r\n#endif\r\n#endif /* if defined (__GNUC__) */\r\n\r\n/** \\brief  Enable interrupts\r\n */\r\n#if defined (__GNUC__) \r\n#define ENABLE_INTERRUPTS() __asm volatile (\"cpsie i\" : : : \"memory\");\r\n#else\r\n#define ENABLE_INTERRUPTS() __asm(\"cpsie i\")\r\n#endif\r\n\r\n\r\n/** \\brief  Disable interrupts\r\n */\r\n#if defined (__GNUC__)\r\n#define DISABLE_INTERRUPTS() __asm volatile (\"cpsid i\" : : : \"memory\");\r\n#else\r\n#define DISABLE_INTERRUPTS() __asm(\"cpsid i\")\r\n#endif\r\n\r\n\r\n/** \\brief  Enter low-power standby state\r\n *    WFI (Wait For Interrupt) makes the processor suspend execution (Clock is stopped) until an IRQ interrupts.\r\n */\r\n#if defined (__GNUC__)\r\n#define STANDBY() __asm volatile (\"wfi\")\r\n#else\r\n#define STANDBY() __asm(\"wfi\")\r\n#endif\r\n\r\n/** \\brief  No-op\r\n */\r\n#define NOP() __asm volatile (\"nop\")\r\n\r\n/** \\brief  Reverse byte order in a word.\r\n */\r\n#if defined (__GNUC__) || defined (__ICCARM__) || defined (__ghs__) || defined (__ARMCC_VERSION)\r\n#define REV_BYTES_32(a, b) __asm volatile (\"rev %0, %1\" : \"=r\" (b) : \"r\" (a))\r\n#else\r\n#define REV_BYTES_32(a, b) (b = ((a & 0xFF000000U) >> 24U) | ((a & 0xFF0000U) >> 8U) \\\r\n                                | ((a & 0xFF00U) << 8U) | ((a & 0xFFU) << 24U))\r\n#endif\r\n\r\n/** \\brief  Reverse byte order in each halfword independently.\r\n */\r\n#if defined (__GNUC__) || defined (__ICCARM__) || defined (__ghs__) || defined (__ARMCC_VERSION)\r\n#define REV_BYTES_16(a, b) __asm volatile (\"rev16 %0, %1\" : \"=r\" (b) : \"r\" (a))\r\n#else\r\n#define REV_BYTES_16(a, b) (b = ((a & 0xFF000000U) >> 8U) | ((a & 0xFF0000U) << 8U) \\\r\n                                | ((a & 0xFF00U) >> 8U) | ((a & 0xFFU) << 8U))\r\n#endif\r\n\r\n/** \\brief  Places a function in RAM.\r\n */\r\n#if defined ( __GNUC__ ) || defined (__ARMCC_VERSION)\r\n    #define START_FUNCTION_DECLARATION_RAMSECTION\r\n    #define END_FUNCTION_DECLARATION_RAMSECTION        __attribute__((section (\".code_ram\")));\r\n#elif defined ( __ghs__ )\r\n    #define START_FUNCTION_DECLARATION_RAMSECTION      _Pragma(\"ghs callmode=far\")\r\n    #define END_FUNCTION_DECLARATION_RAMSECTION        __attribute__((section (\".code_ram\")));\\\r\n                                                       _Pragma(\"ghs callmode=default\")\r\n#elif defined ( __ICCARM__ )\r\n    #define START_FUNCTION_DECLARATION_RAMSECTION      __ramfunc\r\n    #define END_FUNCTION_DECLARATION_RAMSECTION        ;\r\n#elif defined ( __DCC__ )\r\n    #define START_FUNCTION_DECLARATION_RAMSECTION      _Pragma(\"section CODE \\\".code_ram\\\"\") \\\r\n                                                       _Pragma(\"use_section CODE\")\r\n    #define END_FUNCTION_DECLARATION_RAMSECTION        ; \\\r\n                                                       _Pragma(\"section CODE \\\".text\\\"\")\r\n#else\r\n    /* Keep compatibility with software analysis tools */\r\n    #define START_FUNCTION_DECLARATION_RAMSECTION      \r\n    #define END_FUNCTION_DECLARATION_RAMSECTION        ;\r\n#endif\r\n                                                   \r\n    /* For GCC, IAR, GHS, Diab and ARMC there is no need to specify the section when\r\n    defining a function, it is enough to specify it at the declaration. This\r\n    also enables compatibility with software analysis tools. */\r\n    #define START_FUNCTION_DEFINITION_RAMSECTION\r\n    #define END_FUNCTION_DEFINITION_RAMSECTION\r\n\r\n#if defined (__ICCARM__)\r\n    #define DISABLE_CHECK_RAMSECTION_FUNCTION_CALL     _Pragma(\"diag_suppress=Ta022\")\r\n    #define ENABLE_CHECK_RAMSECTION_FUNCTION_CALL      _Pragma(\"diag_default=Ta022\")\r\n#else\r\n    #define DISABLE_CHECK_RAMSECTION_FUNCTION_CALL\r\n    #define ENABLE_CHECK_RAMSECTION_FUNCTION_CALL\r\n#endif\r\n\r\n/** \\brief  Get Core ID\r\n *\r\n *   GET_CORE_ID returns the processor identification number for cm4\r\n */\r\n#define GET_CORE_ID()\t0U\r\n\r\n/** \\brief  Data alignment.\r\n */\r\n#if defined ( __GNUC__ ) || defined ( __ghs__ ) || defined ( __DCC__ ) || defined (__ARMCC_VERSION)\r\n    #define ALIGNED(x)      __attribute__((aligned(x)))\r\n#elif defined ( __ICCARM__ )\r\n    #define stringify(s) tostring(s)\r\n    #define tostring(s) #s\r\n    #define ALIGNED(x)      _Pragma(stringify(data_alignment=x))\r\n#else\r\n    /* Keep compatibility with software analysis tools */\r\n    #define ALIGNED(x)\r\n#endif\r\n\r\n/** \\brief  Endianness.\r\n */\r\n#define CORE_LITTLE_ENDIAN\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* CORE_CM4_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"adc_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file adc_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define, representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define, representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3,  Taking address of near auto variable.\r\n * The code is not dynamically linked. An absolute stack address is obtained\r\n * when taking the address of the near auto variable.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n */\r\n\r\n#include <stddef.h>\r\n#include \"adc_driver.h\"\r\n#include \"adc_hw_access.h\"\r\n#include \"clock_manager.h\"\r\n\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/* The reset value for CFG2[SMPLTS] */\r\n#define ADC_RESET_SAMPLE_TIME_VALUE (12u)\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/* Table of base addresses for ADC instances. */\r\nstatic ADC_Type * const s_adcBase[ADC_INSTANCE_COUNT] = ADC_BASE_PTRS;\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_InitConverterStruct\r\n * Description   : This function initializes the members of the adc_converter_config_t\r\n * structure to default values (Reference Manual resets). This function should be called\r\n * on a structure before using it to configure the converter (ADC_DRV_ConfigConverter), otherwise all members\r\n * must be written (initialized) by the caller. This function insures that all members are written\r\n * with safe values, so the user can modify only the desired members.\r\n *\r\n * Implements : ADC_DRV_InitConverterStruct_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_InitConverterStruct(adc_converter_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->clockDivide    = ADC_CLK_DIVIDE_1;\r\n    config->sampleTime     = (uint8_t)ADC_DEFAULT_SAMPLE_TIME;\r\n    config->resolution     = ADC_RESOLUTION_8BIT;\r\n    config->inputClock     = ADC_CLK_ALT_1;\r\n    config->trigger        = ADC_TRIGGER_SOFTWARE;\r\n    config->pretriggerSel  = ADC_PRETRIGGER_SEL_PDB;\r\n    config->triggerSel     = ADC_TRIGGER_SEL_PDB;\r\n    config->dmaEnable      = false;\r\n    config->voltageRef     = ADC_VOLTAGEREF_VREF;\r\n    config->continuousConvEnable   = false;\r\n    config->supplyMonitoringEnable = false;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ConfigConverter\r\n * Description   : This function configures the ADC converter with the options\r\n * provided in the configuration structure.\r\n *\r\n * Implements : ADC_DRV_ConfigConverter_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ConfigConverter(const uint32_t instance,\r\n                             const adc_converter_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n    /* Some alternative clocks can be unavailable depending on the device */\r\n    DEV_ASSERT(config->inputClock <= NUMBER_OF_ALT_CLOCKS);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n    clock_names_t adc_clocks[ADC_INSTANCE_COUNT] = ADC_CLOCKS;\r\n    uint32_t adc_freq = 0u;\r\n    status_t clk_status = CLOCK_SYS_GetFreq(adc_clocks[instance], &adc_freq);\r\n    DEV_ASSERT(clk_status == STATUS_SUCCESS);\r\n    (void) clk_status;\r\n\r\n    adc_freq = adc_freq / (uint32_t)(1UL << ((uint32_t)(config->clockDivide)));\r\n    DEV_ASSERT((adc_freq >= ADC_CLOCK_FREQ_MIN_RUNTIME) && (adc_freq <= ADC_CLOCK_FREQ_MAX_RUNTIME));\r\n\r\n    ADC_SetClockDivide(base, config->clockDivide);\r\n    ADC_SetSampleTime(base, config->sampleTime);\r\n    ADC_SetResolution(base, config->resolution);\r\n    ADC_SetInputClock(base, config->inputClock);\r\n    ADC_SetTriggerMode(base, config->trigger);\r\n    ADC_SetPretriggerSelect(instance, config->pretriggerSel);\r\n    ADC_SetTriggerSelect(instance, config->triggerSel);\r\n    ADC_SetDMAEnableFlag(base, config->dmaEnable);\r\n    ADC_SetVoltageReference(base, config->voltageRef);\r\n    ADC_SetContinuousConvFlag(base, config->continuousConvEnable);\r\n\r\n    /* Supply monitoring is only available for ADC 0. */\r\n    DEV_ASSERT((config->supplyMonitoringEnable == false) || (instance == 0u));\r\n    if(instance == 0u)\r\n    {\r\n        SIM_Type * const simBase = SIM;\r\n        ADC_SetSupplyMonitoringEnableFlag(simBase, config->supplyMonitoringEnable);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetConverterConfig\r\n * Description   : This functions returns the current converter configuration in\r\n * the form of a configuration structure.\r\n *\r\n * Implements : ADC_DRV_GetConverterConfig_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_GetConverterConfig(const uint32_t instance,\r\n                                adc_converter_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n    config->clockDivide = ADC_GetClockDivide(base);\r\n    config->sampleTime = ADC_GetSampleTime(base);\r\n    config->resolution = ADC_GetResolution(base);\r\n    config->inputClock = ADC_GetInputClock(base);\r\n    config->trigger = ADC_GetTriggerMode(base);\r\n    config->triggerSel = ADC_GetTriggerSelect(instance);\r\n    config->pretriggerSel = ADC_GetPretriggerSelect(instance);\r\n    config->dmaEnable = ADC_GetDMAEnableFlag(base);\r\n    config->voltageRef = ADC_GetVoltageReference(base);\r\n    config->continuousConvEnable = ADC_GetContinuousConvFlag(base);\r\n\r\n    /* Supply monitoring is only available for ADC 0. */\r\n    if(instance == 0u)\r\n    {\r\n        const SIM_Type * const simBase = SIM;\r\n        config->supplyMonitoringEnable = ((simBase->CHIPCTL & SIM_CHIPCTL_ADC_SUPPLYEN_MASK) != 0u) ? true : false;\r\n    }\r\n    else\r\n    {\r\n        config->supplyMonitoringEnable = false;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_Reset\r\n * Description   : This function writes all the internal ADC registers with\r\n * their Reference Manual reset values.\r\n *\r\n * Implements : ADC_DRV_Reset_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_Reset(const uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n\r\n    ADC_Type * const baseAddr = s_adcBase[instance];\r\n    uint8_t idx = 0U;\r\n\r\n    for(idx = 0U; idx < ADC_SC1_COUNT; idx++)\r\n    {\r\n        baseAddr->SC1[idx] = ADC_SC1_ADCH(ADC_INPUTCHAN_DISABLED) | ADC_SC1_AIEN(0x00U);\r\n    }\r\n\r\n    baseAddr->CFG1 = ADC_CFG1_ADICLK(ADC_CLK_ALT_1) | ADC_CFG1_MODE(ADC_RESOLUTION_8BIT) | ADC_CFG1_ADIV(ADC_CLK_DIVIDE_1);\r\n    baseAddr->CFG2 = ADC_CFG2_SMPLTS(ADC_DEFAULT_SAMPLE_TIME);\r\n\r\n    for(idx = 0U; idx < ADC_CV_COUNT; idx++)\r\n    {\r\n        baseAddr->CV[idx] = ADC_CV_CV(0U);\r\n    }\r\n\r\n    baseAddr->SC2 = ADC_SC2_REFSEL(ADC_VOLTAGEREF_VREF) | ADC_SC2_DMAEN(0x00U) | ADC_SC2_ACREN(0x00U) | ADC_SC2_ACFGT(0x00U) | ADC_SC2_ACFE(0x00U) |\r\n                    ADC_SC2_ADTRG(0x00U);\r\n    baseAddr->SC3 = ADC_SC3_AVGS(ADC_AVERAGE_4) | ADC_SC3_AVGE(0x00U) | ADC_SC3_ADCO(0x00U) | ADC_SC3_CAL(0x00U);\r\n    baseAddr->USR_OFS = ADC_USR_OFS_USR_OFS(0U);\r\n    baseAddr->UG = ADC_UG_UG(ADC_DEFAULT_USER_GAIN);\r\n\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n    for(idx = 0U; idx < ADC_aSC1_COUNT; idx++)\r\n    {\r\n        baseAddr->aSC1[idx] = ADC_aSC1_ADCH(ADC_INPUTCHAN_DISABLED) | ADC_aSC1_AIEN(0x00U);\r\n    }\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n    ADC_SetPretriggerSelect(instance, ADC_PRETRIGGER_SEL_PDB);\r\n    ADC_SetTriggerSelect(instance, ADC_TRIGGER_SEL_PDB);\r\n    ADC_DRV_SetSwPretrigger(instance, ADC_SW_PRETRIGGER_DISABLED);\r\n\r\n    /* Reset ADC Supply Monitoring - available only for ADC 0 */\r\n    if(instance == 0u)\r\n    {\r\n        SIM_Type * const simBase = SIM;\r\n        ADC_SetSupplyMonitoringEnableFlag(simBase, false);\r\n\r\n        simBase->CHIPCTL &= ~SIM_CHIPCTL_ADC_SUPPLY_MASK;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_InitHwCompareStruct\r\n * Description   : This function initializes the Hardware Compare configuration\r\n * structure to default values (Reference Manual resets). This function should be\r\n * called before configuring the Hardware Compare feature (ADC_DRV_ConfigHwCompare),\r\n * otherwise all members must be written by the caller. This function insures that all\r\n * members are written with safe values, so the user can modify the desired members.\r\n *\r\n * Implements : ADC_DRV_InitHwCompareStruct_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_InitHwCompareStruct(adc_compare_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->compareEnable = false;\r\n    config->compareGreaterThanEnable = false;\r\n    config->compareRangeFuncEnable = false;\r\n    config->compVal1 = 0U;\r\n    config->compVal2 = 0U;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ConfigHwCompare\r\n * Description   : This functions sets the configuration for the Hardware\r\n * Compare feature using the configuration structure.\r\n *\r\n * Implements : ADC_DRV_ConfigHwCompare_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ConfigHwCompare(const uint32_t instance,\r\n                             const adc_compare_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n    ADC_SetHwCompareEnableFlag(base, config->compareEnable);\r\n    ADC_SetHwCompareGtEnableFlag(base, config->compareGreaterThanEnable);\r\n    ADC_SetHwCompareRangeEnableFlag(base, config->compareRangeFuncEnable);\r\n    ADC_SetHwCompareComp1Value(base, config->compVal1);\r\n    ADC_SetHwCompareComp2Value(base, config->compVal2);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetHwCompareConfig\r\n * Description   : This function returns the configuration for the Hardware\r\n * Compare feature.\r\n *\r\n * Implements : ADC_DRV_GetHwCompareConfig_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_GetHwCompareConfig(const uint32_t instance,\r\n                                adc_compare_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n    config->compareEnable = ADC_GetHwCompareEnableFlag(base);\r\n    config->compareGreaterThanEnable = ADC_GetHwCompareGtEnableFlag(base);\r\n    config->compareRangeFuncEnable = ADC_GetHwCompareRangeEnableFlag(base);\r\n    config->compVal1 = ADC_GetHwCompareComp1Value(base);\r\n    config->compVal2 = ADC_GetHwCompareComp2Value(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_InitHwAverageStruct\r\n * Description   : This function initializes the Hardware Average configuration\r\n * structure to default values (Reference Manual resets). This function should be\r\n * called before configuring the Hardware Average feature (ADC_DRV_ConfigHwAverage),\r\n * otherwise all members must be written by the caller. This function insures that all\r\n * members are written with safe values, so the user can modify the desired members.\r\n *\r\n * Implements : ADC_DRV_InitHwAverageStruct_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_InitHwAverageStruct(adc_average_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->hwAvgEnable = false;\r\n    config->hwAverage = ADC_AVERAGE_4;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ConfigHwAverage\r\n * Description   : This function sets the configuration for the Hardware\r\n * Average feature.\r\n *\r\n * Implements : ADC_DRV_ConfigHwAverage_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ConfigHwAverage(const uint32_t instance,\r\n                             const adc_average_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n    ADC_SetHwAverageEnableFlag(base, config->hwAvgEnable);\r\n    ADC_SetHwAverageMode(base, config->hwAverage);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetHwAverageConfig\r\n * Description   : This function returns the configuration for the Hardware\r\n * Average feature.\r\n *\r\n * Implements : ADC_DRV_GetHwAverageConfig_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_GetHwAverageConfig(const uint32_t instance,\r\n                                adc_average_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n    config->hwAvgEnable = ADC_GetHwAverageEnableFlag(base);\r\n    config->hwAverage = ADC_GetHwAverageMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_InitChanStruct\r\n * Description   : This function initializes the control channel\r\n * configuration structure to default values (Reference Manual resets). This function should\r\n * be called on a structure before using it to configure a channel (ADC_DRV_ConfigChan), otherwise\r\n * all members must be written by the caller. This function insures that all members are written\r\n * with safe values, so the user can modify only the desired members.\r\n *\r\n * Implements : ADC_DRV_InitChanStruct_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_InitChanStruct(adc_chan_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->interruptEnable = false;\r\n    config->channel = ADC_INPUTCHAN_DISABLED;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ConfigChan\r\n * Description   : This function sets a control channel configuration.\r\n *\r\n * When Software Trigger mode is enabled, configuring control channel index 0,\r\n * implicitly triggers a new conversion on the selected ADC input channel.\r\n * Therefore, ADC_DRV_ConfigChan can be used for sw-triggering conversions.\r\n *\r\n * Configuring any control channel while it is actively controlling a conversion\r\n * (sw or hw triggered) will implicitly abort the on-going conversion.\r\n *\r\n * Implements : ADC_DRV_ConfigChan_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ConfigChan(const uint32_t instance,\r\n                        const uint8_t chanIndex,\r\n                        const adc_chan_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(chanIndex < ADC_CTRL_CHANS_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n\r\n    /* ADC_INPUTCHAN_SUPPLY_ can only be used with ADC 0,\r\n     * If used, the feature must be enabled separately via supplyMonitoringEnable flag in adc_converter_config_t. */\r\n    DEV_ASSERT((instance == 0u) || ((uint32_t)config->channel < (uint32_t)ADC_INPUTCHAN_SUPPLY_VDD) || \\\r\n                                   ((uint32_t)config->channel > (uint32_t)ADC_INPUTCHAN_SUPPLY_VDD_LV));\r\n    ADC_SetInputChannel(base, chanIndex, config->channel, config->interruptEnable);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetChanConfig\r\n * Description   : This function returns the current configuration for a control\r\n * channel.\r\n *\r\n * Implements : ADC_DRV_GetChanConfig_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_GetChanConfig(const uint32_t instance,\r\n                           const uint8_t chanIndex,\r\n                           adc_chan_config_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(chanIndex < ADC_CTRL_CHANS_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n    config->interruptEnable = ADC_GetChanInterruptEnableFlag(base, chanIndex);\r\n    config->channel = ADC_GetInputChannel(base, chanIndex);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_SetSwPretrigger\r\n * Description   : This function sets the software pretrigger - affects only first 4 control channels.\r\n *\r\n * Implements : ADC_DRV_SetSwPretrigger_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_SetSwPretrigger(const uint32_t instance,\r\n                             const adc_sw_pretrigger_t swPretrigger)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    SIM_Type * const simBase = SIM;\r\n    uint32_t intermValue = 0U;\r\n    uint32_t mask[ADC_INSTANCE_COUNT] = {0U};\r\n#if (ADC_INSTANCE_COUNT == 1U)\r\n    mask[0] = SIM_ADCOPT_ADC0SWPRETRG_MASK;\r\n#elif (ADC_INSTANCE_COUNT == 2U)\r\n    mask[0] = SIM_ADCOPT_ADC0SWPRETRG_MASK;\r\n    mask[1] = SIM_ADCOPT_ADC1SWPRETRG_MASK;\r\n#else\r\n#error \"Maximum supported value for ADC_INSTANCE_COUNT is 2.\"\r\n#endif\r\n    /* If SW Pretrigger Select is not enabled, the SW pretriggers will be ignored by ADC. */\r\n    DEV_ASSERT((ADC_GetPretriggerSelect(instance) == ADC_PRETRIGGER_SEL_SW) || \\\r\n               (swPretrigger == ADC_SW_PRETRIGGER_DISABLED));\r\n\r\n    intermValue = simBase->ADCOPT & (~ mask[instance]);\r\n    switch(instance)\r\n    {\r\n    case 0:\r\n        intermValue |= SIM_ADCOPT_ADC0SWPRETRG(swPretrigger);\r\n        break;\r\n    case 1:\r\n        intermValue |= SIM_ADCOPT_ADC1SWPRETRG(swPretrigger);\r\n        break;\r\n    default:\r\n        DEV_ASSERT(false);\r\n        break;\r\n    }\r\n\r\n    simBase->ADCOPT = intermValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_WaitConvDone\r\n * Description   : This functions waits for a conversion to complete by\r\n * continuously polling the Conversion Active Flag.\r\n *\r\n * Implements : ADC_DRV_WaitConvDone_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_WaitConvDone(const uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n    while (ADC_GetConvActiveFlag(base) == true)\r\n    {\r\n        /* Wait for conversion to finish */\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetConvCompleteFlag\r\n * Description   : This function returns the state of the Conversion Complete\r\n * flag for a control channel. This flag is set when a conversion is complete\r\n * or the condition generated by the Hardware Compare feature is evaluated to true.\r\n *\r\n * Implements : ADC_DRV_GetConvCompleteFlag_Activity\r\n *END**************************************************************************/\r\nbool ADC_DRV_GetConvCompleteFlag(const uint32_t instance,\r\n                                 const uint8_t chanIndex)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(chanIndex < ADC_CTRL_CHANS_COUNT);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n    uint32_t tmp = base->aSC1[chanIndex];\r\n    tmp = (tmp & ADC_aSC1_COCO_MASK) >> ADC_aSC1_COCO_SHIFT;\r\n#else\r\n    uint32_t tmp = base->SC1[chanIndex];\r\n    tmp = (tmp & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT;\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetChanResult\r\n * Description   : This function returns the conversion result from a\r\n * control channel.\r\n *\r\n * Implements : ADC_DRV_GetChanResult_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_GetChanResult(const uint32_t instance,\r\n                           const uint8_t chanIndex,\r\n                           uint16_t * const result)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(result != NULL);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n\r\n    DEV_ASSERT(chanIndex < ADC_aR_COUNT);\r\n\r\n    uint32_t tmp = base->aR[chanIndex];\r\n    tmp = (tmp & ADC_aR_D_MASK) >> ADC_aR_D_SHIFT;\r\n#else\r\n\r\n    DEV_ASSERT(chanIndex < ADC_R_COUNT);\r\n\r\n    uint32_t tmp = base->R[chanIndex];\r\n    tmp = (tmp & ADC_R_D_MASK) >> ADC_R_D_SHIFT;\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n    *result = (uint16_t)tmp;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_AutoCalibration\r\n * Description   : This functions executes an Auto-Calibration sequence. It\r\n * is recommended to run this sequence before using the ADC converter.\r\n * this function will check and reset clock divide based the adc frequency.\r\n * an error will be displayed if adc_freq too big\r\n * this function will set satisfy clock divide,start calibration.\r\n * final this function: restore adc clock divide,hardware average and trigger settings.\r\n *\r\n * Implements : ADC_DRV_AutoCalibration_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_AutoCalibration(const uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n    /* set hardware average to maximum and set software trigger*/\r\n    bool hwavgen = ADC_GetHwAverageEnableFlag(base);\r\n    adc_average_t hwavg = ADC_GetHwAverageMode(base);\r\n    adc_trigger_t trig = ADC_GetTriggerMode(base);\r\n    uint8_t sampletime = ADC_GetSampleTime(base);\r\n    ADC_SetHwAverageMode(base, ADC_AVERAGE_32);\r\n    ADC_SetHwAverageEnableFlag(base, true);\r\n    ADC_SetTriggerMode(base, ADC_TRIGGER_SOFTWARE);\r\n    /* Set the sample time to the reset value because it affects the\r\n        calibration duration but not the results\r\n     */\r\n    ADC_SetSampleTime(base, ADC_RESET_SAMPLE_TIME_VALUE);\r\n\r\n    base->CLPS = 0x00u;\r\n    base->CLP3 = 0x00u;\r\n    base->CLP2 = 0x00u;\r\n    base->CLP1 = 0x00u;\r\n    base->CLP0 = 0x00u;\r\n    base->CLPX = 0x00u;\r\n    base->CLP9 = 0x00u;\r\n\r\n    /*Set clock divider */\r\n    clock_names_t adc_clocks[ADC_INSTANCE_COUNT] = ADC_CLOCKS;\r\n    uint32_t adc_freq = 0u;\r\n    adc_clk_divide_t adc_clk_divide_res = ADC_GetClockDivide(base);\r\n    adc_clk_divide_t adc_clk_divide = ADC_CLK_DIVIDE_1;\r\n    status_t clk_status = CLOCK_SYS_GetFreq(adc_clocks[instance], &adc_freq);\r\n    DEV_ASSERT(clk_status == STATUS_SUCCESS);\r\n    (void) clk_status;\r\n    DEV_ASSERT(adc_freq >= ADC_CLOCK_FREQ_MIN_RUNTIME);\r\n    if ((adc_freq / (uint32_t)(1UL << ((uint32_t)(adc_clk_divide_res)))) <= (ADC_CLOCK_FREQ_MAX_RUNTIME / 2U))\r\n    {\r\n        /* no action if adc_freq is satisfy */\r\n    }\r\n    else\r\n    {\r\n        if ((adc_freq / 2U) <= (ADC_CLOCK_FREQ_MAX_RUNTIME / 2U))\r\n        {\r\n            adc_clk_divide = ADC_CLK_DIVIDE_2;\r\n        }\r\n        else if ((adc_freq / 4U) <= (ADC_CLOCK_FREQ_MAX_RUNTIME / 2U))\r\n        {\r\n            adc_clk_divide = ADC_CLK_DIVIDE_4;\r\n        }\r\n        else if ((adc_freq / 8U) <= (ADC_CLOCK_FREQ_MAX_RUNTIME / 2U))\r\n        {\r\n            adc_clk_divide = ADC_CLK_DIVIDE_8;\r\n        }\r\n        else\r\n        {\r\n            /* frequency is greater than required clock for calibration */\r\n            DEV_ASSERT(false);\r\n        }\r\n        ADC_SetClockDivide(base, adc_clk_divide);\r\n    }\r\n    /* start calibration */\r\n    ADC_SetCalibrationActiveFlag(base, true);\r\n    while (ADC_GetCalibrationActiveFlag(base))\r\n    {\r\n        /* Wait for calibration to finish */\r\n    }\r\n\r\n    /* restore adc clock divide*/\r\n    ADC_SetClockDivide(base, adc_clk_divide_res);\r\n    /* restore hardware average and trigger settings*/\r\n    ADC_SetHwAverageEnableFlag(base, hwavgen);\r\n    ADC_SetHwAverageMode(base, hwavg);\r\n    ADC_SetTriggerMode(base, trig);\r\n    ADC_SetSampleTime(base, sampletime);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_InitUserCalibrationStruct\r\n * Description   : This function initializes the User Calibration configuration\r\n * structure to default values (Reference Manual resets). This function should be called\r\n * on a structure before using it to configure the User Calibration feature (ADC_DRV_ConfigUserCalibration),\r\n * otherwise all members must be written by the caller. This function insures that all members are written\r\n * with safe values, so the user can modify only the desired members.\r\n *\r\n * Implements : ADC_DRV_InitUserCalibrationStruct_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_InitUserCalibrationStruct(adc_calibration_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->userGain = (uint16_t)ADC_DEFAULT_USER_GAIN;\r\n    config->userOffset = (uint16_t)0U;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ConfigUserCalibration\r\n * Description   : This function sets the configuration for the user calibration\r\n * registers.\r\n *\r\n * Implements : ADC_DRV_ConfigUserCalibration_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ConfigUserCalibration(const uint32_t instance,\r\n                                   const adc_calibration_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n    ADC_SetUserGainValue(base, config->userGain);\r\n    ADC_SetUserOffsetValue(base, config->userOffset);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetUserCalibration\r\n * Description   : This function returns the current user calibration\r\n * register values.\r\n *\r\n * Implements : ADC_DRV_GetUserCalibration_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_GetUserCalibration(const uint32_t instance,\r\n                                adc_calibration_t * const config)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n    config->userGain = ADC_GetUserGainValue(base);\r\n    config->userOffset = ADC_GetUserOffsetValue(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetInterruptNumber\r\n * Description   : This function returns the interrupt number for the specified ADC instance.\r\n *\r\n * Implements : ADC_DRV_GetInterruptNumber_Activity\r\n *END**************************************************************************/\r\nIRQn_Type ADC_DRV_GetInterruptNumber(const uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n\r\n    static const IRQn_Type adcIrqId[ADC_INSTANCE_COUNT] = ADC_IRQS;\r\n    IRQn_Type irqId = adcIrqId[instance];\r\n\r\n    return irqId;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ClearLatchedTriggers\r\n * Description   : This function clears all trigger latched flags of the ADC instance.\r\n *\r\n * Implements : ADC_DRV_ClearLatchedTriggers_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ClearLatchedTriggers(const uint32_t instance,\r\n                                  const adc_latch_clear_t clearMode)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n    DEV_ASSERT((clearMode == ADC_LATCH_CLEAR_WAIT) || (clearMode == ADC_LATCH_CLEAR_FORCE));\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n    if (clearMode == ADC_LATCH_CLEAR_FORCE)\r\n    {\r\n        ADC_ClearLatchTriggers(base);\r\n    }\r\n\r\n    while (ADC_GetTriggerLatchFlags(base) != 0u)\r\n    {\r\n        /* Wait for latched triggers to be processed */\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_ClearTriggerErrors\r\n * Description   : This function clears all trigger error flags of the ADC instance.\r\n *\r\n * Implements : ADC_DRV_ClearTriggerErrors_Activity\r\n *END**************************************************************************/\r\nvoid ADC_DRV_ClearTriggerErrors(const uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n\r\n    ADC_Type * const base = s_adcBase[instance];\r\n\r\n    base->SC2 |= ADC_SC2_TRGSTERR_MASK;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : ADC_DRV_GetTriggerErrorFlags\r\n * Description   : This function returns the trigger error flags bits of the ADC instance.\r\n *\r\n * Implements : ADC_DRV_GetTriggerErrorFlags_Activity\r\n *END**************************************************************************/\r\nuint32_t ADC_DRV_GetTriggerErrorFlags(const uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < ADC_INSTANCE_COUNT);\r\n\r\n    const ADC_Type * const base = s_adcBase[instance];\r\n\r\n    uint32_t trig_errors = (base->SC2 & ADC_SC2_TRGSTERR_MASK) >> ADC_SC2_TRGSTERR_SHIFT;\r\n\r\n    return trig_errors;\r\n}\r\n\r\n/******************************************************************************\r\n * EOF\r\n *****************************************************************************/\r\n"},{"name":"adc_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef ADC_DRIVER_H\r\n#define ADC_DRIVER_H\r\n\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include \"device_registers.h\"\r\n\r\n/*! @file adc_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n */\r\n\r\n/*!\r\n * @addtogroup adc_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*!\r\n * @brief Clock Divider selection\r\n *\r\n * Implements : adc_clk_divide_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_CLK_DIVIDE_1 = 0x00U,   /*!< Input clock divided by 1. */\r\n    ADC_CLK_DIVIDE_2 = 0x01U,   /*!< Input clock divided by 2. */\r\n    ADC_CLK_DIVIDE_4 = 0x02U,   /*!< Input clock divided by 4. */\r\n    ADC_CLK_DIVIDE_8 = 0x03U    /*!< Input clock divided by 8. */\r\n} adc_clk_divide_t;\r\n\r\n/*!\r\n * @brief Conversion resolution selection\r\n *\r\n * Implements : adc_resolution_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_RESOLUTION_8BIT = 0x00U,    /*!< 8-bit resolution mode */\r\n    ADC_RESOLUTION_12BIT = 0x01U,   /*!< 12-bit resolution mode */\r\n    ADC_RESOLUTION_10BIT = 0x02U    /*!< 10-bit resolution mode */\r\n} adc_resolution_t;\r\n\r\n/*!\r\n * @brief Input clock source selection\r\n *\r\n * Implements : adc_input_clock_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_CLK_ALT_1 = 0x00U,  /*!< Input clock alternative 1. */\r\n    ADC_CLK_ALT_2 = 0x01U,  /*!< Input clock alternative 2. */\r\n    ADC_CLK_ALT_3 = 0x02U,  /*!< Input clock alternative 3. */\r\n    ADC_CLK_ALT_4 = 0x03U   /*!< Input clock alternative 4. */\r\n} adc_input_clock_t;\r\n\r\n/*!\r\n * @brief Trigger type selection\r\n *\r\n * Implements : adc_trigger_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_TRIGGER_SOFTWARE       = 0x00U,   /*!< Software trigger. */\r\n    ADC_TRIGGER_HARDWARE       = 0x01U    /*!< Hardware trigger. */\r\n} adc_trigger_t;\r\n\r\n/*!\r\n * @brief Pretrigger types selectable from Trigger Latching and Arbitration Unit\r\n *\r\n * Implements : adc_pretrigger_sel_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_PRETRIGGER_SEL_PDB     = 0x00U,   /*!< PDB pretrigger selected. */\r\n    ADC_PRETRIGGER_SEL_TRGMUX  = 0x01U,   /*!< TRGMUX pretrigger selected. */\r\n    ADC_PRETRIGGER_SEL_SW      = 0x02U    /*!< Software pretrigger selected. */\r\n} adc_pretrigger_sel_t;\r\n\r\n/*!\r\n * @brief Trigger source selectable from Trigger Latching and Arbitration Unit\r\n *\r\n * Implements : adc_trigger_sel_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_TRIGGER_SEL_PDB        = 0x00U,   /*!< PDB trigger selected. */\r\n    ADC_TRIGGER_SEL_TRGMUX     = 0x01U    /*!< TRGMUX trigger selected. */\r\n} adc_trigger_sel_t;\r\n\r\n/*!\r\n * @brief Software pretriggers which may be set from Trigger Latching and Arbitration Unit\r\n *\r\n * Implements : adc_sw_pretrigger_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_SW_PRETRIGGER_DISABLED = 0x00U,   /*!< SW pretrigger disabled. */\r\n    ADC_SW_PRETRIGGER_0        = 0x04U,   /*!< SW pretrigger 0. */\r\n    ADC_SW_PRETRIGGER_1        = 0x05U,   /*!< SW pretrigger 1. */\r\n    ADC_SW_PRETRIGGER_2        = 0x06U,   /*!< SW pretrigger 2. */\r\n    ADC_SW_PRETRIGGER_3        = 0x07U    /*!< SW pretrigger 3. */\r\n} adc_sw_pretrigger_t;\r\n\r\n/*!\r\n * @brief Voltage reference selection\r\n *\r\n * Implements : adc_voltage_reference_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_VOLTAGEREF_VREF = 0x00U,    /*!< VrefH and VrefL as Voltage reference. */\r\n    ADC_VOLTAGEREF_VALT = 0x01U     /*!< ValtH and ValtL as Voltage reference. */\r\n} adc_voltage_reference_t;\r\n\r\n/*!\r\n * @brief Hardware average selection\r\n *\r\n * Implements : adc_average_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_AVERAGE_4 = 0x00U,  /*!< Hardware average of 4 samples. */\r\n    ADC_AVERAGE_8 = 0x01U,  /*!< Hardware average of 8 samples. */\r\n    ADC_AVERAGE_16 = 0x02U, /*!< Hardware average of 16 samples. */\r\n    ADC_AVERAGE_32 = 0x03U  /*!< Hardware average of 32 samples. */\r\n} adc_average_t;\r\n\r\n/*!\r\n * @brief Enumeration of input channels assignable to a control channel.\r\n * \\n <b>Note 0</b>: entries in this enum are affected by ::FEATURE_ADC_NUM_EXT_CHANS, which is device dependent\r\n * and controlled from <i>\"device_name\"_features.h</i> file.\r\n *\r\n * \\n <b>Note 1</b>: the actual number of external channels may differ between device packages\r\n * and ADC instances. Reading a channel that is not connected externally, will return a random value within the range.\r\n * Please refer to the Reference Manual for the maximum number of external channels for each device variant and ADC instance.\r\n *\r\n * \\n <b>Note 2</b>: ADC_INPUTCHAN_SUPPLY_ select which internal supply channel to be measured.\r\n * They are only available for ADC0 and measured internally via internal input channel 0.\r\n * Please note that supply monitoring needs to be enabled separately via dedicated flag in adc_converter_config_t.\r\n *\r\n * Implements : adc_inputchannel_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_INPUTCHAN_EXT0      = 0x00U,              /*!< External input channel 0 */\r\n    ADC_INPUTCHAN_EXT1      = 0x01U,              /*!< External input channel 1 */\r\n#if (FEATURE_ADC_HAS_CHANNEL_2)\r\n    ADC_INPUTCHAN_EXT2      = 0x02U,              /*!< External input channel 2 */\r\n#endif\r\n    ADC_INPUTCHAN_EXT3      = 0x03U,              /*!< External input channel 3 */\r\n    ADC_INPUTCHAN_EXT4      = 0x04U,              /*!< External input channel 4 */\r\n    ADC_INPUTCHAN_EXT5      = 0x05U,              /*!< External input channel 5 */\r\n    ADC_INPUTCHAN_EXT6      = 0x06U,              /*!< External input channel 6 */\r\n    ADC_INPUTCHAN_EXT7      = 0x07U,              /*!< External input channel 7 */\r\n#if (FEATURE_ADC_HAS_CHANNEL_8)\r\n    ADC_INPUTCHAN_EXT8      = 0x08U,              /*!< External input channel 8 */\r\n#endif\r\n    ADC_INPUTCHAN_EXT9      = 0x09U,              /*!< External input channel 9 */\r\n    ADC_INPUTCHAN_EXT10     = 0x0AU,              /*!< External input channel 10 */\r\n    ADC_INPUTCHAN_EXT11     = 0x0BU,              /*!< External input channel 11 */\r\n    ADC_INPUTCHAN_EXT12     = 0x0CU,              /*!< External input channel 12 */\r\n    ADC_INPUTCHAN_EXT13     = 0x0DU,              /*!< External input channel 13 */\r\n    ADC_INPUTCHAN_EXT14     = 0x0EU,              /*!< External input channel 14 */\r\n#if (FEATURE_ADC_MAX_NUM_EXT_CHANS > 15)\r\n    ADC_INPUTCHAN_EXT15     = 0x0FU,              /*!< External input channel 15 */\r\n#if (FEATURE_ADC_MAX_NUM_EXT_CHANS > 16)\r\n    ADC_INPUTCHAN_EXT16     = 0x20U,              /*!< External input channel 16 */\r\n    ADC_INPUTCHAN_EXT17     = 0x21U,              /*!< External input channel 17 */\r\n    ADC_INPUTCHAN_EXT18     = 0x22U,              /*!< External input channel 18 */\r\n    ADC_INPUTCHAN_EXT19     = 0x23U,              /*!< External input channel 19 */\r\n    ADC_INPUTCHAN_EXT20     = 0x24U,              /*!< External input channel 20 */\r\n    ADC_INPUTCHAN_EXT21     = 0x25U,              /*!< External input channel 21 */\r\n    ADC_INPUTCHAN_EXT22     = 0x26U,              /*!< External input channel 22 */\r\n    ADC_INPUTCHAN_EXT23     = 0x27U,              /*!< External input channel 23 */\r\n#if (FEATURE_ADC_MAX_NUM_EXT_CHANS > 24)\r\n    ADC_INPUTCHAN_EXT24     = 0x28U,              /*!< External input channel 24 */\r\n    ADC_INPUTCHAN_EXT25     = 0x29U,              /*!< External input channel 25 */\r\n    ADC_INPUTCHAN_EXT26     = 0x2AU,              /*!< External input channel 26 */\r\n    ADC_INPUTCHAN_EXT27     = 0x2BU,              /*!< External input channel 27 */\r\n    ADC_INPUTCHAN_EXT28     = 0x2CU,              /*!< External input channel 28 */\r\n    ADC_INPUTCHAN_EXT29     = 0x2DU,              /*!< External input channel 29 */\r\n    ADC_INPUTCHAN_EXT30     = 0x2EU,              /*!< External input channel 30 */\r\n    ADC_INPUTCHAN_EXT31     = 0x2FU,              /*!< External input channel 31 */\r\n#endif /* (FEATURE_ADC_MAX_NUM_EXT_CHANS > 24) */\r\n#endif /* (FEATURE_ADC_MAX_NUM_EXT_CHANS > 16) */\r\n#endif/* (FEATURE_ADC_MAX_NUM_EXT_CHANS > 15) */\r\n\r\n    ADC_INPUTCHAN_DISABLED  = ADC_SC1_ADCH_MASK,  /*!< Channel disabled          */\r\n\r\n    ADC_INPUTCHAN_INT0      = 0x15,               /*!< Internal input channel 0  */\r\n    ADC_INPUTCHAN_INT1      = 0x16,               /*!< Internal input channel 1  */\r\n    ADC_INPUTCHAN_INT2      = 0x17,               /*!< Internal input channel 2  */\r\n    ADC_INPUTCHAN_INT3      = 0x1C,               /*!< Internal input channel 3  */\r\n\r\n    ADC_INPUTCHAN_TEMP      = 0x1A,               /*!< Temperature Sensor            */\r\n    ADC_INPUTCHAN_BANDGAP   = 0x1B,               /*!< Band Gap                      */\r\n    ADC_INPUTCHAN_VREFSH    = 0x1D,               /*!< Voltage Reference Select High */\r\n    ADC_INPUTCHAN_VREFSL    = 0x1E,               /*!< Voltage Reference Select Low  */\r\n\r\n    ADC_INPUTCHAN_SUPPLY_VDD            = 0xF00U,   /*!< Monitor internal supply 5 V input VDD supply.              */\r\n    ADC_INPUTCHAN_SUPPLY_VDDA           = 0xF01U,   /*!< Monitor internal supply 5 V input analog supply.           */\r\n    ADC_INPUTCHAN_SUPPLY_VREFH          = 0xF02U,   /*!< Monitor internal supply ADC reference supply.              */\r\n    ADC_INPUTCHAN_SUPPLY_VDD_3V         = 0xF03U,   /*!< Monitor internal supply 3.3 V oscillator regulator output. */\r\n    ADC_INPUTCHAN_SUPPLY_VDD_FLASH_3V   = 0xF04U,   /*!< Monitor internal supply 3.3 V flash regulator output.      */\r\n    ADC_INPUTCHAN_SUPPLY_VDD_LV         = 0xF05U    /*!< Monitor internal supply 1.2 V core regulator output.       */\r\n} adc_inputchannel_t;\r\n\r\n/*!\r\n * @brief Defines the converter configuration\r\n *\r\n * This structure is used to configure the ADC converter\r\n *\r\n * Implements : adc_converter_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    adc_clk_divide_t clockDivide;        /*!< Divider of the input clock for the ADC */\r\n    uint8_t sampleTime;                  /*!< Sample time in AD Clocks */\r\n    adc_resolution_t resolution;         /*!< ADC resolution (8,10,12 bit) */\r\n    adc_input_clock_t inputClock;        /*!< Input clock source */\r\n    adc_trigger_t trigger;               /*!< ADC trigger type (software, hardware) - affects only the first control channel */\r\n    adc_pretrigger_sel_t pretriggerSel;  /*!< Pretrigger source selected from Trigger Latching and Arbitration Unit - affects only the first 4 control channels */\r\n    adc_trigger_sel_t triggerSel;        /*!< Trigger source selected from Trigger Latching and Arbitration Unit */\r\n    bool dmaEnable;                      /*!< Enable DMA for the ADC */\r\n    adc_voltage_reference_t voltageRef;  /*!< Voltage reference used */\r\n    bool continuousConvEnable;           /*!< Enable Continuous conversions */\r\n    bool supplyMonitoringEnable;         /*!< Only available for ADC 0. Enable internal supply monitoring - enables measurement of ADC_INPUTCHAN_SUPPLY_ sources. */\r\n} adc_converter_config_t;\r\n\r\n/*!\r\n * @brief Defines the hardware compare configuration\r\n *\r\n * This structure is used to configure the hardware compare\r\n * feature for the ADC\r\n *\r\n * Implements : adc_compare_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool compareEnable;              /*!< Enable the compare feature */\r\n    bool compareGreaterThanEnable;   /*!< Enable Greater-Than functionality */\r\n    bool compareRangeFuncEnable;     /*!< Enable Range functionality */\r\n    uint16_t compVal1;               /*!< First Compare Value */\r\n    uint16_t compVal2;               /*!< Second Compare Value */\r\n} adc_compare_config_t;\r\n\r\n/*!\r\n * @brief Defines the hardware average configuration\r\n *\r\n * This structure is used to configure the hardware average\r\n * feature for the ADC\r\n *\r\n * Implements : adc_average_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool hwAvgEnable;        /*!< Enable averaging functionality */\r\n    adc_average_t hwAverage; /*!< Selection for number of samples used for averaging */\r\n} adc_average_config_t;\r\n\r\n/*!\r\n * @brief Defines the control channel configuration\r\n *\r\n * This structure is used to configure a control channel\r\n * of the ADC\r\n *\r\n * Implements : adc_chan_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool interruptEnable;       /*!< Enable interrupts for this channel */\r\n    adc_inputchannel_t channel; /*!< Selection of input channel for measurement */\r\n} adc_chan_config_t;\r\n\r\n/*!\r\n * @brief Defines the user calibration configuration\r\n *\r\n * This structure is used to configure the user calibration\r\n * parameters of the ADC.\r\n *\r\n * Implements : adc_calibration_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint16_t userGain;    /*!< User-configurable gain */\r\n    uint16_t userOffset;  /*!< User-configurable Offset (2's complement, subtracted from result) */\r\n} adc_calibration_t;\r\n\r\n/*!\r\n * @brief Defines the trigger latch clear method\r\n * Implements : adc_latch_clear_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    ADC_LATCH_CLEAR_WAIT, /*!< Clear by waiting all latched triggers to be processed */\r\n    ADC_LATCH_CLEAR_FORCE /*!< Process current trigger and clear all latched */\r\n} adc_latch_clear_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined (__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name Converter\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Initializes the converter configuration structure\r\n *\r\n * This function initializes the members of the adc_converter_config_t\r\n * structure to default values (Reference Manual resets). This function should\r\n * be called on a structure before using it to configure the converter with\r\n * ADC_DRV_ConfigConverter(), otherwise all members must be written\r\n * (initialized) by the user. This function insures that all members are written\r\n * with safe values, so the user can modify only the desired members.\r\n *\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_InitConverterStruct(adc_converter_config_t * const config);\r\n\r\n/*!\r\n * @brief Configures the converter with the given configuration structure\r\n *\r\n * This function configures the ADC converter with the options\r\n * provided in the provided structure.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] config the configuration structure\r\n */\r\nvoid ADC_DRV_ConfigConverter(const uint32_t instance,\r\n                             const adc_converter_config_t * const config);\r\n\r\n/*!\r\n * @brief Gets the current converter configuration\r\n *\r\n * This functions returns the configuration for converter in\r\n * the form of a configuration structure.\r\n *\r\n * @param[in] instance instance number\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_GetConverterConfig(const uint32_t instance,\r\n                                adc_converter_config_t * const config);\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Hardware Compare\r\n * The Hardware Compare feature of the S32K144 ADC is a versatile mechanism that\r\n * can be used to monitor that a value is within certain values. Measurements can\r\n * be monitored to be within certain ranges:\r\n *  - less than/ greater than a fixed value\r\n *  - inside or outside of a certain range\r\n *\r\n * Two compare values can be configured (the second value is used only for range\r\n * function mode). The compare values must be written in 12-bit resolution mode\r\n * regardless of the actual used resolution mode.\r\n *\r\n * Once the hardware compare feature is enabled, a conversion is considered\r\n * complete only when the measured value is within the allowable range set by\r\n * the configuration.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Initializes the Hardware Compare configuration structure\r\n *\r\n * This function initializes the Hardware Compare configuration\r\n * structure to default values (Reference Manual resets). This function should be\r\n * called before configuring the Hardware Compare feature (ADC_DRV_ConfigHwCompare),\r\n * otherwise all members must be written by the caller. This function insures\r\n * that all members are written with safe values, so the user can modify the\r\n * desired members.\r\n *\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_InitHwCompareStruct(adc_compare_config_t * const config);\r\n\r\n/*!\r\n * @brief Configures the Hardware Compare feature with the given configuration\r\n * structure\r\n *\r\n * This functions sets the configuration for the Hardware\r\n * Compare feature using the configuration structure.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] config the configuration structure\r\n */\r\nvoid ADC_DRV_ConfigHwCompare(const uint32_t instance,\r\n                             const adc_compare_config_t * const config);\r\n\r\n/*!\r\n * @brief Gets the current Hardware Compare configuration\r\n *\r\n * This function returns the configuration for the Hardware\r\n * Compare feature.\r\n *\r\n * @param[in] instance instance number\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_GetHwCompareConfig(const uint32_t instance,\r\n                                adc_compare_config_t * const config);\r\n\r\n/*! @}*/\r\n/*!\r\n * @name Hardware Average\r\n * The Hardware Average feature of the S32K144 allows for a set of measurements\r\n * to be averaged together as a single conversion. The number of samples to be\r\n * averaged is selectable (4, 8, 16 or 32 samples).\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Initializes the Hardware Average configuration structure\r\n *\r\n * This function initializes the Hardware Average configuration\r\n * structure to default values (Reference Manual resets). This function should be\r\n * called before configuring the Hardware Average feature (ADC_DRV_ConfigHwAverage),\r\n * otherwise all members must be written by the caller. This function insures\r\n * that all members are written with safe values, so the user can modify the\r\n * desired members.\r\n *\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_InitHwAverageStruct(adc_average_config_t * const config);\r\n\r\n/*!\r\n * @brief Configures the Hardware Average feature with the given configuration\r\n * structure\r\n *\r\n * This function sets the configuration for the Hardware\r\n * Average feature.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] config the configuration structure\r\n */\r\nvoid ADC_DRV_ConfigHwAverage(const uint32_t instance,\r\n                             const adc_average_config_t * const config);\r\n\r\n/*!\r\n * @brief Gets the current Hardware Average configuration\r\n *\r\n * This function returns the configuration for the Hardware\r\n * Average feature.\r\n *\r\n * @param[in] instance instance number\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_GetHwAverageConfig(const uint32_t instance,\r\n                                adc_average_config_t * const config);\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Channel configuration\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Initializes the control channel configuration structure\r\n *\r\n * This function initializes the control channel\r\n * configuration structure to default values (Reference Manual resets). This\r\n * function should be called on a structure before using it to configure a\r\n * channel (ADC_DRV_ConfigChan), otherwise all members must be written by the\r\n * caller. This function insures that all members are written with safe values,\r\n * so the user can modify only the desired members.\r\n *\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_InitChanStruct(adc_chan_config_t * const config);\r\n\r\n/*!\r\n * @brief Configures the selected control channel with the given\r\n * configuration structure\r\n *\r\n * When Software Trigger mode is enabled, configuring control channel index 0,\r\n * implicitly triggers a new conversion on the selected ADC input channel.\r\n * Therefore, ADC_DRV_ConfigChan can be used for sw-triggering conversions.\r\n *\r\n * Configuring any control channel while it is actively controlling a conversion\r\n * (sw or hw triggered) will implicitly abort the on-going conversion.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] chanIndex the control channel index\r\n * @param[in] config the configuration structure\r\n */\r\nvoid ADC_DRV_ConfigChan(const uint32_t instance,\r\n                        const uint8_t chanIndex,\r\n                        const adc_chan_config_t * const config);\r\n\r\n/*!\r\n * @brief Gets the current control channel configuration for the selected\r\n * channel index\r\n *\r\n * This function returns the configuration for a control channel\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] chanIndex the control channel index\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_GetChanConfig(const uint32_t instance,\r\n                           const uint8_t chanIndex,\r\n                           adc_chan_config_t * const config);\r\n\r\n/*!\r\n * @brief This function sets the software pretrigger - affects only first 4 control channels.\r\n *\r\n * @param[in] instance  instance number\r\n * @param[in] swPretrigger  the swPretrigger to be enabled\r\n */\r\nvoid ADC_DRV_SetSwPretrigger(const uint32_t instance,\r\n                             const adc_sw_pretrigger_t swPretrigger);\r\n\r\n/*! @}*/\r\n/*!\r\n * @name Converter\r\n * Converter specific methods. These are used to configure and use the A/D\r\n * Converter specific functionality, including:\r\n *  - clock input and divider\r\n *  - sample time in A/D clocks\r\n *  - resolution\r\n *  - trigger source\r\n *  - voltage reference\r\n *  - enable DMA\r\n *  - enable continuous conversion on one channel\r\n *\r\n * To start a conversion, a control channel (see \\ref chan_config \"Channel Configuration\")\r\n * and a trigger source must be configured. Once a conversion is started, the user\r\n * application can wait for it to be finished by calling the ADC_DRV_WaitConvDone() function.\r\n *\r\n * Only the first control channel can be triggered by software. To start a\r\n * conversion in this case, an input channel must be written in the channel\r\n * selection register using the ADC_DRV_ConfigChan() method. Writing a value to\r\n * the control channel while a conversion is being performed on that channel\r\n * will start a new conversion.\r\n *\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Resets the converter (sets all configurations to reset values)\r\n *\r\n * This function resets all the internal ADC registers to\r\n * reset values.\r\n *\r\n * @param[in] instance instance number\r\n */\r\nvoid ADC_DRV_Reset(const uint32_t instance);\r\n\r\n/*!\r\n * @brief Waits for a conversion/calibration to finish\r\n *\r\n * This functions waits for a conversion to complete by\r\n * continuously polling the Conversion Active Flag.\r\n *\r\n * @param[in] instance instance number\r\n */\r\nvoid ADC_DRV_WaitConvDone(const uint32_t instance);\r\n\r\n/*!\r\n * @brief Gets the control channel Conversion Complete Flag state\r\n *\r\n * This function returns the state of the Conversion Complete\r\n * flag for a control channel. This flag is set when a conversion\r\n * is complete or the condition generated by the Hardware\r\n * Compare feature is evaluated to true.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] chanIndex the adc control channel index\r\n * @return the Conversion Complete Flag state\r\n */\r\nbool ADC_DRV_GetConvCompleteFlag(const uint32_t instance,\r\n                                 const uint8_t chanIndex);\r\n/*! @}*/\r\n\r\n/*!\r\n * @anchor chan_config\r\n * @name Channel configuration\r\n * Control register specific functions. These functions control configurations\r\n * for each control channel (input channel selection and interrupt enable).\r\n *\r\n * When software triggering is enabled, calling the ADC_DRV_ConfigChan() method\r\n * for control channel 0 starts a new conversion.\r\n *\r\n * After a conversion is finished, the result can be retrieved using the\r\n * ADC_DRV_GetChanResult() method.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Gets the last result for the selected control channel\r\n *\r\n * This function returns the conversion result from a\r\n * control channel.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] chanIndex the converter control channel index\r\n * @param[out] result the result raw value\r\n */\r\nvoid ADC_DRV_GetChanResult(const uint32_t instance,\r\n                           const uint8_t chanIndex,\r\n                           uint16_t * const result);\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Automatic Calibration\r\n * These methods control the Calibration feature of the ADC.\r\n *\r\n * The ADC_DRV_AutoCalibration() method can be called to execute a calibration\r\n * sequence, or a calibration can be retrieved with the ADC_DRV_GetUserCalibration()\r\n * and saved to non-volatile storage, to avoid calibration on every power-on.\r\n * The calibration structure can be written with the ADC_DRV_ConfigUserCalibration()\r\n * method.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Executes an Auto-Calibration\r\n *\r\n * This functions executes an Auto-Calibration sequence. It\r\n * is recommended to run this sequence before using the ADC\r\n * converter.\r\n *\r\n * @param[in] instance instance number\r\n */\r\nvoid ADC_DRV_AutoCalibration(const uint32_t instance);\r\n\r\n/*!\r\n * @brief Initializes the User Calibration configuration structure\r\n *\r\n * This function initializes the User Calibration configuration\r\n * structure to default values (Reference Manual resets). This function should\r\n * be called on a structure before using it to configure the User Calibration\r\n * feature (ADC_DRV_ConfigUserCalibration), otherwise all members must be\r\n * written by the caller. This function insures that all members are written\r\n * with safe values, so the user can modify only the desired members.\r\n * this function will check and reset clock divide based the adc frequency.\r\n * an error will be displayed if frequency is greater than required clock for calibration.\r\n *\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_InitUserCalibrationStruct(adc_calibration_t * const config);\r\n\r\n/*!\r\n * @brief Configures the User Calibration feature with the given configuration\r\n * structure\r\n *\r\n * This function sets the configuration for the user calibration\r\n * registers.\r\n *\r\n * @param[in] instance instance number\r\n * @param[in] config the configuration structure\r\n */\r\nvoid ADC_DRV_ConfigUserCalibration(const uint32_t instance,\r\n                                   const adc_calibration_t * const config);\r\n\r\n/*!\r\n * @brief Gets the current User Calibration configuration\r\n *\r\n * This function returns the current user calibration\r\n * register values.\r\n *\r\n * @param[in] instance instance number\r\n * @param[out] config the configuration structure\r\n */\r\nvoid ADC_DRV_GetUserCalibration(const uint32_t instance,\r\n                                adc_calibration_t * const config);\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Interrupts\r\n * This method returns the interrupt number for an ADC instance, which can be used\r\n * to configure the interrupt, like in Interrupt Manager.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Returns the interrupt number for the ADC instance.\r\n *\r\n * This function returns the interrupt number for the specified ADC instance.\r\n *\r\n * @param[in] instance instance number of the ADC\r\n * @return irq_number: the interrupt number (index) of the ADC instance, used to configure the interrupt\r\n */\r\nIRQn_Type ADC_DRV_GetInterruptNumber(const uint32_t instance);\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Latched triggers processing\r\n * These functions provide basic operations for using the trigger latch mechanism.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Clear latched triggers under processing\r\n *\r\n * This function clears all trigger latched flags of the ADC instance.\r\n * This function must be called after the hardware trigger source for the ADC has been deactivated.\r\n *\r\n * @param[in] instance instance number of the ADC\r\n * @param[in] clearMode The clearing method for the latched triggers\r\n *        - ADC_LATCH_CLEAR_WAIT : Wait for all latched triggers to be processed.\r\n *        - ADC_LATCH_CLEAR_FORCE : Clear latched triggers and wait for trigger being process to finish.\r\n */\r\nvoid ADC_DRV_ClearLatchedTriggers(const uint32_t instance,\r\n                                  const adc_latch_clear_t clearMode);\r\n\r\n/*!\r\n * @brief Clear all latch trigger error\r\n *\r\n * This function clears all trigger error flags of the ADC instance.\r\n *\r\n * @param[in] instance instance number of the ADC\r\n */\r\nvoid ADC_DRV_ClearTriggerErrors(const uint32_t instance);\r\n\r\n/*!\r\n * @brief Get the trigger error flags bits of the ADC instance\r\n *\r\n * This function returns the trigger error flags bits of the ADC instance.\r\n *\r\n * @param[in] instance instance number of the ADC\r\n * @return trigErrorFlags The Trigger Error Flags bit-mask\r\n */\r\nuint32_t ADC_DRV_GetTriggerErrorFlags(const uint32_t instance);\r\n\r\n/*! @}*/\r\n\r\n#if defined (__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* ADC_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"adc_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef ADC_HW_ACCESS_H\r\n#define ADC_HW_ACCESS_H\r\n\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include \"device_registers.h\"\r\n#include \"adc_driver.h\"\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5,\r\n * Impermissible cast; cannot cast from 'essentially unsigned' to 'essentially enum<i>'.\r\n * All possible values are covered by the enumeration, direct casting is used to optimize code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.3,\r\n * Expression assigned to a narrower or different essential type.\r\n * All possible values are covered by the enumeration, direct casting is used to optimize code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and integer type\r\n * The base addresses are provided as integers so they need to be cast to pointers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer\r\n * The base addresses are provided as integers so they need to be cast to pointers.\r\n */\r\n\r\n/*! @file adc_hw_access.h*/\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined (__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name Converter\r\n * General ADC functions.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Gets the Conversion Active Flag\r\n *\r\n * This function checks whether a conversion is currently\r\n * taking place on the ADC module.\r\n *\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return Conversion Active Flag state\r\n */\r\nstatic inline bool ADC_GetConvActiveFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Gets the current ADC clock divider configuration.\r\n *\r\n * This function returns the configured clock divider\r\n * bitfield value for the ADC instance.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the clock divider value. Possible values:\r\n *        - ADC_CLK_DIVIDE_1 : Divider set to 1.\r\n *        - ADC_CLK_DIVIDE_2 : Divider set to 2.\r\n *        - ADC_CLK_DIVIDE_4 : Divider set to 4.\r\n *        - ADC_CLK_DIVIDE_8 : Divider set to 8.\r\n */\r\nstatic inline adc_clk_divide_t ADC_GetClockDivide(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->CFG1;\r\n    tmp = (tmp & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT;\r\n\r\n    /* Enum defines all possible values, so casting is safe */\r\n    return (adc_clk_divide_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the ADC clock divider configuration.\r\n *\r\n * This functions configures the ADC instance clock divider.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] clockDivide clk divider\r\n *        - ADC_CLK_DIVIDE_1 : Divider set to 1.\r\n *        - ADC_CLK_DIVIDE_2 : Divider set to 2.\r\n *        - ADC_CLK_DIVIDE_4 : Divider set to 4.\r\n *        - ADC_CLK_DIVIDE_8 : Divider set to 8.\r\n */\r\nstatic inline void ADC_SetClockDivide(ADC_Type * const baseAddr,\r\n                                      const adc_clk_divide_t clockDivide)\r\n{\r\n    uint32_t tmp = baseAddr->CFG1;\r\n    tmp &= ~(ADC_CFG1_ADIV_MASK);\r\n    tmp |= ADC_CFG1_ADIV(clockDivide);\r\n    baseAddr->CFG1 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Sample time in AD clock cycles\r\n *\r\n * This function gets the sample time (in AD clocks)\r\n * configured for the ADC. Selection of 2 to 256 ADCK is\r\n * possible. The value returned by this function is the\r\n * sample time minus 1. A sample time of 1 is not supported.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Sample Time in AD Clocks\r\n */\r\nstatic inline uint8_t ADC_GetSampleTime(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->CFG2;\r\n    tmp = (tmp & ADC_CFG2_SMPLTS_MASK) >> ADC_CFG2_SMPLTS_SHIFT;\r\n\r\n    return (uint8_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the Sample time in AD clock cycles\r\n *\r\n * This function configures the sample time for the ADC (in\r\n * ADCK clocks). The actual sample time will be the value\r\n * provided plus 1.  Selection of 2 to 256 ADCK is possible.\r\n * A real sample time of 1 is not supported (a parameter value of 0\r\n * will be automatically be changed to 1).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] sampletime Sample time in AD Clocks\r\n */\r\nstatic inline void ADC_SetSampleTime(ADC_Type * const baseAddr,\r\n                                     uint8_t sampletime)\r\n{\r\n    /* Clip sample time to minimum value */\r\n    uint8_t rsampletime = (uint8_t)((sampletime > 0U) ? sampletime : 1U);\r\n    uint32_t tmp = baseAddr->CFG2;\r\n    tmp &= ~(ADC_CFG2_SMPLTS_MASK);\r\n    tmp |= ADC_CFG2_SMPLTS(rsampletime);\r\n    baseAddr->CFG2 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Resolution Mode configuration\r\n *\r\n * This function returns the configured resolution mode for\r\n * the ADC.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the ADC resolution mode. Possible values:\r\n *        - ADC_RESOLUTION_8BIT : 8-bit resolution mode.\r\n *        - ADC_RESOLUTION_10BIT : 10-bit resolution mode.\r\n *        - ADC_RESOLUTION_12BIT : 12-bit resolution mode.\r\n */\r\nstatic inline adc_resolution_t ADC_GetResolution(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->CFG1;\r\n    tmp = (tmp & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT;\r\n    adc_resolution_t retValue;\r\n    /* Enum does not define all possible values, do a swith-case */\r\n    switch (tmp)\r\n    {\r\n        case 0x00U:\r\n            retValue = ADC_RESOLUTION_8BIT;\r\n            break;\r\n        case 0x01U:\r\n            retValue = ADC_RESOLUTION_12BIT;\r\n            break;\r\n        case 0x02U:\r\n            retValue = ADC_RESOLUTION_10BIT;\r\n            break;\r\n        default:\r\n            retValue = ADC_RESOLUTION_8BIT;\r\n            break;\r\n    }\r\n\r\n    return retValue;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Resolution Mode configuration\r\n *\r\n * This function configures the ADC resolution mode.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] resolution the adc resolution mode\r\n *        - ADC_RESOLUTION_8BIT : 8-bit resolution mode.\r\n *        - ADC_RESOLUTION_10BIT : 10-bit resolution mode.\r\n *        - ADC_RESOLUTION_12BIT : 12-bit resolution mode.\r\n */\r\nstatic inline void ADC_SetResolution(ADC_Type * const baseAddr,\r\n                                     const adc_resolution_t resolution)\r\n{\r\n    uint32_t tmp = baseAddr->CFG1;\r\n    tmp &= ~(ADC_CFG1_MODE_MASK);\r\n    tmp |= ADC_CFG1_MODE(resolution);\r\n    baseAddr->CFG1 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the AD Clock Input configuration\r\n *\r\n * This function returns the configured clock input source\r\n * for the ADC.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the input clock source. Possible values:\r\n *        - ADC_CLK_ALT_1 : ADC Input clock source alternative 1.\r\n *        - ADC_CLK_ALT_2 : ADC Input clock source alternative 2.\r\n *        - ADC_CLK_ALT_3 : ADC Input clock source alternative 3.\r\n *        - ADC_CLK_ALT_4 : ADC Input clock source alternative 4.\r\n */\r\nstatic inline adc_input_clock_t ADC_GetInputClock(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->CFG1;\r\n    tmp = (tmp & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT;\r\n\r\n    /* Enum defines all possible values, so casting is safe */\r\n    return (adc_input_clock_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the AD Clock Input configuration\r\n *\r\n * This function configures the clock input source for the\r\n * ADC.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] inputClock the new input clock source\r\n *        - ADC_CLK_ALT_1 : ADC Input clock source alternative 1.\r\n *        - ADC_CLK_ALT_2 : ADC Input clock source alternative 2.\r\n *        - ADC_CLK_ALT_3 : ADC Input clock source alternative 3.\r\n *        - ADC_CLK_ALT_4 : ADC Input clock source alternative 4.\r\n */\r\nstatic inline void ADC_SetInputClock(ADC_Type * const baseAddr,\r\n                                     const adc_input_clock_t inputClock)\r\n{\r\n    uint32_t tmp = baseAddr->CFG1;\r\n    tmp &= ~(ADC_CFG1_ADICLK_MASK);\r\n    tmp |= ADC_CFG1_ADICLK(inputClock);\r\n    baseAddr->CFG1 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the ADC Trigger Mode\r\n *\r\n * This function returns the configured triggering mode\r\n * for the ADC. In Software Triggering Mode, the user can\r\n * start conversions by setting an input channel in the\r\n * ADC measurement channel A (index 0). When in Hardware\r\n * trigger mode, a conversion is started by another peripheral (\r\n * like PDB or TRGMUX).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the current trigger mode. Possible values:\r\n *        - ADC_TRIGGER_SOFTWARE : Software triggering.\r\n *        - ADC_TRIGGER_HARDWARE : Hardware triggering.\r\n */\r\nstatic inline adc_trigger_t ADC_GetTriggerMode(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT;\r\n\r\n    /* Enum defines all possible values, so casting is safe */\r\n    return (adc_trigger_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the ADC Trigger Mode\r\n *\r\n * This function configures the ADC triggering mode. In\r\n * Software Triggering Mode, the user can start conversions\r\n * by setting an input channel in the ADC measurement channel\r\n * A (index 0). When in Hardware trigger mode, a conversion\r\n * is started by another peripheral (like PDB or TRGMUX).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] trigger the desired trigger mode\r\n *        - ADC_TRIGGER_SOFTWARE : Software triggering.\r\n *        - ADC_TRIGGER_HARDWARE : Hardware triggering.\r\n */\r\nstatic inline void ADC_SetTriggerMode(ADC_Type * const baseAddr,\r\n                                      const adc_trigger_t trigger)\r\n{\r\n    uint32_t tmp = baseAddr->SC2;\r\n    tmp &= ~(ADC_SC2_ADTRG_MASK);\r\n    tmp |= ADC_SC2_ADTRG(trigger);\r\n    baseAddr->SC2 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the pretrigger source configured for an ADC instance\r\n *\r\n * This function gets the pretrigger source selected from\r\n * ADC Trigger Latching and Arbitration Unit,\r\n * affecting control channels 0-3.\r\n *\r\n * @param[in] instance  the ADC instance\r\n * @return  pretrigger source selected. Possible values:\r\n *           - ADC_PRETRIGGER_SEL_PDB     - PDB pretrigger\r\n *           - ADC_PRETRIGGER_SEL_TRGMUX  - TRGMUX pretrigger\r\n *           - ADC_PRETRIGGER_SEL_SW      - Software pretrigger\r\n */\r\nstatic inline adc_pretrigger_sel_t ADC_GetPretriggerSelect(const uint32_t instance)\r\n{\r\n    const SIM_Type * const sim_base          = SIM;\r\n    uint32_t currentVal                      = 0U;\r\n    adc_pretrigger_sel_t returnVal           = ADC_PRETRIGGER_SEL_PDB;\r\n    uint32_t mask[ADC_INSTANCE_COUNT] = {0U};\r\n    uint32_t shift[ADC_INSTANCE_COUNT] = {0U};\r\n#if (ADC_INSTANCE_COUNT == 1u)\r\n    mask[0]  = SIM_ADCOPT_ADC0PRETRGSEL_MASK;\r\n    shift[0] = SIM_ADCOPT_ADC0PRETRGSEL_SHIFT;\r\n#elif (ADC_INSTANCE_COUNT == 2u)\r\n    mask[0]  = SIM_ADCOPT_ADC0PRETRGSEL_MASK;\r\n    mask[1]  = SIM_ADCOPT_ADC1PRETRGSEL_MASK;\r\n    shift[0] = SIM_ADCOPT_ADC0PRETRGSEL_SHIFT;\r\n    shift[1] = SIM_ADCOPT_ADC1PRETRGSEL_SHIFT;\r\n#else\r\n#error \"Maximum supported value for ADC_INSTANCE_COUNT is 2.\"\r\n#endif\r\n    currentVal = (sim_base->ADCOPT & mask[instance]) >> shift[instance];\r\n    switch(currentVal)\r\n    {\r\n        case ADC_PRETRIGGER_SEL_PDB:\r\n            returnVal = ADC_PRETRIGGER_SEL_PDB;     break;\r\n        case ADC_PRETRIGGER_SEL_TRGMUX:\r\n            returnVal = ADC_PRETRIGGER_SEL_TRGMUX;  break;\r\n        case ADC_PRETRIGGER_SEL_SW:\r\n            returnVal = ADC_PRETRIGGER_SEL_SW;      break;\r\n        default:\r\n            DEV_ASSERT(false);                      break;\r\n    }\r\n\r\n    return returnVal;\r\n}\r\n\r\n/*!\r\n * @brief Sets the pretrigger select for an ADC instance\r\n *\r\n * This function sets the pretrigger source selected from\r\n * ADC Trigger Latching and Arbitration Unit,\r\n * affecting control channels 0-3.\r\n *\r\n * @param[in] instance  the ADC instance\r\n * @param[in] pretriggerSel  the pretrigger source to be selected\r\n *           - ADC_PRETRIGGER_SEL_PDB     - PDB pretrigger\r\n *           - ADC_PRETRIGGER_SEL_TRGMUX  - TRGMUX pretrigger\r\n *           - ADC_PRETRIGGER_SEL_SW      - Software pretrigger\r\n */\r\nstatic inline void ADC_SetPretriggerSelect(const uint32_t instance,\r\n                                           const adc_pretrigger_sel_t pretriggerSel)\r\n{\r\n    SIM_Type * const simBase = SIM;\r\n    uint32_t mask[ADC_INSTANCE_COUNT] = {0U};\r\n#if (ADC_INSTANCE_COUNT == 1u)\r\n    mask[0] = SIM_ADCOPT_ADC0PRETRGSEL_MASK;\r\n#elif (ADC_INSTANCE_COUNT == 2u)\r\n    mask[0] = SIM_ADCOPT_ADC0PRETRGSEL_MASK;\r\n    mask[1] = SIM_ADCOPT_ADC1PRETRGSEL_MASK;\r\n#else\r\n#error \"Maximum supported value for ADC_INSTANCE_COUNT is 2.\"\r\n#endif\r\n    uint32_t intermVal = 0U;\r\n\r\n    intermVal = simBase->ADCOPT & (~ mask[instance]);\r\n\r\n    switch(instance)\r\n    {\r\n    case 0:\r\n        intermVal |= SIM_ADCOPT_ADC0PRETRGSEL(pretriggerSel);\r\n        break;\r\n    case 1:\r\n        intermVal |= SIM_ADCOPT_ADC1PRETRGSEL(pretriggerSel);\r\n        break;\r\n    default:\r\n        DEV_ASSERT(false);\r\n        break;\r\n    }\r\n\r\n    simBase->ADCOPT = intermVal;\r\n}\r\n\r\n/*!\r\n * @brief Gets the trigger source configured for an ADC instance\r\n *\r\n * This function gets the trigger source selected from\r\n * ADC Trigger Latching and Arbitration Unit.\r\n *\r\n * @param[in] instance  the ADC instance\r\n * @param[in] triggerSel  the trigger source to be selected\r\n *         - ADC_TRIGGER_SEL_PDB     - PDB trigger selected\r\n *         - ADC_TRIGGER_SEL_TRGMUX  - TRGMUX trigger\r\n */\r\nstatic inline adc_trigger_sel_t ADC_GetTriggerSelect(const uint32_t instance)\r\n{\r\n    const SIM_Type * const sim_base          = SIM;\r\n    uint32_t currentVal                      = 0U;\r\n    adc_trigger_sel_t returnVal              = ADC_TRIGGER_SEL_PDB;\r\n    uint32_t mask[ADC_INSTANCE_COUNT] = {0U};\r\n    uint32_t shift[ADC_INSTANCE_COUNT] = {0U};\r\n#if (ADC_INSTANCE_COUNT == 1u)\r\n    mask[0]  = SIM_ADCOPT_ADC0TRGSEL_MASK;\r\n    shift[0] = SIM_ADCOPT_ADC0TRGSEL_SHIFT;\r\n#elif (ADC_INSTANCE_COUNT == 2u)\r\n    mask[0]  = SIM_ADCOPT_ADC0TRGSEL_MASK;\r\n    mask[1]  = SIM_ADCOPT_ADC1TRGSEL_MASK;\r\n    shift[0] = SIM_ADCOPT_ADC0TRGSEL_SHIFT;\r\n    shift[1] = SIM_ADCOPT_ADC1TRGSEL_SHIFT;\r\n#else\r\n#error \"Maximum supported value for ADC_INSTANCE_COUNT is 2.\"\r\n#endif\r\n    currentVal = (sim_base->ADCOPT & mask[instance]) >> shift[instance];\r\n    switch(currentVal)\r\n    {\r\n    case ADC_TRIGGER_SEL_PDB:\r\n        returnVal = ADC_TRIGGER_SEL_PDB;    break;\r\n    case ADC_TRIGGER_SEL_TRGMUX:\r\n        returnVal = ADC_TRIGGER_SEL_TRGMUX; break;\r\n    default:\r\n        DEV_ASSERT(false);                  break;\r\n    }\r\n\r\n    return returnVal;\r\n}\r\n\r\n/*!\r\n * @brief Sets the trigger select for an ADC instance\r\n *\r\n * This function sets the trigger source selected from\r\n * ADC Trigger Latching and Arbitration Unit.\r\n *\r\n * @param[in] instance  the ADC instance\r\n * @param[in] triggerSel  the trigger source to be selected\r\n *         - ADC_TRIGGER_SEL_PDB     - PDB trigger selected\r\n *         - ADC_TRIGGER_SEL_TRGMUX  - TRGMUX trigger\r\n */\r\nstatic inline void ADC_SetTriggerSelect(const uint32_t instance,\r\n                                        const adc_trigger_sel_t triggerSel)\r\n{\r\n    SIM_Type * const simBase = SIM;\r\n    uint32_t mask[ADC_INSTANCE_COUNT] = {0U};\r\n#if (ADC_INSTANCE_COUNT == 1u)\r\n    mask[0] = SIM_ADCOPT_ADC0TRGSEL_MASK;\r\n#elif (ADC_INSTANCE_COUNT == 2u)\r\n    mask[0] = SIM_ADCOPT_ADC0TRGSEL_MASK;\r\n    mask[1] = SIM_ADCOPT_ADC1TRGSEL_MASK;\r\n#else\r\n#error \"Maximum supported value for ADC_INSTANCE_COUNT is 2.\"\r\n#endif\r\n    uint32_t intermVal = 0U;\r\n\r\n    intermVal = simBase->ADCOPT & (~ mask[instance]);\r\n\r\n    switch(instance)\r\n    {\r\n    case 0:\r\n        intermVal |= SIM_ADCOPT_ADC0TRGSEL(triggerSel);\r\n        break;\r\n    case 1:\r\n        intermVal |= SIM_ADCOPT_ADC1TRGSEL(triggerSel);\r\n        break;\r\n    default:\r\n        DEV_ASSERT(false);\r\n        break;\r\n    }\r\n\r\n    simBase->ADCOPT = intermVal;\r\n}\r\n\r\n/*!\r\n * @brief Gets the DMA Enable Flag state\r\n *\r\n * This function returns the state of the DMA Enable flag.\r\n * DMA can be used to transfer completed conversion values\r\n * from the result registers to RAM without CPU intervention.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the DMA Enable Flag state\r\n */\r\nstatic inline bool ADC_GetDMAEnableFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the DMA Enable Flag state\r\n *\r\n * This function configures the DMA Enable Flag. DMA can be\r\n * used to transfer completed conversion values from the\r\n * result registers to RAM without CPU intervention.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new DMA Enable Flag state\r\n */\r\nstatic inline void ADC_SetDMAEnableFlag(ADC_Type * const baseAddr,\r\n                                        const bool state)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp &= (uint32_t)(~(ADC_SC2_DMAEN_MASK));\r\n    tmp |= ADC_SC2_DMAEN(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC2 = (uint32_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the ADC Reference Voltage selection\r\n *\r\n * This function returns the configured reference voltage\r\n * selection for the ADC. Reference voltage can be selected\r\n * between the pairs (VrefH, VrefL) and (ValtH, ValtL).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the voltage reference input pair. Possible values:\r\n *        - ADC_VOLTAGEREF_VREF : VrefL and VrefH used as voltage reference.\r\n *        - ADC_VOLTAGEREF_VALT : ValtL and ValtH used as voltage reference.\r\n */\r\nstatic inline adc_voltage_reference_t ADC_GetVoltageReference(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT;\r\n\r\n    /* Enum defines all possible values, so casting is safe */\r\n    return (adc_voltage_reference_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the ADC Reference Voltage selection\r\n *\r\n * This function configures the ADC Reference Voltage. Reference\r\n * voltage can be selected between the pairs (VrefH, VrefL)\r\n * and (ValtH, ValtL).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] voltageRef the new voltage reference input\r\n *        - ADC_VOLTAGEREF_VREF : VrefL and VrefH used as voltage reference.\r\n *        - ADC_VOLTAGEREF_VALT : ValtL and ValtH used as voltage reference.\r\n */\r\nstatic inline void ADC_SetVoltageReference(ADC_Type * const baseAddr,\r\n                                           const adc_voltage_reference_t voltageRef)\r\n{\r\n    uint32_t tmp = baseAddr->SC2;\r\n    tmp &= ~(ADC_SC2_REFSEL_MASK);\r\n    tmp |= ADC_SC2_REFSEL(voltageRef);\r\n    baseAddr->SC2 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Continuous Conversion Flag state\r\n *\r\n * This functions returns the state of the Continuous Conversion\r\n * Flag. This feature can be used to continuously sample a\r\n * single channel. When this is active, the channel cannot be\r\n * changed (by software or hardware trigger) until this feature\r\n * is turned off.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Continuous Conversion Flag state\r\n */\r\nstatic inline bool ADC_GetContinuousConvFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC3;\r\n    tmp = (tmp & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Continuous Conversion Flag state\r\n *\r\n * This function configures the Continuous Conversion. This\r\n * feature can be used to continuously sample a single channel.\r\n * When this is active, the channel cannot be changed (by\r\n * software or hardware trigger) until this feature is turned\r\n * off.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Continuous Conversion Flag state\r\n */\r\nstatic inline void ADC_SetContinuousConvFlag(ADC_Type * const baseAddr,\r\n                                             const bool state)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC3;\r\n    /* Clear the affected bitfield and write '0' to the w1c bits to avoid side-effects */\r\n    tmp &= ~(ADC_SC3_ADCO_MASK);\r\n    tmp |= ADC_SC3_ADCO(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC3 = (uint32_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Supply Monitor Enable Flag state\r\n *\r\n * This function configures the Supply Monitor Enable Flag.\r\n * Supply monitoring is available only for ADC 0, and the actual supply to be\r\n * monitored can be selected using ADC_INPUTCHAN_SUPPLY_ enum entries.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Supply Monitor Enable Flag state\r\n */\r\nstatic inline void ADC_SetSupplyMonitoringEnableFlag(SIM_Type * const baseAddr,\r\n                                                  const bool state)\r\n{\r\n    if(state == true)\r\n    {\r\n        baseAddr->CHIPCTL |= SIM_CHIPCTL_ADC_SUPPLYEN_MASK;\r\n    }\r\n    else\r\n    {\r\n        baseAddr->CHIPCTL &= ~SIM_CHIPCTL_ADC_SUPPLYEN_MASK;\r\n    }\r\n}\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Hardware Compare.\r\n * Functions to configure the Hardware Compare feature.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Gets the Hardware Compare Enable Flag state\r\n *\r\n * This function returns the state of the Hardware Compare\r\n * Enable Flag. Hardware Compare can be used to check if the\r\n * ADC result is within or outside of a predefined range.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Hardware Compare Enable Flag state\r\n */\r\nstatic inline bool ADC_GetHwCompareEnableFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Hardware Compare Enable Flag state\r\n *\r\n * This functions configures the Hardware Compare Enable Flag.\r\n * Hardware Compare can be used to check if the ADC result\r\n * is within or outside of a predefined range.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Hardware Compare Enable Flag state\r\n */\r\nstatic inline void ADC_SetHwCompareEnableFlag(ADC_Type * const baseAddr,\r\n                                              const bool state)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp &= (uint32_t)(~(ADC_SC2_ACFE_MASK));\r\n    tmp |= ADC_SC2_ACFE(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC2 = (uint32_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Hardware Compare Greater Than Enable Flag state\r\n *\r\n * This function returns the Hardware Compare Greater Than\r\n * Enable Flag. Using this feature, the ADC can be configured\r\n * to check if the measured value is within or outside of a\r\n * predefined range.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Hardware Compare Greater Than Enable Flag state\r\n */\r\nstatic inline bool ADC_GetHwCompareGtEnableFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Hardware Compare Greater Than Enable Flag state\r\n *\r\n * This function configures the Hardware Compare Greater Than\r\n * Enable Flag. Using this feature, the ADC can be configured\r\n * to check if the measured value is within or outside of a\r\n * predefined range.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Hardware Compare Greater Than Enable Flag state\r\n */\r\nstatic inline void ADC_SetHwCompareGtEnableFlag(ADC_Type * const baseAddr,\r\n                                                const bool state)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp &= (uint32_t)(~(ADC_SC2_ACFGT_MASK));\r\n    tmp |= ADC_SC2_ACFGT(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC2 = (uint32_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Hardware Compare Range Enable state\r\n *\r\n * This function returns the state of the Hardware Compare\r\n * Range Enable Flag. This feature allows configuration\r\n * of a range with two non-zero values or with a non-zero\r\n * and zero value.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Hardware Compare Range Enable Flag state\r\n */\r\nstatic inline bool ADC_GetHwCompareRangeEnableFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Hardware Compare Range Enable state\r\n *\r\n * This function configures the Hardware Compare Range\r\n * Enable Flag. This feature allows configuration\r\n * of a range with two non-zero values or with a non-zero\r\n * and zero value.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Hardware Compare Range Enable Flag state\r\n */\r\nstatic inline void ADC_SetHwCompareRangeEnableFlag(ADC_Type * const baseAddr,\r\n                                                   const bool state)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC2;\r\n    tmp &= (uint32_t)(~(ADC_SC2_ACREN_MASK));\r\n    tmp |= ADC_SC2_ACREN(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC2 = (uint32_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Compare Register 1 value\r\n *\r\n * This function returns the value written in the Hardware\r\n * Compare Register 1. This value defines the upper or lower\r\n * limit for the Hardware Compare Range. This value is always\r\n * 12-bit resolution value (for lower resolution modes, internal\r\n * bit shifting will take place).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Compare Register 1 value\r\n */\r\nstatic inline uint16_t ADC_GetHwCompareComp1Value(const ADC_Type * const baseAddr)\r\n{\r\n    return (uint16_t)baseAddr->CV[0U];\r\n}\r\n\r\n/*!\r\n * @brief Sets the Compare Register 1 value\r\n *\r\n * This function writes a 12-bit value in the Hardware\r\n * Compare Register 1. This value defines the upper or lower\r\n * limit for the Hardware Compare Range. This value is always\r\n * 12-bit resolution (for lower resolution modes, internal\r\n * bit shifting will take place).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] value the new Compare Register 1 value\r\n */\r\nstatic inline void ADC_SetHwCompareComp1Value(ADC_Type * const baseAddr,\r\n                                              const uint16_t value)\r\n{\r\n    baseAddr->CV[0U] = ADC_CV_CV(value);\r\n}\r\n\r\n/*!\r\n * @brief Gets the Compare Register 2 value\r\n *\r\n * This function returns the value written in the Hardware\r\n * Compare Register 2. This value defines the upper or lower\r\n * limit for the Hardware Compare Range. This value is always\r\n * 12-bit resolution (for lower resolution modes, internal\r\n * bit shifting will take place).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Compare Register 2 value\r\n */\r\nstatic inline uint16_t ADC_GetHwCompareComp2Value(const ADC_Type * const baseAddr)\r\n{\r\n    return (uint16_t)baseAddr->CV[1U];\r\n}\r\n\r\n/*!\r\n * @brief Sets the Compare Register 2 value\r\n *\r\n * This function writes a 12-bit value in the Hardware\r\n * Compare Register 2. This value defines the upper or lower\r\n * limit for the Hardware Compare Range. This value is always\r\n * 12-bit resolution value (for lower resolution modes, internal\r\n * bit shifting will take place).\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] value the new Compare Register 2 value\r\n */\r\nstatic inline void ADC_SetHwCompareComp2Value(ADC_Type * const baseAddr,\r\n                                              const uint16_t value)\r\n{\r\n    baseAddr->CV[1U] = ADC_CV_CV(value);\r\n}\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Hardware Average.\r\n * Functions to configure the Hardware Averaging feature.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Gets the Hardware Average Enable Flag state\r\n *\r\n * This function returns the state of the Hardware Average\r\n * Enable Flag. Hardware averaging can be used to obtain an\r\n * average value over multiple consecutive conversions on\r\n * the same channel.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Hardware Average Enable Flag state\r\n */\r\nstatic inline bool ADC_GetHwAverageEnableFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC3;\r\n    tmp = (tmp & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Hardware Average Enable Flag state\r\n *\r\n * This function configures the Hardware Average Enable Flag.\r\n * Hardware averaging can be used to obtain an average value\r\n * over multiple consecutive conversions on the same channel.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Hardware Average Enable Flag state\r\n */\r\nstatic inline void ADC_SetHwAverageEnableFlag(ADC_Type * const baseAddr,\r\n                                              const bool state)\r\n{\r\n    uint32_t tmp = baseAddr->SC3;\r\n    /* Clear the affected bitfield */\r\n    tmp &= ~(ADC_SC3_AVGE_MASK);\r\n    tmp |= ADC_SC3_AVGE(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC3 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Hardware Average Mode\r\n *\r\n * This function returns the configured Hardware Average Mode.\r\n * The mode selects the number of samples to average: 4, 8, 16\r\n * or 32.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Hardware Average Mode selection. Possible values:\r\n *        - ADC_AVERAGE_4 : Hardware average of 4 samples..\r\n *        - ADC_AVERAGE_8 : Hardware average of 8 samples.\r\n *        - ADC_AVERAGE_16 : Hardware average of 16 samples.\r\n *        - ADC_AVERAGE_32 : Hardware average of 32 samples.\r\n */\r\nstatic inline adc_average_t ADC_GetHwAverageMode(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->SC3;\r\n    tmp = (tmp & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT;\r\n\r\n    /* Enum defines all possible values, so casting is safe */\r\n    return (adc_average_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the Hardware Average Mode\r\n *\r\n * This function configures the Hardware Average Mode. The\r\n * mode selects the number of samples to average: 4, 8, 16\r\n * or 32.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] averageMode the new Hardware Average Mode.\r\n *        - ADC_AVERAGE_4 : Hardware average of 4 samples..\r\n *        - ADC_AVERAGE_8 : Hardware average of 8 samples.\r\n *        - ADC_AVERAGE_16 : Hardware average of 16 samples.\r\n *        - ADC_AVERAGE_32 : Hardware average of 32 samples.\r\n */\r\nstatic inline void ADC_SetHwAverageMode(ADC_Type * const baseAddr,\r\n                                        const adc_average_t averageMode)\r\n{\r\n    uint32_t tmp = baseAddr->SC3;\r\n    /* Clear the affected bitfield */\r\n    tmp &= ~(ADC_SC3_AVGS_MASK);\r\n    tmp |= ADC_SC3_AVGS(averageMode);\r\n    baseAddr->SC3 = tmp;\r\n}\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Automatic Calibration.\r\n * Functions configure and use the Automatic Calibration feature.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Gets the Calibration Active Flag state\r\n *\r\n * This function returns the state of the Calibration Active\r\n * Flag. This flag is set if an Auto-Calibration sequence is\r\n * taking place.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the Calibration Active Flag state\r\n */\r\nstatic inline bool ADC_GetCalibrationActiveFlag(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = (uint32_t)baseAddr->SC3;\r\n    tmp = (tmp & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT;\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Sets the Calibration Active Flag state\r\n *\r\n * This functions starts or aborts an Auto-Calibration\r\n * sequence. If this is set, it will remain set until the\r\n * sequence is finished.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] state the new Calibration Active Flag state\r\n */\r\nstatic inline void ADC_SetCalibrationActiveFlag(ADC_Type * const baseAddr,\r\n                                                const bool state)\r\n{\r\n    uint32_t tmp = baseAddr->SC3;\r\n    tmp &= ~(ADC_SC3_CAL_MASK);\r\n    tmp |= ADC_SC3_CAL(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC3 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the User Gain Register value\r\n *\r\n * This function returns the value in the User Gain Register.\r\n * The value in this register is the amplification applied\r\n * to the measured data before being written in the result\r\n * register.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the User Gain Register value\r\n */\r\nstatic inline uint16_t ADC_GetUserGainValue(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->UG;\r\n    tmp = (tmp & ADC_UG_UG_MASK) >> ADC_UG_UG_SHIFT;\r\n\r\n    return (uint16_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Sets the User Gain Register value\r\n *\r\n * This function configures the User Gain Register. The value\r\n * in this register is the amplification applied to the\r\n * measured data before being written in the result register.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] value the new User Gain Register value\r\n */\r\nstatic inline void ADC_SetUserGainValue(ADC_Type * const baseAddr,\r\n                                        const uint16_t value)\r\n{\r\n    uint16_t clp0 = (uint16_t)baseAddr->CLP0;\r\n    uint16_t clp1 = (uint16_t)baseAddr->CLP1;\r\n    uint16_t clp2 = (uint16_t)baseAddr->CLP2;\r\n    uint16_t clp3 = (uint16_t)baseAddr->CLP3;\r\n    uint16_t clps = (uint16_t)baseAddr->CLPS;\r\n    /* Add CLP0, CLP1, CLP2, CLP3 and CLPS */\r\n    uint16_t sum = (uint16_t)(value + clp0 + clp1 + clp2 + clp3 + clps);\r\n    /* If OR of bits [15:11] from the sum is 1 (set), write 0xFFFFU to Gain register */\r\n    uint16_t temp = (uint16_t)(sum & 0xF800U);\r\n    if (temp != 0x0000U)\r\n    {\r\n        temp = 0xFFFFU;\r\n    }\r\n\r\n    baseAddr->UG = (uint32_t)value;\r\n    baseAddr->G = (uint32_t)temp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the User Offset Register value\r\n *\r\n * This function returns the value in the User Offset Register.\r\n * The value in this register is subtracted from the measured\r\n * data before being written in the result register. This value\r\n * is 16-bit signed value. To preserve resolution, lower-order\r\n * bits will be ignored in low resolution-modes.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return the User Offset Register value\r\n */\r\nstatic inline uint16_t ADC_GetUserOffsetValue(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->USR_OFS;\r\n    tmp = (tmp & ADC_USR_OFS_USR_OFS_MASK) >> ADC_USR_OFS_USR_OFS_SHIFT;\r\n\r\n    return (uint16_t)tmp;\r\n}\r\n\r\n/*!\r\n * @brief Sets the User Offset Register value\r\n *\r\n * This function configures the User Offset Register. The value\r\n * in this register is subtracted from the measured data before\r\n * being written in the result register. This value is 16-bit\r\n * signed value. To preserve resolution, lower-order bits\r\n * will be ignored in low resolution-modes.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] value the new User Offset Register value\r\n */\r\nstatic inline void ADC_SetUserOffsetValue(ADC_Type * const baseAddr,\r\n                                          const uint16_t value)\r\n{\r\n    baseAddr->USR_OFS = ADC_USR_OFS_USR_OFS(value);\r\n}\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Converter channels.\r\n * Functions to configure and access each ADC converter channel.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Gets the Channel Interrupt Enable state\r\n *\r\n * This function returns the state of the Channel Interrupt\r\n * Enable Flag. If the flag is set, an interrupt is generated\r\n * when the a conversion is completed for the channel.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] chanIndex the adc measurement channel index\r\n * @return the Channel Interrupt Enable Flag state\r\n */\r\nstatic inline bool ADC_GetChanInterruptEnableFlag(const ADC_Type * const baseAddr,\r\n                                                  const uint8_t chanIndex)\r\n{\r\n\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n\r\n    uint32_t tmp = (uint32_t)baseAddr->aSC1[chanIndex];\r\n    tmp = (tmp & ADC_aSC1_AIEN_MASK) >> ADC_aSC1_AIEN_SHIFT;\r\n#else\r\n\r\n    uint32_t tmp = (uint32_t)baseAddr->SC1[chanIndex];\r\n    tmp = (tmp & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT;\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n    return (tmp != 0u) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Gets the configured input channel for the selected measurement channel\r\n *\r\n * This function returns the configured input channel for a\r\n * measurement channel.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] chanIndex the adc measurement channel index\r\n * @return the Input Channel selected for the Measurement Channel.\r\n */\r\nstatic inline adc_inputchannel_t ADC_GetInputChannel(const ADC_Type * const baseAddr,\r\n                                                     const uint8_t chanIndex)\r\n{\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n    uint32_t tmp = baseAddr->aSC1[chanIndex];\r\n    tmp = (tmp & ADC_aSC1_ADCH_MASK) >> ADC_aSC1_ADCH_SHIFT;\r\n#else\r\n    uint32_t tmp = baseAddr->SC1[chanIndex];\r\n    tmp = (tmp & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT;\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n    uint32_t supplyen = (uint32_t)SIM->CHIPCTL;\r\n    supplyen = (supplyen & SIM_CHIPCTL_ADC_SUPPLYEN_MASK) >> SIM_CHIPCTL_ADC_SUPPLYEN_SHIFT;\r\n    if((tmp == (uint32_t)ADC_INPUTCHAN_INT0) && (supplyen != 0UL))\r\n    {\r\n        tmp = (uint32_t)SIM->CHIPCTL;\r\n        tmp = (tmp & SIM_CHIPCTL_ADC_SUPPLY_MASK) >> SIM_CHIPCTL_ADC_SUPPLY_SHIFT;\r\n        tmp = tmp + (uint32_t)ADC_INPUTCHAN_SUPPLY_VDD;\r\n    }\r\n    /* Enum defines all possible values, so casting is safe */\r\n    return (adc_inputchannel_t)(tmp);\r\n}\r\n\r\n/*!\r\n * @brief Sets the input channel and Channel Interrupt Enable as configuration for the measurement channel.\r\n *\r\n * This function configures the input channel and state of the Interrupt Enable Flag for a measurement\r\n * channel. In software trigger mode, configuring channel\r\n * A (index 0) will start a new conversion immediately.\r\n * If the flag is set, an interrupt is generated when\r\n * the a conversion is completed for the channel.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @param[in] chanIndex the adc measurement channel index\r\n * @param[in] inputChan the Input Channel selected for the Measurement Channel\r\n * @param[in] state the new Channel Interrupt Enable Flag state\r\n */\r\nstatic inline void ADC_SetInputChannel(ADC_Type * const baseAddr,\r\n                                       const uint8_t chanIndex,\r\n                                       const adc_inputchannel_t inputChan,\r\n                                       const bool state)\r\n{\r\n    adc_inputchannel_t inputChanDemapped;\r\n\r\n    /* Internal supply monitor channels need special configuration */\r\n    if((inputChan >= ADC_INPUTCHAN_SUPPLY_VDD) && (inputChan <= ADC_INPUTCHAN_SUPPLY_VDD_LV))\r\n    {\r\n        const uint32_t supplyMonitorIdx = (uint32_t)inputChan - (uint32_t)ADC_INPUTCHAN_SUPPLY_VDD; /* De-map ADC_INPUTCHAN_SUPPLY_ into actual index.*/\r\n\r\n        SIM_Type * const simBase = SIM;\r\n        DEV_ASSERT((simBase ->CHIPCTL & SIM_CHIPCTL_ADC_SUPPLYEN_MASK) != 0UL);\r\n        simBase->CHIPCTL &= ~SIM_CHIPCTL_ADC_SUPPLY_MASK;\r\n        simBase->CHIPCTL |= SIM_CHIPCTL_ADC_SUPPLY(supplyMonitorIdx);\r\n\r\n        inputChanDemapped = ADC_INPUTCHAN_INT0; /* Supply monitor channels are measured on ADC internal input channel 0 */\r\n    }\r\n    else\r\n    {\r\n        inputChanDemapped = inputChan;\r\n    }\r\n\r\n#if FEATURE_ADC_HAS_EXTRA_NUM_REGS\r\n    uint32_t tmp = baseAddr->aSC1[chanIndex];\r\n    tmp &= ~(ADC_aSC1_ADCH_MASK);\r\n    tmp |= ADC_aSC1_ADCH(inputChanDemapped);\r\n    tmp &= ~(ADC_aSC1_AIEN_MASK);\r\n    tmp |= ADC_aSC1_AIEN(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->aSC1[chanIndex] = tmp;\r\n#else\r\n    uint32_t tmp = baseAddr->SC1[chanIndex];\r\n    tmp &= ~(ADC_SC1_ADCH_MASK);\r\n    tmp |= ADC_SC1_ADCH(inputChanDemapped);\r\n    tmp &= ~(ADC_SC1_AIEN_MASK);\r\n    tmp |= ADC_SC1_AIEN(state ? (uint32_t)1u : (uint32_t)0u);\r\n    baseAddr->SC1[chanIndex] = tmp;\r\n#endif /* FEATURE_ADC_HAS_EXTRA_NUM_REGS */\r\n\r\n}\r\n\r\n/*! @}*/\r\n\r\n/*!\r\n * @name Trigger latches.\r\n * Functions using the trigger latch mechanism.\r\n */\r\n/*! @{*/\r\n\r\n/*!\r\n * @brief Clear the latched triggers\r\n *\r\n * This function clears the latched triggers, except for the one under process.\r\n * Before calling this function, make sure the hardware trigger source of the ADC is disabled.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n */\r\nstatic inline void ADC_ClearLatchTriggers(ADC_Type * const baseAddr)\r\n{\r\n    baseAddr->CFG1 |= ADC_CFG1_CLRLTRG(0x01u);\r\n}\r\n\r\n/*!\r\n * @brief Get the trigger latch flags bits.\r\n *\r\n * This function returns the trigger latch flags.\r\n *\r\n * @param[in] baseAddr adc base pointer\r\n * @return trigger latch flags\r\n */\r\nstatic inline uint32_t ADC_GetTriggerLatchFlags(const ADC_Type * const baseAddr)\r\n{\r\n    uint32_t tmp = baseAddr->SC2;\r\n    tmp = (tmp & ADC_SC2_TRGSTLAT_MASK) >> ADC_SC2_TRGSTLAT_SHIFT;\r\n\r\n    return tmp;\r\n}\r\n\r\n/*! @}*/\r\n\r\n#if defined (__cplusplus)\r\n}\r\n#endif\r\n\r\n\r\n#endif /* ADC_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"callbacks.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright 2017-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef CALLBACKS_H\r\n#define CALLBACKS_H\r\n#include <stdint.h>\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, A project should not contain\r\n * unused type declarations.\r\n * The header defines callback types for all PAL modules.\r\n */\r\n\r\n #include <stdint.h>\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n /*!\r\n * @brief Define the enum of the events which can trigger I2C slave callback\r\n *\r\n * This enum should include the events for all platforms\r\n */\r\ntypedef enum\r\n{\r\n    I2C_SLAVE_EVENT_RX_FULL = 0x00U,\r\n    I2C_SLAVE_EVENT_TX_EMPTY = 0x01U,\r\n    I2C_SLAVE_EVENT_TX_REQ = 0x02U,\r\n    I2C_SLAVE_EVENT_RX_REQ = 0x03U,\r\n    I2C_SLAVE_EVENT_STOP = 0X04U,\r\n}i2c_slave_event_t;\r\n\r\n /*!\r\n * @brief Define the enum of the events which can trigger I2C master callback\r\n *\r\n * This enum should include the events for all platforms\r\n *\r\n */\r\ntypedef enum\r\n{\r\n    I2C_MASTER_EVENT_END_TRANSFER                      = 0x4U,\r\n}i2c_master_event_t;\r\n\r\n\r\n/* Callback for all peripherals which supports I2C features for slave mode */\r\ntypedef void (*i2c_slave_callback_t)(i2c_slave_event_t event, void *userData);\r\n\r\n/* Callback for all peripherals which supports I2C features for master mode */\r\ntypedef void (*i2c_master_callback_t)(i2c_master_event_t event, void *userData);\r\n\r\n/* Define the enum of the events which can trigger SPI callback\r\n * This enum should include the events for all platforms\r\n */\r\ntypedef enum\r\n{\r\n    SPI_EVENT_END_TRANSFER = 0\r\n} spi_event_t;\r\n\r\n/* Callback for all peripherals which supports SPI features */\r\ntypedef void (*spi_callback_t)(void *driverState, spi_event_t event, void *userData);\r\n\r\n/*!\r\n * @brief Define the enum of the events which can trigger UART callback\r\n *\r\n * This enum should include the events for all platforms\r\n *\r\n * Implements : uart_event_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    UART_EVENT_RX_FULL      = 0x00U,    /*!< Rx buffer is full */\r\n    UART_EVENT_TX_EMPTY     = 0x01U,    /*!< Tx buffer is empty */\r\n    UART_EVENT_END_TRANSFER = 0x02U,    /*!< The current transfer is ending */\r\n    UART_EVENT_ERROR        = 0x03U,    /*!< An error occured during transfer */\r\n} uart_event_t;\r\n\r\n/*!\r\n * @brief Callback for all peripherals which support UART features\r\n *\r\n * Implements : uart_callback_t_Class\r\n */\r\ntypedef void (*uart_callback_t)(void *driverState, uart_event_t event, void *userData);\r\n\r\n\r\n/* Callback for all peripherals which support TIMING features */\r\ntypedef void (*timer_callback_t)(void *userData);\r\n\r\n\r\n/*! @brief Defines a structure used to pass information to the ADC PAL callback\r\n *\r\n * Implements : adc_callback_info_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint32_t groupIndex;         /*!< Index of the group executing the callback. */\r\n    uint16_t resultBufferTail;   /*!< Offset of the most recent conversion result in the result buffer. */\r\n} adc_callback_info_t;\r\n\r\n/*! @brief Defines the callback used to be called by ADC PAL after the last conversion result in a group\r\n * has been copied to the result buffer.\r\n */\r\ntypedef void (* const adc_callback_t)(const adc_callback_info_t * const callbackInfo, void * userData);\r\n\r\n/* I2S */\r\n/* Define the enum of the events which can trigger i2s callback */\r\n/* Events for all peripherals which support i2s\r\n *\r\n * Implements : i2s_event_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    I2S_EVENT_RX_FULL      = 0x00U,    /*!< Rx buffer is full */\r\n    I2S_EVENT_TX_EMPTY     = 0x01U,    /*!< Tx buffer is empty */\r\n    I2S_EVENT_END_TRANSFER = 0x02U,    /*!< The current transfer is ending. Only FLEXIO instance uses this event. The difference between this and event TX_EMPTY is:\r\n                                            TX_EMPTY is generated when all data has been pushed to hardware fifo, users should not call DeInit here or some last data will be lost;\r\n                                            END_TRANSFER is generated when all data has been pushed to line, the transmission will be stopped before users can start transmit again, user can call DeInit here.\r\n                                            For receiving case, this event is the same as RX_FULL.\r\n                                            */\r\n    I2S_EVENT_ERROR        = 0x03U,    /*!< An error occurred during transfer */\r\n} i2s_event_t;\r\n\r\n/* Callback for all peripherals which support i2s\r\n *\r\n * Implements : i2s_callback_t_Class\r\n */\r\ntypedef void (*i2s_callback_t)(i2s_event_t event, void *userData);\r\n\r\n/*! @brief Define the enum of the events which can trigger CAN callback\r\n *  This enum should include the events for all platforms\r\n *  Implements : can_event_t_Class\r\n */\r\ntypedef enum {\r\n    CAN_EVENT_RX_COMPLETE,     /*!< A frame was received in the configured Rx buffer. */\r\n    CAN_EVENT_TX_COMPLETE,     /*!< A frame was sent from the configured Tx buffer. */\r\n} can_event_t;\r\n\r\n/*! @brief Callback for all peripherals which support CAN features\r\n * Implements : can_callback_t_Class\r\n */\r\ntypedef void (*can_callback_t)(uint32_t instance,\r\n                               can_event_t eventType,\r\n                               uint32_t objIdx,\r\n                               void *driverState);\r\n\r\n/*!\r\n * @brief Callback for security modules\r\n * Implements : security_callback_t_Class\r\n */\r\ntypedef void (*security_callback_t)(uint32_t completedCmd, void *callbackParam);\r\n\r\n/* Define the enum of the events which can trigger the output compare callback */\r\ntypedef enum\r\n{\r\n    OC_EVENT_GENERATION_OUTPUT_COMPLETE = 0x00U    /*!< Generation output signal is completed */\r\n} oc_event_t;\r\n\r\n/* Callback for all peripherals which support OC feature */\r\ntypedef void (*oc_callback_t)(oc_event_t event, void *userData);\r\n/* Define the enum of the events which can trigger the input capture callback */\r\ntypedef enum\r\n{\r\n    IC_EVENT_MEASUREMENT_COMPLETE = 0x00U    /*!< Capture input signal is completed */\r\n} ic_event_t;\r\n\r\n/* Callback for all peripherals which support IC feature */\r\ntypedef void (*ic_callback_t)(ic_event_t event, void *userData);\r\n\r\n#endif /* CALLBACKS_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"clock.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\inc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#if !defined(CLOCK_H)\r\n#define CLOCK_H\r\n\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n\r\n/*\r\n * Include the cpu specific clock API header files.\r\n */\r\n \r\n #if (defined(S32K14x_SERIES) || defined(S32K11x_SERIES))\r\n    /* S32K144 Clock System Level API header file */\r\n    #include \"../src/clock/S32K1xx/clock_S32K1xx.h\"\r\n#elif (defined(S32MTV_SERIES))\r\n    /* S32MTV Clock System Level API header file */\r\n    #include \"../src/clock/S32Mxx/clock_S32Mxx.h\"\r\n#elif (defined(MPC5777C_SERIES))\r\n    /* MPC5777C Clock System Level API header file */\r\n    #include \"../src/clock/MPC5777C/clock_MPC5777C.c\"\r\n#elif (defined(MPC574x_SERIES) || defined(S32R_SERIES))\r\n    /* MPC574x Clock System Level API header file */\r\n    #include \"../src/clock/MPC57xx/clock_MPC57xx.h\"\r\n#elif (defined(S32S247_SERIES))\r\n    /* S32S247 Clock System Level API header file */\r\n    #include \"../src/clock/S32Sxx/clock_S32Sxx.h\"\r\n#elif (defined(SJA1110_SERIES))\r\n    /* SJA1110 Clock System Level API header file */\r\n    #include \"../src/clock/SJA1110x/clock_SJA1110x.h\"\r\n#elif (defined(S32V234_SERIES))\r\n    /* S32Vxx Clock System Level API header file */\r\n    #include \"../src/clock/S32Vxx/clock_S32Vxx.h\"\r\n#else\r\n    #error \"No valid CPU defined!\"\r\n#endif\r\n\r\n/*!\r\n * @file clock.h\r\n */\r\n \r\n/*! @addtogroup clock*/\r\n/*! @{*/\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @name Dynamic clock setting\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n \r\n /*!\r\n * @brief Gets the clock frequency for a specific clock name.\r\n *\r\n * This function checks the current clock configurations and then calculates\r\n * the clock frequency for a specific clock name defined in clock_names_t.\r\n * Clock modules must be properly configured before using this function. \r\n * See features.h for supported clock names for different chip families.\r\n * The returned value is in Hertz. If it cannot find the clock name\r\n * or the name is not supported for a specific chip family, it returns an\r\n * STATUS_UNSUPPORTED. If frequency is required for a peripheral and the\r\n * module is not clocked, then STATUS_MCU_GATED_OFF status is returned.\r\n * Frequency is returned if a valid address is provided. If frequency is\r\n * required for a peripheral that doesn't support protocol clock, the zero \r\n * value is provided.\r\n *\r\n * @param[in] clockName Clock names defined in clock_names_t\r\n * @param[out] frequency Returned clock frequency value in Hertz\r\n * @return status   Error code defined in status_t\r\n */\r\nstatus_t CLOCK_DRV_GetFreq(clock_names_t clockName,\r\n                           uint32_t *frequency);\r\n                           \r\n\r\n/*!\r\n * @brief Set clock configuration according to pre-defined structure.\r\n *\r\n * This function sets system to target clock configuration; It sets the\r\n * clock modules registers for clock mode change. \r\n *\r\n * @param[in] config  Pointer to configuration structure.\r\n *\r\n * @return Error code.\r\n *\r\n * @note If external clock is used in the target mode, please make sure it is\r\n * enabled, for example, if the external oscillator is used, please setup correctly.\r\n *\r\n * @note If the configuration structure is NULL, the function will set a default\r\n * configuration for clock.\r\n */\r\nstatus_t CLOCK_DRV_Init(clock_user_config_t const * config);\r\n\r\n/*! @} */\r\n\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n/*! @}*/\r\n\r\n#endif /* CLOCK_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n\r\n"},{"name":"clock_S32K1xx.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, There shall be no occurrence of\r\n * undefined or critical unspecified behaviour.\r\n * The addresses of the stack variables are only used at local scope.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.3, Expression assigned to a narrower or different essential type.\r\n * The cast is required to perform a conversion between an unsigned integer and an enum type.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The base address parameter from HAL functions is provided as integer so\r\n * it needs to be cast to pointer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The base address parameter from HAL functions is provided as integer so\r\n * a conversion between a pointer and an integer has to be performed\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n* @section [global]\r\n * Violates MISRA 2012 Required Rule 13.5, side effects on right hand of logical operator, ''&&''\r\n * Those functions do not have side effects.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 13.5, side effects on right hand of logical operator, ''&&''\r\n * Those functions do not have side effects.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 14.3, controlling expressions shall not be invariant.\r\n * Code must address all devices.\r\n */\r\n\r\n#include \"device_registers.h\"\r\n#include \"sim_hw_access.h\"\r\n#include \"scg_hw_access.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"pmc_hw_access.h\"\r\n#include \"smc_hw_access.h\"\r\n#include \"clock.h\"\r\n#include \"interrupt_manager.h\"\r\n#include <stddef.h>   /* This header is included for bool type */\r\n/*\r\n * README:\r\n * This file provides these APIs:\r\n * 1. APIs to get the frequency of output clocks in Reference Manual ->\r\n * Chapter Clock Distribution -> Figure Clocking diagram.\r\n * 2. APIs for IP modules listed in Reference Manual -> Chapter Clock Distribution\r\n * -> Module clocks.\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\nstatic clock_manager_state_t g_clockState;\r\n\r\n/* This frequency values should be set by different boards. */\r\n/* SIM */\r\nuint32_t g_TClkFreq[NUMBER_OF_TCLK_INPUTS];      /* TCLKx clocks    */\r\n\r\n/* RTC */\r\nuint32_t g_RtcClkInFreq;                         /* RTC CLKIN clock */\r\n\r\n/* SCG */\r\nuint32_t g_xtal0ClkFreq;                         /* EXTAL0 clock    */\r\n\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n/* @brief System PLL base multiplier value, it is the multiplier value when SCG_SPLLCFG[MULT]=0. */\r\n#define SCG_SPLL_MULT_BASE 16U\r\n\r\n/*\r\n * @brief System PLL base divider value, it is the PLL reference clock divider value when\r\n * SCG_SPLLCFG[PREDIV]=0.\r\n */\r\n#define SCG_SPLL_PREDIV_BASE 1U\r\n\r\n/*\r\n * @brief System PLL reference clock after SCG_SPLLCFG[PREDIV] should be in the range of\r\n * SCG_SPLL_REF_MIN to SCG_SPLL_REF_MAX.\r\n */\r\n#define SCG_SPLL_REF_MIN 8000000U\r\n\r\n/*\r\n * @brief System PLL reference clock after SCG_SPLLCFG[PREDIV] should be in the range of\r\n * SCG_SPLL_REF_MIN to SCG_SPLL_REF_MAX.\r\n */\r\n#define SCG_SPLL_REF_MAX 32000000U\r\n#endif\r\n\r\n/*\r\n * @brief LPO 128K fixed clock frequency.\r\n */\r\n#define LPO_128K_FREQUENCY 128000UL\r\n\r\n/*\r\n * @brief LPO 32K fixed clock frequency.\r\n */\r\n#define LPO_32K_FREQUENCY 32000UL\r\n\r\n/*\r\n * @brief LPO 1K fixed clock frequency.\r\n */\r\n#define LPO_1K_FREQUENCY 1000UL\r\n\r\n/*\r\n * @brief Running modes.\r\n */\r\n#define HIGH_SPEED_RUNNING_MODE (1UL << 7U)\r\n#define RUN_SPEED_RUNNING_MODE  (1UL << 0U)\r\n#define VLPR_SPEED_RUNNING_MODE (1UL << 2U)\r\n\r\n\r\n#define MODES_MAX_NO 7U\r\n\r\n#if (defined(S32K142W_SERIES) || defined(S32K144W_SERIES))\r\n#define CLOCK_MAX_FREQUENCIES_VLPR_MODE                                                                    \\\r\n{/* SYS_CLK    BUS_CLK     SLOW_CLK */                                                                     \\\r\n{       0UL,       0UL,         0UL},               /*!< Invalid entry */                                  \\\r\n{ 1000000UL, 1000000UL,   250000UL},               /*!< Maximum frequencies when system clock is SOSC */  \\\r\n{ 1000000UL, 1000000UL,   250000UL},               /*!< Maximum frequencies when system clock is SIRC */  \\\r\n{ 1000000UL, 1000000UL,   250000UL},               /*!< Maximum frequencies when system clock is FIRC */  \\\r\n{       0UL,       0UL,         0UL},               /*!< Invalid entry */                                  \\\r\n{       0UL,       0UL,         0UL},               /*!< Invalid entry */                                  \\\r\n{ 1000000UL, 1000000UL,   250000UL},               /*!< Maximum frequencies when system clock is SPLL */  \\\r\n}\r\n#define CLOCK_MAX_FREQUENCIES_RUN_MODE                                                                     \\\r\n{/* SYS_CLK    BUS_CLK     SLOW_CLK */                                                                     \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{80000000UL, 48000000UL,  20000000UL},              /*!< Maximum frequencies when system clock is SOSC */  \\\r\n{80000000UL, 48000000UL,  20000000UL},              /*!< Maximum frequencies when system clock is SIRC */  \\\r\n{80000000UL, 48000000UL,  20000000UL},              /*!< Maximum frequencies when system clock is FIRC */  \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{80000000UL, 40000000UL,  20000000UL},              /*!< Maximum frequencies when system clock is SPLL */  \\\r\n}\r\n#else\r\n#define CLOCK_MAX_FREQUENCIES_VLPR_MODE                                                                    \\\r\n{/* SYS_CLK    BUS_CLK     SLOW_CLK */                                                                     \\\r\n{       0UL,       0UL,         0UL},               /*!< Invalid entry */                                  \\\r\n{ 4000000UL, 4000000UL,   1000000UL},               /*!< Maximum frequencies when system clock is SOSC */  \\\r\n{ 4000000UL, 4000000UL,   1000000UL},               /*!< Maximum frequencies when system clock is SIRC */  \\\r\n{ 4000000UL, 4000000UL,   1000000UL},               /*!< Maximum frequencies when system clock is FIRC */  \\\r\n{       0UL,       0UL,         0UL},               /*!< Invalid entry */                                  \\\r\n{       0UL,       0UL,         0UL},               /*!< Invalid entry */                                  \\\r\n{ 4000000UL, 4000000UL,   1000000UL},               /*!< Maximum frequencies when system clock is SPLL */  \\\r\n}\r\n#if (defined(S32K118_SERIES) || defined(S32K116_SERIES))\r\n#define CLOCK_MAX_FREQUENCIES_RUN_MODE                                                                     \\\r\n{/* SYS_CLK    BUS_CLK     SLOW_CLK */                                                                     \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{48000000UL, 48000000UL,  24000000UL},              /*!< Maximum frequencies when system clock is SOSC */  \\\r\n{48000000UL, 48000000UL,  24000000UL},              /*!< Maximum frequencies when system clock is SIRC */  \\\r\n{48000000UL, 48000000UL,  24000000UL},              /*!< Maximum frequencies when system clock is FIRC */  \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{48000000UL, 40000000UL,  24000000UL},              /*!< Maximum frequencies when system clock is SPLL */  \\\r\n}\r\n#else\r\n#define CLOCK_MAX_FREQUENCIES_RUN_MODE                                                                     \\\r\n{/* SYS_CLK    BUS_CLK     SLOW_CLK */                                                                     \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{80000000UL, 48000000UL,  26670000UL},              /*!< Maximum frequencies when system clock is SOSC */  \\\r\n{80000000UL, 48000000UL,  26670000UL},              /*!< Maximum frequencies when system clock is SIRC */  \\\r\n{80000000UL, 48000000UL,  26670000UL},              /*!< Maximum frequencies when system clock is FIRC */  \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{       0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{80000000UL, 40000000UL,  26670000UL},              /*!< Maximum frequencies when system clock is SPLL */  \\\r\n}\r\n#endif\r\n#endif\r\n\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n#define CLOCK_MAX_FREQUENCIES_HSRUN_MODE                                                                    \\\r\n{/* SYS_CLK    BUS_CLK     SLOW_CLK */                                                                      \\\r\n{        0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{112000000UL, 56000000UL,  28000000UL},              /*!< Maximum frequencies when system clock is SOSC */  \\\r\n{112000000UL, 56000000UL,  28000000UL},              /*!< Maximum frequencies when system clock is SIRC */  \\\r\n{112000000UL, 56000000UL,  28000000UL},              /*!< Maximum frequencies when system clock is FIRC */  \\\r\n{        0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{        0UL,        0UL,         0UL},              /*!< Invalid entry */                                  \\\r\n{112000000UL, 56000000UL,  28000000UL},              /*!< Maximum frequencies when system clock is SPLL */  \\\r\n}\r\n#endif\r\n\r\n/*\r\n * @brief Number of peripheral clocks.\r\n */\r\n#if defined(PCC_FTFM_INDEX)\r\n    #define TMP_FTFM 1U\r\n#else\r\n    #define TMP_FTFM 0U\r\n#endif\r\n#if defined(PCC_FTFC_INDEX)\r\n    #define TMP_FTFC 1U\r\n#else\r\n    #define TMP_FTFC 0U\r\n#endif\r\n#if defined(PCC_DMAMUX_INDEX)\r\n    #define TMP_DMAMUX 1U\r\n#else\r\n    #define TMP_DMAMUX 0U\r\n#endif\r\n#if defined(PCC_FlexCAN0_INDEX)\r\n    #define TMP_FlexCAN0 1U\r\n#else\r\n    #define TMP_FlexCAN0 0U\r\n#endif\r\n#if defined(PCC_FlexCAN1_INDEX)\r\n    #define TMP_FlexCAN1 1U\r\n#else\r\n    #define TMP_FlexCAN1 0U\r\n#endif\r\n#if defined(PCC_FTM3_INDEX)\r\n    #define TMP_FTM3 1U\r\n#else\r\n    #define TMP_FTM3 0U\r\n#endif\r\n#if defined(PCC_ADC1_INDEX)\r\n    #define TMP_ADC1 1U\r\n#else\r\n    #define TMP_ADC1 0U\r\n#endif\r\n#if defined(PCC_FlexCAN2_INDEX)\r\n    #define TMP_FlexCAN2 1U\r\n#else\r\n    #define TMP_FlexCAN2 0U\r\n#endif\r\n#if defined(PCC_LPSPI0_INDEX)\r\n    #define TMP_LPSPI0 1U\r\n#else\r\n    #define TMP_LPSPI0 0U\r\n#endif\r\n#if defined(PCC_LPSPI1_INDEX)\r\n    #define TMP_LPSPI1 1U\r\n#else\r\n    #define TMP_LPSPI1 0U\r\n#endif\r\n#if defined(PCC_LPSPI2_INDEX)\r\n    #define TMP_LPSPI2 1U\r\n#else\r\n    #define TMP_LPSPI2 0U\r\n#endif\r\n#if defined(PCC_PDB1_INDEX)\r\n    #define TMP_PDB1 1U\r\n#else\r\n    #define TMP_PDB1 0U\r\n#endif\r\n#if defined(PCC_CRC_INDEX)\r\n    #define TMP_CRC 1U\r\n#else\r\n    #define TMP_CRC 0U\r\n#endif\r\n#if defined(PCC_PDB0_INDEX)\r\n    #define TMP_PDB0 1U\r\n#else\r\n    #define TMP_PDB0 0U\r\n#endif\r\n#if defined(PCC_LPIT_INDEX)\r\n    #define TMP_LPIT 1U\r\n#else\r\n    #define TMP_LPIT 0U\r\n#endif\r\n#if defined(PCC_FTM0_INDEX)\r\n    #define TMP_FTM0 1U\r\n#else\r\n    #define TMP_FTM0 0U\r\n#endif\r\n#if defined(PCC_FTM1_INDEX)\r\n    #define TMP_FTM1 1U\r\n#else\r\n    #define TMP_FTM1 0U\r\n#endif\r\n#if defined(PCC_FTM2_INDEX)\r\n    #define TMP_FTM2 1U\r\n#else\r\n    #define TMP_FTM2 0U\r\n#endif\r\n#if defined(PCC_ADC0_INDEX)\r\n    #define TMP_ADC0 1U\r\n#else\r\n    #define TMP_ADC0 0U\r\n#endif\r\n#if defined(PCC_RTC_INDEX)\r\n    #define TMP_RTC 1U\r\n#else\r\n    #define TMP_RTC 0U\r\n#endif\r\n#if defined(PCC_LPTMR0_INDEX)\r\n    #define TMP_LPTMR0 1U\r\n#else\r\n    #define TMP_LPTMR0 0U\r\n#endif\r\n#if defined(PCC_PORTA_INDEX)\r\n    #define TMP_PORTA 1U\r\n#else\r\n    #define TMP_PORTA 0U\r\n#endif\r\n#if defined(PCC_PORTB_INDEX)\r\n    #define TMP_PORTB 1U\r\n#else\r\n    #define TMP_PORTB 0U\r\n#endif\r\n#if defined(PCC_PORTC_INDEX)\r\n    #define TMP_PORTC 1U\r\n#else\r\n    #define TMP_PORTC 0U\r\n#endif\r\n#if defined(PCC_PORTD_INDEX)\r\n    #define TMP_PORTD 1U\r\n#else\r\n    #define TMP_PORTD 0U\r\n#endif\r\n#if defined(PCC_PORTE_INDEX)\r\n    #define TMP_PORTE 1U\r\n#else\r\n    #define TMP_PORTE 0U\r\n#endif\r\n#if defined(PCC_SAI0_INDEX)\r\n    #define TMP_SAI0 1U\r\n#else\r\n    #define TMP_SAI0 0U\r\n#endif\r\n#if defined(PCC_SAI1_INDEX)\r\n    #define TMP_SAI1 1U\r\n#else\r\n    #define TMP_SAI1 0U\r\n#endif\r\n#if defined(PCC_FlexIO_INDEX)\r\n    #define TMP_FlexIO 1U\r\n#else\r\n    #define TMP_FlexIO 0U\r\n#endif\r\n#if defined(PCC_EWM_INDEX)\r\n    #define TMP_EWM 1U\r\n#else\r\n    #define TMP_EWM 0U\r\n#endif\r\n#if defined(PCC_LPI2C0_INDEX)\r\n    #define TMP_LPI2C0 1U\r\n#else\r\n    #define TMP_LPI2C0 0U\r\n#endif\r\n#if defined(PCC_LPI2C1_INDEX)\r\n    #define TMP_LPI2C1 1U\r\n#else\r\n    #define TMP_LPI2C1 0U\r\n#endif\r\n#if defined(PCC_LPUART0_INDEX)\r\n    #define TMP_LPUART0 1U\r\n#else\r\n    #define TMP_LPUART0 0U\r\n#endif\r\n#if defined(PCC_LPUART1_INDEX)\r\n    #define TMP_LPUART1 1U\r\n#else\r\n    #define TMP_LPUART1 0U\r\n#endif\r\n#if defined(PCC_LPUART2_INDEX)\r\n    #define TMP_LPUART2 1U\r\n#else\r\n    #define TMP_LPUART2 0U\r\n#endif\r\n#if defined(PCC_FTM4_INDEX)\r\n    #define TMP_FTM4 1U\r\n#else\r\n    #define TMP_FTM4 0U\r\n#endif\r\n#if defined(PCC_FTM5_INDEX)\r\n    #define TMP_FTM5 1U\r\n#else\r\n    #define TMP_FTM5 0U\r\n#endif\r\n#if defined(PCC_FTM6_INDEX)\r\n    #define TMP_FTM6 1U\r\n#else\r\n    #define TMP_FTM6 0U\r\n#endif\r\n#if defined(PCC_FTM7_INDEX)\r\n    #define TMP_FTM7 1U\r\n#else\r\n    #define TMP_FTM7 0U\r\n#endif\r\n#if defined(PCC_CMP0_INDEX)\r\n    #define TMP_CMP0 1U\r\n#else\r\n    #define TMP_CMP0 0U\r\n#endif\r\n#if defined(PCC_QSPI_INDEX)\r\n    #define TMP_QSPI 1U\r\n#else\r\n    #define TMP_QSPI 0U\r\n#endif\r\n#if defined(PCC_ENET_INDEX)\r\n    #define TMP_ENET 1U\r\n#else\r\n    #define TMP_ENET 0U\r\n#endif\r\n\r\n#define CLOCK_PERIPHERALS_COUNT (TMP_FTFM + TMP_FTFC + TMP_DMAMUX + TMP_FlexCAN0 + TMP_FlexCAN1 + TMP_FTM3 + TMP_ADC1 + TMP_FlexCAN2 + TMP_LPSPI0 + TMP_LPSPI1 + TMP_LPSPI2 + TMP_PDB1 + TMP_CRC + TMP_PDB0 + TMP_LPIT + TMP_FTM0 + TMP_FTM1 + TMP_FTM2 + TMP_ADC0 + TMP_RTC + TMP_LPTMR0 + TMP_PORTA + TMP_PORTB + TMP_PORTC + TMP_PORTD + TMP_PORTE + TMP_SAI0 + TMP_SAI1 + TMP_FlexIO + TMP_EWM + TMP_LPI2C0 + TMP_LPI2C1 + TMP_LPUART0 + TMP_LPUART1 + TMP_LPUART2 + TMP_FTM4 + TMP_FTM5 + TMP_FTM6 + TMP_FTM7 + TMP_CMP0 + TMP_QSPI + TMP_ENET)\r\n\r\n\r\n/*! @brief Clock name mappings\r\n *         Constant array storing the mappings between clock names and peripheral clock control indexes.\r\n *         If there is no peripheral clock control index for a clock name, then the corresponding value is\r\n *         PCC_INVALID_INDEX.\r\n */\r\nconst uint16_t clockNameMappings[] = PCC_CLOCK_NAME_MAPPINGS;\r\n\r\n/*! @brief Peripheral features list\r\n *         Constant array storing the mappings between clock names of the peripherals and feature lists.\r\n */\r\nconst uint8_t peripheralFeaturesList[] = PERIPHERAL_FEATURES;\r\n\r\n/*!\r\n * @brief SCG system clock type.\r\n * Implements scg_system_clock_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SYSTEM_CLOCK_CORE,  /*!< Core clock.        */\r\n    SCG_SYSTEM_CLOCK_BUS,   /*!< BUS clock.         */\r\n    SCG_SYSTEM_CLOCK_SLOW,  /*!< System slow clock. */\r\n    SCG_SYSTEM_CLOCK_MAX,   /*!< Max value.         */\r\n} scg_system_clock_type_t;\r\n\r\n/*!\r\n * @brief SCG asynchronous clock type.\r\n * Implements scg_async_clock_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_ASYNC_CLOCK_DIV1   = 0U,   /*!< Clock divider 1  */\r\n    SCG_ASYNC_CLOCK_DIV2   = 1U,   /*!< Clock divider 2  */\r\n    SCG_ASYNC_CLOCK_MAX    = 2U,   /*!< Max value.       */\r\n} scg_async_clock_type_t;\r\n\r\n/*!\r\n * @brief SCG system clock modes.\r\n * Implements scg_system_clock_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SYSTEM_CLOCK_MODE_CURRENT = 0U,  /*!< Current mode.            */\r\n    SCG_SYSTEM_CLOCK_MODE_RUN     = 1U,  /*!< Run mode.                */\r\n    SCG_SYSTEM_CLOCK_MODE_VLPR    = 2U,  /*!< Very Low Power Run mode. */\r\n    SCG_SYSTEM_CLOCK_MODE_HSRUN   = 3U,  /*!< High Speed Run mode.     */\r\n    SCG_SYSTEM_CLOCK_MODE_NONE           /*!< MAX value.               */\r\n} scg_system_clock_mode_t;\r\n\r\n\r\n/*******************************************************************************\r\n * INTERNAL FUNCTIONS\r\n ******************************************************************************/\r\nstatic void CLOCK_SYS_GetDefaultConfiguration(clock_manager_user_config_t * config);\r\n\r\nstatic status_t CLOCK_SYS_GetScgClockFreq(clock_names_t clockName,\r\n                                          uint32_t * frequency);\r\n\r\n#ifdef QuadSPI_INSTANCE_COUNT\r\nstatic uint32_t CLOCK_SYS_GetQSPIInternalReferenceClock(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiSfifClkHyp(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiIpgClk(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiIpgClkSfif(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiIpgClk2Xsfif(void);\r\n#endif\r\n\r\nstatic status_t CLOCK_SYS_GetSimClockFreq(clock_names_t clockName,\r\n                                          uint32_t * frequency);\r\n\r\nstatic status_t CLOCK_SYS_GetPccClockFreq(clock_names_t clockName,\r\n                                          uint32_t * frequency);\r\n\r\nstatic uint32_t CLOCK_SYS_GetPeripheralClock(clock_names_t clockName,\r\n                                             scg_async_clock_type_t divider);\r\n\r\nstatic scg_system_clock_mode_t CLOCK_SYS_GetCurrentRunMode(void);\r\n\r\nstatic status_t CLOCK_SYS_TransitionSystemClock(const scg_system_clock_config_t * to_clk);\r\n\r\nstatic uint32_t CLOCK_SYS_GetSimClkOutFreq(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetScgClkOutFreq(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetSimRtcClkFreq(void);\r\n\r\nstatic status_t CLOCK_SYS_ConfigureTemporarySystemClock(void);\r\n\r\nstatic status_t CLOCK_SYS_ConfigureModulesFromScg(const scg_config_t * scgConfig);\r\n\r\nstatic status_t CLOCK_SYS_ConfigureSIRC(bool enable, const scg_sirc_config_t * sircConfig);\r\n\r\nstatic status_t CLOCK_SYS_ConfigureFIRC(bool enable, const scg_firc_config_t * fircConfig);\r\n\r\nstatic status_t CLOCK_SYS_ConfigureSOSC(bool enable, const scg_sosc_config_t * soscConfig);\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\nstatic status_t CLOCK_SYS_ConfigureSPLL(bool enable, const scg_spll_config_t * spllConfig);\r\n#endif\r\n\r\nstatic uint32_t CLOCK_SYS_GetSystemClockFreq(scg_system_clock_type_t type);\r\n\r\nstatic status_t CLOCK_SYS_SetSystemClockConfig(scg_system_clock_mode_t mode,\r\n                                               scg_system_clock_config_t const * config);\r\n\r\nstatic uint32_t CLOCK_SYS_GetSysAsyncFreq(clock_names_t clockSource,\r\n                                          scg_async_clock_type_t type);\r\n\r\nstatic uint32_t CLOCK_SYS_GetSircFreq(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetFircFreq(void);\r\n\r\nstatic uint32_t CLOCK_SYS_GetSysOscFreq(void);\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\nstatic uint32_t CLOCK_SYS_GetSysPllFreq(void);\r\n#endif\r\n\r\nstatic uint32_t CLOCK_SYS_GetLpoFreq(void);\r\n\r\nstatic status_t CLOCK_SYS_TransitionToTmpSysClk(scg_system_clock_src_t currentSysClkSrc);\r\n\r\nstatic void CLOCK_SYS_GetCurrentSysClkConfig(scg_system_clock_config_t * sysClockConfig);\r\n\r\nstatic status_t CLOCK_SYS_SetScgConfiguration(const scg_config_t * scgConfig);\r\n\r\nstatic status_t CLOCK_SYS_GetFtmOptionFreq(clock_names_t clockName, uint32_t * frequency);\r\n\r\nstatic void CLOCK_SYS_SetPccConfiguration(const pcc_config_t * peripheralClockConfig);\r\n\r\nstatic void CLOCK_SYS_SetSimConfiguration(const sim_clock_config_t * simClockConfig);\r\n\r\nstatic void CLOCK_SYS_SetPmcConfiguration(const pmc_config_t * pmcConfig);\r\n\r\nstatic scg_async_clock_div_t CLOCK_SYS_ConvertAsyncDividerValue(uint16_t divider);\r\n\r\nstatic status_t CLOCK_SYS_SetSircClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2);\r\n\r\nstatic status_t CLOCK_SYS_SetFircClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2);\r\n\r\nstatic status_t CLOCK_SYS_SetSoscClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2);\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\nstatic status_t CLOCK_SYS_SetSpllClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2);\r\n#endif\r\n\r\nstatic scg_sosc_ext_ref_t CLOCK_SYS_GetExtRef(xosc_ref_t refClk);\r\n\r\nstatic clock_names_t CLOCK_SYS_GetDefaultModuleClkCfgSource(void);\r\n\r\nstatic scg_system_clock_mode_t CLOCK_SYS_GetSysClockMode(const pwr_modes_t mode);\r\n\r\nstatic scg_system_clock_src_t CLOCK_SYS_GetSysClockSource(clock_names_t src);\r\n\r\nstatic uint32_t CLOCK_SYS_GetSrcFreq(scg_system_clock_src_t src);\r\n\r\nstatic status_t CLOCK_SYS_CheckPCCClock(clock_names_t clockName);\r\n\r\nstatic void CLOCK_SYS_SetClockGate(clock_names_t peripheralClock, bool gating);\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_DRV_Init\r\n * Description   : This function sets the system to target configuration, it\r\n * only sets the clock modules registers for clock mode change, but not send\r\n * notifications to drivers.\r\n *\r\n * Implements CLOCK_DRV_Init_Activity\r\n * END**************************************************************************/\r\nstatus_t CLOCK_DRV_Init(clock_manager_user_config_t const * config)\r\n{\r\n    status_t result;\r\n    clock_manager_user_config_t config_default;\r\n    clock_manager_user_config_t const * cfg = config;\r\n\r\n    DEV_ASSERT(CLOCK_SYS_GetCurrentRunMode() == SCG_SYSTEM_CLOCK_MODE_RUN);\r\n\r\n    if (config == NULL)\r\n    {\r\n        /* Get default configuration */\r\n        CLOCK_SYS_GetDefaultConfiguration(&config_default);\r\n        cfg = &config_default;\r\n    }\r\n\r\n    /* Set SCG settings. */\r\n    result = CLOCK_SYS_SetScgConfiguration(&cfg->scgConfig);\r\n\r\n    if (STATUS_SUCCESS == result)\r\n    {\r\n        /* Set SIM settings. */\r\n        CLOCK_SYS_SetSimConfiguration(&cfg->simConfig);\r\n\r\n        /* Set PCC settings. */\r\n        CLOCK_SYS_SetPccConfiguration(&cfg->pccConfig);\r\n\r\n        /* Set PMC settings. */\r\n        CLOCK_SYS_SetPmcConfiguration(&cfg->pmcConfig);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_SetScgConfiguration\r\n * Description   : This function configures the SCG blocks\r\n *\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_SetScgConfiguration(const scg_config_t * scgConfig)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    DEV_ASSERT(scgConfig != NULL);\r\n\r\n    if (scgConfig != NULL)\r\n    {\r\n        /* Configure a temporary system clock source: FIRC */\r\n        status = CLOCK_SYS_ConfigureTemporarySystemClock();\r\n\r\n        if (status == STATUS_SUCCESS)\r\n        {\r\n            /* Configure clock sources from SCG */\r\n            status = CLOCK_SYS_ConfigureModulesFromScg(scgConfig);\r\n        }\r\n\r\n        if (status == STATUS_SUCCESS)\r\n        {\r\n            g_RtcClkInFreq = 0U; /* reset the value RTC_clk frequency. */\r\n            if (scgConfig->rtcConfig.initialize)\r\n            {\r\n                /* RTC Clock settings. */\r\n                g_RtcClkInFreq = scgConfig->rtcConfig.rtcClkInFreq;\r\n            }\r\n\r\n            /* Configure SCG ClockOut. */\r\n            if (scgConfig->clockOutConfig.initialize)\r\n            {\r\n                /* ClockOut settings. */\r\n                SCG_SetClockoutSourceSel(SCG, (uint32_t)scgConfig->clockOutConfig.source);\r\n            }\r\n\r\n            /* Configure SCG clock modes. */\r\n            if (scgConfig->clockModeConfig.initialize)\r\n            {\r\n                /* Configure SCG clock modes */\r\n                status = CLOCK_SYS_SetSystemClockConfig(SCG_SYSTEM_CLOCK_MODE_RUN, &(scgConfig->clockModeConfig.rccrConfig));\r\n                if (status == STATUS_SUCCESS)\r\n                {\r\n                    status = CLOCK_SYS_SetSystemClockConfig(SCG_SYSTEM_CLOCK_MODE_VLPR, &(scgConfig->clockModeConfig.vccrConfig));\r\n                }\r\n\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n                if (status == STATUS_SUCCESS)\r\n                {\r\n                    status = CLOCK_SYS_SetSystemClockConfig(SCG_SYSTEM_CLOCK_MODE_HSRUN, &(scgConfig->clockModeConfig.hccrConfig));\r\n                }\r\n#endif\r\n            }\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_SetPccConfiguration\r\n * Description   : This function configures the PCC block\r\n *\r\n * END**************************************************************************/\r\nstatic void CLOCK_SYS_SetPccConfiguration(const pcc_config_t * peripheralClockConfig)\r\n{\r\n    DEV_ASSERT(peripheralClockConfig != NULL);\r\n\r\n    uint32_t i;\r\n\r\n    if ((peripheralClockConfig != NULL) && (peripheralClockConfig->peripheralClocks != NULL))\r\n    {\r\n        for (i = 0U; i < peripheralClockConfig->count; i++)\r\n        {\r\n            /* Disable the peripheral clock */\r\n            PCC_SetClockMode(PCC, peripheralClockConfig->peripheralClocks[i].clockName, false);\r\n\r\n            /* Set peripheral clock control */\r\n            PCC_SetPeripheralClockControl(PCC,\r\n                                          peripheralClockConfig->peripheralClocks[i].clockName,\r\n                                          peripheralClockConfig->peripheralClocks[i].clkGate,\r\n                                          (uint32_t)peripheralClockConfig->peripheralClocks[i].clkSrc,\r\n                                          (uint32_t)peripheralClockConfig->peripheralClocks[i].divider,\r\n                                          (uint32_t)peripheralClockConfig->peripheralClocks[i].frac);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_SetSimConfiguration\r\n * Description   : This function configures the SIM block\r\n *\r\n * END**************************************************************************/\r\nstatic void CLOCK_SYS_SetSimConfiguration(const sim_clock_config_t * simClockConfig)\r\n{\r\n    DEV_ASSERT(simClockConfig != NULL);\r\n    uint8_t i;\r\n\r\n    /* ClockOut settings. */\r\n    if (simClockConfig->clockOutConfig.initialize)\r\n    {\r\n        SIM_SetClockout(SIM, simClockConfig->clockOutConfig.enable, simClockConfig->clockOutConfig.source, simClockConfig->clockOutConfig.divider);\r\n    }\r\n\r\n    /* Low Power Clock settings from SIM. */\r\n    if (simClockConfig->lpoClockConfig.initialize)\r\n    {\r\n        SIM_SetLpoClocks(SIM,\r\n                         simClockConfig->lpoClockConfig.enableLpo1k,\r\n                         simClockConfig->lpoClockConfig.enableLpo32k,\r\n                         simClockConfig->lpoClockConfig.sourceLpoClk,\r\n                         simClockConfig->lpoClockConfig.sourceRtcClk);\r\n    }\r\n\r\n    /* Platform Gate Clock settings. */\r\n    if (simClockConfig->platGateConfig.initialize)\r\n    {\r\n        SIM_SetMscmClockGate(SIM, simClockConfig->platGateConfig.enableMscm);\r\n        SIM_SetMpuClockGate(SIM, simClockConfig->platGateConfig.enableMpu);\r\n        SIM_SetDmaClockGate(SIM, simClockConfig->platGateConfig.enableDma);\r\n        SIM_SetErmClockGate(SIM, simClockConfig->platGateConfig.enableErm);\r\n        SIM_SetEimClockGate(SIM, simClockConfig->platGateConfig.enableEim);\r\n#if defined (QuadSPI_INSTANCE_COUNT)\r\n        SIM_SetQspiIntRefClockGate(SIM, simClockConfig->qspiRefClkGating.enableQspiRefClk);\r\n#endif\r\n    }\r\n\r\n    /* TCLK Clock settings. */\r\n    if (simClockConfig->tclkConfig.initialize)\r\n    {\r\n        for (i = 0; i < NUMBER_OF_TCLK_INPUTS; i++)\r\n        {\r\n            g_TClkFreq[i] = simClockConfig->tclkConfig.tclkFreq[i];\r\n        }\r\n\r\n        /* FTMOPT0 clock settings */\r\n        for (i = 0; i < FTM_INSTANCE_COUNT; i++)\r\n        {\r\n            SIM_SetExtPinSourceFtm(SIM, i, simClockConfig->tclkConfig.extPinSrc[i]);\r\n        }\r\n    }\r\n\r\n    /* Debug trace Clock settings. */\r\n    if (simClockConfig->traceClockConfig.initialize)\r\n    {\r\n        SIM_ClearTraceClockConfig(SIM);\r\n        SIM_SetTraceClockSource(SIM, simClockConfig->traceClockConfig.source);\r\n\r\n        SIM_SetTraceClockConfig(SIM, false, 0U, 0U);\r\n\r\n        if (simClockConfig->traceClockConfig.divEnable)\r\n        {\r\n            SIM_SetTraceClockConfig(SIM,\r\n                                    simClockConfig->traceClockConfig.divEnable,\r\n                                    simClockConfig->traceClockConfig.divider,\r\n                                    simClockConfig->traceClockConfig.divFraction);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_SetPmcConfiguration\r\n * Description   : This function configures the PMC block\r\n *\r\n * END**************************************************************************/\r\nstatic void CLOCK_SYS_SetPmcConfiguration(const pmc_config_t * pmcConfig)\r\n{\r\n    DEV_ASSERT(pmcConfig != NULL);\r\n\r\n    /* Low Power Clock settings from PMC. */\r\n    if (pmcConfig->lpoClockConfig.initialize)\r\n    {\r\n        /* Enable/disable the low power oscillator. */\r\n        PMC_SetLpoMode(PMC, pmcConfig->lpoClockConfig.enable);\r\n\r\n        /* Write trimming value. */\r\n        PMC_SetLpoTrimValue(PMC, pmcConfig->lpoClockConfig.trimValue);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetDefaultConfiguration\r\n * Description   : This function gets the system to a default configuration, it\r\n * only gets the clock modules registers for clock mode change, but not send\r\n * notifications to drivers.\r\n *\r\n * END**************************************************************************/\r\nstatic void CLOCK_SYS_GetDefaultConfiguration(clock_manager_user_config_t * config)\r\n{\r\n    uint32_t i = 0U;\r\n    static peripheral_clock_config_t peripheralClockConfig[CLOCK_PERIPHERALS_COUNT] = {\r\n#ifdef PCC_ADC0_INDEX\r\n        {\r\n            .clockName        = ADC0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_ADC1_INDEX\r\n        {\r\n            .clockName        = ADC1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_CMP0_INDEX\r\n        {\r\n            .clockName        = CMP0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_CRC_INDEX\r\n        {\r\n            .clockName        = CRC0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_DMAMUX_INDEX\r\n        {\r\n            .clockName        = DMAMUX0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_ENET_INDEX\r\n        {\r\n            .clockName        = ENET0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_EWM_INDEX\r\n        {\r\n            .clockName        = EWM0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FlexCAN0_INDEX\r\n        {\r\n            .clockName        = FlexCAN0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FlexCAN1_INDEX\r\n        {\r\n            .clockName        = FlexCAN1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FlexCAN2_INDEX\r\n        {\r\n            .clockName        = FlexCAN2_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FlexIO_INDEX\r\n        {\r\n            .clockName        = FLEXIO0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTFM_INDEX\r\n        {\r\n            .clockName        = FTFM0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTFC_INDEX\r\n        {\r\n            .clockName        = FTFC0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM0_INDEX\r\n        {\r\n            .clockName        = FTM0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM1_INDEX\r\n        {\r\n            .clockName        = FTM1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM2_INDEX\r\n        {\r\n            .clockName        = FTM2_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM3_INDEX\r\n        {\r\n            .clockName        = FTM3_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM4_INDEX\r\n        {\r\n            .clockName        = FTM4_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM5_INDEX\r\n        {\r\n            .clockName        = FTM5_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM6_INDEX\r\n        {\r\n            .clockName        = FTM6_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_FTM7_INDEX\r\n        {\r\n            .clockName        = FTM7_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPI2C0_INDEX\r\n        {\r\n            .clockName        = LPI2C0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPI2C1_INDEX\r\n        {\r\n            .clockName        = LPI2C1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPIT_INDEX\r\n        {\r\n            .clockName        = LPIT0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPSPI0_INDEX\r\n        {\r\n            .clockName        = LPSPI0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPSPI1_INDEX\r\n        {\r\n            .clockName        = LPSPI1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPSPI2_INDEX\r\n        {\r\n            .clockName        = LPSPI2_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPTMR0_INDEX\r\n        {\r\n            .clockName        = LPTMR0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPUART0_INDEX\r\n        {\r\n            .clockName        = LPUART0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPUART1_INDEX\r\n        {\r\n            .clockName        = LPUART1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_LPUART2_INDEX\r\n        {\r\n            .clockName        = LPUART2_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_SIRC_DIV1,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PDB0_INDEX\r\n        {\r\n            .clockName        = PDB0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PDB1_INDEX\r\n        {\r\n            .clockName        = PDB1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PORTA_INDEX\r\n        {\r\n            .clockName        = PORTA_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PORTB_INDEX\r\n        {\r\n            .clockName        = PORTB_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PORTC_INDEX\r\n        {\r\n            .clockName        = PORTC_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PORTD_INDEX\r\n        {\r\n            .clockName        = PORTD_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_PORTE_INDEX\r\n        {\r\n            .clockName        = PORTE_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_QSPI_INDEX\r\n        {\r\n            .clockName        = QSPI0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_RTC_INDEX\r\n        {\r\n            .clockName        = RTC0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_SAI0_INDEX\r\n        {\r\n            .clockName        = SAI0_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n#ifdef PCC_SAI1_INDEX\r\n        {\r\n            .clockName        = SAI1_CLK,\r\n            .clkGate          = true,\r\n            .clkSrc           = CLK_SRC_OFF,\r\n            .frac             = MULTIPLY_BY_ONE,\r\n            .divider          = DIVIDE_BY_ONE,\r\n        },\r\n#endif\r\n    };\r\n\r\n    /* SCG */\r\n    config->scgConfig.sircConfig.initialize               = true;                               /*!< Initialize */\r\n    /* SIRCCSR */\r\n    config->scgConfig.sircConfig.enableInStop             = false;                              /*!< SIRCSTEN  */\r\n    config->scgConfig.sircConfig.enableInLowPower         = true;                               /*!< SIRCLPEN  */\r\n    config->scgConfig.sircConfig.locked                   = false;                              /*!< LK        */\r\n    /* SIRCCFG */\r\n    config->scgConfig.sircConfig.range                    = SCG_SIRC_RANGE_HIGH;                /*!< RANGE - High range (8 MHz) */\r\n    /* SIRCDIV */\r\n    config->scgConfig.sircConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SIRCDIV1  */\r\n    config->scgConfig.sircConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SIRCDIV2  */\r\n\r\n    config->scgConfig.fircConfig.initialize               = true;                               /*!< Initialize */\r\n     /* FIRCCSR */\r\n    config->scgConfig.fircConfig.regulator                = true;                               /*!< FIRCREGOFF */\r\n    config->scgConfig.fircConfig.locked                   = false;                              /*!< LK         */\r\n    /* FIRCCFG */\r\n    config->scgConfig.fircConfig.range                    = SCG_FIRC_RANGE_48M;                 /*!< RANGE      */\r\n    /* FIRCDIV */\r\n    config->scgConfig.fircConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< FIRCDIV1   */\r\n    config->scgConfig.fircConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< FIRCDIV2   */\r\n\r\n    config->scgConfig.rtcConfig.initialize                = true;                               /*!< Initialize  */\r\n    config->scgConfig.rtcConfig.rtcClkInFreq              = 0U;                                 /*!< RTC_CLKIN   */\r\n\r\n    config->scgConfig.soscConfig.initialize               = true;                               /*!< Initialize */\r\n    config->scgConfig.soscConfig.freq                     = 8000000U;                           /*!< Frequency  */\r\n    /* SOSCCSR */\r\n    config->scgConfig.soscConfig.monitorMode              = SCG_SOSC_MONITOR_DISABLE;           /*!< SOSCCM      */\r\n    config->scgConfig.soscConfig.locked                   = false;                              /*!< LK          */\r\n    /* SOSCCFG */\r\n    config->scgConfig.soscConfig.extRef                   = SCG_SOSC_REF_OSC;                   /*!< EREFS       */\r\n    config->scgConfig.soscConfig.gain                     = SCG_SOSC_GAIN_LOW;                  /*!< HGO         */\r\n    config->scgConfig.soscConfig.range                    = SCG_SOSC_RANGE_MID;                 /*!< RANGE       */\r\n    /* SOSCDIV */\r\n    config->scgConfig.soscConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SOSCDIV1    */\r\n    config->scgConfig.soscConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SOSCDIV2    */\r\n\r\n#ifdef SCG_SPLLCSR_SPLLEN_MASK\r\n    config->scgConfig.spllConfig.initialize               = true;                               /*!< Initialize */\r\n    /* SPLLCSR */\r\n    config->scgConfig.spllConfig.monitorMode              = SCG_SPLL_MONITOR_DISABLE;           /*!< SPLLCM     */\r\n    config->scgConfig.spllConfig.locked                   = false;                              /*!< LK         */\r\n    /* SPLLCFG */\r\n#if (defined(S32K142W_SERIES) || defined(S32K144W_SERIES))\r\n    config->scgConfig.spllConfig.prediv                   = SCG_SPLL_CLOCK_PREDIV_BY_1;         /*!< PREDIV     */\r\n    config->scgConfig.spllConfig.mult                     = SCG_SPLL_CLOCK_MULTIPLY_BY_40;      /*!< MULT       */\r\n    config->scgConfig.spllConfig.src                      = 0U;                                 /*!< SOURCE     */\r\n        /* SPLLDIV */\r\n    config->scgConfig.spllConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_2;           /*!< SPLLDIV1   */\r\n    config->scgConfig.spllConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_4;           /*!< SPLLDIV2   */\r\n#else\r\n    config->scgConfig.spllConfig.prediv                   = SCG_SPLL_CLOCK_PREDIV_BY_1;         /*!< PREDIV     */\r\n    config->scgConfig.spllConfig.mult                     = SCG_SPLL_CLOCK_MULTIPLY_BY_28;      /*!< MULT       */\r\n    config->scgConfig.spllConfig.src                      = 0U;                                 /*!< SOURCE     */\r\n        /* SPLLDIV */\r\n    config->scgConfig.spllConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SPLLDIV1   */\r\n    config->scgConfig.spllConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SPLLDIV2   */\r\n#endif\r\n#endif\r\n\r\n    config->scgConfig.clockOutConfig.initialize           = true;                               /*!< Initialize    */\r\n    config->scgConfig.clockOutConfig.source               = SCG_CLOCKOUT_SRC_FIRC;              /*!< SCG CLKOUTSEL     */\r\n\r\n    config->scgConfig.clockModeConfig.initialize          = true;                               /*!< Initialize */\r\n    /*!< RCCR - Run Clock Control Register          */\r\n    config->scgConfig.clockModeConfig.rccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_FIRC;          /*!< SCS        */\r\n    config->scgConfig.clockModeConfig.rccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVCORE    */\r\n    config->scgConfig.clockModeConfig.rccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVBUS     */\r\n#if (defined(S32K142W_SERIES) || defined(S32K144W_SERIES))\r\n    config->scgConfig.clockModeConfig.rccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */\r\n#else\r\n    config->scgConfig.clockModeConfig.rccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVSLOW    */\r\n#endif\r\n    /*!< VCCR - VLPR Clock Control Register        */\r\n#if (defined(S32K142W_SERIES) || defined(S32K144W_SERIES))\r\n    config->scgConfig.clockModeConfig.vccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_SIRC;          /*!< SCS        */\r\n    config->scgConfig.clockModeConfig.vccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_8;          /*!< DIVCORE    */\r\n    config->scgConfig.clockModeConfig.vccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVBUS     */\r\n    config->scgConfig.clockModeConfig.vccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */\r\n#else\r\n    config->scgConfig.clockModeConfig.vccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_SIRC;          /*!< SCS        */\r\n    config->scgConfig.clockModeConfig.vccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVCORE    */\r\n    config->scgConfig.clockModeConfig.vccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVBUS     */\r\n    config->scgConfig.clockModeConfig.vccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */\r\n#endif\r\n\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n    /*!< HCCR - HSRUN Clock Control Register        */\r\n    config->scgConfig.clockModeConfig.hccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;       /*!< SCS        */\r\n    config->scgConfig.clockModeConfig.hccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVCORE    */\r\n    config->scgConfig.clockModeConfig.hccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVBUS     */\r\n    config->scgConfig.clockModeConfig.hccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */\r\n#endif\r\n\r\n    /* PCC */\r\n    config->pccConfig.peripheralClocks                    = peripheralClockConfig;             /*!< Peripheral clock control configurations  */\r\n    config->pccConfig.count                               = CLOCK_PERIPHERALS_COUNT;         /*!< Number of the peripheral clock control configurations  */\r\n\r\n    /* SIM */\r\n    /*!< Clock Out configuration.           */\r\n    config->simConfig.clockOutConfig.initialize           = true;                               /*!< Initialize    */\r\n    config->simConfig.clockOutConfig.enable               = false;                              /*!< CLKOUTEN      */\r\n    config->simConfig.clockOutConfig.source               = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT;   /*!< CLKOUTSEL     */\r\n    config->simConfig.clockOutConfig.divider              = SIM_CLKOUT_DIV_BY_1;                /*!< CLKOUTDIV     */\r\n    /*!< Low Power Clock configuration.     */\r\n    config->simConfig.lpoClockConfig.initialize           = true;                               /*!< Initialize    */\r\n    config->simConfig.lpoClockConfig.enableLpo1k          = true;                               /*!< LPO1KCLKEN    */\r\n    config->simConfig.lpoClockConfig.enableLpo32k         = true;                               /*!< LPO32KCLKEN   */\r\n    config->simConfig.lpoClockConfig.sourceLpoClk         = SIM_LPO_CLK_SEL_LPO_128K;           /*!< LPOCLKSEL     */\r\n    config->simConfig.lpoClockConfig.sourceRtcClk         = SIM_RTCCLK_SEL_SOSCDIV1_CLK;        /*!< RTCCLKSEL     */\r\n    /*!< Platform Gate Clock configuration. */\r\n    config->simConfig.platGateConfig.initialize           = true;                               /*!< Initialize    */\r\n    config->simConfig.platGateConfig.enableMscm           = true;                               /*!< CGCMSCM       */\r\n    config->simConfig.platGateConfig.enableMpu            = true;                               /*!< CGCMPU       */\r\n    config->simConfig.platGateConfig.enableDma            = true;                               /*!< CGCDMA       */\r\n    config->simConfig.platGateConfig.enableErm            = true;                               /*!< CGCERM       */\r\n    config->simConfig.platGateConfig.enableEim            = true;                               /*!< CGCMEIM       */\r\n    /*!< Quad Spi Internal Reference Clock Gating. */\r\n    config->simConfig.qspiRefClkGating.enableQspiRefClk   = true;                               /*!< Qspi reference clock gating    */\r\n    /*!< TCLK CLOCK configuration. */\r\n    config->simConfig.tclkConfig.initialize               = true;                               /*!< Initialize    */\r\n    config->simConfig.tclkConfig.tclkFreq[0]              = 0U;                                 /*!< TCLK0         */\r\n    config->simConfig.tclkConfig.tclkFreq[1]              = 0U;                                 /*!< TCLK0         */\r\n    config->simConfig.tclkConfig.tclkFreq[2]              = 0U;                                 /*!< TCLK0         */\r\n    for (i = 0; i < FTM_INSTANCE_COUNT; i++)\r\n    {\r\n        config->simConfig.tclkConfig.extPinSrc[i]              = 0U;                                 /*!< FTMx ext pin source         */\r\n    }\r\n\r\n     /*!< Debug trace Clock Configuration. */\r\n    config->simConfig.traceClockConfig.initialize         = true;                               /*!< Initialize    */\r\n    config->simConfig.traceClockConfig.divEnable          = true;                               /*!< TRACEDIVEN    */\r\n    config->simConfig.traceClockConfig.source             = CLOCK_TRACE_SRC_CORE_CLK;           /*!< TRACECLK_SEL  */\r\n    config->simConfig.traceClockConfig.divider            = 0U;                                 /*!< TRACEDIV      */\r\n    config->simConfig.traceClockConfig.divFraction        = false;                              /*!< TRACEFRAC     */\r\n\r\n    /* PMC */\r\n    /*!< Low Power Clock configuration.     */\r\n    config->pmcConfig.lpoClockConfig.initialize           = true;                               /*!< Initialize             */\r\n    config->pmcConfig.lpoClockConfig.enable               = true;                               /*!< Enable/disable LPO     */\r\n    config->pmcConfig.lpoClockConfig.trimValue            = 0;                                  /*!< Trimming value for LPO */\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetScgClockFreq\r\n * Description   : This function returns the frequency of a given clock from SCG\r\n *\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_GetScgClockFreq(clock_names_t clockName,\r\n                                          uint32_t * frequency)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n    uint32_t freq = 0U;\r\n\r\n    switch (clockName)\r\n    {\r\n        /* Main clocks */\r\n        case CORE_CLK:\r\n            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);\r\n            break;\r\n        case BUS_CLK:\r\n            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);\r\n            break;\r\n        case SLOW_CLK:\r\n            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_SLOW);\r\n            break;\r\n        case CLKOUT_CLK:\r\n            freq = CLOCK_SYS_GetSimClkOutFreq();\r\n            break;\r\n\r\n        /* Other internal clocks used by peripherals. */\r\n        case SIRC_CLK:\r\n            freq = CLOCK_SYS_GetSircFreq();\r\n            break;\r\n        case FIRC_CLK:\r\n            freq = CLOCK_SYS_GetFircFreq();\r\n            break;\r\n        case SOSC_CLK:\r\n            freq = CLOCK_SYS_GetSysOscFreq();\r\n            break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case SPLL_CLK:\r\n            freq = CLOCK_SYS_GetSysPllFreq();\r\n            break;\r\n#endif\r\n        case RTC_CLKIN_CLK:\r\n            freq = g_RtcClkInFreq;\r\n            break;\r\n        case SCG_CLKOUT_CLK:\r\n            freq = CLOCK_SYS_GetScgClkOutFreq();\r\n            break;\r\n        case SIRCDIV1_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n            break;\r\n        case SIRCDIV2_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n            break;\r\n        case FIRCDIV1_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n            break;\r\n        case FIRCDIV2_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n            break;\r\n        case SOSCDIV1_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n            break;\r\n        case SOSCDIV2_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n            break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case SPLLDIV1_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n            break;\r\n        case SPLLDIV2_CLK:\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n            break;\r\n#endif\r\n        default:\r\n            returnCode = STATUS_UNSUPPORTED;\r\n            break;\r\n    }\r\n\r\n    if (frequency != NULL)\r\n    {\r\n        *frequency = freq;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n#ifdef QuadSPI_INSTANCE_COUNT\r\nstatic uint32_t CLOCK_SYS_GetQSPIInternalReferenceClock(void)\r\n{\r\n    uint32_t freq = 0U;\r\n    uint32_t divValue = 0U;\r\n\r\n    if (SIM_GetClockingModeSelection(SIM))\r\n    {\r\n        if (QSPI_GetClockingSourceSelection(QuadSPI))\r\n        {\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n        }\r\n        else\r\n        {\r\n            freq = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n        }\r\n\r\n        divValue = QSPI_GetClockingProgrammableDividerValue(QuadSPI);\r\n        freq /= (divValue + 1U);\r\n    }\r\n\r\n    return freq;\r\n}\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiSfifClkHyp(void)\r\n{\r\n    uint32_t freq = 0U;\r\n\r\n    freq = CLOCK_SYS_GetQSPIInternalReferenceClock();\r\n    freq >>= 1U;\r\n\r\n    return freq;\r\n}\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiIpgClk(void)\r\n{\r\n    uint32_t freq = 0U;\r\n\r\n    if (PCC_GetClockMode(PCC, QSPI0_CLK))\r\n    {\r\n        if (QSPI_GetClockingModeSelection(QuadSPI))\r\n        {\r\n            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);\r\n        }\r\n        else\r\n        {\r\n            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);\r\n        }\r\n    }\r\n\r\n    return freq;\r\n}\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiIpgClkSfif(void)\r\n{\r\n    uint32_t freq = 0U;\r\n\r\n    freq = CLOCK_SYS_GetQSPIInternalReferenceClock();\r\n\r\n    if (QSPI_GetClockingHyperRamMode(QuadSPI))\r\n    {\r\n        freq >>= 1U;\r\n    }\r\n\r\n    return freq;\r\n}\r\n\r\nstatic uint32_t CLOCK_SYS_GetQspiIpgClk2Xsfif(void)\r\n{\r\n    uint32_t freq = 0U;\r\n\r\n    if (QSPI_GetClockingHyperRamMode(QuadSPI))\r\n    {\r\n        freq = CLOCK_SYS_GetQSPIInternalReferenceClock();\r\n    }\r\n\r\n    return freq;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetSimClockFreq\r\n * Description   : This function returns the frequency of a given clock from SIM\r\n *\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_GetSimClockFreq(clock_names_t clockName,\r\n                                          uint32_t * frequency)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n    uint32_t clockPinSelect;\r\n    uint32_t freq = 0U;\r\n\r\n    switch (clockName)\r\n    {\r\n        /* SIM clocks */\r\n        case SIM_FTM0_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm0ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n        case SIM_FTM1_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm1ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#if FTM_INSTANCE_COUNT > 2U\r\n        case SIM_FTM2_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm2ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 3U\r\n        case SIM_FTM3_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm3ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 4U\r\n        case SIM_FTM4_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm4ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 5U\r\n        case SIM_FTM5_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm5ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 6U\r\n        case SIM_FTM6_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm6ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 7U\r\n        case SIM_FTM7_CLOCKSEL:\r\n            clockPinSelect = SIM_GetFtm7ExternalClkPinMode(SIM);\r\n            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)\r\n            {\r\n                freq = g_TClkFreq[clockPinSelect];\r\n            }\r\n\r\n            break;\r\n#endif\r\n        case SIM_CLKOUTSELL:\r\n            freq = CLOCK_SYS_GetSimClkOutFreq();\r\n            break;\r\n        case SIM_RTCCLK_CLK:\r\n            freq = CLOCK_SYS_GetSimRtcClkFreq();\r\n            break;\r\n        case SIM_LPO_CLK:\r\n            if (PMC_GetLpoMode(PMC))\r\n            {\r\n                freq = CLOCK_SYS_GetLpoFreq();\r\n            }\r\n\r\n            break;\r\n        case SIM_LPO_1K_CLK:\r\n            if (PMC_GetLpoMode(PMC))\r\n            {\r\n                freq = ((SIM_GetLpo32KStatus(SIM)) && (SIM_GetLpo1KStatus(SIM))) ? LPO_1K_FREQUENCY : 0UL;\r\n            }\r\n\r\n            break;\r\n        case SIM_LPO_32K_CLK:\r\n            if (PMC_GetLpoMode(PMC))\r\n            {\r\n                freq = SIM_GetLpo32KStatus(SIM) ? LPO_32K_FREQUENCY : 0UL;\r\n            }\r\n\r\n            break;\r\n        case SIM_LPO_128K_CLK:\r\n            if (PMC_GetLpoMode(PMC))\r\n            {\r\n                freq = LPO_128K_FREQUENCY;\r\n            }\r\n\r\n            break;\r\n        case SIM_EIM_CLK:\r\n            if (!SIM_GetEimClockGate(SIM))\r\n            {\r\n                /* EIM is not clocked. */\r\n                returnCode = STATUS_MCU_GATED_OFF;\r\n            }\r\n\r\n            break;\r\n        case SIM_ERM_CLK:\r\n            if (!SIM_GetErmClockGate(SIM))\r\n            {\r\n                /* ERM is not clocked. */\r\n                returnCode = STATUS_MCU_GATED_OFF;\r\n            }\r\n\r\n            break;\r\n        case SIM_DMA_CLK:\r\n            if (!SIM_GetDmaClockGate(SIM))\r\n            {\r\n                /* DMA is not clocked. */\r\n                returnCode = STATUS_MCU_GATED_OFF;\r\n            }\r\n\r\n            break;\r\n        case SIM_MPU_CLK:\r\n            if (!SIM_GetMpuClockGate(SIM))\r\n            {\r\n                /* MPU is not clocked. */\r\n                returnCode = STATUS_MCU_GATED_OFF;\r\n            }\r\n\r\n            break;\r\n        case SIM_MSCM_CLK:\r\n            if (!SIM_GetMscmClockGate(SIM))\r\n            {\r\n                /* MSCM is not clocked. */\r\n                returnCode = STATUS_MCU_GATED_OFF;\r\n            }\r\n\r\n            break;\r\n#ifdef QuadSPI_INSTANCE_COUNT\r\n        case QSPI_MODULE_SFIF_CLK_HYP:\r\n            freq = CLOCK_SYS_GetQspiSfifClkHyp();\r\n            break;\r\n\r\n        case QSPI_MODULE_CLK:\r\n            freq = CLOCK_SYS_GetQspiIpgClk();\r\n            break;\r\n\r\n        case QSPI_MODULE_CLK_SFIF:\r\n            freq = CLOCK_SYS_GetQspiIpgClkSfif();\r\n            break;\r\n\r\n        case QSPI_MODULE_CLK_2XSFIF:\r\n            freq = CLOCK_SYS_GetQspiIpgClk2Xsfif();\r\n            break;\r\n#endif\r\n        default:\r\n            returnCode = STATUS_UNSUPPORTED;\r\n            break;\r\n    }\r\n\r\n    /* get interface clock of some special module */\r\n    if ((clockName > SIM_LPO_128K_CLK) && (clockName <= SIM_MSCM_CLK) && (returnCode == STATUS_SUCCESS))\r\n    {\r\n        freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);\r\n    }\r\n    /* return status mcu gate off if frequency is 0. */\r\n    if ((freq == 0UL) && (returnCode != STATUS_UNSUPPORTED))\r\n    {\r\n        returnCode = STATUS_MCU_GATED_OFF;\r\n    }\r\n\r\n    if (frequency != NULL)\r\n    {\r\n        *frequency = freq;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_CheckPCCClock\r\n * Description   : Checks if PCC clock name is valid and if the module is enabled.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_CheckPCCClock(clock_names_t clockName)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n\r\n    /* Invalid PCC clock names. */\r\n    if ((clockName <= SIM_END_OF_CLOCKS) ||\r\n        (clockName == PCC_END_OF_BUS_CLOCKS) ||\r\n        (clockName == PCC_END_OF_SYS_CLOCKS) ||\r\n        (clockName == PCC_END_OF_SLOW_CLOCKS) ||\r\n        (clockName == PCC_END_OF_ASYNCH_DIV1_CLOCKS) ||\r\n        (clockName == PCC_END_OF_ASYNCH_DIV2_CLOCKS))\r\n    {\r\n        returnCode = STATUS_UNSUPPORTED;\r\n    }\r\n    else if (PCC_GetClockMode(PCC, clockName) == false)\r\n    {\r\n        /* Module is not clocked. */\r\n        returnCode = STATUS_MCU_GATED_OFF;\r\n    }\r\n    else\r\n    {\r\n        returnCode = STATUS_SUCCESS;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetPccClockFreq\r\n * Description   : This function returns the clock frequency of peripheral functional clock.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_GetPccClockFreq(clock_names_t clockName,\r\n                                          uint32_t * frequency)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n    uint32_t freq = 0U;\r\n    uint32_t interfaceFreq = 0U;\r\n\r\n    returnCode = CLOCK_SYS_CheckPCCClock(clockName);\r\n\r\n    if (returnCode == STATUS_SUCCESS)\r\n    {\r\n        if ((peripheralFeaturesList[clockName] & HAS_INT_CLOCK_FROM_BUS_CLOCK) != 0U)\r\n        {\r\n            /* Check whether BUS CLOCK is clocked. */\r\n            interfaceFreq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);\r\n            returnCode = (status_t)((interfaceFreq == 0U) ? STATUS_MCU_GATED_OFF : STATUS_SUCCESS);\r\n        }\r\n        else if ((peripheralFeaturesList[clockName] & HAS_INT_CLOCK_FROM_SYS_CLOCK) != 0U)\r\n        {\r\n            /* Check whether SYS CLOCK is clocked. */\r\n            interfaceFreq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);\r\n            returnCode = (status_t)((interfaceFreq == 0U) ? STATUS_MCU_GATED_OFF : STATUS_SUCCESS);\r\n        }\r\n        else if ((peripheralFeaturesList[clockName] & HAS_INT_CLOCK_FROM_SLOW_CLOCK) != 0U)\r\n        {\r\n            /* Check whether SLOW CLOCK is clocked. */\r\n            interfaceFreq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_SLOW);\r\n            returnCode = (status_t)((interfaceFreq == 0U) ? STATUS_MCU_GATED_OFF : STATUS_SUCCESS);\r\n        }\r\n        else\r\n        {   /* It's an issue in peripheral features list, each peripheral must have one interface clock. */\r\n            DEV_ASSERT(false);\r\n        }\r\n\r\n        if (returnCode == STATUS_SUCCESS)\r\n        {\r\n            /* Check whether peripheral has protocol clock (functional clock) */\r\n            if ((peripheralFeaturesList[clockName] & (HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_PROTOCOL_CLOCK_FROM_ASYNC2)) != 0U)\r\n            {\r\n                if ((peripheralFeaturesList[clockName] & HAS_PROTOCOL_CLOCK_FROM_ASYNC1) != 0U)\r\n                {\r\n                    /* Check whether the functional clock is clocked */\r\n                    freq = CLOCK_SYS_GetPeripheralClock(clockName, SCG_ASYNC_CLOCK_DIV1);\r\n                }\r\n\r\n                if ((peripheralFeaturesList[clockName] & HAS_PROTOCOL_CLOCK_FROM_ASYNC2) != 0U)\r\n                {\r\n                    /* Check whether the functional clock is clocked */\r\n                    freq = CLOCK_SYS_GetPeripheralClock(clockName, SCG_ASYNC_CLOCK_DIV2);\r\n                }\r\n\r\n                if (freq == 0U)\r\n                {\r\n                    returnCode = STATUS_MCU_GATED_OFF;\r\n                }\r\n            }\r\n            else\r\n            {\r\n#if defined(QuadSPI_INSTANCE_COUNT)\r\n                if (clockName == QSPI0_CLK)\r\n                {\r\n                    freq = CLOCK_SYS_GetQspiIpgClk();\r\n                }\r\n                else\r\n                {\r\n                    freq = interfaceFreq;\r\n                }\r\n#else\r\n                freq = interfaceFreq;\r\n#endif\r\n            }\r\n        }\r\n    }\r\n    (void)interfaceFreq;\r\n\r\n    /* If frequency reference is provided, write this value */\r\n    if (frequency != NULL)\r\n    {\r\n        *frequency = freq;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_DRV_GetFreq\r\n * Description   : This function returns the frequency of a given clock\r\n *\r\n * Implements CLOCK_DRV_GetFreq_Activity\r\n * END**************************************************************************/\r\nstatus_t CLOCK_DRV_GetFreq(clock_names_t clockName,\r\n                           uint32_t * frequency)\r\n{\r\n    status_t returnCode;\r\n\r\n    /* Frequency of the clock name from SCG */\r\n    if (clockName < SCG_END_OF_CLOCKS)\r\n    {\r\n        returnCode = CLOCK_SYS_GetScgClockFreq(clockName, frequency);\r\n    }\r\n    /* Frequency of the clock name from SIM */\r\n    else if (clockName < SIM_END_OF_CLOCKS)\r\n    {\r\n        returnCode = CLOCK_SYS_GetSimClockFreq(clockName, frequency);\r\n    }\r\n    /* Frequency of the clock name from PCC */\r\n    else if (clockName < PCC_END_OF_CLOCKS)\r\n    {\r\n        returnCode = CLOCK_SYS_GetPccClockFreq(clockName, frequency);\r\n    }\r\n    /* Invalid clock name */\r\n    else\r\n    {\r\n        returnCode = STATUS_UNSUPPORTED;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetFtmOptionFreq\r\n * Description   : Internal function used by CLOCK_SYS_GetPeripheralClock function\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_GetFtmOptionFreq(clock_names_t clockName, uint32_t * frequency)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n\r\n    switch (clockName)\r\n    {\r\n        case FTM0_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM0_CLOCKSEL, frequency);\r\n            break;\r\n        case FTM1_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM1_CLOCKSEL, frequency);\r\n            break;\r\n#if FTM_INSTANCE_COUNT > 2U\r\n        case FTM2_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM2_CLOCKSEL, frequency);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 3U\r\n        case FTM3_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM3_CLOCKSEL, frequency);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 4U\r\n        case FTM4_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM4_CLOCKSEL, frequency);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 5U\r\n        case FTM5_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM5_CLOCKSEL, frequency);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 6U\r\n        case FTM6_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM6_CLOCKSEL, frequency);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 7U\r\n        case FTM7_CLK:\r\n            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM7_CLOCKSEL, frequency);\r\n            break;\r\n#endif\r\n        default:\r\n            /* Do nothing */\r\n            break;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetPeripheralClock\r\n * Description   : Internal function used by CLOCK_SYS_GetPccClockFreq function\r\n * END**************************************************************************/\r\n\r\nstatic uint32_t CLOCK_SYS_GetPeripheralClock(clock_names_t clockName,\r\n                                             scg_async_clock_type_t divider)\r\n{\r\n    uint32_t frequency = 0;\r\n    uint32_t fracValue = PCC_GetFracValueSel(PCC, clockName);\r\n    uint32_t divValue = PCC_GetDividerSel(PCC, clockName);\r\n\r\n    /* Check division factor */\r\n    if (((uint32_t)fracValue) <= ((uint32_t)divValue))\r\n    {\r\n        /* Check clock gate */\r\n        if (PCC_GetClockMode(PCC, clockName))\r\n        {\r\n            /* Check clock source */\r\n            switch (PCC_GetClockSourceSel(PCC, clockName))\r\n            {\r\n                case (uint32_t)CLK_SRC_SOSC:\r\n                    frequency = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, divider);\r\n                    break;\r\n                case (uint32_t)CLK_SRC_SIRC:\r\n                    frequency = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, divider);\r\n                    break;\r\n                case (uint32_t)CLK_SRC_FIRC:\r\n                    frequency = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, divider);\r\n                    break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n                case (uint32_t)CLK_SRC_SPLL:\r\n                    frequency = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, divider);\r\n                    break;\r\n#endif\r\n#if FEATURE_HAS_LPO_PERIPHERAL_CLOCK_SOURCE\r\n                case (uint32_t)CLK_SRC_LPO:\r\n                    (void)CLOCK_SYS_GetSimClockFreq(SIM_LPO_CLK, &frequency);\r\n                    divValue = 0U;\r\n                    break;\r\n#endif\r\n                default:\r\n                    (void)CLOCK_SYS_GetFtmOptionFreq(clockName, &frequency);\r\n                    divValue = 0U;\r\n                    break;\r\n            }\r\n\r\n            frequency = frequency / (divValue + 1U);\r\n            frequency = frequency * (fracValue + 1U);\r\n        }\r\n    }\r\n\r\n    return frequency;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetCurrentRunMode\r\n * Description   : Internal function used by CLOCK_SYS_SetScgConfiguration function\r\n * END**************************************************************************/\r\nstatic scg_system_clock_mode_t CLOCK_SYS_GetCurrentRunMode(void)\r\n{\r\n    scg_system_clock_mode_t mode;\r\n\r\n    /* Get the current running mode */\r\n    switch (SMC_GetCurrentRunningMode(SMC))\r\n    {\r\n        /* High speed run mode */\r\n        case HIGH_SPEED_RUNNING_MODE:\r\n            mode = SCG_SYSTEM_CLOCK_MODE_HSRUN;\r\n            break;\r\n        /* Run mode */\r\n        case RUN_SPEED_RUNNING_MODE:\r\n            mode = SCG_SYSTEM_CLOCK_MODE_RUN;\r\n            break;\r\n        /* Very low power run mode */\r\n        case VLPR_SPEED_RUNNING_MODE:\r\n            mode = SCG_SYSTEM_CLOCK_MODE_VLPR;\r\n            break;\r\n        /* This should never happen - core has to be in some run mode to execute code */\r\n        default:\r\n            mode = SCG_SYSTEM_CLOCK_MODE_NONE;\r\n            break;\r\n    }\r\n\r\n    return mode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_TransitionSystemClock\r\n * Description   : Internal function used by CLOCK_SYS_ConfigureTemporarySystemClock and\r\n * CLOCK_SYS_ConfigureModulesFromScg functions\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_TransitionSystemClock(const scg_system_clock_config_t * to_clk)\r\n{\r\n    scg_system_clock_mode_t run_mode;\r\n    status_t retValue = STATUS_SUCCESS;\r\n    uint32_t timeout;\r\n\r\n    /* Check destination clock */\r\n    DEV_ASSERT(to_clk != NULL);\r\n    DEV_ASSERT(to_clk->src != SCG_SYSTEM_CLOCK_SRC_NONE);\r\n\r\n    /* Get & Convert Run mode from SMC to SCG defines*/\r\n    run_mode = CLOCK_SYS_GetCurrentRunMode();\r\n\r\n    /* Check the current mode */\r\n    DEV_ASSERT(run_mode != SCG_SYSTEM_CLOCK_MODE_NONE);\r\n\r\n    /* Update run mode configuration */\r\n    retValue = CLOCK_SYS_SetSystemClockConfig(run_mode, to_clk);\r\n\r\n    if (retValue == STATUS_SUCCESS)\r\n    {\r\n        /* Wait for system clock to transition. */\r\n#ifdef ERRATA_E10777\r\n        timeout = 10U;\r\n#else\r\n        timeout = 1U;\r\n#endif\r\n\r\n        do\r\n        {\r\n            timeout--;\r\n        }\r\n        while ((SCG_GetCurrentSystemClockSource(SCG) != ((uint32_t)to_clk->src)) && (timeout > 0U));\r\n\r\n        if (timeout == 0U)\r\n        {\r\n            retValue = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return retValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSimClkOutFreq\r\n * Description   : Internal function used by CLOCK_SYS_GetFreq function\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSimClkOutFreq(void)\r\n{\r\n    uint32_t frequency;\r\n\r\n    if (SIM_GetClockoutStatus(SIM))\r\n    {\r\n        switch (SIM_GetClockoutSelectorValue(SIM))\r\n        {\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT):\r\n                frequency = CLOCK_SYS_GetScgClkOutFreq();\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_SOSC_DIV2_CLK):\r\n                frequency = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_SIRC_DIV2_CLK):\r\n                frequency = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_FIRC_DIV2_CLK):\r\n                frequency = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_HCLK):\r\n                frequency = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);\r\n                break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_SPLL_DIV2_CLK):\r\n                frequency = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV2);\r\n                break;\r\n#endif\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_BUS_CLK):\r\n                frequency = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_LPO_128K_CLK):\r\n                frequency = LPO_128K_FREQUENCY;\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_LPO_CLK):\r\n                frequency = CLOCK_SYS_GetLpoFreq();\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_RTC_CLK):\r\n                frequency = CLOCK_SYS_GetSimRtcClkFreq();\r\n                break;\r\n#ifdef QuadSPI_INSTANCE_COUNT\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_SFIF_CLK_HYP):\r\n                frequency = CLOCK_SYS_GetQspiSfifClkHyp();\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_IPG_CLK):\r\n                frequency = CLOCK_SYS_GetQspiIpgClk();\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_IPG_CLK_SFIF):\r\n                frequency = CLOCK_SYS_GetQspiIpgClkSfif();\r\n                break;\r\n            case ((uint32_t)SIM_CLKOUT_SEL_SYSTEM_IPG_CLK_2XSFIF):\r\n                frequency = CLOCK_SYS_GetQspiIpgClk2Xsfif();\r\n                break;\r\n#endif\r\n            default:\r\n                /* Invalid SIM CLKOUT selection.*/\r\n                frequency = 0U;\r\n                break;\r\n        }\r\n\r\n        /* Apply Divide Ratio */\r\n        frequency /= (SIM_GetClockoutDividerValue(SIM) + 1U);\r\n    }\r\n    else\r\n    {\r\n        /* Output disabled. */\r\n        frequency = 0U;\r\n    }\r\n\r\n    return frequency;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetScgClkOutFreq\r\n * Description   : Internal function used by CLOCK_SYS_GetFreq function\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetScgClkOutFreq(void)\r\n{\r\n    uint32_t frequency;\r\n\r\n    switch (SCG_GetClockoutSourceSel(SCG))\r\n    {\r\n        case ((uint32_t)SCG_CLOCKOUT_SRC_SCG_SLOW):\r\n            frequency = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_SLOW);\r\n            break;\r\n        case ((uint32_t)SCG_CLOCKOUT_SRC_SOSC):\r\n            frequency = CLOCK_SYS_GetSysOscFreq();\r\n            break;\r\n        case ((uint32_t)SCG_CLOCKOUT_SRC_SIRC):\r\n            frequency = CLOCK_SYS_GetSircFreq();\r\n            break;\r\n        case ((uint32_t)SCG_CLOCKOUT_SRC_FIRC):\r\n            frequency = CLOCK_SYS_GetFircFreq();\r\n            break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case ((uint32_t)SCG_CLOCKOUT_SRC_SPLL):\r\n            frequency = CLOCK_SYS_GetSysPllFreq();\r\n            break;\r\n#endif\r\n        default:\r\n            /* Invalid SCG CLKOUT selection.*/\r\n            frequency = 0U;\r\n            break;\r\n    }\r\n\r\n    return frequency;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSimRtcClkFreq\r\n * Description   : Internal function used by CLOCK_SYS_GetFreq function\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSimRtcClkFreq()\r\n{\r\n    uint32_t frequency;\r\n\r\n    /* Check RTCCLK Select */\r\n    switch (SIM_GetRtcClkSrc(SIM))\r\n    {\r\n        case ((uint32_t)SIM_RTCCLK_SEL_SOSCDIV1_CLK):\r\n            frequency = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n            break;\r\n        case ((uint32_t)SIM_RTCCLK_SEL_LPO_32K):\r\n            frequency = SIM_GetLpo32KStatus(SIM) ? LPO_32K_FREQUENCY : 0UL;\r\n            break;\r\n        case ((uint32_t)SIM_RTCCLK_SEL_RTC_CLKIN):\r\n            frequency = g_RtcClkInFreq;\r\n            break;\r\n        case ((uint32_t)SIM_RTCCLK_SEL_FIRCDIV1_CLK):\r\n            frequency = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV1);\r\n            break;\r\n        default:\r\n            /* Invalid RTCCLK selection.*/\r\n            frequency = 0U;\r\n            break;\r\n    }\r\n\r\n    return frequency;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConfigureSIRC\r\n * Description   : Configures SIRC module based on provided configuration.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_ConfigureSIRC(bool enable, const scg_sirc_config_t * sircConfig)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    scg_sirc_config_t sircDefaultConfig;\r\n    const scg_sirc_config_t * sircCfg;\r\n    uint32_t timeout;\r\n\r\n    if (sircConfig == NULL)\r\n    {\r\n        sircDefaultConfig.enableInStop      = false;\r\n        sircDefaultConfig.enableInLowPower  = true;\r\n        sircDefaultConfig.locked            = false;\r\n\r\n        sircDefaultConfig.div1              = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n        sircDefaultConfig.div2              = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n\r\n        sircDefaultConfig.range             = SCG_SIRC_RANGE_HIGH;\r\n\r\n        sircCfg = &sircDefaultConfig;\r\n    }\r\n    else\r\n    {\r\n        sircCfg = sircConfig;\r\n    }\r\n\r\n    /* If clock is used by system, return error. */\r\n    if (SCG_GetSircSystemClockMode(SCG))\r\n    {\r\n        status = STATUS_BUSY;\r\n    }\r\n    /* Disable SIRC */\r\n    else\r\n    {\r\n        /* Clear LK bit field */\r\n        SCG_ClearSircLock(SCG);\r\n\r\n        /* Disable monitor, disable clock and clear error. */\r\n        SCG_ClearSircControl(SCG);\r\n    }\r\n\r\n    /* Configure SIRC. */\r\n    if (enable  && (status == STATUS_SUCCESS))\r\n    {\r\n        /* Now start to set up SIRC clock. */\r\n        /* Step 1. Setup dividers. */\r\n        SCG_SetSircAsyncConfig(SCG, sircCfg->div1, sircCfg->div2);\r\n\r\n        /* Step 2. Set SIRC configuration: frequency range. */\r\n        SCG_SetSircConfiguration(SCG, sircCfg->range);\r\n\r\n        /* Step 3. Set SIRC control: enable clock, configure source in STOP and VLP modes, configure lock feature. */\r\n        SCG_SetSircControl(SCG, sircCfg->enableInStop, sircCfg->enableInLowPower, sircCfg->locked);\r\n\r\n        /* Wait for SIRC to initialize */\r\n        timeout = SIRC_STABILIZATION_TIMEOUT;\r\n        while ((CLOCK_SYS_GetSircFreq() == 0U) && (timeout > 0U))\r\n        {\r\n            timeout--;\r\n        }\r\n\r\n        if (timeout == 0U)\r\n        {\r\n            status = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConfigureFIRC\r\n * Description   : Configures FIRC module based on provided configuration.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_ConfigureFIRC(bool enable, const scg_firc_config_t * fircConfig)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    scg_firc_config_t fircDefaultConfig;\r\n    const scg_firc_config_t * fircCfg;\r\n    uint32_t timeout;\r\n\r\n    if (fircConfig == NULL)\r\n    {\r\n        fircDefaultConfig.regulator         = true;\r\n        fircDefaultConfig.locked            = false;\r\n\r\n        fircDefaultConfig.div1              = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n        fircDefaultConfig.div2              = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n\r\n        fircDefaultConfig.range             = SCG_FIRC_RANGE_48M;\r\n\r\n        fircCfg = &fircDefaultConfig;\r\n    }\r\n    else\r\n    {\r\n        fircCfg = fircConfig;\r\n    }\r\n\r\n    /* If clock is used by system, return error. */\r\n    if (SCG_GetFircSystemClockMode(SCG))\r\n    {\r\n        status = STATUS_BUSY;\r\n    }\r\n    /* Disable FIRC */\r\n    else\r\n    {\r\n        /* Clear LK bit field */\r\n        SCG_ClearFircLock(SCG);\r\n\r\n        /* Disable monitor, disable clock and clear error. */\r\n        SCG_ClearFircControl(SCG);\r\n    }\r\n\r\n    /* Configure FIRC. */\r\n    if (enable && (status == STATUS_SUCCESS))\r\n    {\r\n        /* Now start to set up FIRC clock. */\r\n        /* Step 1. Setup dividers. */\r\n        SCG_SetFircAsyncConfig(SCG, fircCfg->div1, fircCfg->div2);\r\n\r\n        /* Step 2. Set FIRC configuration. */\r\n        SCG_SetFircConfiguration(SCG, fircCfg->range);\r\n\r\n        /* Step 3. Enable clock, config regulator and locking feature. */\r\n        SCG_SetFircControl(SCG, fircCfg->regulator, fircCfg->locked);\r\n\r\n        /* Wait for FIRC to initialize */\r\n        timeout = FIRC_STABILIZATION_TIMEOUT;\r\n        while ((CLOCK_SYS_GetFircFreq() == 0U) && (timeout > 0U))\r\n        {\r\n            timeout--;\r\n        }\r\n\r\n        if (timeout == 0U)\r\n        {\r\n            status = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConfigureSOSC\r\n * Description   : Configures SOSC module based on provided configuration.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_ConfigureSOSC(bool enable, const scg_sosc_config_t * soscConfig)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    scg_sosc_config_t soscDefaultConfig;\r\n    const scg_sosc_config_t * soscCfg;\r\n    uint32_t timeout;\r\n\r\n    if (soscConfig == NULL)\r\n    {\r\n        soscDefaultConfig.monitorMode       = SCG_SOSC_MONITOR_DISABLE;\r\n        soscDefaultConfig.locked            = false;\r\n\r\n        soscDefaultConfig.div1              = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n        soscDefaultConfig.div2              = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n\r\n        soscDefaultConfig.extRef            = SCG_SOSC_REF_OSC;\r\n        soscDefaultConfig.gain              = SCG_SOSC_GAIN_LOW;\r\n        soscDefaultConfig.range             = SCG_SOSC_RANGE_MID;\r\n\r\n        soscDefaultConfig.freq              = 8000000U;\r\n\r\n        soscCfg = &soscDefaultConfig;\r\n    }\r\n    else\r\n    {\r\n        soscCfg = soscConfig;\r\n    }\r\n\r\n    /* If clock is used by system, return error. */\r\n    if (SCG_GetSoscSystemClockMode(SCG))\r\n    {\r\n        status = STATUS_BUSY;\r\n    }\r\n    /* Disable SOSC */\r\n    else\r\n    {\r\n        /* Clear LK bit field */\r\n        SCG_ClearSoscLock(SCG);\r\n\r\n        /* Disable monitor, disable clock and clear error. */\r\n        SCG_ClearSoscControl(SCG);\r\n\r\n        g_xtal0ClkFreq = 0U;\r\n    }\r\n\r\n    /* Configure SOSC. */\r\n    if (enable && (status == STATUS_SUCCESS))\r\n    {\r\n        /* Now start to set up OSC clock. */\r\n        /* Step 1. Setup dividers. */\r\n        SCG_SetSoscAsyncConfig(SCG, soscCfg->div1, soscCfg->div2);\r\n\r\n        /* Step 2. Set OSC configuration. */\r\n        SCG_SetSoscConfiguration(SCG, soscCfg->range, soscCfg->gain, soscCfg->extRef);\r\n\r\n        /* Step 3. Enable clock, configure monitor, lock register. */\r\n        switch (soscCfg->monitorMode)\r\n        {\r\n            case SCG_SOSC_MONITOR_DISABLE:\r\n            {\r\n                SCG_SetSoscControl(SCG, false, false, soscCfg->locked);\r\n            }\r\n            break;\r\n            case SCG_SOSC_MONITOR_INT:\r\n            {\r\n                SCG_SetSoscControl(SCG, true, false, soscCfg->locked);\r\n            }\r\n            break;\r\n            case SCG_SOSC_MONITOR_RESET:\r\n            {\r\n                SCG_SetSoscControl(SCG, true, true, soscCfg->locked);\r\n            }\r\n            break;\r\n            default:\r\n                /* Invalid monitor mode */\r\n                DEV_ASSERT(false);\r\n                break;\r\n        }\r\n\r\n        g_xtal0ClkFreq = soscCfg->freq;\r\n\r\n        /* Wait for System OSC to initialize */\r\n        timeout = SOSC_STABILIZATION_TIMEOUT;\r\n        while ((CLOCK_SYS_GetSysOscFreq() == 0U) && (timeout > 0U))\r\n        {\r\n            timeout--;\r\n        }\r\n\r\n        if (timeout == 0U)\r\n        {\r\n            status = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConfigureSPLL\r\n * Description   : Configures SPLL module based on provided configuration.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_ConfigureSPLL(bool enable, const scg_spll_config_t * spllConfig)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    scg_spll_config_t spllDefaultConfig;\r\n    const scg_spll_config_t * spllCfg;\r\n    uint32_t srcFreq, timeout;\r\n\r\n    if (spllConfig == NULL)\r\n    {\r\n        spllDefaultConfig.monitorMode    = SCG_SPLL_MONITOR_DISABLE;\r\n        spllDefaultConfig.locked         = false;\r\n\r\n        spllDefaultConfig.div1           = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n        spllDefaultConfig.div2           = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n\r\n        spllDefaultConfig.prediv         = 0;\r\n        spllDefaultConfig.mult           = 7;\r\n        spllDefaultConfig.src            = 0;\r\n\r\n        spllCfg = &spllDefaultConfig;\r\n    }\r\n    else\r\n    {\r\n        spllCfg = spllConfig;\r\n    }\r\n\r\n    /* If clock is used by system, return error. */\r\n    if (SCG_GetSpllSystemClockMode(SCG))\r\n    {\r\n        status = STATUS_BUSY;\r\n    }\r\n    /* Disable the SPLL. */\r\n    else\r\n    {\r\n        /* Clear LK bit field */\r\n        SCG_ClearSpllLock(SCG);\r\n\r\n        /* Disable monitor, disable clock and clear error. */\r\n        SCG_ClearSpllControl(SCG);\r\n    }\r\n\r\n    /* Configure SPLL. */\r\n    if (enable && (status == STATUS_SUCCESS))\r\n    {\r\n        /* Get clock source frequency. */\r\n#ifdef SCG_SPLLCFG_SOURCE_MASK\r\n        switch (SCG_GetSourcSpll(SCG))\r\n        {\r\n            case 0U:\r\n                srcFreq = CLOCK_SYS_GetSysOscFreq();\r\n            break;\r\n            case 1U:\r\n                srcFreq = CLOCK_SYS_GetFircFreq();\r\n            break;\r\n            default:\r\n                srcFreq = 0U;\r\n            break;\r\n        }\r\n#else\r\n        srcFreq = CLOCK_SYS_GetSysOscFreq();\r\n#endif\r\n        DEV_ASSERT(srcFreq != 0U);\r\n\r\n        /* Pre-divider checking. */\r\n        srcFreq /= (((uint32_t)spllCfg->prediv) + SCG_SPLL_PREDIV_BASE);\r\n        DEV_ASSERT((srcFreq >= SCG_SPLL_REF_MIN) && (srcFreq <= SCG_SPLL_REF_MAX));\r\n        /* Now start to set up PLL clock. */\r\n#ifdef SCG_SPLLCFG_SOURCE_MASK\r\n        SCG_SetSourceSpll(SCG, spllCfg->src);\r\n#endif\r\n        SCG_SetSpllAsyncConfig(SCG, spllCfg->div1, spllCfg->div2);\r\n\r\n        /* Step 2. Set PLL configuration. */\r\n        SCG_SetSpllConfiguration(SCG, spllCfg->prediv, spllCfg->mult);\r\n\r\n        /* Step 3. Enable clock, configure monitor, lock register. */\r\n        switch (spllCfg->monitorMode)\r\n        {\r\n            case SCG_SPLL_MONITOR_DISABLE:\r\n            {\r\n                SCG_SetSpllControl(SCG, false, false, spllCfg->locked);\r\n            }\r\n            break;\r\n            case SCG_SPLL_MONITOR_INT:\r\n            {\r\n                SCG_SetSpllControl(SCG, true, false, spllCfg->locked);\r\n            }\r\n            break;\r\n            case SCG_SPLL_MONITOR_RESET:\r\n            {\r\n                SCG_SetSpllControl(SCG, true, true, spllCfg->locked);\r\n            }\r\n            break;\r\n            default:\r\n                /* Invalid monitor mode */\r\n                DEV_ASSERT(false);\r\n                break;\r\n        }\r\n\r\n        /* Wait for System PLL to initialize */\r\n        timeout = SPLL_STABILIZATION_TIMEOUT;\r\n        while ((CLOCK_SYS_GetSysPllFreq() == 0U) && (timeout > 0U))\r\n        {\r\n            timeout--;\r\n        }\r\n\r\n        if (timeout == 0U)\r\n        {\r\n            status = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConfigureTemporarySystemClock\r\n * Description   : Configures and transitions to a temporary system clock source: FIRC\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_ConfigureTemporarySystemClock(void)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    scg_system_clock_config_t sysClockConfig;\r\n    static const scg_system_clock_div_t tmpSysClk[TMP_SYS_CLK_NO][TMP_SYS_DIV_NO] = TMP_SYSTEM_CLOCK_CONFIGS;\r\n\r\n    /* If the current system clock source is not FIRC:\r\n     * 1. Enable FIRC (if it's not enabled)\r\n     * 2. Switch to FIRC.\r\n     */\r\n    if (SCG_GetCurrentSystemClockSource(SCG) != ((uint32_t)SCG_SYSTEM_CLOCK_SRC_FIRC))\r\n    {\r\n        /* If FIRC is not on, then FIRC is configured\r\n         * with the default configuration */\r\n        if (CLOCK_SYS_GetFircFreq() == 0UL)\r\n        {\r\n            status = CLOCK_SYS_ConfigureFIRC(true, NULL);\r\n        }\r\n\r\n        /* FIRC is enabled, transition the system clock source to FIRC. */\r\n        if (status == STATUS_SUCCESS)\r\n        {\r\n            sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_FIRC;\r\n            sysClockConfig.divCore = tmpSysClk[TMP_FIRC_CLK][TMP_SYS_DIV];\r\n            sysClockConfig.divBus  = tmpSysClk[TMP_FIRC_CLK][TMP_BUS_DIV];\r\n            sysClockConfig.divSlow = tmpSysClk[TMP_FIRC_CLK][TMP_SLOW_DIV];\r\n            status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConfigureModulesFromScg\r\n * Description   : Configures all modules from SCG (SIRC, FIRC, SOSC and SPLL)\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_ConfigureModulesFromScg(const scg_config_t * scgConfig)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    scg_system_clock_config_t sysClockConfig;\r\n    const scg_system_clock_config_t * nextSysClockConfig;\r\n    static const scg_system_clock_div_t tmpSysClk[TMP_SYS_CLK_NO][TMP_SYS_DIV_NO] = TMP_SYSTEM_CLOCK_CONFIGS;\r\n\r\n    /* Configure all clock sources that are different from the\r\n     * current system clock source FIRC (SIRC, SOSC, SPLL). */\r\n    status = CLOCK_SYS_ConfigureSIRC(scgConfig->sircConfig.initialize, &scgConfig->sircConfig);\r\n    if (status == STATUS_SUCCESS)\r\n    {\r\n        status = CLOCK_SYS_ConfigureSOSC(scgConfig->soscConfig.initialize, &scgConfig->soscConfig);\r\n#if FEATURE_HAS_SPLL_CLK\r\n        if (status == STATUS_SUCCESS)\r\n        {\r\n            status = CLOCK_SYS_ConfigureSPLL(scgConfig->spllConfig.initialize,&scgConfig->spllConfig);\r\n        }\r\n#endif\r\n    }\r\n\r\n    /* Get the next system clock source */\r\n    switch (CLOCK_SYS_GetCurrentRunMode())\r\n    {\r\n        case SCG_SYSTEM_CLOCK_MODE_RUN:\r\n        {\r\n            nextSysClockConfig = &scgConfig->clockModeConfig.rccrConfig;\r\n        }\r\n        break;\r\n        case SCG_SYSTEM_CLOCK_MODE_VLPR:\r\n        {\r\n            nextSysClockConfig = &scgConfig->clockModeConfig.vccrConfig;\r\n        }\r\n        break;\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n        case SCG_SYSTEM_CLOCK_MODE_HSRUN:\r\n        {\r\n            nextSysClockConfig = &scgConfig->clockModeConfig.hccrConfig;\r\n        }\r\n        break;\r\n#endif\r\n        default:\r\n            DEV_ASSERT(false);\r\n            nextSysClockConfig = NULL;\r\n            break;\r\n    }\r\n\r\n    if (status == STATUS_SUCCESS)\r\n    {\r\n        /* The current system clock source is FIRC.\r\n         * Verify whether the next system clock source is FIRC. */\r\n        if (nextSysClockConfig->src == SCG_SYSTEM_CLOCK_SRC_FIRC)\r\n        {\r\n            /* If they are the same, search for a temporary system clock source\r\n             * (use one of the following sources: SPLL, SOSC, SIRC)\r\n             * Assume that a temporary clock is not found status = ERROR. */\r\n            status = STATUS_ERROR;\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n            /* SPLL is enabled */\r\n            if (scgConfig->spllConfig.initialize && (status == STATUS_ERROR))\r\n            {\r\n                sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;\r\n                sysClockConfig.divCore = tmpSysClk[TMP_SPLL_CLK][TMP_SYS_DIV];\r\n                sysClockConfig.divBus  = tmpSysClk[TMP_SPLL_CLK][TMP_BUS_DIV];\r\n                sysClockConfig.divSlow = tmpSysClk[TMP_SPLL_CLK][TMP_SLOW_DIV];\r\n                status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n            }\r\n#endif\r\n\r\n            /* SOSC is enabled and SPLL configuration for system clock source is not valid */\r\n            if (scgConfig->soscConfig.initialize && (status == STATUS_ERROR))\r\n            {\r\n                sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_OSC;\r\n                sysClockConfig.divCore = tmpSysClk[TMP_SOSC_CLK][TMP_SYS_DIV];\r\n                sysClockConfig.divBus  = tmpSysClk[TMP_SOSC_CLK][TMP_BUS_DIV];\r\n                sysClockConfig.divSlow = tmpSysClk[TMP_SOSC_CLK][TMP_SLOW_DIV];\r\n                status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n            }\r\n\r\n\r\n            /* SIRC is enabled and SOSC configuration for system clock source is not valid */\r\n            if (scgConfig->sircConfig.initialize && (status == STATUS_ERROR))\r\n            {\r\n                sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SIRC;\r\n                sysClockConfig.divCore = tmpSysClk[TMP_SIRC_CLK][TMP_SYS_DIV];\r\n                sysClockConfig.divBus  = tmpSysClk[TMP_SIRC_CLK][TMP_BUS_DIV];\r\n                sysClockConfig.divSlow = tmpSysClk[TMP_SIRC_CLK][TMP_SLOW_DIV];\r\n                status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n            }\r\n\r\n            /* Transitioned to a temporary system clock source. */\r\n            if (status == STATUS_SUCCESS)\r\n            {\r\n                /* Configure the remaining clock source (FIRC). */\r\n                status = CLOCK_SYS_ConfigureFIRC(scgConfig->fircConfig.initialize, &scgConfig->fircConfig);\r\n\r\n                if (status == STATUS_SUCCESS)\r\n                {\r\n                    /* Transition to the next system clock source. */\r\n                    sysClockConfig.src     = nextSysClockConfig->src;\r\n                    sysClockConfig.divCore = nextSysClockConfig->divCore;\r\n                    sysClockConfig.divBus  = nextSysClockConfig->divBus;\r\n                    sysClockConfig.divSlow = nextSysClockConfig->divSlow;\r\n                    status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {   /* Transition to the next system clock source. */\r\n            sysClockConfig.src     = nextSysClockConfig->src;\r\n            sysClockConfig.divCore = nextSysClockConfig->divCore;\r\n            sysClockConfig.divBus  = nextSysClockConfig->divBus;\r\n            sysClockConfig.divSlow = nextSysClockConfig->divSlow;\r\n            status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n\r\n            if (status == STATUS_SUCCESS)\r\n            {\r\n                /* Configure the remaining clock source (FIRC) */\r\n                status = CLOCK_SYS_ConfigureFIRC(scgConfig->fircConfig.initialize, &scgConfig->fircConfig);\r\n            }\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSystemClockFreq\r\n * Description   : This function gets the SCG system clock frequency, these\r\n * clocks are used for core, platform, external and bus clock domains.\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSystemClockFreq(scg_system_clock_type_t type)\r\n{\r\n    uint32_t freq;\r\n\r\n\r\n    DEV_ASSERT(type < SCG_SYSTEM_CLOCK_MAX);\r\n\r\n    switch (SCG_GetCurrentSystemClockSource(SCG))\r\n    {\r\n        case ((uint32_t)SCG_SYSTEM_CLOCK_SRC_SYS_OSC):\r\n            freq = CLOCK_SYS_GetSysOscFreq();\r\n            break;\r\n        case ((uint32_t)SCG_SYSTEM_CLOCK_SRC_SIRC):\r\n            freq = CLOCK_SYS_GetSircFreq();\r\n            break;\r\n        case ((uint32_t)SCG_SYSTEM_CLOCK_SRC_FIRC):\r\n            freq = CLOCK_SYS_GetFircFreq();\r\n            break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case ((uint32_t)SCG_SYSTEM_CLOCK_SRC_SYS_PLL):\r\n            freq = CLOCK_SYS_GetSysPllFreq();\r\n            break;\r\n#endif\r\n        default:\r\n            freq = 0U;\r\n            break;\r\n    }\r\n\r\n    freq /= (SCG_GetCurrentCoreClockDividerRatio(SCG) + 1U);\r\n\r\n    switch (type)\r\n    {\r\n        case SCG_SYSTEM_CLOCK_CORE:\r\n            /* Intentionally left blank */\r\n            break;\r\n        case SCG_SYSTEM_CLOCK_BUS:\r\n            freq /= (SCG_GetCurrentBusClockDividerRatio(SCG) + 1U);\r\n            break;\r\n        case SCG_SYSTEM_CLOCK_SLOW:\r\n            freq /= (SCG_GetCurrentSlowClockDividerRatio(SCG) + 1U);\r\n            break;\r\n        default:\r\n            freq = 0U;\r\n            break;\r\n    }\r\n\r\n    return freq;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSrcFreq\r\n * Description   : Gets source frequency.\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSrcFreq(scg_system_clock_src_t src)\r\n{\r\n    uint32_t srcFreq = 0U;\r\n\r\n    switch (src)\r\n    {\r\n        case SCG_SYSTEM_CLOCK_SRC_SYS_OSC:\r\n            srcFreq = CLOCK_SYS_GetSysOscFreq();\r\n            break;\r\n        case SCG_SYSTEM_CLOCK_SRC_SIRC:\r\n            srcFreq = CLOCK_SYS_GetSircFreq();\r\n            break;\r\n        case SCG_SYSTEM_CLOCK_SRC_FIRC:\r\n            srcFreq = CLOCK_SYS_GetFircFreq();\r\n            break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case SCG_SYSTEM_CLOCK_SRC_SYS_PLL:\r\n            srcFreq = CLOCK_SYS_GetSysPllFreq();\r\n            break;\r\n#endif\r\n        default:\r\n            srcFreq = 0U;\r\n            break;\r\n    }\r\n\r\n    return srcFreq;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_SetSystemClockConfig\r\n * Description   : This function sets the system configuration for the specified mode.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_SetSystemClockConfig(scg_system_clock_mode_t mode,\r\n                                               scg_system_clock_config_t const * config)\r\n{\r\n    status_t status = STATUS_SUCCESS;\r\n    uint32_t srcFreq = 0U;\r\n\r\n    /* The maximum clock frequencies of system clocks in all power modes */\r\n    static const uint32_t maxSysClksInVLPR[MODES_MAX_NO][SYS_CLK_MAX_NO]  = CLOCK_MAX_FREQUENCIES_VLPR_MODE;\r\n    static const uint32_t maxSysClksInRUN[MODES_MAX_NO][SYS_CLK_MAX_NO]   = CLOCK_MAX_FREQUENCIES_RUN_MODE;\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n    static const uint32_t maxSysClksInHSRUN[MODES_MAX_NO][SYS_CLK_MAX_NO] = CLOCK_MAX_FREQUENCIES_HSRUN_MODE;\r\n#endif\r\n    const uint32_t sysFreqMul = ((uint32_t)config->divCore) + 1UL;\r\n    const uint32_t busFreqMul = (((uint32_t)config->divCore) + 1UL) * (((uint32_t)config->divBus) + 1UL);\r\n    const uint32_t slowFreqMul = (((uint32_t)config->divCore) + 1UL) * (((uint32_t)config->divSlow) + 1UL);\r\n\r\n    DEV_ASSERT(mode != SCG_SYSTEM_CLOCK_MODE_CURRENT);\r\n\r\n    srcFreq = CLOCK_SYS_GetSrcFreq(config->src);\r\n    srcFreq >>= 4U;\r\n\r\n    switch (mode)\r\n    {\r\n        case SCG_SYSTEM_CLOCK_MODE_RUN:       /*!< Run mode.                */\r\n            /* Verify the frequencies of sys, bus and slow clocks. */\r\n            if ((srcFreq > (sysFreqMul  * (maxSysClksInRUN[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */\r\n                (srcFreq > (busFreqMul  * (maxSysClksInRUN[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */\r\n                (srcFreq > (slowFreqMul * (maxSysClksInRUN[(uint32_t)config->src][SLOW_CLK_INDEX] >> 4U))))      /* Slow clock */\r\n            {\r\n                /* Configuration for the next system clock source is not valid. */\r\n                status = STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                SCG_SetRunClockControl(SCG, (uint32_t)config->src, (uint32_t)config->divCore, (uint32_t)config->divBus, (uint32_t)config->divSlow);\r\n            }\r\n            break;\r\n        case SCG_SYSTEM_CLOCK_MODE_VLPR:      /*!< Very Low Power Run mode. */\r\n            DEV_ASSERT(SCG_SYSTEM_CLOCK_SRC_SIRC    == config->src);\r\n            /* Verify the frequencies of sys, bus and slow clocks. */\r\n            if ((srcFreq > (sysFreqMul  * (maxSysClksInVLPR[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */\r\n                (srcFreq > (busFreqMul  * (maxSysClksInVLPR[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */\r\n                (srcFreq > (slowFreqMul * (maxSysClksInVLPR[(uint32_t)config->src][SLOW_CLK_INDEX] >> 4U))))      /* Slow clock */\r\n            {\r\n                /* Configuration for the next system clock source is not valid. */\r\n                status = STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                SCG_SetVlprClockControl(SCG, (uint32_t)config->src, (uint32_t)config->divCore, (uint32_t)config->divBus, (uint32_t)config->divSlow);\r\n            }\r\n            break;\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n        case SCG_SYSTEM_CLOCK_MODE_HSRUN:     /*!< High Speed Run mode.     */\r\n            DEV_ASSERT((SCG_SYSTEM_CLOCK_SRC_FIRC == config->src) || ( SCG_SYSTEM_CLOCK_SRC_SYS_PLL == config->src));\r\n            /* Verify the frequencies of sys, bus and slow clocks. */\r\n            if ((srcFreq > (sysFreqMul  * (maxSysClksInHSRUN[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */\r\n                (srcFreq > (busFreqMul * (maxSysClksInHSRUN[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */\r\n                (srcFreq > (slowFreqMul * (maxSysClksInHSRUN[(uint32_t)config->src][SLOW_CLK_INDEX] >> 4U))))      /* Slow clock */\r\n            {\r\n                /* Configuration for the next system clock source is not valid. */\r\n                status = STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                SCG_SetHsrunClockControl(SCG, (uint32_t)config->src, (uint32_t)config->divCore, (uint32_t)config->divBus, (uint32_t)config->divSlow);\r\n            }\r\n            break;\r\n#endif\r\n        default:\r\n            /* Invalid mode */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSysAsyncFreq\r\n * Description   : Gets SCG asynchronous clock frequency from a clock source.\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSysAsyncFreq(clock_names_t clockSource,\r\n                                          scg_async_clock_type_t type)\r\n{\r\n    uint32_t freq, div = 0U;\r\n\r\n    switch (type)\r\n    {\r\n        case SCG_ASYNC_CLOCK_DIV1:\r\n        {\r\n            switch (clockSource)\r\n            {\r\n                case FIRC_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetFircFreq();\r\n                    div = SCG_GetFircFirstAsyncDivider(SCG);\r\n                }\r\n                break;\r\n                case SIRC_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetSircFreq();\r\n                    div = SCG_GetSircFirstAsyncDivider(SCG);\r\n                }\r\n                break;\r\n                case SOSC_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetSysOscFreq();\r\n                    div = SCG_GetSoscFirstAsyncDivider(SCG);\r\n                }\r\n                break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n                case SPLL_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetSysPllFreq();\r\n                    div = SCG_GetSpllFirstAsyncDivider(SCG);\r\n                }\r\n                break;\r\n#endif\r\n                default:\r\n                {\r\n                    /* Invalid clock source type */\r\n                    freq = 0U;\r\n                    DEV_ASSERT(false);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        break;\r\n        case SCG_ASYNC_CLOCK_DIV2:\r\n        {\r\n            switch (clockSource)\r\n            {\r\n                case FIRC_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetFircFreq();\r\n                    div = SCG_GetFircSecondAsyncDivider(SCG);\r\n                }\r\n                break;\r\n                case SIRC_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetSircFreq();\r\n                    div = SCG_GetSircSecondAsyncDivider(SCG);\r\n                }\r\n                break;\r\n                case SOSC_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetSysOscFreq();\r\n                    div = SCG_GetSoscSecondAsyncDivider(SCG);\r\n                }\r\n                break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n                case SPLL_CLK:\r\n                {\r\n                    freq = CLOCK_SYS_GetSysPllFreq();\r\n                    div = SCG_GetSpllSecondAsyncDivider(SCG);\r\n                }\r\n                break;\r\n#endif\r\n                default:\r\n                {\r\n                    /* Invalid clock source type */\r\n                    freq = 0U;\r\n                    DEV_ASSERT(false);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        break;\r\n        default:\r\n            /* Invalid async clock source */\r\n            freq = 0U;\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n\r\n    if (div != 0U)\r\n    {\r\n        freq = (freq >> (div - 1U));\r\n    }\r\n    else  /* Output disabled. */\r\n    {\r\n        freq = 0U;\r\n    }\r\n\r\n    return freq;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSysOscFreq\r\n * Description   : Gets SCG System OSC clock frequency (SYSOSC).\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSysOscFreq(void)\r\n{\r\n    uint32_t retValue;\r\n    if (SCG_GetSoscStatus(SCG)) /* System OSC clock is valid. */\r\n    {\r\n        retValue = g_xtal0ClkFreq;\r\n    }\r\n    else\r\n    {\r\n        retValue = 0U;\r\n    }\r\n\r\n    return retValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSircFreq\r\n * Description   : Gets SCG Slow IRC clock frequency (SIRC).\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSircFreq(void)\r\n{\r\n    uint32_t retValue = 0U;\r\n\r\n    if (SCG_GetSircStatus(SCG)) /* SIRC is valid. */\r\n    {\r\n        if (SCG_GetSircRange(SCG) != 0U)\r\n        {\r\n            retValue = FEATURE_SCG_SIRC_HIGH_RANGE_FREQ;\r\n        }\r\n    }\r\n\r\n    return retValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetFircFreq\r\n * Description   : Gets SCG Fast IRC clock frequency (FIRC).\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetFircFreq(void)\r\n{\r\n    uint32_t retValue;\r\n\r\n    static const uint32_t fircFreq[] = {\r\n        FEATURE_SCG_FIRC_FREQ0,\r\n    };\r\n\r\n    if (SCG_GetFircStatus(SCG)) /* FIRC is valid. */\r\n    {\r\n        retValue = fircFreq[SCG_GetFircRange(SCG)];\r\n    }\r\n    else\r\n    {\r\n        retValue = 0U;\r\n    }\r\n\r\n    return retValue;\r\n}\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSysPllFreq\r\n * Description   : Gets SCG System PLL clock frequency (SYSPLL).\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetSysPllFreq(void)\r\n{\r\n    uint32_t freq, retValue;\r\n\r\n    if (SCG_GetSpllStatus(SCG)) /* System PLL is valid. */\r\n    {\r\n        /* Get source Spll frequency. */\r\n#ifdef SCG_SPLLCFG_SOURCE_MASK\r\n        switch (SCG_GetSourcSpll(SCG))\r\n        {\r\n            case 0U:\r\n                freq = CLOCK_SYS_GetSysOscFreq();\r\n            break;\r\n            case 1U:\r\n                freq = CLOCK_SYS_GetFircFreq();\r\n            break;\r\n            default:\r\n                freq = 0U;\r\n            break;\r\n        }\r\n#else\r\n        freq = CLOCK_SYS_GetSysOscFreq();\r\n#endif\r\n\r\n        if (freq != 0U) /* If source is valid. */\r\n        {\r\n            freq /= (SCG_GetSpllPredivider(SCG) + SCG_SPLL_PREDIV_BASE);    /* Pre-divider. */\r\n            freq *= (SCG_GetSpllMultiplier(SCG) + SCG_SPLL_MULT_BASE);      /* Multiplier. */\r\n            freq = freq >> 1U;  /* Divide VCO by 2. */\r\n        }\r\n\r\n        retValue = freq;\r\n    }\r\n    else\r\n    {\r\n        retValue = 0U;\r\n    }\r\n\r\n    return retValue;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetLpoFreq\r\n * Description   : Gets SIM LPO clock frequency (LPO).\r\n * END**************************************************************************/\r\nstatic uint32_t CLOCK_SYS_GetLpoFreq(void)\r\n{\r\n    uint32_t freq = 0U;\r\n\r\n    switch (SIM_GetLpoClkSelectorValue(SIM))\r\n    {\r\n        case 0U:  /* SIM_LPO_CLK_SEL_LPO_128K */\r\n            freq = LPO_128K_FREQUENCY;\r\n            break;\r\n        case 1U:  /* SIM_LPO_CLK_SEL_NO_CLOCK: */\r\n            freq = 0U;\r\n            break;\r\n        case 2U:  /* SIM_LPO_CLK_SEL_LPO_32K: */\r\n            freq = SIM_GetLpo32KStatus(SIM) ? LPO_32K_FREQUENCY : 0UL;\r\n            break;\r\n        case 3U:  /* SIM_LPO_CLK_SEL_LPO_1K:  */\r\n            freq = ((SIM_GetLpo32KStatus(SIM)) && (SIM_GetLpo1KStatus(SIM))) ? LPO_1K_FREQUENCY : 0UL;\r\n            break;\r\n        default:\r\n            /* Invalid LPOCLKSEL selection.*/\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n    return freq;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_TransitionToTmpSysClk\r\n * Description   : Transition to a temporary system clock\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_TransitionToTmpSysClk(scg_system_clock_src_t currentSysClkSrc)\r\n{\r\n    scg_system_clock_config_t sysClockConfig;\r\n\r\n    static const scg_system_clock_div_t tmpSysClk[TMP_SYS_CLK_NO][TMP_SYS_DIV_NO] = TMP_SYSTEM_CLOCK_CONFIGS;\r\n\r\n    status_t status = STATUS_ERROR;\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n    /* SPLL is functional, and is not the current system clock source */\r\n    if ((CLOCK_SYS_GetSysPllFreq() != 0U) && (currentSysClkSrc != SCG_SYSTEM_CLOCK_SRC_SYS_PLL) && (status == STATUS_ERROR))\r\n    {\r\n        sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;\r\n        sysClockConfig.divCore = tmpSysClk[TMP_SPLL_CLK][TMP_SYS_DIV];\r\n        sysClockConfig.divBus  = tmpSysClk[TMP_SPLL_CLK][TMP_BUS_DIV];\r\n        sysClockConfig.divSlow = tmpSysClk[TMP_SPLL_CLK][TMP_SLOW_DIV];\r\n        status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n    }\r\n#endif\r\n    /* FIRC is functional, it is not the current system clock source, no valid source has been found yet. */\r\n    if ((CLOCK_SYS_GetFircFreq() != 0U) && (currentSysClkSrc != SCG_SYSTEM_CLOCK_SRC_FIRC) && (status != STATUS_SUCCESS))\r\n    {\r\n        sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_FIRC;\r\n        sysClockConfig.divCore = tmpSysClk[TMP_FIRC_CLK][TMP_SYS_DIV];\r\n        sysClockConfig.divBus  = tmpSysClk[TMP_FIRC_CLK][TMP_BUS_DIV];\r\n        sysClockConfig.divSlow = tmpSysClk[TMP_FIRC_CLK][TMP_SLOW_DIV];\r\n        status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n    }\r\n\r\n\r\n    /* SOSC is functional, it is not the current system clock source, no valid source has been found yet. */\r\n    if ((CLOCK_SYS_GetSysOscFreq() != 0U) && (currentSysClkSrc != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) && (status != STATUS_SUCCESS))\r\n    {\r\n        sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_OSC;\r\n        sysClockConfig.divCore = tmpSysClk[TMP_SOSC_CLK][TMP_SYS_DIV];\r\n        sysClockConfig.divBus  = tmpSysClk[TMP_SOSC_CLK][TMP_BUS_DIV];\r\n        sysClockConfig.divSlow = tmpSysClk[TMP_SOSC_CLK][TMP_SLOW_DIV];\r\n        status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n    }\r\n\r\n    /* SIRC is functional, it is not the current system clock source, no valid source has been found yet. */\r\n    if ((CLOCK_SYS_GetSircFreq() != 0U) && (currentSysClkSrc != SCG_SYSTEM_CLOCK_SRC_SIRC) && (status != STATUS_SUCCESS))\r\n    {\r\n        sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SIRC;\r\n        sysClockConfig.divCore = tmpSysClk[TMP_SIRC_CLK][TMP_SYS_DIV];\r\n        sysClockConfig.divBus  = tmpSysClk[TMP_SIRC_CLK][TMP_BUS_DIV];\r\n        sysClockConfig.divSlow = tmpSysClk[TMP_SIRC_CLK][TMP_SLOW_DIV];\r\n        status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_TransitionToTmpSysClk\r\n * Description   : Transition to a temporary system clock\r\n * END**************************************************************************/\r\nstatic void CLOCK_SYS_GetCurrentSysClkConfig(scg_system_clock_config_t * sysClockConfig)\r\n{\r\n    static const scg_system_clock_div_t sysClkDivMappings[((uint32_t) SCG_SYSTEM_CLOCK_DIV_BY_16)+ 1U] = {\r\n            SCG_SYSTEM_CLOCK_DIV_BY_1, SCG_SYSTEM_CLOCK_DIV_BY_2,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_3, SCG_SYSTEM_CLOCK_DIV_BY_4,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_5, SCG_SYSTEM_CLOCK_DIV_BY_6,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_7, SCG_SYSTEM_CLOCK_DIV_BY_8,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_9, SCG_SYSTEM_CLOCK_DIV_BY_10,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_11, SCG_SYSTEM_CLOCK_DIV_BY_12,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_13, SCG_SYSTEM_CLOCK_DIV_BY_14,\r\n            SCG_SYSTEM_CLOCK_DIV_BY_15, SCG_SYSTEM_CLOCK_DIV_BY_16 };\r\n\r\n    /* Save the current system clock source configuration */\r\n    switch(SCG_GetCurrentSystemClockSource(SCG))\r\n    {\r\n    case 1U:\r\n    {\r\n        sysClockConfig->src = SCG_SYSTEM_CLOCK_SRC_SYS_OSC;\r\n        break;\r\n    }\r\n    case 2U:\r\n    {\r\n        sysClockConfig->src = SCG_SYSTEM_CLOCK_SRC_SIRC;\r\n        break;\r\n    }\r\n    case 3U:\r\n    {\r\n        sysClockConfig->src = SCG_SYSTEM_CLOCK_SRC_FIRC;\r\n        break;\r\n    }\r\n#if FEATURE_HAS_SPLL_CLK\r\n    case 6U:\r\n    {\r\n        sysClockConfig->src = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;\r\n        break;\r\n    }\r\n#endif\r\n    default:\r\n    {\r\n        /* Invalid system clock value */\r\n        DEV_ASSERT(false);\r\n        break;\r\n    }\r\n    }\r\n    sysClockConfig->divBus  = sysClkDivMappings[SCG_GetCurrentBusClockDividerRatio(SCG)];\r\n    sysClockConfig->divCore = sysClkDivMappings[SCG_GetCurrentCoreClockDividerRatio(SCG)];\r\n    sysClockConfig->divSlow = sysClkDivMappings[SCG_GetCurrentSlowClockDividerRatio(SCG)];\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_ConvertAsyncDividerValue\r\n * Description   : Converts an integer value to asynchronous divider value type.\r\n * END**************************************************************************/\r\nstatic scg_async_clock_div_t CLOCK_SYS_ConvertAsyncDividerValue(uint16_t divider)\r\n{\r\n    scg_async_clock_div_t retValue;\r\n\r\n    switch(divider)\r\n    {\r\n        case (1U << 6U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_64;\r\n            break;\r\n        case (1U << 5U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_32;\r\n            break;\r\n        case (1U << 4U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_16;\r\n            break;\r\n        case (1U << 3U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_8;\r\n            break;\r\n        case (1U << 2U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_4;\r\n            break;\r\n        case (1U << 1U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_2;\r\n            break;\r\n        case (1U << 0U):\r\n            retValue = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n            break;\r\n        case 0U:\r\n            /* Pass - through */\r\n        default:\r\n            retValue = SCG_ASYNC_CLOCK_DISABLE;\r\n            break;\r\n    }\r\n    return retValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetDefaultModuleClkCfgSource\r\n * Description   : Gets default module clock source.\r\n * END**************************************************************************/\r\nstatic clock_names_t CLOCK_SYS_GetDefaultModuleClkCfgSource(void)\r\n{\r\n    clock_names_t ret = CLOCK_NAME_COUNT;\r\n\r\n    if (CLOCK_SYS_GetSircFreq() != 0U)\r\n    {\r\n        ret = SIRC_CLK;\r\n    }\r\n    else if (CLOCK_SYS_GetFircFreq() != 0U)\r\n    {\r\n        ret = FIRC_CLK;\r\n    }\r\n#if FEATURE_HAS_SPLL_CLK\r\n    else if (CLOCK_SYS_GetSysPllFreq() != 0U)\r\n    {\r\n        ret = SPLL_CLK;\r\n    }\r\n#endif\r\n    else if (CLOCK_SYS_GetSysOscFreq() != 0U)\r\n    {\r\n        ret = SOSC_CLK;\r\n    }\r\n    else\r\n    {\r\n        ret = CLOCK_NAME_COUNT;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_SetClockGate\r\n * Description   : Sets clock gate.\r\n * END**************************************************************************/\r\nstatic void CLOCK_SYS_SetClockGate(clock_names_t peripheralClock, bool gating)\r\n{\r\n    switch (peripheralClock)\r\n    {\r\n        case SIM_MSCM_CLK:\r\n            SIM_SetMscmClockGate(SIM, gating);\r\n            break;\r\n\r\n        case SIM_MPU_CLK:\r\n            SIM_SetMpuClockGate(SIM, gating);\r\n            break;\r\n\r\n        case SIM_DMA_CLK:\r\n            SIM_SetDmaClockGate(SIM, gating);\r\n            break;\r\n\r\n        case SIM_ERM_CLK:\r\n            SIM_SetErmClockGate(SIM, gating);\r\n            break;\r\n\r\n        case SIM_EIM_CLK:\r\n            SIM_SetEimClockGate(SIM, gating);\r\n            break;\r\n        default:\r\n            /* Invalid clock name */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_DRV_SetModuleClock\r\n * Description   : This function enables a peripheral clock\r\n *\r\n * Implements CLOCK_DRV_SetModuleClock_Activity\r\n * END**************************************************************************/\r\nvoid CLOCK_DRV_SetModuleClock(clock_names_t peripheralClock, const module_clk_config_t * moduleClkConfig)\r\n{\r\n    uint32_t source = 0U, divider = 0U, multiplier = 0U;\r\n    module_clk_config_t defaultModuleClkCfg;\r\n    const module_clk_config_t * moduleClkCfg;\r\n\r\n    /* Configuration is not provided, a default one will be used. */\r\n    if (moduleClkConfig == NULL)\r\n    {\r\n        defaultModuleClkCfg.gating = true;\r\n        defaultModuleClkCfg.source = CLOCK_SYS_GetDefaultModuleClkCfgSource();\r\n        defaultModuleClkCfg.mul = 1U;\r\n        defaultModuleClkCfg.div = 1U;\r\n        moduleClkCfg = &defaultModuleClkCfg;\r\n    }\r\n    else\r\n    {\r\n        moduleClkCfg = moduleClkConfig;\r\n    }\r\n\r\n    /* Check that clock gating is configurable from PCC */\r\n    if ((peripheralFeaturesList[peripheralClock] & HAS_CLOCK_GATING_IN_SIM) == 0U)\r\n    {\r\n        /* Check that protocol clock is supported by the peripheral corresponding to the clock name */\r\n        if ((peripheralFeaturesList[peripheralClock] & (HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_PROTOCOL_CLOCK_FROM_ASYNC2)) != 0U)\r\n        {\r\n            switch(moduleClkCfg->source)\r\n            {\r\n                case SIRC_CLK:\r\n                    source = CLK_SRC_SIRC;\r\n                    break;\r\n                case FIRC_CLK:\r\n                    source = CLK_SRC_FIRC;\r\n                    break;\r\n                case SOSC_CLK:\r\n                    source = CLK_SRC_SOSC;\r\n                    break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n                case SPLL_CLK:\r\n                    source = CLK_SRC_SPLL;\r\n                    break;\r\n#endif\r\n                default:\r\n                    /* Invalid name of the clock source. */\r\n                    DEV_ASSERT(false);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        /* Check that divider is supported by the peripheral corresponding to the clock name */\r\n        if ((peripheralFeaturesList[peripheralClock] & HAS_DIVIDER) != 0U)\r\n        {\r\n            DEV_ASSERT((0U < ((uint32_t)moduleClkCfg->div)) && (((uint32_t)moduleClkCfg->div) <= (1UL << PCC_PCCn_PCD_WIDTH)));\r\n            divider = ((uint32_t)moduleClkCfg->div) - 1U;\r\n        }\r\n\r\n        /* Check that multiplier is supported by the peripheral corresponding to the clock name */\r\n        if ((peripheralFeaturesList[peripheralClock] & HAS_MULTIPLIER) != 0U)\r\n        {\r\n            DEV_ASSERT((0U < ((uint32_t)moduleClkCfg->mul)) && (((uint32_t)moduleClkCfg->mul) <= (1UL << PCC_PCCn_FRAC_WIDTH)));\r\n            multiplier = ((uint32_t)moduleClkCfg->mul) - 1U;\r\n        }\r\n\r\n        /* Disable the peripheral clock */\r\n        PCC_SetClockMode(PCC, peripheralClock, false);\r\n\r\n        if (moduleClkCfg->gating)\r\n        {\r\n            /* Set peripheral clock control */\r\n            PCC_SetPeripheralClockControl(PCC, peripheralClock, true, source, divider, multiplier);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        CLOCK_SYS_SetClockGate(peripheralClock, moduleClkCfg->gating);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSysClockMode\r\n * Description   : Gets default system clock mode.\r\n * END**************************************************************************/\r\nstatic scg_system_clock_mode_t CLOCK_SYS_GetSysClockMode(const pwr_modes_t mode)\r\n{\r\n    scg_system_clock_mode_t sysClockMode;\r\n\r\n    switch(mode)\r\n    {\r\n        /* High speed run mode */\r\n        case HSRUN_MODE:\r\n            sysClockMode = SCG_SYSTEM_CLOCK_MODE_HSRUN;\r\n            break;\r\n        /* Run mode */\r\n        case RUN_MODE:\r\n            sysClockMode = SCG_SYSTEM_CLOCK_MODE_RUN;\r\n            break;\r\n        /* Very low power run mode */\r\n        case VLPR_MODE:\r\n            sysClockMode = SCG_SYSTEM_CLOCK_MODE_VLPR;\r\n            break;\r\n        /* This should never happen - input power mode is invalid */\r\n        default:\r\n            sysClockMode = SCG_SYSTEM_CLOCK_MODE_NONE;\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n    return sysClockMode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetSysClockSource\r\n * Description   : Gets default system clock source.\r\n * END**************************************************************************/\r\nstatic scg_system_clock_src_t CLOCK_SYS_GetSysClockSource(clock_names_t src)\r\n{\r\n    scg_system_clock_src_t source;\r\n\r\n    switch(src)\r\n    {\r\n        case SIRC_CLK:\r\n            source = SCG_SYSTEM_CLOCK_SRC_SIRC;\r\n            break;\r\n\r\n        case FIRC_CLK:\r\n            source = SCG_SYSTEM_CLOCK_SRC_FIRC;\r\n            break;\r\n\r\n        case SOSC_CLK:\r\n            source = SCG_SYSTEM_CLOCK_SRC_SYS_OSC;\r\n            break;\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case SPLL_CLK:\r\n            source = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;\r\n            break;\r\n#endif\r\n\r\n        default:\r\n            source = SCG_SYSTEM_CLOCK_SRC_NONE;\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n    return source;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_DRV_SetSystemClock\r\n * Description   : This function configures the system clocks (core, bus and flash clocks).\r\n *\r\n * Implements CLOCK_DRV_SetSystemClock_Activity\r\n * END**************************************************************************/\r\nstatus_t CLOCK_DRV_SetSystemClock(const pwr_modes_t * mode,\r\n                                  const sys_clk_config_t * sysClkConfig)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n\r\n    scg_system_clock_mode_t sysClockMode, currentSysClockMode = CLOCK_SYS_GetCurrentRunMode();\r\n    scg_system_clock_config_t sysClockConfig;\r\n\r\n    static const scg_system_clock_div_t sysClkDivMappings[] = {SCG_SYSTEM_CLOCK_DIV_BY_1,SCG_SYSTEM_CLOCK_DIV_BY_1,SCG_SYSTEM_CLOCK_DIV_BY_2,SCG_SYSTEM_CLOCK_DIV_BY_3,SCG_SYSTEM_CLOCK_DIV_BY_4,SCG_SYSTEM_CLOCK_DIV_BY_5,SCG_SYSTEM_CLOCK_DIV_BY_6,SCG_SYSTEM_CLOCK_DIV_BY_7,SCG_SYSTEM_CLOCK_DIV_BY_8,SCG_SYSTEM_CLOCK_DIV_BY_9,SCG_SYSTEM_CLOCK_DIV_BY_10,SCG_SYSTEM_CLOCK_DIV_BY_11,SCG_SYSTEM_CLOCK_DIV_BY_12,SCG_SYSTEM_CLOCK_DIV_BY_13,SCG_SYSTEM_CLOCK_DIV_BY_14,SCG_SYSTEM_CLOCK_DIV_BY_15,SCG_SYSTEM_CLOCK_DIV_BY_16};\r\n    static const scg_system_clock_div_t defSysClk[TMP_SYS_CLK_NO][TMP_SYS_DIV_NO] = TMP_SYSTEM_CLOCK_CONFIGS;\r\n\r\n    /* The power mode is not provided, the current one will be used by default. */\r\n    if (mode == NULL)\r\n    {\r\n        sysClockMode = currentSysClockMode;\r\n    }\r\n    else\r\n    {\r\n        sysClockMode = CLOCK_SYS_GetSysClockMode(*mode);\r\n    }\r\n\r\n    /* System clock configuration is not provided, a default one will be used. */\r\n    if (sysClkConfig == NULL)\r\n    {\r\n        /* Find a valid clock source. */\r\n        if (CLOCK_SYS_GetFircFreq() != 0U)\r\n        {\r\n            sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_FIRC;\r\n            sysClockConfig.divCore = defSysClk[TMP_FIRC_CLK][TMP_SYS_DIV];\r\n            sysClockConfig.divBus  = defSysClk[TMP_FIRC_CLK][TMP_BUS_DIV];\r\n            sysClockConfig.divSlow = defSysClk[TMP_FIRC_CLK][TMP_SLOW_DIV];\r\n        }\r\n#if FEATURE_HAS_SPLL_CLK\r\n        else if (CLOCK_SYS_GetSysPllFreq() != 0U)\r\n        {\r\n            sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;\r\n            sysClockConfig.divCore = defSysClk[TMP_SPLL_CLK][TMP_SYS_DIV];\r\n            sysClockConfig.divBus  = defSysClk[TMP_SPLL_CLK][TMP_BUS_DIV];\r\n            sysClockConfig.divSlow = defSysClk[TMP_SPLL_CLK][TMP_SLOW_DIV];\r\n        }\r\n#endif\r\n        else if (CLOCK_SYS_GetSysOscFreq() != 0U)\r\n        {\r\n            sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_OSC;\r\n            sysClockConfig.divCore = defSysClk[TMP_SOSC_CLK][TMP_SYS_DIV];\r\n            sysClockConfig.divBus  = defSysClk[TMP_SOSC_CLK][TMP_BUS_DIV];\r\n            sysClockConfig.divSlow = defSysClk[TMP_SOSC_CLK][TMP_SLOW_DIV];\r\n        }\r\n        else if (CLOCK_SYS_GetSircFreq() != 0U)\r\n        {\r\n            sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SIRC;\r\n            if (sysClockMode == SCG_SYSTEM_CLOCK_MODE_VLPR)\r\n            {\r\n                sysClockConfig.divCore = FEATURE_VLPR_SYS_CLK;\r\n                sysClockConfig.divBus  = FEATURE_VLPR_BUS_CLK;\r\n                sysClockConfig.divSlow = FEATURE_VLPR_SLOW_CLK;\r\n            }\r\n            else\r\n            {\r\n                sysClockConfig.divCore = defSysClk[TMP_SIRC_CLK][TMP_SYS_DIV];\r\n                sysClockConfig.divBus  = defSysClk[TMP_SIRC_CLK][TMP_BUS_DIV];\r\n                sysClockConfig.divSlow = defSysClk[TMP_SIRC_CLK][TMP_SLOW_DIV];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /* Can't reach this point, at least one clock source is functional.\r\n             * This code is written to avoid MISRA 15.7 (no 'else' at end of 'if ... else if' chain) */\r\n            DEV_ASSERT(false);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* The system clock source from input configuration structure must be valid. */\r\n        DEV_ASSERT((CLOCK_SYS_GetSircFreq() != 0U) || (sysClkConfig->src != SIRC_CLK));\r\n        DEV_ASSERT((CLOCK_SYS_GetFircFreq() != 0U) || (sysClkConfig->src != FIRC_CLK));\r\n        DEV_ASSERT((CLOCK_SYS_GetSysOscFreq() != 0U) || (sysClkConfig->src != SOSC_CLK));\r\n#if FEATURE_HAS_SPLL_CLK\r\n        DEV_ASSERT((CLOCK_SYS_GetSysPllFreq() != 0U) || (sysClkConfig->src != SPLL_CLK));\r\n#endif\r\n\r\n        sysClockConfig.src = CLOCK_SYS_GetSysClockSource(sysClkConfig->src);\r\n\r\n        DEV_ASSERT(sysClkConfig->dividers[0U] != 0U);\r\n        DEV_ASSERT(sysClkConfig->dividers[1U] != 0U);\r\n        DEV_ASSERT(sysClkConfig->dividers[2U] != 0U);\r\n\r\n        sysClockConfig.divCore = sysClkDivMappings[sysClkConfig->dividers[0U]];\r\n        sysClockConfig.divBus  = sysClkDivMappings[sysClkConfig->dividers[1U]];\r\n        sysClockConfig.divSlow = sysClkDivMappings[sysClkConfig->dividers[2U]];\r\n    }\r\n\r\n    /* System clock is configured in the current mode,\r\n     * set configuration and wait until the system clock is changed. */\r\n    if (sysClockMode == currentSysClockMode)\r\n    {\r\n        retCode = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);\r\n    }\r\n    /* System clock is not configured in the current mode, just set configuration. */\r\n    else\r\n    {\r\n        retCode = CLOCK_SYS_SetSystemClockConfig(sysClockMode,&sysClockConfig);\r\n    }\r\n    return retCode;\r\n}\r\n\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_DRV_GetSystemClockSource\r\n * Description   : This function gets the current system clock source\r\n *\r\n * Implements CLOCK_DRV_GetSystemClockSource_Activity\r\n * END**************************************************************************/\r\nvoid CLOCK_DRV_GetSystemClockSource(sys_clk_config_t *sysClkConfig)\r\n{\r\n    switch(SCG_GetCurrentSystemClockSource(SCG))\r\n    {\r\n        case SCG_SYSTEM_CLOCK_SRC_SYS_OSC:\r\n        {\r\n            sysClkConfig->src = SOSC_CLK;\r\n        }\r\n        break;\r\n        case SCG_SYSTEM_CLOCK_SRC_SIRC:\r\n        {\r\n            sysClkConfig->src = SIRC_CLK;\r\n        }\r\n        break;\r\n        case SCG_SYSTEM_CLOCK_SRC_FIRC:\r\n        {\r\n            sysClkConfig->src = FIRC_CLK;\r\n        }\r\n        break;\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case SCG_SYSTEM_CLOCK_SRC_SYS_PLL:\r\n        {\r\n            sysClkConfig->src = SPLL_CLK;\r\n        }\r\n        break;\r\n#endif\r\n        default:\r\n        {\r\n            /* Invalid system clock source. */\r\n            DEV_ASSERT(false);\r\n            sysClkConfig->src = SIRC_CLK;\r\n        }\r\n        break;\r\n    }\r\n\r\n    /* Core divider */\r\n    sysClkConfig->dividers[0U] = (uint16_t) (SCG_GetCurrentCoreClockDividerRatio(SCG) + 1U);\r\n\r\n    /* Bus divider */\r\n    sysClkConfig->dividers[1U] = (uint16_t) (SCG_GetCurrentBusClockDividerRatio(SCG) + 1U);\r\n\r\n    /* Slow divider */\r\n    sysClkConfig->dividers[2U] = (uint16_t) (SCG_GetCurrentSlowClockDividerRatio(SCG) + 1U);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_SetSircClockSource\r\n * Description   : Sets SIRC clock.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_SetSircClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n    scg_system_clock_config_t currentSysClockConfig;\r\n    bool revertTmpSysClkTransition = false;\r\n    scg_sirc_config_t scgSircConfig;\r\n\r\n    /* Check whether the current system clock source is SIRC */\r\n    if (SCG_GetCurrentSystemClockSource(SCG) == ((uint32_t)SCG_SYSTEM_CLOCK_SRC_SIRC))\r\n    {\r\n        if (clockSourceEnable == false)\r\n        {\r\n            /* Can't disable SIRC, it's used as system clock source */\r\n            retCode = STATUS_ERROR;\r\n        }\r\n        else\r\n        {\r\n            /* Save the current system clock source configuration */\r\n            CLOCK_SYS_GetCurrentSysClkConfig(&currentSysClockConfig);\r\n\r\n            /* Transition to a temporary system clock source */\r\n            retCode = CLOCK_SYS_TransitionToTmpSysClk(SCG_SYSTEM_CLOCK_SRC_SIRC);\r\n\r\n            revertTmpSysClkTransition = (retCode == STATUS_SUCCESS) ? true : false;\r\n        }\r\n    }\r\n\r\n    if (retCode == STATUS_SUCCESS)\r\n    {\r\n        if (clkSrcConfig == NULL)\r\n        {\r\n            retCode = CLOCK_SYS_ConfigureSIRC(true, NULL);\r\n        }\r\n        else\r\n        {\r\n            /* Check VLP modes */\r\n            scgSircConfig.enableInLowPower  = true;\r\n            scgSircConfig.enableInStop  = true;\r\n            scgSircConfig.locked            = false;\r\n\r\n            scgSircConfig.div1              = divider1;\r\n            scgSircConfig.div2              = divider2;\r\n\r\n            scgSircConfig.range             = SCG_SIRC_RANGE_HIGH;\r\n\r\n            retCode = CLOCK_SYS_ConfigureSIRC(clockSourceEnable, &scgSircConfig);\r\n        }\r\n\r\n        /* If system clock source was SIRC and SIRC has been set successfully,\r\n         * then transition back to SIRC */\r\n        if ((retCode == STATUS_SUCCESS) && (revertTmpSysClkTransition == true))\r\n        {\r\n            retCode = CLOCK_SYS_TransitionSystemClock(&currentSysClockConfig);\r\n        }\r\n    }\r\n\r\n    return retCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_SetFircClockSource\r\n * Description   : Sets FIRC clock.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_SetFircClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n    scg_system_clock_config_t currentSysClockConfig;\r\n    bool revertTmpSysClkTransition = false;\r\n    scg_firc_config_t scgFircConfig;\r\n\r\n    /* Check whether the current system clock source is FIRC */\r\n    if (SCG_GetCurrentSystemClockSource(SCG) == ((uint32_t)SCG_SYSTEM_CLOCK_SRC_FIRC))\r\n    {\r\n        if (clockSourceEnable == false)\r\n        {\r\n            /* Can't disable FIRC, it's used as system clock source. */\r\n            retCode = STATUS_ERROR;\r\n        }\r\n        else\r\n        {\r\n            /* Save the current system clock source configuration. */\r\n            CLOCK_SYS_GetCurrentSysClkConfig(&currentSysClockConfig);\r\n\r\n            /* Transition to a temporary system clock source. */\r\n            retCode = CLOCK_SYS_TransitionToTmpSysClk(SCG_SYSTEM_CLOCK_SRC_FIRC);\r\n\r\n            revertTmpSysClkTransition = (retCode == STATUS_SUCCESS) ? true : false;\r\n        }\r\n    }\r\n\r\n    if (retCode == STATUS_SUCCESS)\r\n    {\r\n        if (clkSrcConfig == NULL)\r\n        {\r\n            retCode = CLOCK_SYS_ConfigureFIRC(clockSourceEnable, NULL);\r\n        }\r\n        else\r\n        {\r\n            scgFircConfig.locked            = false;\r\n\r\n            scgFircConfig.div1              = divider1;\r\n            scgFircConfig.div2              = divider2;\r\n\r\n            scgFircConfig.range             = SCG_FIRC_RANGE_48M;\r\n            scgFircConfig.regulator         = 0U;\r\n\r\n            retCode = CLOCK_SYS_ConfigureFIRC(clockSourceEnable, &scgFircConfig);\r\n        }\r\n\r\n        /* If system clock source was FIRC and FIRC has been set successfully,\r\n         * then transition back to FIRC */\r\n        if ((retCode == STATUS_SUCCESS) && (revertTmpSysClkTransition == true))\r\n        {\r\n            retCode = CLOCK_SYS_TransitionSystemClock(&currentSysClockConfig);\r\n        }\r\n    }\r\n\r\n    return retCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_GetExtRef\r\n * Description   : Gets external reference value for SOSC clock.\r\n * END**************************************************************************/\r\nstatic scg_sosc_ext_ref_t CLOCK_SYS_GetExtRef(xosc_ref_t refClk)\r\n{\r\n    scg_sosc_ext_ref_t extRef = SCG_SOSC_REF_EXT;\r\n\r\n    switch (refClk)\r\n    {\r\n        case XOSC_EXT_REF:\r\n            extRef            = SCG_SOSC_REF_EXT;\r\n            break;\r\n\r\n        case XOSC_INT_OSC:\r\n            extRef            = SCG_SOSC_REF_OSC;\r\n            break;\r\n\r\n        default:\r\n            /* Invalid input reference value */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n    return extRef;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_SetSoscClockSource\r\n * Description   : Sets SOSC clock.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_SetSoscClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n    scg_system_clock_config_t currentSysClockConfig;\r\n    bool revertTmpSysClkTransition = false;\r\n    scg_sosc_config_t scgSoscConfig;\r\n\r\n    /* Check whether the current system clock source is SOSC */\r\n    if (SCG_GetCurrentSystemClockSource(SCG) == ((uint32_t)SCG_SYSTEM_CLOCK_SRC_SYS_OSC))\r\n    {\r\n        if (clockSourceEnable == false)\r\n        {\r\n            /* Can't disable SOSC, it's used as system clock source. */\r\n            retCode = STATUS_ERROR;\r\n        }\r\n        else\r\n        {\r\n            /* Save the current system clock source configuration. */\r\n            CLOCK_SYS_GetCurrentSysClkConfig(&currentSysClockConfig);\r\n\r\n            /* Transition to a temporary system clock source. */\r\n            retCode = CLOCK_SYS_TransitionToTmpSysClk(SCG_SYSTEM_CLOCK_SRC_SYS_OSC);\r\n\r\n            revertTmpSysClkTransition = (retCode == STATUS_SUCCESS) ? true : false;\r\n        }\r\n    }\r\n\r\n    if (retCode == STATUS_SUCCESS)\r\n    {\r\n        if (clkSrcConfig == NULL)\r\n        {\r\n            retCode = CLOCK_SYS_ConfigureSOSC(clockSourceEnable, NULL);\r\n        }\r\n        else\r\n        {\r\n            scgSoscConfig.freq              = clkSrcConfig->refFreq;\r\n\r\n            scgSoscConfig.monitorMode       = SCG_SOSC_MONITOR_DISABLE;\r\n            scgSoscConfig.locked            = false;\r\n\r\n            scgSoscConfig.div1              = divider1;\r\n            scgSoscConfig.div2              = divider2;\r\n\r\n            scgSoscConfig.extRef            = CLOCK_SYS_GetExtRef(clkSrcConfig->refClk);\r\n\r\n            scgSoscConfig.gain              = SCG_SOSC_GAIN_LOW;\r\n\r\n            if((scgSoscConfig.freq >= 4000000U) && (scgSoscConfig.freq <= 8000000U))\r\n            {\r\n                scgSoscConfig.range             = SCG_SOSC_RANGE_MID;\r\n            }\r\n            else if((scgSoscConfig.freq >= 8000000U) && (scgSoscConfig.freq <= 40000000U))\r\n            {\r\n                scgSoscConfig.range             = SCG_SOSC_RANGE_HIGH;\r\n            }\r\n            else\r\n            {\r\n                /* Frequency of the input reference clock is invalid. */\r\n                DEV_ASSERT(false);\r\n            }\r\n\r\n            retCode = CLOCK_SYS_ConfigureSOSC(clockSourceEnable, &scgSoscConfig);\r\n        }\r\n\r\n        /* If system clock source was SOSC and SOSC has been set successfully,\r\n         * then transition back to SOSC */\r\n        if ((retCode == STATUS_SUCCESS) && (revertTmpSysClkTransition == true))\r\n        {\r\n            retCode = CLOCK_SYS_TransitionSystemClock(&currentSysClockConfig);\r\n        }\r\n    }\r\n\r\n    return retCode;\r\n}\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n/*FUNCTION**********************************************************************\r\n * Function Name : CLOCK_SYS_SetSpllClockSource\r\n * Description   : Sets SPLL clock.\r\n * END**************************************************************************/\r\nstatic status_t CLOCK_SYS_SetSpllClockSource(bool clockSourceEnable, const clock_source_config_t * clkSrcConfig, scg_async_clock_div_t divider1, scg_async_clock_div_t divider2)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n    scg_system_clock_config_t currentSysClockConfig;\r\n    bool revertTmpSysClkTransition = false;\r\n    scg_spll_config_t scgSpllConfig;\r\n\r\n    /* Check whether the current system clock source is PLL */\r\n    if (SCG_GetCurrentSystemClockSource(SCG) == ((uint32_t)SCG_SYSTEM_CLOCK_SRC_SYS_PLL))\r\n    {\r\n        if (clockSourceEnable == false)\r\n        {\r\n            /* Can't disable PLL, it's used as system clock source. */\r\n            retCode = STATUS_ERROR;\r\n        }\r\n        else\r\n        {\r\n            /* Save the current system clock source configuration. */\r\n            CLOCK_SYS_GetCurrentSysClkConfig(&currentSysClockConfig);\r\n\r\n            /* Transition to a temporary system clock source. */\r\n            retCode = CLOCK_SYS_TransitionToTmpSysClk(SCG_SYSTEM_CLOCK_SRC_SYS_PLL);\r\n\r\n            revertTmpSysClkTransition = (retCode == STATUS_SUCCESS) ? true : false;\r\n        }\r\n    }\r\n\r\n    if (retCode == STATUS_SUCCESS)\r\n    {\r\n        if (clkSrcConfig == NULL)\r\n        {\r\n            retCode = CLOCK_SYS_ConfigureSPLL(clockSourceEnable, NULL);\r\n        }\r\n        else\r\n        {\r\n            scgSpllConfig.monitorMode       = SCG_SPLL_MONITOR_DISABLE;\r\n            scgSpllConfig.locked            = false;\r\n\r\n            scgSpllConfig.div1              = divider1;\r\n            scgSpllConfig.div2              = divider2;\r\n\r\n            DEV_ASSERT((SCG_SPLL_PREDIV_BASE <= clkSrcConfig->div) && (clkSrcConfig->div < (SCG_SPLL_PREDIV_BASE + (1U << SCG_SPLLCFG_PREDIV_WIDTH)) ));\r\n            scgSpllConfig.prediv = (uint8_t)(clkSrcConfig->div - SCG_SPLL_PREDIV_BASE);\r\n\r\n            DEV_ASSERT((SCG_SPLL_MULT_BASE <= clkSrcConfig->mul) && (clkSrcConfig->mul < (SCG_SPLL_MULT_BASE + (1U << SCG_SPLLCFG_MULT_WIDTH)) ));\r\n            scgSpllConfig.mult = (uint8_t)(clkSrcConfig->mul - SCG_SPLL_MULT_BASE);\r\n\r\n            if (retCode == STATUS_SUCCESS)\r\n            {\r\n                retCode = CLOCK_SYS_ConfigureSPLL(clockSourceEnable, &scgSpllConfig);\r\n            }\r\n        }\r\n\r\n        /* If system clock source was PLL and PLL has been set successfully,\r\n         * then transition back to PLL */\r\n        if ((retCode == STATUS_SUCCESS) && (revertTmpSysClkTransition == true))\r\n        {\r\n            retCode = CLOCK_SYS_TransitionSystemClock(&currentSysClockConfig);\r\n        }\r\n    }\r\n\r\n    return retCode;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_DRV_SetClockSource\r\n * Description   : This function configures a clock source\r\n *\r\n * Implements CLOCK_DRV_SetClockSource_Activity\r\n * END**************************************************************************/\r\nstatus_t CLOCK_DRV_SetClockSource(clock_names_t clockSource, const clock_source_config_t * clkSrcConfig)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n    bool clockSourceEnable = true;\r\n\r\n    scg_async_clock_div_t divider1, divider2;\r\n\r\n    if (clkSrcConfig == NULL)\r\n    {\r\n        divider1 = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n        divider2 = SCG_ASYNC_CLOCK_DIV_BY_1;\r\n    }\r\n    else\r\n    {\r\n        divider1 = CLOCK_SYS_ConvertAsyncDividerValue(clkSrcConfig->outputDiv1);\r\n        divider2 = CLOCK_SYS_ConvertAsyncDividerValue(clkSrcConfig->outputDiv2);\r\n    }\r\n\r\n    /* Check whether the command enables and disables the clock source */\r\n    if ((clkSrcConfig != NULL) && (clkSrcConfig->enable == false))\r\n    {\r\n        clockSourceEnable = false;\r\n    }\r\n\r\n    switch (clockSource)\r\n    {\r\n        case SIRC_CLK:\r\n            retCode = CLOCK_SYS_SetSircClockSource(clockSourceEnable, clkSrcConfig, divider1, divider2);\r\n            break;\r\n\r\n        case FIRC_CLK:\r\n            retCode = CLOCK_SYS_SetFircClockSource(clockSourceEnable, clkSrcConfig, divider1, divider2);\r\n            break;\r\n\r\n        case SOSC_CLK:\r\n            retCode = CLOCK_SYS_SetSoscClockSource(clockSourceEnable, clkSrcConfig, divider1, divider2);\r\n            break;\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n        case SPLL_CLK:\r\n            retCode = CLOCK_SYS_SetSpllClockSource(clockSourceEnable, clkSrcConfig, divider1, divider2);\r\n            break;\r\n#endif\r\n\r\n        case SIM_LPO_CLK:\r\n\r\n            if (clockSourceEnable)\r\n            {\r\n                SIM_SetLpoClocks(SIM,true,true,SIM_LPO_CLK_SEL_LPO_128K,SIM_RTCCLK_SEL_SOSCDIV1_CLK);\r\n                PMC_SetLpoMode(PMC, true);\r\n            }\r\n            else\r\n            {\r\n                PMC_SetLpoMode(PMC, false);\r\n            }\r\n            break;\r\n\r\n        default:\r\n            /* Invalid name of the clock source */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n\r\n    return retCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_Init\r\n * Description   : Install pre-defined clock configurations.\r\n * This function installs the pre-defined clock configuration table to the\r\n * clock manager.\r\n *\r\n * Implements CLOCK_SYS_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t CLOCK_SYS_Init(clock_manager_user_config_t const **clockConfigsPtr,\r\n                              uint8_t configsNumber,\r\n                              clock_manager_callback_user_config_t **callbacksPtr,\r\n                              uint8_t callbacksNumber)\r\n{\r\n    DEV_ASSERT(clockConfigsPtr != NULL);\r\n    DEV_ASSERT(callbacksPtr != NULL);\r\n\r\n    g_clockState.configTable     = clockConfigsPtr;\r\n    g_clockState.clockConfigNum  = configsNumber;\r\n    g_clockState.callbackConfig  = callbacksPtr;\r\n    g_clockState.callbackNum     = callbacksNumber;\r\n\r\n    /*\r\n     * errorCallbackIndex is the index of the callback which returns error\r\n     * during clock mode switch. If all callbacks return success, then the\r\n     * errorCallbackIndex is callbacksNumber.\r\n     */\r\n    g_clockState.errorCallbackIndex = callbacksNumber;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_UpdateConfiguration\r\n * Description   : Send notification and change system clock configuration.\r\n * This function sends the notification to all callback functions, if all\r\n * callbacks return OK or forceful policy is used, this function will change\r\n * system clock configuration. The function should be called only on run mode.\r\n *\r\n * Implements CLOCK_SYS_UpdateConfiguration_Activity\r\n *END**************************************************************************/\r\nstatus_t CLOCK_SYS_UpdateConfiguration(uint8_t targetConfigIndex,\r\n                                                   clock_manager_policy_t policy)\r\n{\r\n    uint8_t callbackIdx;\r\n    bool successfulSetConfig;           /* SetConfiguraiton status */\r\n    status_t ret = STATUS_SUCCESS;\r\n    const clock_manager_callback_user_config_t * callbackConfig;\r\n    clock_notify_struct_t notifyStruct;\r\n\r\n    DEV_ASSERT(targetConfigIndex < g_clockState.clockConfigNum);       /* Clock configuration index is out of range. */\r\n\r\n    notifyStruct.targetClockConfigIndex = targetConfigIndex;\r\n    notifyStruct.policy                 = policy;\r\n\r\n    /* Disable interrupts */\r\n    INT_SYS_DisableIRQGlobal();\r\n    /* Set errorcallbackindex as callbackNum, which means no callback error now.*/\r\n    g_clockState.errorCallbackIndex = g_clockState.callbackNum;\r\n\r\n    /* First step: Send \"BEFORE\" notification. */\r\n    notifyStruct.notifyType = CLOCK_MANAGER_NOTIFY_BEFORE;\r\n\r\n    /* Send notification to all callback. */\r\n    for (callbackIdx=0; callbackIdx<g_clockState.callbackNum; callbackIdx++)\r\n    {\r\n        callbackConfig = g_clockState.callbackConfig[callbackIdx];\r\n        if ((callbackConfig) &&\r\n            (callbackConfig->callbackType != CLOCK_MANAGER_CALLBACK_AFTER))\r\n        {\r\n            if (STATUS_SUCCESS !=\r\n                    (*callbackConfig->callback)(&notifyStruct,\r\n                        callbackConfig->callbackData))\r\n            {\r\n                g_clockState.errorCallbackIndex = callbackIdx;\r\n\r\n                if (CLOCK_MANAGER_POLICY_AGREEMENT == policy)\r\n                {\r\n                    /* Save the error callback index. */\r\n                    ret = STATUS_MCU_NOTIFY_BEFORE_ERROR;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* If all callback success or forceful policy is used. */\r\n    if ((STATUS_SUCCESS == ret) ||\r\n        (policy == CLOCK_MANAGER_POLICY_FORCIBLE))\r\n    {\r\n        /* clock mode switch. */\r\n        ret = CLOCK_SYS_SetConfiguration(g_clockState.configTable[targetConfigIndex]);\r\n        successfulSetConfig = (STATUS_SUCCESS == ret);\r\n\r\n        g_clockState.curConfigIndex = targetConfigIndex;\r\n    }\r\n    else\r\n    {\r\n        /* Unsuccessful setConfiguration */\r\n        successfulSetConfig = false;\r\n    }\r\n\r\n    if(successfulSetConfig){\r\n        notifyStruct.notifyType = CLOCK_MANAGER_NOTIFY_AFTER;\r\n\r\n        for (callbackIdx=0; callbackIdx<g_clockState.callbackNum; callbackIdx++)\r\n        {\r\n            callbackConfig = g_clockState.callbackConfig[callbackIdx];\r\n            if ((callbackConfig) &&\r\n                (callbackConfig->callbackType != CLOCK_MANAGER_CALLBACK_BEFORE))\r\n            {\r\n                if (STATUS_SUCCESS !=\r\n                        (*callbackConfig->callback)(&notifyStruct,\r\n                            callbackConfig->callbackData))\r\n                {\r\n                    g_clockState.errorCallbackIndex = callbackIdx;\r\n\r\n                    if (CLOCK_MANAGER_POLICY_AGREEMENT == policy)\r\n                    {\r\n                        /* Save the error callback index. */\r\n                        ret = STATUS_MCU_NOTIFY_AFTER_ERROR;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else /* Error occurs, need to send \"RECOVER\" notification. */\r\n    {\r\n        notifyStruct.notifyType = CLOCK_MANAGER_NOTIFY_RECOVER;\r\n        for(;;)\r\n        {\r\n            callbackConfig = g_clockState.callbackConfig[callbackIdx];\r\n            if (callbackConfig != NULL)\r\n            {\r\n                (void)(*callbackConfig->callback)(&notifyStruct,\r\n                        callbackConfig->callbackData);\r\n            }\r\n            if(callbackIdx == 0U)\r\n            {\r\n                break;\r\n            }\r\n            callbackIdx--;\r\n        }\r\n    }\r\n\r\n    /* Enable interrupts */\r\n    INT_SYS_EnableIRQGlobal();\r\n\r\n    return ret;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetCurrentConfiguration\r\n * Description   : Get current clock configuration index.\r\n *\r\n * Implements CLOCK_SYS_GetCurrentConfiguration_Activity\r\n *END**************************************************************************/\r\nuint8_t CLOCK_SYS_GetCurrentConfiguration(void)\r\n{\r\n    return g_clockState.curConfigIndex;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetErrorCallback\r\n * Description   : Get the callback which returns error in last clock switch.\r\n *\r\n * Implements CLOCK_SYS_GetErrorCallback_Activity\r\n *END**************************************************************************/\r\nclock_manager_callback_user_config_t* CLOCK_SYS_GetErrorCallback(void)\r\n{\r\n    clock_manager_callback_user_config_t *retValue;\r\n\r\n    /* If all callbacks return success. */\r\n    if (g_clockState.errorCallbackIndex >= g_clockState.clockConfigNum)\r\n    {\r\n        retValue = NULL;\r\n    }\r\n    else\r\n    {\r\n        retValue = g_clockState.callbackConfig[g_clockState.errorCallbackIndex];\r\n    }\r\n    return retValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_GetFreq\r\n * Description   : Wrapper over CLOCK_DRV_GetFreq function. It's part of the old API.\r\n *\r\n * Implements CLOCK_SYS_GetFreq_Activity\r\n *END**************************************************************************/\r\nstatus_t CLOCK_SYS_GetFreq(clock_names_t clockName, uint32_t *frequency)\r\n{\r\n    return CLOCK_DRV_GetFreq(clockName,frequency);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : CLOCK_SYS_SetConfiguration\r\n * Description   : Wrapper over CLOCK_DRV_Init function. It's part of the old API.\r\n *\r\n * Implements CLOCK_SYS_SetConfiguration_Activity\r\n *END**************************************************************************/\r\nstatus_t CLOCK_SYS_SetConfiguration(clock_manager_user_config_t const * config)\r\n{\r\n    return CLOCK_DRV_Init(config);\r\n}\r\n\r\n\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"clock_S32K1xx.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\clock\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef CLOCK_S32K1xx_H\r\n#define CLOCK_S32K1xx_H\r\n\r\n/*!\r\n * @file clock_S32K1xx.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, A project should not contain unused type declarations.\r\n * The types are defined here to be used by other drivers or application.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to implement enumeration entries as macro.\r\n * Enumeration entries (macros) are referenced from application code.\r\n */\r\n\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n\r\n\r\n/*!\r\n * @ingroup clock_manager\r\n * @defgroup clock_manager_s32k1xx\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*! @brief Peripheral features list\r\n *         Constant array storing the mappings between clock names of the peripherals and feature lists.\r\n */\r\nextern const uint8_t peripheralFeaturesList[CLOCK_NAME_COUNT];\r\n\r\n\r\n/*! @brief TClk clock frequency. */\r\n#define NUMBER_OF_TCLK_INPUTS 3U\r\nextern uint32_t g_TClkFreq[NUMBER_OF_TCLK_INPUTS];      /*!< TCLKx clocks */\r\n\r\n/*! @brief EXTAL0 clock frequency. */\r\nextern uint32_t g_xtal0ClkFreq;\r\n\r\n/*! @brief RTC_CLKIN clock frequency. */\r\nextern uint32_t g_RtcClkInFreq;\r\n\r\n/*! @brief The maximum number of system clock dividers and system clock divider indexes. */\r\n#define SYS_CLK_MAX_NO    3U\r\n#define CORE_CLK_INDEX    0U\r\n#define BUS_CLK_INDEX     1U\r\n#define SLOW_CLK_INDEX    2U\r\n\r\n/*!\r\n * @brief SIM CLK32KSEL clock source select\r\n * Implements sim_rtc_clk_sel_src_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SIM_RTCCLK_SEL_SOSCDIV1_CLK   = 0x0U,           /*!< SOSCDIV1 clock          */\r\n    SIM_RTCCLK_SEL_LPO_32K        = 0x1U,           /*!< 32 kHz LPO clock        */\r\n    SIM_RTCCLK_SEL_RTC_CLKIN      = 0x2U,           /*!< RTC_CLKIN clock         */\r\n    SIM_RTCCLK_SEL_FIRCDIV1_CLK   = 0x3U,           /*!< FIRCDIV1 clock          */\r\n} sim_rtc_clk_sel_src_t;\r\n\r\n/*!\r\n * @brief SIM LPOCLKSEL clock source select\r\n * Implements sim_lpoclk_sel_src_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SIM_LPO_CLK_SEL_LPO_128K    = 0x0,           /*!< 128 kHz LPO clock */\r\n    SIM_LPO_CLK_SEL_NO_CLOCK    = 0x1,           /*!< No clock */\r\n    SIM_LPO_CLK_SEL_LPO_32K     = 0x2,           /*!< 32 kHz LPO clock which is divided by the 128 kHz LPO clock */\r\n    SIM_LPO_CLK_SEL_LPO_1K      = 0x3,           /*!< 1 kHz LPO clock which is divided by the 128 kHz LPO clock */\r\n} sim_lpoclk_sel_src_t;\r\n\r\n/*!\r\n * @brief SIM CLKOUT select\r\n * Implements sim_clkout_src_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT     = 0U,     /*!< SCG CLKOUT                                   */\r\n    SIM_CLKOUT_SEL_SYSTEM_SOSC_DIV2_CLK  = 2U,     /*!< SOSC DIV2 CLK                                */\r\n    SIM_CLKOUT_SEL_SYSTEM_SIRC_DIV2_CLK  = 4U,     /*!< SIRC DIV2 CLK                                */\r\n    SIM_CLKOUT_SEL_SYSTEM_FIRC_DIV2_CLK  = 6U,     /*!< FIRC DIV2 CLK                                */\r\n    SIM_CLKOUT_SEL_SYSTEM_HCLK           = 7U,     /*!< HCLK                                         */\r\n    SIM_CLKOUT_SEL_SYSTEM_SPLL_DIV2_CLK  = 8U,     /*!< SPLL DIV2 CLK                                */\r\n    SIM_CLKOUT_SEL_SYSTEM_BUS_CLK        = 9U,     /*!< BUS_CLK                                      */\r\n    SIM_CLKOUT_SEL_SYSTEM_LPO_128K_CLK   = 10U,    /*!< LPO_CLK 128 Khz                              */\r\n    SIM_CLKOUT_SEL_SYSTEM_LPO_CLK        = 12U,    /*!< LPO_CLK as selected by SIM LPO CLK Select    */\r\n    SIM_CLKOUT_SEL_SYSTEM_RTC_CLK        = 14U,    /*!< RTC CLK as selected by SIM CLK 32 KHz Select */\r\n\r\n#if defined (QuadSPI_INSTANCE_COUNT)\r\n    SIM_CLKOUT_SEL_SYSTEM_SFIF_CLK_HYP   = 5U,     /*!< SFIF_CLK_HYP                                 */\r\n    SIM_CLKOUT_SEL_SYSTEM_IPG_CLK        = 11U,    /*!< IPG_CLK                                      */\r\n    SIM_CLKOUT_SEL_SYSTEM_IPG_CLK_SFIF   = 13U,    /*!< IPG_CLK_SFIF                                 */\r\n    SIM_CLKOUT_SEL_SYSTEM_IPG_CLK_2XSFIF = 15U     /*!< IP_CLK_2XSFIF                                */\r\n#endif\r\n} sim_clkout_src_t;\r\n\r\n/*!\r\n * @brief SIM CLKOUT divider\r\n * Implements sim_clkout_div_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SIM_CLKOUT_DIV_BY_1 = 0x0U,        /*!< Divided by 1 */\r\n    SIM_CLKOUT_DIV_BY_2 = 0x1U,        /*!< Divided by 2 */\r\n    SIM_CLKOUT_DIV_BY_3 = 0x2U,        /*!< Divided by 3 */\r\n    SIM_CLKOUT_DIV_BY_4 = 0x3U,        /*!< Divided by 4 */\r\n    SIM_CLKOUT_DIV_BY_5 = 0x4U,        /*!< Divided by 5 */\r\n    SIM_CLKOUT_DIV_BY_6 = 0x5U,        /*!< Divided by 6 */\r\n    SIM_CLKOUT_DIV_BY_7 = 0x6U,        /*!< Divided by 7 */\r\n    SIM_CLKOUT_DIV_BY_8 = 0x7U,        /*!< Divided by 8 */\r\n} sim_clkout_div_t;\r\n\r\n\r\n/*!\r\n * @brief SIM ClockOut configuration.\r\n * Implements sim_clock_out_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool              initialize;     /*!< Initialize or not the ClockOut clock.  */\r\n    bool              enable;         /*!< SIM ClockOut enable.                   */\r\n    sim_clkout_src_t  source;         /*!< SIM ClockOut source select.            */\r\n    sim_clkout_div_t  divider;        /*!< SIM ClockOut divide ratio.             */\r\n} sim_clock_out_config_t;\r\n\r\n\r\n/*!\r\n * @brief SIM LPO Clocks configuration.\r\n * Implements sim_lpo_clock_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool                  initialize;       /*!< Initialize or not the LPO clock.     */\r\n    sim_rtc_clk_sel_src_t sourceRtcClk;     /*!< RTC_CLK source select.               */\r\n    sim_lpoclk_sel_src_t  sourceLpoClk;     /*!< LPO clock source select.             */\r\n    bool                  enableLpo32k;     /*!< MSCM Clock Gating Control enable.    */\r\n    bool                  enableLpo1k;      /*!< MSCM Clock Gating Control enable.    */\r\n} sim_lpo_clock_config_t;\r\n\r\n/*!\r\n * @brief SIM  Platform Gate Clock configuration.\r\n * Implements sim_tclk_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool      initialize;                         /*!< Initialize or not the TCLK clock.  */\r\n    uint32_t  tclkFreq[NUMBER_OF_TCLK_INPUTS];    /*!< TCLKx frequency.                    */\r\n    uint32_t  extPinSrc[FTM_INSTANCE_COUNT];     /*!< FTMx frequency.                    */\r\n} sim_tclk_config_t;\r\n\r\n/*!\r\n * @brief SIM  Platform Gate Clock configuration.\r\n * Implements sim_plat_gate_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool initialize;     /*!< Initialize or not the Trace clock.  */\r\n    bool enableMscm;     /*!< MSCM Clock Gating Control enable.   */\r\n    bool enableMpu;      /*!< MPU Clock Gating Control enable.    */\r\n    bool enableDma;      /*!< DMA Clock Gating Control enable.    */\r\n    bool enableErm;      /*!< ERM Clock Gating Control enable.    */\r\n    bool enableEim;      /*!< EIM Clock Gating Control enable.    */\r\n} sim_plat_gate_config_t;\r\n\r\n/*!\r\n * @brief SIM QSPI reference clock gating.\r\n * Implements sim_qspi_ref_clk_gating_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool enableQspiRefClk;      /*!< qspi internal reference clock gating control enable.          */\r\n} sim_qspi_ref_clk_gating_t;\r\n\r\n\r\n/*!\r\n * @brief Debug trace clock source select\r\n * Implements clock_trace_src_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    CLOCK_TRACE_SRC_CORE_CLK            = 0x0          /*!< core clock     */\r\n} clock_trace_src_t;\r\n\r\n\r\n/*!\r\n * @brief SIM Debug Trace clock configuration.\r\n * Implements sim_trace_clock_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool               initialize;    /*!< Initialize or not the Trace clock.  */\r\n    bool               divEnable;     /*!< Trace clock divider enable.         */\r\n    clock_trace_src_t  source;        /*!< Trace clock select.                 */\r\n    uint8_t            divider;       /*!< Trace clock divider divisor.        */\r\n    bool               divFraction;   /*!< Trace clock divider fraction.       */\r\n} sim_trace_clock_config_t;\r\n\r\n/*!\r\n * @brief SIM configure structure.\r\n * Implements sim_clock_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    sim_clock_out_config_t    clockOutConfig;                 /*!< Clock Out configuration.           */\r\n    sim_lpo_clock_config_t    lpoClockConfig;                 /*!< Low Power Clock configuration.     */\r\n    sim_tclk_config_t         tclkConfig;                     /*!< TCLK, FTM option Clock configuration. */\r\n    sim_plat_gate_config_t    platGateConfig;                 /*!< Platform Gate Clock configuration. */\r\n    sim_trace_clock_config_t  traceClockConfig;               /*!< Trace clock configuration.         */\r\n    sim_qspi_ref_clk_gating_t qspiRefClkGating;               /*!< Qspi Reference Clock Gating.       */\r\n} sim_clock_config_t;\r\n\r\n\r\n/*!\r\n * @brief SCG system clock source.\r\n * Implements scg_system_clock_src_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SYSTEM_CLOCK_SRC_SYS_OSC  = 1U,       /*!< System OSC. */\r\n    SCG_SYSTEM_CLOCK_SRC_SIRC     = 2U,       /*!< Slow IRC.   */\r\n    SCG_SYSTEM_CLOCK_SRC_FIRC     = 3U,       /*!< Fast IRC.   */\r\n#if FEATURE_HAS_SPLL_CLK\r\n    SCG_SYSTEM_CLOCK_SRC_SYS_PLL  = 6U,       /*!< System PLL. */\r\n#endif\r\n    SCG_SYSTEM_CLOCK_SRC_NONE     = 255U      /*!< MAX value.  */\r\n} scg_system_clock_src_t;\r\n\r\n/*!\r\n * @brief SCG system clock divider value.\r\n * Implements scg_system_clock_div_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SYSTEM_CLOCK_DIV_BY_1   = 0U,     /*!< Divided by 1. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_2   = 1U,     /*!< Divided by 2. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_3   = 2U,     /*!< Divided by 3. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_4   = 3U,     /*!< Divided by 4. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_5   = 4U,     /*!< Divided by 5. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_6   = 5U,     /*!< Divided by 6. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_7   = 6U,     /*!< Divided by 7. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_8   = 7U,     /*!< Divided by 8. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_9   = 8U,     /*!< Divided by 9. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_10  = 9U,     /*!< Divided by 10. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_11  = 10U,    /*!< Divided by 11. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_12  = 11U,    /*!< Divided by 12. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_13  = 12U,    /*!< Divided by 13. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_14  = 13U,    /*!< Divided by 14. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_15  = 14U,    /*!< Divided by 15. */\r\n    SCG_SYSTEM_CLOCK_DIV_BY_16  = 15U,    /*!< Divided by 16. */\r\n} scg_system_clock_div_t;\r\n\r\n/*!\r\n * @brief SCG system clock configuration.\r\n * Implements scg_system_clock_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_system_clock_div_t divSlow;  /*!< Slow clock divider.      */\r\n    scg_system_clock_div_t divBus;   /*!< BUS clock divider.       */\r\n    scg_system_clock_div_t divCore;  /*!< Core clock divider.      */\r\n    scg_system_clock_src_t src;      /*!< System clock source.     */\r\n} scg_system_clock_config_t;\r\n\r\n/*!\r\n * @name SCG Clockout.\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief SCG ClockOut type.\r\n * Implements scg_clockout_src_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_CLOCKOUT_SRC_SCG_SLOW = 0U,   /*!< SCG SLOW.   */\r\n    SCG_CLOCKOUT_SRC_SOSC     = 1U,   /*!< System OSC. */\r\n    SCG_CLOCKOUT_SRC_SIRC     = 2U,   /*!< Slow IRC.   */\r\n    SCG_CLOCKOUT_SRC_FIRC     = 3U,   /*!< Fast IRC.   */\r\n    SCG_CLOCKOUT_SRC_SPLL     = 6U,   /*!< System PLL. */\r\n} scg_clockout_src_t;\r\n/*! @} */\r\n\r\n\r\n/*!\r\n * @brief SCG asynchronous clock divider value.\r\n * Implements scg_async_clock_div_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_ASYNC_CLOCK_DISABLE   = 0U,        /*!< Clock output is disabled.  */\r\n    SCG_ASYNC_CLOCK_DIV_BY_1  = 1U,        /*!< Divided by 1.              */\r\n    SCG_ASYNC_CLOCK_DIV_BY_2  = 2U,        /*!< Divided by 2.              */\r\n    SCG_ASYNC_CLOCK_DIV_BY_4  = 3U,        /*!< Divided by 4.              */\r\n    SCG_ASYNC_CLOCK_DIV_BY_8  = 4U,        /*!< Divided by 8.              */\r\n    SCG_ASYNC_CLOCK_DIV_BY_16 = 5U,        /*!< Divided by 16.             */\r\n    SCG_ASYNC_CLOCK_DIV_BY_32 = 6U,        /*!< Divided by 32.             */\r\n    SCG_ASYNC_CLOCK_DIV_BY_64 = 7U         /*!< Divided by 64.             */\r\n} scg_async_clock_div_t;\r\n\r\n\r\n/*!\r\n * @brief SCG system OSC monitor mode.\r\n * Implements scg_sosc_monitor_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SOSC_MONITOR_DISABLE = 0U,                         /*!< Monitor disable.                          */\r\n    SCG_SOSC_MONITOR_INT     = 1U,                         /*!< Interrupt when system OSC error detected. */\r\n    SCG_SOSC_MONITOR_RESET   = 2U,                          /*!< Reset when system OSC error detected.     */\r\n} scg_sosc_monitor_mode_t;\r\n\r\n/*!\r\n * @brief SCG OSC frequency range select\r\n * Implements scg_sosc_range_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SOSC_RANGE_MID    = 2U,  /*!< Medium frequency range selected for the crystal OSC (4 Mhz to 8 Mhz).  */\r\n    SCG_SOSC_RANGE_HIGH   = 3U,  /*!< High frequency range selected for the crystal OSC (8 Mhz to 40 Mhz).   */\r\n} scg_sosc_range_t;\r\n\r\n/*!\r\n * @brief SCG OSC high gain oscillator select.\r\n * Implements scg_sosc_gain_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SOSC_GAIN_LOW    = 0x0,  /*!< Configure crystal oscillator for low-power operation */\r\n    SCG_SOSC_GAIN_HIGH   = 0x1,  /*!< Configure crystal oscillator for high-gain operation */\r\n} scg_sosc_gain_t;\r\n\r\n/*!\r\n * @brief SCG OSC external reference clock select.\r\n * Implements scg_sosc_ext_ref_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SOSC_REF_EXT   = 0x0,     /*!< External reference clock requested    */\r\n    SCG_SOSC_REF_OSC   = 0x1,     /*!< Internal oscillator of OSC requested. */\r\n} scg_sosc_ext_ref_t;\r\n\r\n/*!\r\n * @brief SCG system OSC configuration.\r\n * Implements scg_sosc_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint32_t  freq;                        /*!< System OSC frequency.                                 */\r\n\r\n    scg_sosc_monitor_mode_t monitorMode;   /*!< System OSC Clock monitor mode.                       */\r\n\r\n    scg_sosc_ext_ref_t extRef;             /*!< System OSC External Reference Select.                */\r\n    scg_sosc_gain_t    gain;               /*!< System OSC high-gain operation.                      */\r\n\r\n    scg_sosc_range_t   range;              /*!< System OSC frequency range.                          */\r\n\r\n    scg_async_clock_div_t div1;            /*!< Asynchronous peripheral source.                      */\r\n    scg_async_clock_div_t div2;            /*!< Asynchronous peripheral source.                      */\r\n\r\n    bool enableInStop;                     /*!< System OSC is enable or not in stop mode.            */\r\n    bool enableInLowPower;                 /*!< System OSC is enable or not in low power mode.       */\r\n\r\n    bool locked;                           /*!< System OSC Control Register can be written.          */\r\n\r\n    bool initialize;                       /*!< Initialize or not the System OSC module.             */\r\n} scg_sosc_config_t;\r\n\r\n/*!\r\n * @brief SCG slow IRC clock frequency range.\r\n * Implements scg_sirc_range_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SIRC_RANGE_HIGH = 1U,  /*!< Slow IRC high range clock (8 MHz). */\r\n} scg_sirc_range_t;\r\n\r\n/*!\r\n * @brief SCG slow IRC clock configuration.\r\n * Implements scg_sirc_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_sirc_range_t range;         /*!< Slow IRC frequency range.                 */\r\n\r\n    scg_async_clock_div_t div1;     /*!< Asynchronous peripheral source.           */\r\n    scg_async_clock_div_t div2;     /*!< Asynchronous peripheral source.           */\r\n\r\n    bool initialize;                /*!< Initialize or not the SIRC module.        */\r\n    bool enableInStop;              /*!< SIRC is enable or not in stop mode.       */\r\n    bool enableInLowPower;          /*!< SIRC is enable or not in low power mode.  */\r\n\r\n    bool locked;                    /*!< SIRC Control Register can be written.     */\r\n} scg_sirc_config_t;\r\n\r\n/*!\r\n * @brief SCG fast IRC clock frequency range.\r\n * Implements scg_firc_range_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_FIRC_RANGE_48M,   /*!< Fast IRC is trimmed to 48MHz.  */\r\n} scg_firc_range_t;\r\n\r\n/*!\r\n * @brief SCG fast IRC clock configuration.\r\n * Implements scg_firc_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_firc_range_t range;            /*!< Fast IRC frequency range.                 */\r\n\r\n    scg_async_clock_div_t div1;        /*!< Asynchronous peripheral source.           */\r\n    scg_async_clock_div_t div2;        /*!< Asynchronous peripheral source.           */\r\n\r\n    bool enableInStop;                 /*!< FIRC is enable or not in stop mode.       */\r\n    bool enableInLowPower;             /*!< FIRC is enable or not in lowpower mode.   */\r\n    bool regulator;                    /*!< FIRC regulator is enable or not.          */\r\n    bool locked;                       /*!< FIRC Control Register can be written.     */\r\n\r\n    bool initialize;                   /*!< Initialize or not the FIRC module.        */\r\n} scg_firc_config_t;\r\n\r\n/*!\r\n * @brief SCG system PLL monitor mode.\r\n * Implements scg_spll_monitor_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SPLL_MONITOR_DISABLE = 0U,                         /*!< Monitor disable.                          */\r\n    SCG_SPLL_MONITOR_INT     = 1U,                         /*!< Interrupt when system PLL error detected. */\r\n    SCG_SPLL_MONITOR_RESET   = 2U                          /*!< Reset when system PLL error detected.     */\r\n} scg_spll_monitor_mode_t;\r\n\r\n\r\n/*!\r\n * @brief SCG system PLL predivider.\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SPLL_CLOCK_PREDIV_BY_1 = 0U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_2 = 1U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_3 = 2U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_4 = 3U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_5 = 4U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_6 = 5U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_7 = 6U,\r\n    SCG_SPLL_CLOCK_PREDIV_BY_8 = 7U\r\n\r\n} scg_spll_clock_prediv_t;\r\n\r\n/*!\r\n * @brief SCG system PLL multiplier.\r\n */\r\ntypedef enum\r\n{\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_16 = 0U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_17 = 1U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_18 = 2U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_19 = 3U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_20 = 4U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_21 = 5U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_22 = 6U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_23 = 7U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_24 = 8U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_25 = 9U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_26 = 10U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_27 = 11U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_28 = 12U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_29 = 13U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_30 = 14U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_31 = 15U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_32 = 16U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_33 = 17U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_34 = 18U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_35 = 19U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_36 = 20U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_37 = 21U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_38 = 22U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_39 = 23U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_40 = 24U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_41 = 25U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_42 = 26U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_43 = 27U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_44 = 28U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_45 = 29U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_46 = 30U,\r\n    SCG_SPLL_CLOCK_MULTIPLY_BY_47 = 31U\r\n} scg_spll_clock_multiply_t;\r\n\r\n/*!\r\n * @brief SCG system PLL configuration.\r\n * Implements scg_spll_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_spll_monitor_mode_t monitorMode; /*!< Clock monitor mode selected.                    */\r\n\r\n    uint8_t        prediv;               /*!< PLL reference clock divider.                    */\r\n    uint8_t        mult;                 /*!< System PLL multiplier.                          */\r\n    uint8_t        src;                  /*!< System PLL source.                              */\r\n\r\n    scg_async_clock_div_t div1;          /*!< Asynchronous peripheral source.                 */\r\n    scg_async_clock_div_t div2;          /*!< Asynchronous peripheral source.                 */\r\n\r\n    bool enableInStop;                   /*!< System PLL clock is enable or not in stop mode. */\r\n\r\n    bool locked;                         /*!< System PLL Control Register can be written.     */\r\n    bool initialize;                     /*!< Initialize or not the System PLL module.        */\r\n} scg_spll_config_t;\r\n\r\n/*!\r\n * @brief SCG RTC configuration.\r\n * Implements scg_rtc_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint32_t rtcClkInFreq;              /*!< RTC_CLKIN frequency.                            */\r\n    bool initialize;                    /*!< Initialize or not the RTC.                      */\r\n} scg_rtc_config_t;\r\n\r\n/*!\r\n * @brief SCG Clock Mode Configuration structure.\r\n * Implements scg_clock_mode_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_system_clock_config_t rccrConfig;      /*!< Run Clock Control configuration.                 */\r\n    scg_system_clock_config_t vccrConfig;      /*!< VLPR Clock Control configuration.                */\r\n    scg_system_clock_config_t hccrConfig;      /*!< HSRUN Clock Control configuration.               */\r\n    scg_system_clock_src_t    alternateClock;  /*!< Alternate clock used during initialization       */\r\n    bool                      initialize;      /*!< Initialize or not the Clock Mode Configuration.  */\r\n} scg_clock_mode_config_t;\r\n\r\n/*!\r\n * @brief SCG ClockOut Configuration structure.\r\n * Implements scg_clockout_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_clockout_src_t        source;          /*!< ClockOut source select.                          */\r\n    bool                      initialize;      /*!< Initialize or not the ClockOut.                  */\r\n} scg_clockout_config_t;\r\n\r\n/*!\r\n * @brief SCG configure structure.\r\n * Implements scg_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_sirc_config_t         sircConfig;      /*!< Slow internal reference clock configuration.     */\r\n    scg_firc_config_t         fircConfig;      /*!< Fast internal reference clock configuration.     */\r\n    scg_sosc_config_t         soscConfig;      /*!< System oscillator configuration.                 */\r\n    scg_spll_config_t         spllConfig;      /*!< System Phase locked loop configuration.          */\r\n    scg_rtc_config_t          rtcConfig;       /*!< Real Time Clock configuration.                   */\r\n    scg_clockout_config_t     clockOutConfig;  /*!< SCG ClockOut Configuration.                      */\r\n    scg_clock_mode_config_t   clockModeConfig; /*!< SCG Clock Mode Configuration.                    */\r\n} scg_config_t;\r\n\r\n/*! @brief PCC clock source select\r\n *  Implements peripheral_clock_source_t_Class\r\n */\r\ntypedef uint8_t peripheral_clock_source_t;\r\n\r\n#define    CLK_SRC_OFF          0x00U             /*!< Clock is off */\r\n#define    CLK_SRC_SOSC         0x01U             /*!< OSCCLK - System Oscillator Bus Clock */\r\n#define    CLK_SRC_SIRC         0x02U             /*!< SCGIRCLK - Slow IRC Clock */\r\n#define    CLK_SRC_FIRC         0x03U             /*!< SCGFIRCLK - Fast IRC Clock */\r\n#define    CLK_SRC_SPLL         0x06U             /*!< SCGPCLK System PLL clock */\r\n#define    CLK_SRC_SOSC_DIV1    0x01U             /*!< OSCCLK - System Oscillator Bus Clock */\r\n#define    CLK_SRC_SIRC_DIV1    0x02U             /*!< SCGIRCLK - Slow IRC Clock */\r\n#define    CLK_SRC_FIRC_DIV1    0x03U             /*!< SCGFIRCLK - Fast IRC Clock */\r\n#define    CLK_SRC_SPLL_DIV1    0x06U             /*!< SCGPCLK System PLL clock */\r\n#define    CLK_SRC_SOSC_DIV2    0x01U             /*!< OSCCLK - System Oscillator Bus Clock */\r\n#define    CLK_SRC_SIRC_DIV2    0x02U             /*!< SCGIRCLK - Slow IRC Clock */\r\n#define    CLK_SRC_FIRC_DIV2    0x03U             /*!< SCGFIRCLK - Fast IRC Clock */\r\n#define    CLK_SRC_SPLL_DIV2    0x06U             /*!< SCGPCLK System PLL clock */\r\n#ifdef FEATURE_HAS_LPO_PERIPHERAL_CLOCK_SOURCE\r\n#define    CLK_SRC_LPO          0x07U             /*!< LPO clock */\r\n#endif\r\n\r\n/*! @brief PCC fractional value select\r\n *  Implements peripheral_clock_frac_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    MULTIPLY_BY_ONE   = 0x00U,             /*!< Fractional value is zero */\r\n    MULTIPLY_BY_TWO   = 0x01U              /*!< Fractional value is one */\r\n} peripheral_clock_frac_t;\r\n\r\n/*! @brief PCC divider value select\r\n *  Implements peripheral_clock_divider_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    DIVIDE_BY_ONE     = 0x00U,             /*!< Divide by 1 (pass-through, no clock divide) */\r\n    DIVIDE_BY_TWO     = 0x01U,             /*!< Divide by 2 */\r\n    DIVIDE_BY_THREE   = 0x02U,             /*!< Divide by 3 */\r\n    DIVIDE_BY_FOUR    = 0x03U,             /*!< Divide by 4 */\r\n    DIVIDE_BY_FIVE    = 0x04U,             /*!< Divide by 5 */\r\n    DIVIDE_BY_SIX     = 0x05U,             /*!< Divide by 6 */\r\n    DIVIDE_BY_SEVEN   = 0x06U,             /*!< Divide by 7 */\r\n    DIVIDE_BY_EIGTH   = 0x07U              /*!< Divide by 8 */\r\n} peripheral_clock_divider_t;\r\n\r\n/*! @brief PCC peripheral instance clock configuration.\r\n *  Implements peripheral_clock_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    /* clockName   is the name of the peripheral clock\r\n     *    must be one of the following values (see the clock_names_t type from S32K1xx_clock_names.h)\r\n     *    PCC_DMA0_CLOCK\r\n     *    PCC_MPU0_CLOCK\r\n     *    ...\r\n     *    PCC_LPUART3_CLOCK\r\n     */\r\n    clock_names_t clockName;\r\n    bool clkGate;                                      /*!< Peripheral clock gate.                     */\r\n    peripheral_clock_source_t clkSrc;                  /*!< Peripheral clock source.                   */\r\n    peripheral_clock_frac_t frac;                      /*!< Peripheral clock fractional value.         */\r\n    peripheral_clock_divider_t divider;                /*!< Peripheral clock divider value.            */\r\n} peripheral_clock_config_t;\r\n\r\n/*! @brief PCC configuration.\r\n *  Implements pcc_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint32_t count;                                    /*!< Number of peripherals to be configured.               */\r\n    peripheral_clock_config_t * peripheralClocks;       /*!< Pointer to the peripheral clock configurations array. */\r\n} pcc_config_t;\r\n\r\n/*! @brief PMC LPO configuration.\r\n * Implements pmc_lpo_clock_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool                  initialize;       /*!< Initialize or not the PMC LPO settings. */\r\n    bool                  enable;           /*!< Enable/disable LPO     */\r\n    int8_t                trimValue;        /*!< LPO trimming value     */\r\n} pmc_lpo_clock_config_t;\r\n\r\n/*!\r\n * @brief PMC configure structure.\r\n * Implements pmc_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    pmc_lpo_clock_config_t lpoClockConfig;   /*!< Low Power Clock configuration.     */\r\n} pmc_config_t;\r\n\r\n/*!\r\n * @brief Clock configuration structure.\r\n * Implements clock_manager_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    scg_config_t                scgConfig;      /*!< SCG Clock configuration.      */\r\n    sim_clock_config_t          simConfig;      /*!< SIM Clock configuration.      */\r\n    pcc_config_t                pccConfig;      /*!< PCC Clock configuration.      */\r\n    pmc_config_t                pmcConfig;      /*!< PMC Clock configuration.      */\r\n} clock_manager_user_config_t;\r\n\r\ntypedef clock_manager_user_config_t clock_user_config_t;\r\n\r\n/*!\r\n * @brief Power mode.\r\n * Implements pwr_modes_t_Class\r\n */\r\ntypedef enum {\r\n\r\n    NO_MODE       = 0U,\r\n    RUN_MODE      = (1U<<0U),\r\n    VLPR_MODE     = (1U<<1U),\r\n    HSRUN_MODE    = (1U<<2U),\r\n    STOP_MODE     = (1U<<3U),\r\n    VLPS_MODE     = (1U<<4U),\r\n    ALL_MODES     = 0x7FFFFFFF\r\n\r\n} pwr_modes_t;\r\n\r\n\r\n/*!\r\n * @brief XOSC reference clock select (internal oscillator is bypassed or not)\r\n * Implements xosc_ref_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    XOSC_EXT_REF  = 0U,      /*!< Internal oscillator is bypassed, external reference clock requested. */\r\n    XOSC_INT_OSC  = 1U,      /*!< Internal oscillator of XOSC requested. */\r\n} xosc_ref_t;\r\n\r\n/*! @brief module clock configuration.\r\n *  Implements module_clk_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool          gating;                     /*!< Clock gating. */\r\n    clock_names_t source;                     /*!< Clock source input (some modules don't have protocol clock) */\r\n    uint16_t      mul;                        /*!< Multiplier (some modules don't have fractional) */\r\n    uint16_t      div;                        /*!< Divider (some modules don't have divider) */\r\n\r\n}module_clk_config_t;\r\n\r\n/*!\r\n * @brief System clock configuration.\r\n * Implements sys_clk_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    clock_names_t src;                         /*!< System clock source. */\r\n    uint16_t dividers[SYS_CLK_MAX_NO];         /*!< System clock dividers. Value by which system clock is divided. 0 means that system clock is not divided. */\r\n} sys_clk_config_t;\r\n\r\n/*!\r\n * @brief Clock source configuration.\r\n * Implements clock_source_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n\tbool       enable;                   /*!< Enable/disable clock source. */\r\n\txosc_ref_t refClk;                   /*!< Bypass option. It applies to external oscillator clock sources                          */\r\n    uint32_t   refFreq;                  /*!< Frequency of the input reference clock. It applies to external oscillator clock sources */\r\n\tuint16_t   mul;                      /*!< Multiplier. It applies to PLL clock sources. Valid range is 16 - 47. */\r\n\tuint16_t   div;                      /*!< Divider. It applies to PLL clock sources. Valid range is 1-8. */\r\n\r\n\tuint16_t   outputDiv1;               /*!< First output divider. It's used as protocol clock by modules. Zero means that divider is disabled.   /\r\n\t\t\t\t\t\t\t\t\t\t  *   Possible values 0(disabled), 1, 2, 4, 8, 16, 32, 64; all the other values are not valid.             /\r\n\t\t\t\t\t\t\t\t\t\t  */\r\n\tuint16_t   outputDiv2;               /*!< Second output divider. It's used as protocol clock by modules. Zero means that divider is disabled.   /\r\n\t\t\t\t\t\t\t\t\t\t  *   Possible values 0(disabled), 1, 2, 4, 8, 16, 32, 64; all the other values are not valid.              /\r\n\t\t\t\t\t\t\t\t\t\t  */\r\n\r\n} clock_source_config_t;\r\n\r\n\r\n/*!\r\n * @brief The clock notification type.\r\n * Implements clock_manager_notify_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    CLOCK_MANAGER_NOTIFY_RECOVER = 0x00U,  /*!< Notify IP to recover to previous work state.      */\r\n    CLOCK_MANAGER_NOTIFY_BEFORE  = 0x01U,  /*!< Notify IP that system will change clock setting.  */\r\n    CLOCK_MANAGER_NOTIFY_AFTER   = 0x02U,  /*!< Notify IP that have changed to new clock setting. */\r\n} clock_manager_notify_t;\r\n\r\n/*!\r\n * @brief The callback type, indicates what kinds of notification this callback handles.\r\n * Implements clock_manager_callback_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    CLOCK_MANAGER_CALLBACK_BEFORE       = 0x01U, /*!< Callback handles BEFORE notification.          */\r\n    CLOCK_MANAGER_CALLBACK_AFTER        = 0x02U, /*!< Callback handles AFTER notification.           */\r\n    CLOCK_MANAGER_CALLBACK_BEFORE_AFTER = 0x03U  /*!< Callback handles BEFORE and AFTER notification */\r\n} clock_manager_callback_type_t;\r\n\r\n/*!\r\n * @brief Clock transition policy.\r\n * Implements clock_manager_policy_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    CLOCK_MANAGER_POLICY_AGREEMENT,  /*!< Clock transfers gracefully. */\r\n    CLOCK_MANAGER_POLICY_FORCIBLE    /*!< Clock transfers forcefully. */\r\n} clock_manager_policy_t;\r\n\r\n/*!\r\n * @brief Clock notification structure passed to clock callback function.\r\n * Implements clock_notify_struct_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t targetClockConfigIndex;    /*!< Target clock configuration index. */\r\n    clock_manager_policy_t policy;     /*!< Clock transition policy.          */\r\n    clock_manager_notify_t notifyType; /*!< Clock notification type.          */\r\n} clock_notify_struct_t;\r\n\r\n/*!\r\n * @brief Type of clock callback functions.\r\n */\r\ntypedef status_t (*clock_manager_callback_t)(clock_notify_struct_t *notify,\r\n                                             void* callbackData);\r\n\r\n/*!\r\n * @brief Structure for callback function and its parameter.\r\n * Implements clock_manager_callback_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    clock_manager_callback_t      callback;      /*!< Entry of callback function.     */\r\n    clock_manager_callback_type_t callbackType;  /*!< Callback type.                  */\r\n    void* callbackData;                          /*!< Parameter of callback function. */\r\n} clock_manager_callback_user_config_t;\r\n\r\n/*!\r\n * @brief Clock manager state structure.\r\n * Implements clock_manager_state_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    clock_manager_user_config_t const **configTable;/*!< Pointer to clock configure table.*/\r\n    uint8_t clockConfigNum;                         /*!< Number of clock configurations.  */\r\n    uint8_t curConfigIndex;                         /*!< Index of current configuration.  */\r\n    clock_manager_callback_user_config_t **callbackConfig; /*!< Pointer to callback table.*/\r\n    uint8_t callbackNum;                            /*!< Number of clock callbacks.       */\r\n    uint8_t errorCallbackIndex;                     /*!< Index of callback returns error. */\r\n} clock_manager_state_t;\r\n\r\n\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined (__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n/*!\r\n * @brief Configures module clock\r\n *\r\n * This function configures a module clock according to the configuration.\r\n * If no configuration is provided (moduleClkConfig is null), then a default one is used\r\n * moduleClkConfig must be passed as null when module doesn't support protocol clock.\r\n *\r\n * @param[in] peripheralClock   Clock name of the configured module clock\r\n * @param[in] moduleClkConfig   Pointer to the configuration structure.\r\n */\r\nvoid CLOCK_DRV_SetModuleClock(clock_names_t peripheralClock, const module_clk_config_t * moduleClkConfig);\r\n\r\n/*!\r\n * @brief Configures the system clocks.\r\n *\r\n * This function configures the system clocks (core, bus and flash clocks) in the specified power mode.\r\n * If no power mode is specified (null parameter) then it is the current power mode.\r\n *\r\n * @param[in] mode              Pointer to power mode for which the configured system clocks apply\r\n * @param[in] sysClkConfig      Pointer to the system clocks configuration structure.\r\n */\r\nstatus_t CLOCK_DRV_SetSystemClock(const pwr_modes_t * mode,\r\n                                  const sys_clk_config_t * sysClkConfig);\r\n\r\n/*!\r\n * @brief Gets the system clock source.\r\n *\r\n * This function gets the current system clock source.\r\n *\r\n * @return Value of the current system clock source.\r\n */\r\nvoid CLOCK_DRV_GetSystemClockSource(sys_clk_config_t *sysClkConfig);\r\n\r\n/*!\r\n * @brief This function configures a clock source.\r\n *\r\n * The clock source is configured based on the provided configuration.\r\n * All values from the previous configuration of clock source are overwritten.\r\n * If no configuration is provided, then a default one is used.\r\n *\r\n * @param[in] clockSource  Clock name of the configured clock source\r\n * @param[in] clkSrcConfig Pointer to the configuration structure\r\n * @return Status of clock source initialization\r\n */\r\nstatus_t CLOCK_DRV_SetClockSource(clock_names_t clockSource, const clock_source_config_t * clkSrcConfig);\r\n\r\n/*!\r\n * @brief Install pre-defined clock configurations.\r\n *\r\n * This function installs the pre-defined clock configuration table to\r\n * clock manager.\r\n *\r\n * @param[in] clockConfigsPtr Pointer to the clock configuration table.\r\n * @param[in] configsNumber Number of clock configurations in table.\r\n * @param[in] callbacksPtr Pointer to the callback configuration table.\r\n * @param[in] callbacksNumber Number of callback configurations in table.\r\n *\r\n * @return Error code.\r\n */\r\nstatus_t CLOCK_SYS_Init(clock_manager_user_config_t const **clockConfigsPtr,\r\n                        uint8_t configsNumber,\r\n                        clock_manager_callback_user_config_t **callbacksPtr,\r\n                        uint8_t callbacksNumber);\r\n\r\n/*!\r\n * @brief Set system clock configuration according to pre-defined structure.\r\n *\r\n * This function sets system to target clock configuration; before transition,\r\n * clock manager will send notifications to all drivers registered to the\r\n * callback table.  When graceful policy is used, if some drivers are not ready\r\n * to change, clock transition will not occur, all drivers still work in\r\n * previous configuration and error is returned. When forceful policy is used,\r\n * all drivers should stop work and system changes to new clock configuration.\r\n * The function should be called only on run mode.\r\n *\r\n * @param[in] targetConfigIndex Index of the clock configuration.\r\n * @param[in] policy Transaction policy, graceful or forceful.\r\n *\r\n * @return Error code.\r\n *\r\n * @note If external clock is used in the target mode, please make sure it is\r\n * enabled, for example, if the external oscillator is used, please setup\r\n * EREFS/HGO correctly and make sure OSCINIT is set.\r\n */\r\nstatus_t CLOCK_SYS_UpdateConfiguration(uint8_t targetConfigIndex,\r\n                                       clock_manager_policy_t policy);\r\n\r\n/*!\r\n * @brief Set system clock configuration.\r\n *\r\n * This function sets the system to target configuration, it only sets the\r\n * clock modules registers for clock mode change, but not send notifications\r\n * to drivers. This function is different by different SoCs.\r\n *\r\n * @param[in] config Target configuration.\r\n *\r\n * @return Error code.\r\n *\r\n * @note If external clock is used in the target mode, please make sure it is\r\n * enabled, for example, if the external oscillator is used, please setup\r\n * EREFS/HGO correctly and make sure OSCINIT is set.\r\n * This function should be called only on run mode.\r\n */\r\nstatus_t CLOCK_SYS_SetConfiguration(clock_manager_user_config_t const * config);\r\n\r\n/*!\r\n * @brief Get current system clock configuration.\r\n *\r\n * @return Current clock configuration index.\r\n */\r\nuint8_t CLOCK_SYS_GetCurrentConfiguration(void);\r\n\r\n/*!\r\n * @brief Get the callback which returns error in last clock switch.\r\n *\r\n * When graceful policy is used, if some IP is not ready to change clock\r\n * setting, the callback will return error and system stay in current\r\n * configuration. Applications can use this function to check which\r\n * IP callback returns error.\r\n *\r\n * @return Pointer to the callback which returns error.\r\n */\r\nclock_manager_callback_user_config_t* CLOCK_SYS_GetErrorCallback(void);\r\n\r\n/*!\r\n * @brief Wrapper over CLOCK_DRV_GetFreq function. It's part of the old API.\r\n *\r\n * @param[in] clockName Clock names defined in clock_names_t\r\n * @param[out] frequency Returned clock frequency value in Hertz\r\n * @return status   Error code defined in status_t\r\n */\r\nstatus_t CLOCK_SYS_GetFreq(clock_names_t clockName, uint32_t *frequency);\r\n\r\n\r\n#if defined (__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n/*! @}*/\r\n\r\n#endif /* CLOCK_S32K1xx_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"clock_manager.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\inc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n#if !defined(CLOCK_MANAGER_H)\r\n#define CLOCK_MANAGER_H\r\n#include \"clock.h\"\r\n/*!\r\n * @file clock_manager.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This header file is included by application only. It was created \r\n * for backward compatibility reasons.\r\n */\r\n#endif /* CLOCK_MANAGER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"devassert.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef DEVASSERT_H\r\n#define DEVASSERT_H\r\n\r\n#include <stdbool.h>\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, global macro not referenced.\r\n * The macro is defined to be used by drivers to validate input parameters and can be disabled.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro defined.\r\n * The macros are used to validate input parameters to driver functions.\r\n *\r\n */\r\n\r\n/**\r\n\\page Error_detection_and_reporting Error detection and reporting\r\n\r\nS32 SDK drivers can use a mechanism to validate data coming from upper software layers (application code) by performing\r\na number of checks on input parameters' range or other invariants that can be statically checked (not dependent on\r\nruntime conditions). A failed validation is indicative of a software bug in application code, therefore it is important\r\nto use this mechanism during development.\r\n\r\nThe validation is performed by using DEV_ASSERT macro.\r\nA default implementation of this macro is provided in this file. However, application developers can provide their own\r\nimplementation in a custom file. This requires defining the CUSTOM_DEVASSERT symbol with the specific file name in the\r\nproject configuration (for example: -DCUSTOM_DEVASSERT=\"custom_devassert.h\")\r\n\r\nThe default implementation accommodates two behaviors, based on DEV_ERROR_DETECT symbol:\r\n - When DEV_ERROR_DETECT symbol is defined in the project configuration (for example: -DDEV_ERROR_DETECT), the validation\r\n   performed by the DEV_ASSERT macro is enabled, and a failed validation triggers a software breakpoint and further execution is\r\n   prevented (application spins in an infinite loop)\r\n   This configuration is recommended for development environments, as it prevents further execution and allows investigating\r\n   potential problems from the point of error detection.\r\n - When DEV_ERROR_DETECT symbol is not defined, the DEV_ASSERT macro is implemented as no-op, therefore disabling all validations.\r\n   This configuration can be used to eliminate the overhead of development-time checks.\r\n\r\nIt is the application developer's responsibility to decide the error detection strategy for production code: one can opt to\r\ndisable development-time checking altogether (by not defining DEV_ERROR_DETECT symbol), or one can opt to keep the checks\r\nin place and implement a recovery mechanism in case of a failed validation, by defining CUSTOM_DEVASSERT to point\r\nto the file containing the custom implementation.\r\n*/\r\n\r\n#if defined (CUSTOM_DEVASSERT)\r\n    /* If the CUSTOM_DEVASSERT symbol is defined, then add the custom implementation */\r\n    #include CUSTOM_DEVASSERT\r\n#elif defined (DEV_ERROR_DETECT)\r\n    /* Implement default assert macro */\r\nstatic inline void DevAssert(volatile bool x)\r\n{\r\n    if(x) { } else { BKPT_ASM; for(;;) {} }\r\n}\r\n    #define DEV_ASSERT(x) DevAssert(x)\r\n#else\r\n    /* Assert macro does nothing */\r\n    #define DEV_ASSERT(x) ((void)0)\r\n#endif\r\n\r\n#endif /* DEVASSERT_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"device_registers.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n** ###################################################################\r\n**     Abstract:\r\n**         Common include file for CMSIS register access layer headers.\r\n**\r\n**     Copyright (c) 2015 Freescale Semiconductor, Inc.\r\n**     Copyright 2016-2020 NXP\r\n**     All rights reserved.\r\n**\r\n**     NXP Confidential. This software is owned or controlled by NXP and may only be\r\n**     used strictly in accordance with the applicable license terms. By expressly\r\n**     accepting such terms or by downloading, installing, activating and/or otherwise\r\n**     using the software, you are agreeing that you have read, and that you agree to\r\n**     comply with and are bound by, such license terms. If you do not agree to be\r\n**     bound by the applicable license terms, then you may not retain, install,\r\n**     activate or otherwise use the software. The production use license in\r\n**     Section 2.3 is expressly granted for this software.\r\n**\r\n**     http:                 www.nxp.com\r\n**     mail:                 support@nxp.com\r\n** ###################################################################\r\n*/\r\n\r\n#ifndef DEVICE_REGISTERS_H\r\n#define DEVICE_REGISTERS_H\r\n\r\n/**\r\n* @page misra_violations MISRA-C:2012 violations\r\n*\r\n* @section [global]\r\n* Violates MISRA 2012 Advisory Rule 2.5, global macro not referenced.\r\n* The macro defines the device currently in use and may be used by components for specific checks.\r\n*\r\n*/\r\n\r\n\r\n/*\r\n * Include the cpu specific register header files.\r\n *\r\n * The CPU macro should be declared in the project or makefile.\r\n */\r\n\r\n#if (defined(CPU_S32K148) || defined(CPU_S32K146) || defined(CPU_S32K144HFT0VLLT) || defined(CPU_S32K144LFT0MLLT) || defined(CPU_S32K142) || defined(CPU_S32K142W) || defined(CPU_S32K144W))\r\n\r\n    #define S32K14x_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_cm4.h\"\r\n\r\n    #if defined(CPU_S32K148)\r\n\r\n        #define S32K148_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32K148/include/S32K148.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K148/include/S32K148_features.h\"\r\n\r\n    #elif defined(CPU_S32K146)\r\n\r\n        #define S32K146_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32K146/include/S32K146.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K146/include/S32K146_features.h\"\r\n\r\n    #elif (defined(CPU_S32K144HFT0VLLT) || defined(CPU_S32K144LFT0MLLT))\r\n\r\n        #define S32K144_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32K144/include/S32K144.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K144/include/S32K144_features.h\"\r\n\r\n    #elif defined(CPU_S32K142)\r\n\r\n        #define S32K142_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32K142/include/S32K142.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K142/include/S32K142_features.h\"\r\n        \r\n    #elif defined(CPU_S32K142W)\r\n\r\n        #define S32K142W_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32K142W/include/S32K142W.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K142W/include/S32K142W_features.h\"\r\n        \r\n    #elif defined(CPU_S32K144W)\r\n\r\n        #define S32K144W_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32K144W/include/S32K144W.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K144W/include/S32K144W_features.h\"\r\n\r\n    #endif\r\n\r\n#elif defined(CPU_S32V234)\r\n\r\n    #define S32V234_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_cm4.h\"\r\n    /* Register definitions */\r\n    #include \"S32V234/include/S32V234.h\"\r\n    /* CPU specific feature definitions */\r\n    #include \"S32V234/include/S32V234_features.h\"\r\n\r\n#elif (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n\r\n    #define S32K11x_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_cm0.h\"\r\n    \r\n    #if defined(CPU_S32K116)\r\n    \r\n        #define S32K116_SERIES\r\n        /* Register definitions */\r\n        #include \"S32K116/include/S32K116.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K116/include/S32K116_features.h\"\r\n    #elif defined(CPU_S32K118)\r\n    \r\n        #define S32K118_SERIES\r\n        /* Register definitions */\r\n        #include \"S32K118/include/S32K118.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32K118/include/S32K118_features.h\"\r\n        \r\n    #endif\r\n\r\n#elif defined(CPU_MPC5777C)\r\n\r\n    #define MPC5777C_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_e200.h\"\r\n    /* Register definitions */\r\n    #include \"MPC5777C/include/MPC5777C.h\"\r\n    /* CPU specific feature definitions */\r\n    #include \"MPC5777C/include/MPC5777C_features.h\"\r\n\r\n#elif (defined(CPU_MPC5746R) || defined(CPU_MPC5748G) || defined(CPU_MPC5746C) || defined(CPU_MPC5741P)|| defined(CPU_MPC5742P)|| defined(CPU_MPC5743P)|| defined(CPU_MPC5744P) || defined(CPU_MPC5744B) || defined(CPU_MPC5745B) || defined(CPU_MPC5746B) || defined(CPU_MPC5744C) || defined(CPU_MPC5745C) || defined(CPU_MPC5747C) || defined(CPU_MPC5748C) || defined(CPU_MPC5746G) || defined(CPU_MPC5747G))\r\n\r\n    #define MPC574x_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_e200.h\"\r\n\r\n    #if (defined(CPU_MPC5746R))\r\n\r\n        #define MPC5746R_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5746R/include/MPC5746R.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5746R/include/MPC5746R_features.h\"\r\n\r\n    #elif (defined(CPU_MPC5748G))\r\n\r\n        #define MPC5748G_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5748G/include/MPC5748G.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5748G/include/MPC5748G_features.h\"\r\n\r\n    #elif (defined(CPU_MPC5747C))\r\n\r\n        #define MPC5747C_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5747C/include/MPC5747C.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5747C/include/MPC5747C_features.h\"\r\n\r\n    #elif (defined(CPU_MPC5748C))\r\n\r\n        #define MPC5748C_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5748C/include/MPC5748C.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5748C/include/MPC5748C_features.h\"\r\n\r\n    #elif (defined(CPU_MPC5746G))\r\n\r\n        #define MPC5746G_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5746G/include/MPC5746G.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5746G/include/MPC5746G_features.h\"\r\n\r\n    #elif (defined(CPU_MPC5747G))\r\n\r\n        #define MPC5747G_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5747G/include/MPC5747G.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5747G/include/MPC5747G_features.h\"\r\n\r\n    #elif defined(CPU_MPC5746C)\r\n\r\n        #define MPC5746C_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5746C/include/MPC5746C.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5746C/include/MPC5746C_features.h\"\r\n\r\n    #elif defined(CPU_MPC5744B)\r\n\r\n        #define MPC5744B_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5744B/include/MPC5744B.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5744B/include/MPC5744B_features.h\"\r\n\r\n    #elif defined(CPU_MPC5745B)\r\n\r\n        #define MPC5745B_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5745B/include/MPC5745B.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5745B/include/MPC5745B_features.h\"\r\n\r\n    #elif defined(CPU_MPC5746B)\r\n\r\n        #define MPC5746B_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5746B/include/MPC5746B.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5746B/include/MPC5746B_features.h\"\r\n\r\n    #elif defined(CPU_MPC5744C)\r\n\r\n        #define MPC5744C_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5744C/include/MPC5744C.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5744C/include/MPC5744C_features.h\"\r\n\r\n    #elif defined(CPU_MPC5745C)\r\n\r\n        #define MPC5745C_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5745C/include/MPC5745C.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5745C/include/MPC5745C_features.h\"\r\n\r\n    #elif defined(CPU_MPC5741P)\r\n\r\n        #define MPC5741P_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5741P/include/MPC5741P.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5741P/include/MPC5741P_features.h\"\r\n\r\n    #elif defined(CPU_MPC5742P)\r\n\r\n        #define MPC5742P_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5742P/include/MPC5742P.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5742P/include/MPC5742P_features.h\"\r\n\r\n    #elif defined(CPU_MPC5743P)\r\n\r\n        #define MPC5743P_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5743P/include/MPC5743P.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5743P/include/MPC5743P_features.h\"\r\n\r\n    #elif defined(CPU_MPC5744P)\r\n\r\n        #define MPC5744P_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"MPC5744P/include/MPC5744P.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"MPC5744P/include/MPC5744P_features.h\"\r\n\r\n    #endif\r\n#elif (defined(CPU_S32R274) || defined(CPU_S32R372))\r\n\r\n    #define S32R_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_e200.h\"\r\n\r\n    #if (defined(CPU_S32R274))\r\n\r\n        #define S32R274_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32R274/include/S32R274.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32R274/include/S32R274_features.h\"\r\n\r\n    #elif (defined(CPU_S32R372))\r\n\r\n        #define S32R372_SERIES\r\n\r\n        /* Register definitions */\r\n        #include \"S32R372/include/S32R372.h\"\r\n        /* CPU specific feature definitions */\r\n        #include \"S32R372/include/S32R372_features.h\"\r\n    #endif\r\n#elif (defined(CPU_S32MTV))\r\n\r\n    #define S32MTV_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_cm4.h\"\r\n\r\n    /* Register definitions */\r\n    #include \"S32MTV/include/S32MTV.h\"\r\n    /* CPU specific feature definitions */\r\n    #include \"S32MTV/include/S32MTV_features.h\"\r\n\r\n#elif defined(CPU_SJA1110)\r\n\r\n    #define SJA1110_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_cm7.h\"\r\n\r\n    /* Register definitions */\r\n    #include \"SJA1110/include/SJA1110.h\"\r\n    /* CPU specific feature definitions */\r\n    #include \"SJA1110/include/SJA1110_features.h\"\r\n    /* float32_t, float64_t definitions */\r\n    #include \"SJA1110/include/SJA1110_floats.h\"\r\n\r\n#elif defined(CPU_S32S247)\r\n\r\n    #define S32S247_SERIES\r\n\r\n    /* Specific core definitions */\r\n    #include \"common/s32_core_cm7.h\"\r\n\r\n    /* Register definitions */\r\n    #include \"S32S247/include/S32S247.h\"\r\n    /* CPU specific feature definitions */\r\n    #include \"S32S247/include/S32S247_features.h\"\r\n\r\n#else\r\n    #error \"No valid CPU defined!\"\r\n#endif\r\n\r\n#include \"devassert.h\"\r\n\r\n#endif /* DEVICE_REGISTERS_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"edma_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, Taking address of near auto variable.\r\n * The code is not dynamically linked. An absolute stack address is obtained\r\n * when taking the address of the near auto variable. A source of error in\r\n * writing dynamic code is that the stack segment may be different from the data\r\n * segment.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, Could define variable at block scope\r\n * The variable is used in all flexio drivers so it must remain global.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to perform a conversion between a pointer and an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from pointer to unsigned long, Cast from unsigned long to pointer.\r\n * The cast is required to perform a conversion between a pointer and an unsigned long define,\r\n * representing an address.\r\n */\r\n\r\n#include \"edma_irq.h\"\r\n#include \"clock_manager.h\"\r\n#include \"interrupt_manager.h\"\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n\r\n/*! @brief Array of base addresses for DMA instances. */\r\nstatic DMA_Type * const s_edmaBase[DMA_INSTANCE_COUNT] = DMA_BASE_PTRS;\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n/*! @brief Array of base addresses for DMAMUX instances. */\r\nstatic DMAMUX_Type * const s_dmaMuxBase[DMAMUX_INSTANCE_COUNT] = DMAMUX_BASE_PTRS;\r\n#endif /* FEATURE_DMAMUX_AVAILABLE */\r\n\r\n/*! @brief Array of default DMA channel interrupt handlers. */\r\nstatic const IRQn_Type s_edmaIrqId[FEATURE_DMA_VIRTUAL_CHANNELS_INTERRUPT_LINES] = DMA_CHN_IRQS;\r\n\r\n#ifdef FEATURE_DMA_HAS_ERROR_IRQ\r\n/*! @brief Array of default DMA error interrupt handlers. */\r\nstatic const IRQn_Type s_edmaErrIrqId[FEATURE_DMA_VIRTUAL_ERROR_INTERRUPT_LINES] = DMA_ERROR_IRQS;\r\n#endif /* FEATURE_DMA_HAS_ERROR_IRQ */\r\n\r\n#else /* FEATURE_DMA_HWV3 */\r\n    \r\n/*! @brief Array of base addresses for DMA instances. */\r\nstatic DMA_Type * const s_edmaBase[DMA_INSTANCE_COUNT] = DMA_BASE_PTRS;\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n/*! @brief Array of base addresses for DMAMUX instances. */\r\nstatic DMAMUX_Type * const s_dmaMuxBase[DMAMUX_INSTANCE_COUNT] = DMAMUX_BASE_PTRS;\r\n#endif /* FEATURE_DMAMUX_AVAILABLE */\r\n\r\n/*! @brief Array of default DMA channel interrupt handlers. */\r\nstatic const IRQn_Type s_edmaIrqId[FEATURE_DMA_VIRTUAL_CHANNELS_INTERRUPT_LINES] = DMA_CHN_IRQS;\r\n\r\n#ifdef FEATURE_DMA_HAS_ERROR_IRQ\r\n/*! @brief Array of default DMA error interrupt handlers. */\r\nstatic const IRQn_Type s_edmaErrIrqId[FEATURE_DMA_VIRTUAL_ERROR_INTERRUPT_LINES] = DMA_ERROR_IRQS;\r\n#endif /* FEATURE_DMA_HAS_ERROR_IRQ */\r\n\r\n#endif /* FEATURE_DMA_HWV3 */\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n/*! @brief Array for eDMA & DMAMUX clock sources. */\r\nstatic const clock_names_t s_edmaClockNames[DMA_INSTANCE_COUNT] = FEATURE_DMA_CLOCK_NAMES;\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\nstatic const clock_names_t s_dmamuxClockNames[DMAMUX_INSTANCE_COUNT] = FEATURE_DMAMUX_CLOCK_NAMES;\r\n#endif /* FEATURE_DMAMUX_AVAILABLE */\r\n#endif /* (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT) */\r\n\r\n/*! @brief EDMA global structure to maintain eDMA state */\r\nstatic edma_state_t * s_virtEdmaState;\r\n\r\n/*******************************************************************************\r\n * Prototypes\r\n ******************************************************************************/                                    \r\nstatic void EDMA_DRV_ClearIntStatus(uint8_t virtualChannel);\r\nstatic void EDMA_DRV_ClearSoftwareTCD(edma_software_tcd_t *stcd);\r\nstatic void EDMA_DRV_ClearStructure(uint8_t *sructPtr, size_t size);\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\nstatic bool EDMA_DRV_ValidTransferSize(edma_transfer_size_t size);\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_Init\r\n * Description   : Initializes the eDMA module.\r\n *\r\n * Implements    : EDMA_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_Init(edma_state_t *edmaState,\r\n                       const edma_user_config_t *userConfig,\r\n                       edma_chn_state_t * const chnStateArray[],\r\n                       const edma_channel_config_t * const chnConfigArray[],\r\n                       uint32_t chnCount)\r\n{\r\n    uint32_t index = 0U;\r\n    DMA_Type *edmaRegBase = NULL;\r\n    IRQn_Type irqNumber = NotAvail_IRQn;\r\n    status_t edmaStatus = STATUS_SUCCESS;\r\n    status_t chnInitStatus = STATUS_SUCCESS;\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    uint32_t freq = 0U;\r\n    status_t clockManagerStatus = STATUS_SUCCESS;\r\n#endif\r\n\r\n    /* Check the state and configuration structure pointers are valid */\r\n    DEV_ASSERT((edmaState != NULL) && (userConfig != NULL));\r\n\r\n    /* Check the module has not already been initialized */\r\n    DEV_ASSERT(s_virtEdmaState == NULL);\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    /* Check that eDMA and DMAMUX modules are clock gated on */\r\n    for (index = 0U; index < (uint32_t)DMA_INSTANCE_COUNT; index++)\r\n    {\r\n        clockManagerStatus = CLOCK_SYS_GetFreq(s_edmaClockNames[index], &freq);\r\n        DEV_ASSERT(clockManagerStatus == STATUS_SUCCESS);\r\n    }\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n    for (index = 0U; index < (uint32_t)DMAMUX_INSTANCE_COUNT; index++)\r\n    {\r\n        clockManagerStatus = CLOCK_SYS_GetFreq(s_dmamuxClockNames[index], &freq);\r\n        DEV_ASSERT(clockManagerStatus == STATUS_SUCCESS);\r\n    }\r\n#endif /* FEATURE_DMAMUX_AVAILABLE */\r\n#endif /* (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT) */\r\n\r\n    /* Save the runtime state structure for the driver */\r\n    s_virtEdmaState = edmaState;\r\n\r\n    /* Clear the state structure. */\r\n    EDMA_DRV_ClearStructure((uint8_t *)s_virtEdmaState, sizeof(edma_state_t));\r\n\r\n    /* Init all DMA instances */\r\n    for(index = 0U; index < (uint32_t)DMA_INSTANCE_COUNT; index++)\r\n    {\r\n        edmaRegBase = s_edmaBase[index];\r\n\r\n        /* Init eDMA module on hardware level. */\r\n        EDMA_Init(edmaRegBase);\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n        /* Set arbitration mode */\r\n        EDMA_SetChannelArbitrationMode(edmaRegBase, userConfig->chnArbitration);\r\n#else /* FEATURE_DMA_HWV3 */\r\n        /* Set arbitration mode */\r\n        EDMA_SetChannelArbitrationMode(edmaRegBase, userConfig->chnArbitration);\r\n#if (FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U)        \r\n        EDMA_SetGroupArbitrationMode(edmaRegBase, userConfig->groupArbitration);\r\n        EDMA_SetGroupPriority(edmaRegBase, userConfig->groupPriority);\r\n#endif /* (FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U) */\r\n#endif /* FEATURE_DMA_HWV3 */\r\n        /* Set 'Halt on error' configuration */\r\n        EDMA_SetHaltOnErrorCmd(edmaRegBase, userConfig->haltOnError);\r\n    }\r\n\r\n#if defined FEATURE_DMA_HAS_ERROR_IRQ\r\n    /* Enable the error interrupts for eDMA module. */\r\n    for (index = 0U; index < (uint32_t)FEATURE_DMA_VIRTUAL_ERROR_INTERRUPT_LINES; index++)\r\n    {\r\n        /* Enable channel interrupt ID. */\r\n        irqNumber = s_edmaErrIrqId[index];\r\n        INT_SYS_EnableIRQ(irqNumber);\r\n    }\r\n#endif\r\n\r\n    /* Register all edma channel interrupt handlers into vector table. */\r\n    for (index = 0U; index < (uint32_t)FEATURE_DMA_VIRTUAL_CHANNELS_INTERRUPT_LINES; index++)\r\n    {\r\n        /* Enable channel interrupt ID. */\r\n        irqNumber = s_edmaIrqId[index];\r\n        INT_SYS_EnableIRQ(irqNumber);\r\n    }\r\n    \r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n    /* Initialize all DMAMUX instances */\r\n    for (index = 0U; index < (uint32_t)DMAMUX_INSTANCE_COUNT; index++)\r\n    {\r\n        DMAMUX_Init(s_dmaMuxBase[index]);\r\n    }\r\n#endif\r\n\r\n    /* Initialize the channels based on configuration list */\r\n    if ((chnStateArray != NULL) && (chnConfigArray != NULL))\r\n    {\r\n        for (index = 0U; index < chnCount; index++)\r\n        {\r\n            chnInitStatus = EDMA_DRV_ChannelInit(chnStateArray[index], chnConfigArray[index]);\r\n            if (chnInitStatus != STATUS_SUCCESS)\r\n            {\r\n                edmaStatus = chnInitStatus;\r\n            }\r\n        }\r\n    }\r\n\r\n    return edmaStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_Deinit\r\n * Description   : Deinitialize EDMA.\r\n *\r\n * Implements    : EDMA_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_Deinit(void)\r\n{\r\n    uint32_t index = 0U;\r\n    IRQn_Type irqNumber = NotAvail_IRQn;\r\n    const edma_chn_state_t *chnState = NULL;\r\n\r\n#if defined FEATURE_DMA_HAS_ERROR_IRQ\r\n    /* Disable the error interrupts for eDMA module. */\r\n    for (index = 0U; index < (uint32_t)FEATURE_DMA_VIRTUAL_ERROR_INTERRUPT_LINES; index++)\r\n    {\r\n        /* Enable channel interrupt ID. */\r\n        irqNumber = s_edmaErrIrqId[index];\r\n        INT_SYS_DisableIRQ(irqNumber);\r\n    }\r\n#endif\r\n\r\n    if (s_virtEdmaState != NULL)\r\n    {\r\n        /* Release all edma channel. */\r\n        for (index = 0U; index < (uint32_t)FEATURE_DMA_VIRTUAL_CHANNELS; index++)\r\n        {\r\n            /* Release all channels. */\r\n            chnState = s_virtEdmaState->virtChnState[index];\r\n            if (chnState != NULL)\r\n            {\r\n                (void) EDMA_DRV_ReleaseChannel(chnState->virtChn);\r\n            }\r\n        }\r\n        for (index = 0U; index < (uint32_t)FEATURE_DMA_VIRTUAL_CHANNELS_INTERRUPT_LINES; index++)\r\n        {\r\n            /* Disable channel interrupts. */\r\n            irqNumber = s_edmaIrqId[index];\r\n            INT_SYS_DisableIRQ(irqNumber);\r\n        }\r\n    }\r\n\r\n    s_virtEdmaState = NULL;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ChannelInit\r\n * Description   : Initialize EDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_ChannelInit_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_ChannelInit(edma_chn_state_t *edmaChannelState,\r\n                              const edma_channel_config_t *edmaChannelConfig)\r\n{\r\n    /* Check the state and configuration structure pointers are valid */\r\n    DEV_ASSERT((edmaChannelState != NULL) && (edmaChannelConfig != NULL));\r\n\r\n    /* Check if the module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n    \r\n    /* Check the channel has not already been allocated */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[edmaChannelConfig->virtChnConfig] == NULL);    \r\n    \r\n    /* Check if the channel defined by user in the channel configuration structure is valid */\r\n    DEV_ASSERT(edmaChannelConfig->virtChnConfig < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(edmaChannelConfig->virtChnConfig);\r\n\r\n    /* Get DMA channel from virtual channel */\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(edmaChannelConfig->virtChnConfig);\r\n\r\n    /* Get virtual channel value */\r\n    uint8_t virtualChannel = edmaChannelConfig->virtChnConfig;\r\n    \r\n    /* Get status */\r\n    status_t retStatus = STATUS_SUCCESS;\r\n    \r\n    /* Load corresponding DMA instance pointer */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n        \r\n    /* Reset the channel state structure to default value. */\r\n    EDMA_DRV_ClearStructure((uint8_t *)edmaChannelState, sizeof(edma_chn_state_t));\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE     \r\n    retStatus = EDMA_DRV_SetChannelRequestAndTrigger(edmaChannelConfig->virtChnConfig, (uint8_t)edmaChannelConfig->source, edmaChannelConfig->enableTrigger);\r\n#endif    \r\n\r\n    /* Clear the TCD registers for this channel */\r\n    EDMA_TCDClearReg(edmaRegBase, dmaChannel);\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE \r\n    if (retStatus == STATUS_SUCCESS)\r\n#endif\r\n    {\r\n        /* Set virtual channel state */\r\n        s_virtEdmaState->virtChnState[virtualChannel] = edmaChannelState;    \r\n        /* Set virtual channel value */\r\n        s_virtEdmaState->virtChnState[virtualChannel]->virtChn = virtualChannel;        \r\n        /* Set virtual channel status to normal */\r\n        s_virtEdmaState->virtChnState[virtualChannel]->status = EDMA_CHN_NORMAL;\r\n        \r\n        /* Enable error interrupt for this channel */\r\n        EDMA_SetErrorIntCmd(edmaRegBase, dmaChannel, true);        \r\n#ifdef FEATURE_DMA_HWV3\r\n        /* Put the channel in a priority group, as defined in configuration */\r\n        EDMA_SetChannelPriorityGroup(edmaRegBase, dmaChannel, edmaChannelConfig->groupPriority);\r\n#endif\r\n\r\n        /* Set the channel priority, as defined in the configuration, only if fixed arbitration mode is selected */\r\n        if ((EDMA_GetChannelArbitrationMode(edmaRegBase) == EDMA_ARBITRATION_FIXED_PRIORITY) &&\r\n            (edmaChannelConfig->channelPriority != EDMA_CHN_DEFAULT_PRIORITY))\r\n        {\r\n            EDMA_SetChannelPriority(edmaRegBase, dmaChannel, edmaChannelConfig->channelPriority);\r\n        }\r\n        /* Install the user callback */\r\n        retStatus = EDMA_DRV_InstallCallback(edmaChannelConfig->virtChnConfig, edmaChannelConfig->callback, edmaChannelConfig->callbackParam);\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_InstallCallback\r\n * Description   : Register callback function and parameter.\r\n *\r\n * Implements    : EDMA_DRV_InstallCallback_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_InstallCallback(uint8_t virtualChannel,\r\n                                  edma_callback_t callback,\r\n                                  void *parameter)\r\n{\r\n    /* Check the channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check the channel is allocated */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    s_virtEdmaState->virtChnState[virtualChannel]->callback = callback;\r\n    s_virtEdmaState->virtChnState[virtualChannel]->parameter = parameter;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ReleaseChannel\r\n * Description   : Free eDMA channel's hardware and software resource.\r\n *\r\n * Implements    : EDMA_DRV_ReleaseChannel_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_ReleaseChannel(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check the DMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Get pointer to channel state */\r\n    edma_chn_state_t *chnState = s_virtEdmaState->virtChnState[virtualChannel];\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(chnState != NULL);\r\n\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n\r\n    /* Stop edma channel. */\r\n    EDMA_SetDmaRequestCmd(edmaRegBase, dmaChannel, false);\r\n\r\n    /* Reset the channel state structure to default value. */\r\n    EDMA_DRV_ClearStructure((uint8_t *)chnState, sizeof(edma_chn_state_t));\r\n\r\n    s_virtEdmaState->virtChnState[virtualChannel] = NULL;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ClearIntStatus\r\n * Description   : Clear done and interrupt retStatus.\r\n *\r\n *END**************************************************************************/\r\nstatic void EDMA_DRV_ClearIntStatus(uint8_t virtualChannel)\r\n{\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_ClearDoneStatusFlag(edmaRegBase, dmaChannel);\r\n    EDMA_ClearIntStatusFlag(edmaRegBase, dmaChannel);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ClearSoftwareTCD\r\n * Description   : Clear the software tcd structure.\r\n *\r\n *END**************************************************************************/\r\nstatic void EDMA_DRV_ClearSoftwareTCD(edma_software_tcd_t *stcd)\r\n{\r\n    EDMA_DRV_ClearStructure((uint8_t *)stcd, sizeof(edma_software_tcd_t));\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_IRQHandler\r\n * Description   : EDMA IRQ handler.\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_IRQHandler(uint8_t virtualChannel)\r\n{\r\n    const edma_chn_state_t *chnState = s_virtEdmaState->virtChnState[virtualChannel];\r\n\r\n    EDMA_DRV_ClearIntStatus(virtualChannel);\r\n\r\n    if (chnState != NULL)\r\n    {\r\n        if (chnState->callback != NULL)\r\n        {\r\n            chnState->callback(chnState->parameter, chnState->status);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ErrorIRQHandler\r\n * Description   : EDMA error IRQ handler\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_ErrorIRQHandler(uint8_t virtualChannel)\r\n{\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_SetDmaRequestCmd(edmaRegBase, dmaChannel, false);\r\n    edma_chn_state_t *chnState = s_virtEdmaState->virtChnState[virtualChannel];\r\n    if (chnState != NULL)\r\n    {\r\n        EDMA_DRV_ClearIntStatus(virtualChannel);\r\n        EDMA_ClearErrorIntStatusFlag(edmaRegBase, dmaChannel);\r\n        chnState->status = EDMA_CHN_ERROR;\r\n        if (chnState->callback != NULL)\r\n        {\r\n            chnState->callback(chnState->parameter, chnState->status);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ConfigSingleBlockTransfer\r\n * Description   : Configures a DMA single block transfer.\r\n *\r\n * Implements    : EDMA_DRV_ConfigSingleBlockTransfer_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_ConfigSingleBlockTransfer(uint8_t virtualChannel,\r\n                                            edma_transfer_type_t type,\r\n                                            uint32_t srcAddr,\r\n                                            uint32_t destAddr,\r\n                                            edma_transfer_size_t transferSize,\r\n                                            uint32_t dataBufferSize)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    /* Check if the value passed for 'transferSize' is valid */\r\n    DEV_ASSERT(EDMA_DRV_ValidTransferSize(transferSize));\r\n#endif\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    /* Compute the transfer offset, based on transfer size.\r\n     * The number of bytes transferred in each source read/destination write\r\n     * is obtained with the following formula:\r\n     *    source_read_size = 2^SSIZE\r\n     *    destination_write_size = 2^DSIZE\r\n     */\r\n    uint8_t transferOffset = (uint8_t) (1U << ((uint8_t)transferSize));\r\n\r\n    /* Check that source address and destination address are valid */\r\n    DEV_ASSERT((srcAddr % transferOffset) == 0U);\r\n    DEV_ASSERT((destAddr % transferOffset) == 0U);\r\n\r\n    /* The number of bytes to be transferred (buffer size) must\r\n     * be a multiple of the source read/destination write size\r\n     */\r\n    if ((dataBufferSize % transferOffset) != 0U)\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    if (retStatus == STATUS_SUCCESS)\r\n    {\r\n        /* Clear transfer control descriptor for the current channel */\r\n        EDMA_TCDClearReg(edmaRegBase, dmaChannel);  \r\n\r\n#ifdef FEATURE_DMA_ENGINE_STALL\r\n        /* Configure the DMA Engine to stall for a number of cycles after each R/W */\r\n        EDMA_TCDSetEngineStall(edmaRegBase, dmaChannel, EDMA_ENGINE_STALL_4_CYCLES);\r\n#endif\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n        EDMA_SetMinorLoopMappingCmd(edmaRegBase, dmaChannel, false);\r\n#else\r\n        EDMA_SetMinorLoopMappingCmd(edmaRegBase, true);\r\n#endif\r\n\r\n        /* Configure source and destination addresses */\r\n        EDMA_TCDSetSrcAddr(edmaRegBase, dmaChannel, srcAddr);\r\n        EDMA_TCDSetDestAddr(edmaRegBase, dmaChannel, destAddr);\r\n\r\n        /* Set transfer size (1B/2B/4B/16B/32B) */\r\n        EDMA_TCDSetAttribute(edmaRegBase, dmaChannel, EDMA_MODULO_OFF, EDMA_MODULO_OFF, transferSize, transferSize);\r\n\r\n        /* Configure source/destination offset. */\r\n        switch (type)\r\n        {\r\n            case EDMA_TRANSFER_PERIPH2MEM:\r\n                EDMA_TCDSetSrcOffset(edmaRegBase, dmaChannel, 0);\r\n                EDMA_TCDSetDestOffset(edmaRegBase, dmaChannel, (int8_t) transferOffset);\r\n                break;\r\n            case EDMA_TRANSFER_MEM2PERIPH:\r\n                EDMA_TCDSetSrcOffset(edmaRegBase, dmaChannel, (int8_t) transferOffset);\r\n                EDMA_TCDSetDestOffset(edmaRegBase, dmaChannel, 0);\r\n                break;\r\n            case EDMA_TRANSFER_MEM2MEM:\r\n                EDMA_TCDSetSrcOffset(edmaRegBase, dmaChannel, (int8_t) transferOffset);\r\n                EDMA_TCDSetDestOffset(edmaRegBase, dmaChannel, (int8_t) transferOffset);\r\n                break;\r\n            case EDMA_TRANSFER_PERIPH2PERIPH:\r\n                EDMA_TCDSetSrcOffset(edmaRegBase, dmaChannel, 0);\r\n                EDMA_TCDSetDestOffset(edmaRegBase, dmaChannel, 0);\r\n                break;\r\n            default:\r\n                /* This should never be reached - all the possible values have been handled. */\r\n                break;\r\n        }\r\n\r\n        /* Set the total number of bytes to be transfered */\r\n        EDMA_TCDSetNbytes(edmaRegBase, dmaChannel, dataBufferSize);\r\n\r\n        /* Set major iteration count to 1 (single block mode) */\r\n        EDMA_TCDSetMajorCount(edmaRegBase, dmaChannel, 1U);\r\n\r\n        /* Enable interrupt when the transfer completes */\r\n        EDMA_TCDSetMajorCompleteIntCmd(edmaRegBase, dmaChannel, true);\r\n        \r\n        /* Set virtual channel status to normal */\r\n        s_virtEdmaState->virtChnState[virtualChannel]->status = EDMA_CHN_NORMAL;    \r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ConfigMultiBlockTransfer\r\n * Description   : Configures a DMA single block transfer.\r\n *\r\n * Implements    : EDMA_DRV_ConfigMultiBlockTransfer_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_ConfigMultiBlockTransfer(uint8_t virtualChannel,\r\n                                           edma_transfer_type_t type,\r\n                                           uint32_t srcAddr,\r\n                                           uint32_t destAddr,\r\n                                           edma_transfer_size_t transferSize,\r\n                                           uint32_t blockSize,\r\n                                           uint32_t blockCount,\r\n                                           bool disableReqOnCompletion)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    /* Compute the transfer offset, based on transfer size.\r\n     * The number of bytes transferred in each source read/destination write\r\n     * is obtained with the following formula:\r\n     *    source_read_size = 2^SSIZE\r\n     *    destination_write_size = 2^DSIZE\r\n     */\r\n    uint8_t transferOffset = (uint8_t) (1U << ((uint8_t)transferSize));\r\n\r\n    /* Check that source address and destination address are valid */\r\n    DEV_ASSERT((srcAddr % transferOffset) == 0U);\r\n    DEV_ASSERT((destAddr % transferOffset) == 0U);\r\n#endif /* (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT) */\r\n\r\n    /* Configure the transfer for one data block */\r\n    retStatus = EDMA_DRV_ConfigSingleBlockTransfer(virtualChannel, type, srcAddr, destAddr, transferSize, blockSize);\r\n\r\n    if (retStatus == STATUS_SUCCESS)\r\n    {\r\n        DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n\r\n        /* Set the number of data blocks */\r\n        EDMA_TCDSetMajorCount(edmaRegBase, dmaChannel, blockCount);\r\n\r\n        /* Enable/disable requests upon completion */\r\n        EDMA_TCDSetDisableDmaRequestAfterTCDDoneCmd(edmaRegBase, dmaChannel, disableReqOnCompletion);\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ConfigLoopTransfer\r\n * Description   : Configures the DMA transfer in a loop.\r\n *\r\n * Implements    : EDMA_DRV_ConfigLoopTransfer_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_ConfigLoopTransfer(uint8_t virtualChannel,\r\n                                     const edma_transfer_config_t *transferConfig)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Check the transfer configuration structure is valid */\r\n    DEV_ASSERT(transferConfig != NULL);\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    /* Compute the transfer offset, based on transfer size.\r\n     * The number of bytes transferred in each source read/destination write\r\n     * is obtained with the following formula:\r\n     *    source_read_size = 2^SSIZE\r\n     *    destination_write_size = 2^DSIZE\r\n     */\r\n    uint8_t srcTransferOffset = (uint8_t) (1U << ((uint8_t)transferConfig->srcTransferSize));\r\n    uint8_t destTransferOffset = (uint8_t) (1U << ((uint8_t)transferConfig->destTransferSize));\r\n\r\n    /* Check that source address and destination address are valid */\r\n    DEV_ASSERT((transferConfig->srcAddr % srcTransferOffset) == 0U);\r\n    DEV_ASSERT((transferConfig->destAddr % destTransferOffset) == 0U);\r\n#endif /* (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT) */\r\n\r\n    /* Check the minor/major loop properties are defined */\r\n    DEV_ASSERT(transferConfig->loopTransferConfig != NULL);\r\n    \r\n    /* If the modulo feature is enabled, check alignment of addresses */\r\n    DEV_ASSERT((transferConfig->srcModulo == EDMA_MODULO_OFF) ||\r\n               ((transferConfig->srcAddr % (((uint32_t)1U) << (uint32_t)transferConfig->srcModulo)) == 0U));\r\n    DEV_ASSERT((transferConfig->destModulo == EDMA_MODULO_OFF) ||\r\n               ((transferConfig->destAddr % (((uint32_t)1U) << (uint32_t)transferConfig->destModulo)) == 0U));\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n#endif\r\n\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n    EDMA_SetMinorLoopMappingCmd(edmaRegBase, dmaChannel, true);\r\n#else\r\n    EDMA_SetMinorLoopMappingCmd(edmaRegBase, true);\r\n#endif\r\n    /* Write the configuration in the transfer control descriptor registers */\r\n    EDMA_DRV_PushConfigToReg(virtualChannel, transferConfig);\r\n    \r\n    /* Set virtual channel status to normal */\r\n    s_virtEdmaState->virtChnState[virtualChannel]->status = EDMA_CHN_NORMAL;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ConfigScatterGatherTransfer\r\n * Description   : Configure eDMA for scatter/gather operation\r\n *\r\n * Implements    : EDMA_DRV_ConfigScatterGatherTransfer_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_ConfigScatterGatherTransfer(uint8_t virtualChannel,\r\n                                              edma_software_tcd_t *stcd,\r\n                                              edma_transfer_size_t transferSize,\r\n                                              uint32_t bytesOnEachRequest,\r\n                                              const edma_scatter_gather_list_t *srcList,\r\n                                              const edma_scatter_gather_list_t *destList,\r\n                                              uint8_t tcdCount)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Check the input arrays for scatter/gather operation are valid */\r\n    DEV_ASSERT((stcd != NULL) && (srcList != NULL) && (destList != NULL));\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    /* Check if the value passed for 'transferSize' is valid */\r\n    DEV_ASSERT(EDMA_DRV_ValidTransferSize(transferSize));\r\n#endif\r\n\r\n    uint8_t i = 0U;\r\n    uint16_t transferOffset = 0U;\r\n    uint32_t stcdAlignedAddr = STCD_ADDR(stcd);\r\n    edma_software_tcd_t *edmaSwTcdAddr = (edma_software_tcd_t *)stcdAlignedAddr;\r\n    edma_loop_transfer_config_t edmaLoopConfig;\r\n    edma_transfer_config_t edmaTransferConfig;\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    /* Set virtual channel status to normal */\r\n    s_virtEdmaState->virtChnState[virtualChannel]->status = EDMA_CHN_NORMAL;    \r\n    \r\n    /* Compute the transfer offset, based on transfer size.\r\n     * The number of bytes transferred in each source read/destination write\r\n     * is obtained with the following formula:\r\n     *    source_read_size = 2^SSIZE\r\n     *    destination_write_size = 2^DSIZE\r\n     */\r\n    transferOffset = (uint16_t) (1UL << ((uint16_t)transferSize));\r\n\r\n    /* The number of bytes to be transferred on each request must\r\n     * be a multiple of the source read/destination write size\r\n     */\r\n    if ((bytesOnEachRequest % transferOffset) != 0U)\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    /* Clear the configuration structures before initializing them. */\r\n    EDMA_DRV_ClearStructure((uint8_t *)(&edmaTransferConfig), sizeof(edma_transfer_config_t));\r\n    EDMA_DRV_ClearStructure((uint8_t *)(&edmaLoopConfig), sizeof(edma_loop_transfer_config_t));\r\n\r\n    /* Configure the transfer for scatter/gather mode. */\r\n    edmaTransferConfig.srcLastAddrAdjust = 0;\r\n    edmaTransferConfig.destLastAddrAdjust = 0;\r\n    edmaTransferConfig.srcModulo = EDMA_MODULO_OFF;\r\n    edmaTransferConfig.destModulo = EDMA_MODULO_OFF;\r\n    edmaTransferConfig.srcTransferSize = transferSize;\r\n    edmaTransferConfig.destTransferSize = transferSize;\r\n    edmaTransferConfig.minorByteTransferCount = bytesOnEachRequest;\r\n    edmaTransferConfig.interruptEnable = true;\r\n    edmaTransferConfig.scatterGatherEnable = true;\r\n    edmaTransferConfig.loopTransferConfig = &edmaLoopConfig;\r\n    edmaTransferConfig.loopTransferConfig->srcOffsetEnable = false;\r\n    edmaTransferConfig.loopTransferConfig->dstOffsetEnable = false;\r\n    edmaTransferConfig.loopTransferConfig->minorLoopChnLinkEnable = false;\r\n    edmaTransferConfig.loopTransferConfig->majorLoopChnLinkEnable = false;\r\n\r\n    /* Copy scatter/gather lists to transfer configuration*/\r\n    for (i = 0U; (i < tcdCount) && (retStatus == STATUS_SUCCESS); i++)\r\n    {\r\n        edmaTransferConfig.srcAddr = srcList[i].address;\r\n        edmaTransferConfig.destAddr = destList[i].address;\r\n        if ((srcList[i].length != destList[i].length) || (srcList[i].type != destList[i].type))\r\n        {\r\n            retStatus = STATUS_ERROR;\r\n            break;\r\n        }\r\n        edmaTransferConfig.loopTransferConfig->majorLoopIterationCount = srcList[i].length/bytesOnEachRequest;\r\n\r\n        switch (srcList[i].type)\r\n        {\r\n            case EDMA_TRANSFER_PERIPH2MEM:\r\n                /* Configure Source Read. */\r\n                edmaTransferConfig.srcOffset = 0;\r\n                /* Configure Dest Write. */\r\n                edmaTransferConfig.destOffset = (int16_t) transferOffset;\r\n                break;\r\n            case EDMA_TRANSFER_MEM2PERIPH:\r\n                /* Configure Source Read. */\r\n                edmaTransferConfig.srcOffset = (int16_t) transferOffset;\r\n                /* Configure Dest Write. */\r\n                edmaTransferConfig.destOffset = 0;\r\n                break;\r\n            case EDMA_TRANSFER_MEM2MEM:\r\n                /* Configure Source Read. */\r\n                edmaTransferConfig.srcOffset = (int16_t) transferOffset;\r\n                /* Configure Dest Write. */\r\n                edmaTransferConfig.destOffset = (int16_t) transferOffset;\r\n                break;\r\n            case EDMA_TRANSFER_PERIPH2PERIPH:\r\n                /* Configure Source Read. */\r\n                edmaTransferConfig.srcOffset = 0;\r\n                /* Configure Dest Write. */\r\n                edmaTransferConfig.destOffset = 0;\r\n                break;\r\n            default:\r\n                /* This should never be reached - all the possible values have been handled. */\r\n                break;\r\n        }\r\n\r\n        /* Configure the pointer to next software TCD structure; for the last one, this address should be 0 */\r\n        if (i == ((uint8_t)(tcdCount - 1U)))\r\n        {\r\n            edmaTransferConfig.scatterGatherNextDescAddr = 0U;\r\n        }\r\n        else\r\n        {\r\n            edma_software_tcd_t * ptNextAddr = &edmaSwTcdAddr[i];\r\n            edmaTransferConfig.scatterGatherNextDescAddr = ((uint32_t) ptNextAddr);\r\n        }\r\n\r\n        if (i == 0U)\r\n        {\r\n            /* Push the configuration for the first descriptor to registers */\r\n            EDMA_DRV_PushConfigToReg(virtualChannel, &edmaTransferConfig);\r\n        }\r\n        else\r\n        {\r\n            /* Copy configuration to software TCD structure */\r\n            EDMA_DRV_PushConfigToSTCD(&edmaTransferConfig, &edmaSwTcdAddr[i - 1U]);\r\n        }\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_StartChannel\r\n * Description   : Starts an eDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_StartChannel_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_StartChannel(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Enable requests for current channel */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_SetDmaRequestCmd(edmaRegBase, dmaChannel, true);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_StopChannel\r\n * Description   : Stops an eDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_StopChannel_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_StopChannel(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Disable requests for current channel */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_SetDmaRequestCmd(edmaRegBase, dmaChannel, false);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetChannelRequestAndTrigger\r\n * Description   : Sets DMA channel request source in DMAMUX and controls\r\n *                 the DMA channel periodic triggering.\r\n *\r\n * Implements    : EDMA_DRV_SetChannelRequestAndTrigger_Activity\r\n *END**************************************************************************/\r\nstatus_t EDMA_DRV_SetChannelRequestAndTrigger(uint8_t virtualChannel,\r\n                                              uint8_t request,\r\n                                              bool enableTrigger)\r\n{\r\n    /* Check the virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < (uint32_t)FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n    /* Retrieve the DMAMUX instance serving this request */\r\n    uint8_t dmaMuxInstance = (uint8_t)FEATURE_DMAMUX_REQ_SRC_TO_INSTANCE(request);\r\n\r\n    /* Get request index for the corresponding DMAMUX instance */\r\n    uint8_t dmaMuxRequest = (uint8_t)FEATURE_DMAMUX_REQ_SRC_TO_CH(request);\r\n\r\n    /* Get DMAMUX channel for the selected request */\r\n    uint8_t dmaMuxChannel = (uint8_t)FEATURE_DMAMUX_DMA_CH_TO_CH(virtualChannel);\r\n\r\n    /* Retrieve the appropriate DMAMUX instance */\r\n    DMAMUX_Type *dmaMuxRegBase = s_dmaMuxBase[dmaMuxInstance];\r\n\r\n    /* Set request and trigger */\r\n\tDMAMUX_SetChannelCmd(dmaMuxRegBase, dmaMuxChannel, false);\r\n    DMAMUX_SetChannelSource(dmaMuxRegBase, dmaMuxChannel, dmaMuxRequest);\r\n#ifdef FEATURE_DMAMUX_HAS_TRIG\t\r\n\tDMAMUX_SetChannelTrigger(dmaMuxRegBase, dmaMuxChannel, enableTrigger);\r\n#else\r\n    (void)enableTrigger;\t\r\n#endif\t\r\n\tDMAMUX_SetChannelCmd(dmaMuxRegBase, dmaMuxChannel, true);\r\n    \r\n    return STATUS_SUCCESS;\r\n#else\r\n    (void)virtualChannel;    \r\n    (void)request;\r\n    (void)enableTrigger;    \r\n    return STATUS_UNSUPPORTED;\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ClearTCD\r\n * Description   : Clears all registers to 0 for the hardware TCD.\r\n *\r\n * Implements    : EDMA_DRV_ClearTCD_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_ClearTCD(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Clear the TCD memory */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDClearReg(edmaRegBase, dmaChannel);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetSrcAddr\r\n * Description   : Configures the source address for the eDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_SetSrcAddr_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetSrcAddr(uint8_t virtualChannel,\r\n                         uint32_t address)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD source address */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetSrcAddr(edmaRegBase, dmaChannel, address);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetSrcOffset\r\n * Description   : Configures the source address signed offset for the eDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_SetSrcOffset_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetSrcOffset(uint8_t virtualChannel,\r\n                           int16_t offset)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD source offset */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetSrcOffset(edmaRegBase, dmaChannel, offset);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetSrcReadChunkSize\r\n * Description   : Configures the source read data chunk size (transferred in a read sequence).\r\n *\r\n * Implements    : EDMA_DRV_SetSrcReadChunkSize_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetSrcReadChunkSize(uint8_t virtualChannel,\r\n                                  edma_transfer_size_t size)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD source transfer size */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetSrcTransferSize(edmaRegBase, dmaChannel, size);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetSrcLastAddrAdjustment\r\n * Description   : Configures the source address last adjustment.\r\n *\r\n * Implements    : EDMA_DRV_SetSrcLastAddrAdjustment_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetSrcLastAddrAdjustment(uint8_t virtualChannel,\r\n                                       int32_t adjust)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD source last adjustment */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetSrcLastAdjust(edmaRegBase, dmaChannel, adjust);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetDestLastAddrAdjustment\r\n * Description   : Configures the source address last adjustment.\r\n *\r\n * Implements    : EDMA_DRV_SetDestLastAddrAdjustment_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetDestLastAddrAdjustment(uint8_t virtualChannel,\r\n                                        int32_t adjust)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD source last adjustment */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetDestLastAdjust(edmaRegBase, dmaChannel, adjust);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetDestAddr\r\n * Description   : Configures the destination address for the eDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_SetDestAddr_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetDestAddr(uint8_t virtualChannel,\r\n                          uint32_t address)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD destination address */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetDestAddr(edmaRegBase, dmaChannel, address);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetDestOffset\r\n * Description   : Configures the destination address signed offset for the eDMA channel.\r\n *\r\n * Implements    : EDMA_DRV_SetDestOffset_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetDestOffset(uint8_t virtualChannel,\r\n                            int16_t offset)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD destination offset */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetDestOffset(edmaRegBase, dmaChannel, offset);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetDestWriteChunkSize\r\n * Description   : Configures the destination data chunk size (transferred in a write sequence).\r\n *\r\n * Implements    : EDMA_DRV_SetDestWriteChunkSize_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetDestWriteChunkSize(uint8_t virtualChannel,\r\n                                    edma_transfer_size_t size)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD source transfer size */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetDestTransferSize(edmaRegBase, dmaChannel, size);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetMinorLoopBlockSize\r\n * Description   : Configures the number of bytes to be transferred in each service request of the channel.\r\n *\r\n * Implements    : EDMA_DRV_SetMinorLoopBlockSize_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetMinorLoopBlockSize(uint8_t virtualChannel,\r\n                                    uint32_t nbytes)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set channel TCD minor loop block size */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetNbytes(edmaRegBase, dmaChannel, nbytes);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetMajorLoopIterationCount\r\n * Description   : Configures the number of major loop iterations.\r\n *\r\n * Implements    : EDMA_DRV_SetMajorLoopIterationCount_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetMajorLoopIterationCount(uint8_t virtualChannel,\r\n                                         uint32_t majorLoopCount)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Set the major loop iteration count */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetMajorCount(edmaRegBase, dmaChannel, majorLoopCount);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_GetRemainingMajorIterationsCount\r\n * Description   : Returns the remaining major loop iteration count.\r\n *\r\n * Implements    : EDMA_DRV_GetRemainingMajorIterationsCount_Activity\r\n *END**************************************************************************/\r\nuint32_t EDMA_DRV_GetRemainingMajorIterationsCount(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Retrieve the number of minor loops yet to be triggered */\r\n    const DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    uint32_t count = EDMA_TCDGetCurrentMajorCount(edmaRegBase, dmaChannel);\r\n\r\n    return count;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_SetScatterGatherLink\r\n * Description   : Configures the memory address of the next TCD, in scatter/gather mode.\r\n *\r\n * Implements    : EDMA_DRV_SetScatterGatherLink_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_SetScatterGatherLink(uint8_t virtualChannel,\r\n                                   uint32_t nextTCDAddr)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Configures the memory address of the next TCD */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetScatterGatherLink(edmaRegBase, dmaChannel, nextTCDAddr);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_DisableRequestsOnTransferComplete\r\n * Description   : Disables/Enables the DMA request after the major loop completes for the TCD.\r\n *\r\n * Implements    : EDMA_DRV_DisableRequestsOnTransferComplete_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_DisableRequestsOnTransferComplete(uint8_t virtualChannel,\r\n                                                bool disable)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Disables/Enables the DMA request upon TCD completion */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TCDSetDisableDmaRequestAfterTCDDoneCmd(edmaRegBase, dmaChannel, disable);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ConfigureInterrupt\r\n * Description   : Disables/Enables the channel interrupt requests.\r\n *\r\n * Implements    : EDMA_DRV_ConfigureInterrupt_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_ConfigureInterrupt(uint8_t virtualChannel,\r\n                                 edma_channel_interrupt_t intSrc,\r\n                                 bool enable)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Disables/Enables the channel interrupt requests. */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    switch (intSrc)\r\n    {\r\n        case EDMA_CHN_ERR_INT:\r\n            /* Enable channel interrupt request when error conditions occur */\r\n            EDMA_SetErrorIntCmd(edmaRegBase, dmaChannel, enable);\r\n            break;\r\n        case EDMA_CHN_HALF_MAJOR_LOOP_INT:\r\n            /* Enable channel interrupt request when major iteration count reaches halfway point */\r\n            EDMA_TCDSetMajorHalfCompleteIntCmd(edmaRegBase, dmaChannel, enable);\r\n            break;\r\n        case EDMA_CHN_MAJOR_LOOP_INT:\r\n            /* Enable channel interrupt request when major iteration count reaches zero */\r\n            EDMA_TCDSetMajorCompleteIntCmd(edmaRegBase, dmaChannel, enable);\r\n            break;\r\n        default:\r\n            /* This branch should never be reached if driver API is used properly */\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_CancelTransfer\r\n * Description   : Cancels the running transfer for this channel.\r\n *\r\n * Implements    : EDMA_DRV_CancelTransfer_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_CancelTransfer(bool error)\r\n{\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    uint32_t dmaInstance = 0U;\r\n\r\n    for(dmaInstance = 0U; dmaInstance < (uint32_t)DMA_INSTANCE_COUNT; dmaInstance++)\r\n    {\r\n        /* Cancel the running transfer. */\r\n        DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n        if (error)\r\n        {\r\n            EDMA_CancelTransferWithError(edmaRegBase);\r\n        }\r\n        else\r\n        {\r\n            EDMA_CancelTransfer(edmaRegBase);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_TriggerSwRequest\r\n * Description   : Triggers a sw request for the current channel.\r\n *\r\n * Implements    : EDMA_DRV_TriggerSwRequest_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_TriggerSwRequest(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    /* Trigger the channel transfer. */\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n    EDMA_TriggerChannelStart(edmaRegBase, dmaChannel);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_PushConfigToSTCD\r\n * Description   : Copy the configuration to the software TCD structure.\r\n *\r\n * Implements    : EDMA_DRV_PushConfigToSTCD_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_PushConfigToSTCD(const edma_transfer_config_t *config,\r\n                               edma_software_tcd_t *stcd)\r\n{\r\n    if ((config != NULL) && (stcd != NULL))\r\n    {\r\n        /* Clear the array of software TCDs passed by the user */\r\n        EDMA_DRV_ClearSoftwareTCD(stcd);\r\n\r\n        /* Set the software TCD fields */\r\n        stcd->ATTR = (uint16_t)(DMA_TCD_ATTR_SMOD(config->srcModulo) | DMA_TCD_ATTR_SSIZE(config->srcTransferSize) |\r\n                                DMA_TCD_ATTR_DMOD(config->destModulo) | DMA_TCD_ATTR_DSIZE(config->destTransferSize));\r\n        stcd->SADDR = config->srcAddr;\r\n        stcd->SOFF = config->srcOffset;\r\n        stcd->NBYTES = config->minorByteTransferCount;\r\n        stcd->SLAST = config->srcLastAddrAdjust;\r\n        stcd->DADDR = config->destAddr;\r\n        stcd->DOFF = config->destOffset;\r\n        stcd->CITER = (uint16_t) config->loopTransferConfig->majorLoopIterationCount;\r\n        if (config->scatterGatherEnable)\r\n        {\r\n            stcd->DLAST_SGA = (int32_t) config->scatterGatherNextDescAddr;\r\n        }\r\n        else\r\n        {\r\n            stcd->DLAST_SGA = config->destLastAddrAdjust;\r\n        }\r\n#ifdef FEATURE_DMA_HWV3\r\n        stcd->CSR = (uint16_t) (((config->interruptEnable ? 1UL : 0UL) << DMA_TCD_CSR_INTMAJOR_SHIFT) |\r\n                                ((config->scatterGatherEnable ? 1UL : 0UL) << DMA_TCD_CSR_ESG_SHIFT));\r\n#else\r\n        stcd->CSR = (uint16_t) (((config->interruptEnable ? 1UL : 0UL) << DMA_TCD_CSR_INTMAJOR_SHIFT) |\r\n                                  ((config->scatterGatherEnable ? 1UL : 0UL) << DMA_TCD_CSR_ESG_SHIFT));\r\n#endif\r\n        stcd->BITER = (uint16_t) config->loopTransferConfig->majorLoopIterationCount;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_PushConfigToReg\r\n * Description   : Copy the configuration to the TCD registers.\r\n *\r\n * Implements    : EDMA_DRV_PushConfigToReg_Activity\r\n *END**************************************************************************/\r\nvoid EDMA_DRV_PushConfigToReg(uint8_t virtualChannel,\r\n                              const edma_transfer_config_t *tcd)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    /* Check the transfer configuration structure is valid */\r\n    DEV_ASSERT(tcd != NULL);\r\n\r\n    /* Get DMA instance from virtual channel */\r\n    uint8_t dmaInstance = (uint8_t)FEATURE_DMA_VCH_TO_INSTANCE(virtualChannel);\r\n\r\n    /* Get DMA channel from virtual channel*/\r\n    uint8_t dmaChannel = (uint8_t)FEATURE_DMA_VCH_TO_CH(virtualChannel);\r\n\r\n    DMA_Type *edmaRegBase = s_edmaBase[dmaInstance];\r\n\r\n    /* Clear TCD registers */\r\n    EDMA_TCDClearReg(edmaRegBase, dmaChannel);\r\n\r\n#ifdef FEATURE_DMA_ENGINE_STALL\r\n    /* Configure the DMA Engine to stall for a number of cycles after each R/W */\r\n    EDMA_TCDSetEngineStall(edmaRegBase, dmaChannel, EDMA_ENGINE_STALL_4_CYCLES);\r\n#endif\r\n\r\n    /* Set source and destination addresses */\r\n    EDMA_TCDSetSrcAddr(edmaRegBase, dmaChannel, tcd->srcAddr);\r\n    EDMA_TCDSetDestAddr(edmaRegBase, dmaChannel, tcd->destAddr);\r\n    /* Set source/destination modulo feature and transfer size */\r\n    EDMA_TCDSetAttribute(edmaRegBase, dmaChannel, tcd->srcModulo, tcd->destModulo,\r\n                         tcd->srcTransferSize, tcd->destTransferSize);\r\n    /* Set source/destination offset and last adjustment; for scatter/gather operation, destination\r\n     * last adjustment is the address of the next TCD structure to be loaded by the eDMA engine */\r\n    EDMA_TCDSetSrcOffset(edmaRegBase, dmaChannel, tcd->srcOffset);\r\n    EDMA_TCDSetDestOffset(edmaRegBase, dmaChannel, tcd->destOffset);\r\n    EDMA_TCDSetSrcLastAdjust(edmaRegBase, dmaChannel, tcd->srcLastAddrAdjust);\r\n    \r\n    if (tcd->scatterGatherEnable)\r\n    {\r\n        EDMA_TCDSetScatterGatherCmd(edmaRegBase, dmaChannel, true);\r\n        EDMA_TCDSetScatterGatherLink(edmaRegBase, dmaChannel, tcd->scatterGatherNextDescAddr);\r\n    }\r\n    else\r\n    {\r\n        EDMA_TCDSetScatterGatherCmd(edmaRegBase, dmaChannel, false);\r\n        EDMA_TCDSetDestLastAdjust(edmaRegBase, dmaChannel, tcd->destLastAddrAdjust);\r\n    }\r\n\r\n    /* Configure channel interrupt */\r\n    EDMA_TCDSetMajorCompleteIntCmd(edmaRegBase, dmaChannel, tcd->interruptEnable);\r\n\r\n    /* If loop configuration is available, copy minor/major loop setup to registers */\r\n    if (tcd->loopTransferConfig != NULL)\r\n    {\r\n        EDMA_TCDSetSrcMinorLoopOffsetCmd(edmaRegBase, dmaChannel, tcd->loopTransferConfig->srcOffsetEnable);\r\n        EDMA_TCDSetDestMinorLoopOffsetCmd(edmaRegBase, dmaChannel, tcd->loopTransferConfig->dstOffsetEnable);\r\n        EDMA_TCDSetMinorLoopOffset(edmaRegBase, dmaChannel, tcd->loopTransferConfig->minorLoopOffset);\r\n        EDMA_TCDSetNbytes(edmaRegBase, dmaChannel, tcd->minorByteTransferCount);\r\n\r\n        EDMA_TCDSetChannelMinorLink(edmaRegBase, dmaChannel, tcd->loopTransferConfig->minorLoopChnLinkNumber,\r\n                                    tcd->loopTransferConfig->minorLoopChnLinkEnable);\r\n        EDMA_TCDSetChannelMajorLink(edmaRegBase, dmaChannel, tcd->loopTransferConfig->majorLoopChnLinkNumber,\r\n                                    tcd->loopTransferConfig->majorLoopChnLinkEnable);\r\n\r\n        EDMA_TCDSetMajorCount(edmaRegBase, dmaChannel, tcd->loopTransferConfig->majorLoopIterationCount);\r\n    }\r\n    else\r\n    {\r\n        EDMA_TCDSetNbytes(edmaRegBase, dmaChannel, tcd->minorByteTransferCount);\r\n    }\r\n}\r\n\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ValidTransferSize\r\n * Description   : Check if the transfer size value is legal (0/1/2/4/5).\r\n *\r\n *END**************************************************************************/\r\nstatic bool EDMA_DRV_ValidTransferSize(edma_transfer_size_t size)\r\n{\r\n    bool isValid;\r\n    switch (size)\r\n    {\r\n        case EDMA_TRANSFER_SIZE_1B:\r\n        case EDMA_TRANSFER_SIZE_2B:\r\n        case EDMA_TRANSFER_SIZE_4B:\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_8B\r\n        case EDMA_TRANSFER_SIZE_8B:\r\n#endif\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_16B\r\n        case EDMA_TRANSFER_SIZE_16B:\r\n#endif\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_32B\r\n        case EDMA_TRANSFER_SIZE_32B:\r\n#endif\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_64B\r\n        case EDMA_TRANSFER_SIZE_64B:\r\n#endif\r\n            isValid = true;\r\n            break;\r\n        default:\r\n            isValid = false;\r\n            break;\r\n    }\r\n    return isValid;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_GetChannelStatus\r\n * Description   : Returns the eDMA channel retStatus.\r\n *\r\n * Implements    : EDMA_DRV_GetChannelStatus_Activity\r\n *END**************************************************************************/\r\nedma_chn_status_t EDMA_DRV_GetChannelStatus(uint8_t virtualChannel)\r\n{\r\n    /* Check that virtual channel number is valid */\r\n    DEV_ASSERT(virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS);\r\n\r\n    /* Check that eDMA module is initialized */\r\n    DEV_ASSERT(s_virtEdmaState != NULL);\r\n\r\n    /* Check that virtual channel is initialized */\r\n    DEV_ASSERT(s_virtEdmaState->virtChnState[virtualChannel] != NULL);\r\n\r\n    return s_virtEdmaState->virtChnState[virtualChannel]->status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_GetDmaRegBaseAddr\r\n * Description   : Returns the DMA register base address.\r\n *\r\n * Implements    : EDMA_DRV_GetDmaRegBaseAddr\r\n *END**************************************************************************/\r\nDMA_Type * EDMA_DRV_GetDmaRegBaseAddr(uint32_t instance)\r\n{\r\n    /* Check that instance is valid */\r\n    DEV_ASSERT(instance < DMA_INSTANCE_COUNT);\r\n    \r\n    return s_edmaBase[instance];\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_DRV_ClearStructure\r\n * Description   : Clears all bytes at the passed structure pointer.\r\n *\r\n *END**************************************************************************/\r\nstatic void EDMA_DRV_ClearStructure(uint8_t *sructPtr, size_t size)\r\n{\r\n    while (size > 0U)\r\n    {\r\n        *sructPtr = 0;\r\n        sructPtr ++;\r\n        size --;\r\n    }\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n\r\n"},{"name":"edma_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n /*!\r\n * @file edma_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to enable the use of a macro for computing TCD related values needed by\r\n * the user code (even if the macro is not used inside the EDMA driver code).\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro defined.\r\n * This is required to allow the use of a macro for computing TCD related values needed by\r\n * the user.\r\n */\r\n\r\n#if !defined(EDMA_DRIVER_H)\r\n#define EDMA_DRIVER_H\r\n\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n#include <stddef.h>\r\n\r\n/*!\r\n * @addtogroup edma_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief Macro for the memory size needed for the software TCD.\r\n *\r\n * Software TCD is aligned to 32 bytes. We don't need a software TCD structure for the first\r\n * descriptor, since the configuration is pushed directly to registers.\r\n * To make sure the software TCD can meet the eDMA module requirement regarding alignment,\r\n * allocate memory for the remaining descriptors with extra 31 bytes.\r\n */\r\n#define STCD_SIZE(number)           (((number) * 32U) - 1U)\r\n#define STCD_ADDR(address)          (((uint32_t)address + 31UL) & ~0x1FUL)\r\n\r\n/*!\r\n * @brief Macro for accessing the least significant bit of the ERR register.\r\n *\r\n * The erroneous channels are retrieved from ERR register by subsequently right\r\n * shifting all the ERR bits + \"AND\"-ing the result with this mask.\r\n */\r\n#define EDMA_ERR_LSB_MASK           1U\r\n\r\n/*! @brief eDMA channel interrupts.\r\n * Implements : edma_channel_interrupt_t_Class\r\n */\r\ntypedef enum {\r\n    EDMA_CHN_ERR_INT = 0U,         /*!< Error interrupt */\r\n    EDMA_CHN_HALF_MAJOR_LOOP_INT,  /*!< Half major loop interrupt. */\r\n    EDMA_CHN_MAJOR_LOOP_INT        /*!< Complete major loop interrupt. */\r\n} edma_channel_interrupt_t;\r\n\r\n/*! @brief eDMA channel arbitration algorithm used for selection among channels.\r\n * Implements : edma_arbitration_algorithm_t_Class\r\n */\r\ntypedef enum {\r\n    EDMA_ARBITRATION_FIXED_PRIORITY = 0U,  /*!< Fixed Priority */\r\n    EDMA_ARBITRATION_ROUND_ROBIN           /*!< Round-Robin arbitration */\r\n} edma_arbitration_algorithm_t;\r\n\r\n/*! @brief eDMA channel priority setting\r\n * Implements : edma_channel_priority_t_Class\r\n */\r\ntypedef enum {\r\n    EDMA_CHN_PRIORITY_0 = 0U,\r\n    EDMA_CHN_PRIORITY_1 = 1U,\r\n    EDMA_CHN_PRIORITY_2 = 2U,\r\n    EDMA_CHN_PRIORITY_3 = 3U,\r\n#ifndef FEATURE_DMA_4_CH_PRIORITIES    \r\n    EDMA_CHN_PRIORITY_4 = 4U,\r\n    EDMA_CHN_PRIORITY_5 = 5U,\r\n    EDMA_CHN_PRIORITY_6 = 6U,\r\n    EDMA_CHN_PRIORITY_7 = 7U,\r\n#ifndef FEATURE_DMA_8_CH_PRIORITIES\r\n    EDMA_CHN_PRIORITY_8 = 8U,\r\n    EDMA_CHN_PRIORITY_9 = 9U,\r\n    EDMA_CHN_PRIORITY_10 = 10U,\r\n    EDMA_CHN_PRIORITY_11 = 11U,\r\n    EDMA_CHN_PRIORITY_12 = 12U,\r\n    EDMA_CHN_PRIORITY_13 = 13U,\r\n    EDMA_CHN_PRIORITY_14 = 14U,\r\n    EDMA_CHN_PRIORITY_15 = 15U,\r\n#endif\r\n#endif\r\n    EDMA_CHN_DEFAULT_PRIORITY = 255U\r\n} edma_channel_priority_t;\r\n\r\n#if FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U\r\n/*! @brief eDMA group priority setting\r\n * Implements : edma_group_priority_t_Class\r\n */\r\ntypedef enum {\r\n#ifdef FEATURE_DMA_HWV3\r\n    EDMA_CHN_GROUP_0 = 0U,\r\n    EDMA_CHN_GROUP_1 = 1U,\r\n    EDMA_CHN_GROUP_2 = 2U,\r\n    EDMA_CHN_GROUP_3 = 3U,\r\n    EDMA_CHN_GROUP_4 = 4U,\r\n    EDMA_CHN_GROUP_5 = 5U,\r\n    EDMA_CHN_GROUP_6 = 6U,\r\n    EDMA_CHN_GROUP_7 = 7U,\r\n    EDMA_CHN_GROUP_8 = 8U,\r\n    EDMA_CHN_GROUP_9 = 9U,\r\n    EDMA_CHN_GROUP_10 = 10U,\r\n    EDMA_CHN_GROUP_11 = 11U,\r\n    EDMA_CHN_GROUP_12 = 12U,\r\n    EDMA_CHN_GROUP_13 = 13U,\r\n    EDMA_CHN_GROUP_14 = 14U,\r\n    EDMA_CHN_GROUP_15 = 15U,\r\n    EDMA_CHN_GROUP_16 = 16U,\r\n    EDMA_CHN_GROUP_17 = 17U,\r\n    EDMA_CHN_GROUP_18 = 18U,\r\n    EDMA_CHN_GROUP_19 = 19U,\r\n    EDMA_CHN_GROUP_20 = 20U,\r\n    EDMA_CHN_GROUP_21 = 21U,\r\n    EDMA_CHN_GROUP_22 = 22U,\r\n    EDMA_CHN_GROUP_23 = 23U,\r\n    EDMA_CHN_GROUP_24 = 24U,\r\n    EDMA_CHN_GROUP_25 = 25U,\r\n    EDMA_CHN_GROUP_26 = 26U,\r\n    EDMA_CHN_GROUP_27 = 27U,\r\n    EDMA_CHN_GROUP_28 = 28U,\r\n    EDMA_CHN_GROUP_29 = 29U,\r\n    EDMA_CHN_GROUP_30 = 30U,\r\n    EDMA_CHN_GROUP_31 = 31U\r\n#else\r\n    EDMA_GRP0_PRIO_LOW_GRP1_PRIO_HIGH = 0U,\r\n    EDMA_GRP0_PRIO_HIGH_GRP1_PRIO_LOW = 1U\r\n#endif\r\n} edma_group_priority_t;\r\n#endif\r\n\r\n/*! @brief eDMA modulo configuration\r\n * Implements : edma_modulo_t_Class\r\n */\r\ntypedef enum {\r\n    EDMA_MODULO_OFF = 0U,\r\n    EDMA_MODULO_2B,\r\n    EDMA_MODULO_4B,\r\n    EDMA_MODULO_8B,\r\n    EDMA_MODULO_16B,\r\n    EDMA_MODULO_32B,\r\n    EDMA_MODULO_64B,\r\n    EDMA_MODULO_128B,\r\n    EDMA_MODULO_256B,\r\n    EDMA_MODULO_512B,\r\n    EDMA_MODULO_1KB,\r\n    EDMA_MODULO_2KB,\r\n    EDMA_MODULO_4KB,\r\n    EDMA_MODULO_8KB,\r\n    EDMA_MODULO_16KB,\r\n    EDMA_MODULO_32KB,\r\n    EDMA_MODULO_64KB,\r\n    EDMA_MODULO_128KB,\r\n    EDMA_MODULO_256KB,\r\n    EDMA_MODULO_512KB,\r\n    EDMA_MODULO_1MB,\r\n    EDMA_MODULO_2MB,\r\n    EDMA_MODULO_4MB,\r\n    EDMA_MODULO_8MB,\r\n    EDMA_MODULO_16MB,\r\n    EDMA_MODULO_32MB,\r\n    EDMA_MODULO_64MB,\r\n    EDMA_MODULO_128MB,\r\n    EDMA_MODULO_256MB,\r\n    EDMA_MODULO_512MB,\r\n    EDMA_MODULO_1GB,\r\n    EDMA_MODULO_2GB\r\n} edma_modulo_t;\r\n\r\n/*! @brief eDMA transfer configuration\r\n * Implements : edma_transfer_size_t_Class\r\n */\r\ntypedef enum {\r\n#ifdef FEATURE_DMA_HWV3\r\n    EDMA_TRANSFER_SIZE_1B  = 0x0U,\r\n    EDMA_TRANSFER_SIZE_2B  = 0x1U,\r\n    EDMA_TRANSFER_SIZE_4B  = 0x2U,\r\n    EDMA_TRANSFER_SIZE_8B  = 0x3U,\r\n    EDMA_TRANSFER_SIZE_16B = 0x4U,\r\n    EDMA_TRANSFER_SIZE_32B = 0x5U,\r\n    EDMA_TRANSFER_SIZE_64B = 0x6U\r\n#else\r\n    EDMA_TRANSFER_SIZE_1B  = 0x0U,\r\n    EDMA_TRANSFER_SIZE_2B  = 0x1U,\r\n    EDMA_TRANSFER_SIZE_4B  = 0x2U,\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_8B\r\n    EDMA_TRANSFER_SIZE_8B  = 0x3U,\r\n#endif\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_16B \r\n    EDMA_TRANSFER_SIZE_16B = 0x4U,\r\n#endif\r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_32B\r\n    EDMA_TRANSFER_SIZE_32B = 0x5U,\r\n#endif    \r\n#ifdef FEATURE_DMA_TRANSFER_SIZE_64B\r\n    EDMA_TRANSFER_SIZE_64B = 0x6U\r\n#endif\r\n#endif\r\n} edma_transfer_size_t;\r\n\r\n/*!\r\n * @brief The user configuration structure for the eDMA driver.\r\n *\r\n * Use an instance of this structure with the EDMA_DRV_Init() function. This allows the user to configure\r\n * settings of the EDMA peripheral with a single function call.\r\n * Implements : edma_user_config_t_Class\r\n */\r\ntypedef struct {\r\n    edma_arbitration_algorithm_t chnArbitration;         /*!< eDMA channel arbitration. */\r\n#if FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U\r\n#ifndef FEATURE_DMA_HWV3\r\n    edma_arbitration_algorithm_t groupArbitration;       /*!< eDMA group arbitration. */\r\n    edma_group_priority_t groupPriority;                 /*!< eDMA group priority. Used while eDMA\r\n                                                              group arbitration is set to fixed priority. */\r\n#endif\r\n#endif\r\n    bool haltOnError;                                    /*!< Any error causes the HALT bit to set. Subsequently, all\r\n                                                              service requests are ignored until the HALT bit is cleared. */\t\t\t\t\t\t\t\t\t\t\t\t\t  \r\n} edma_user_config_t;\r\n\r\n/*!\r\n * @brief Channel status for eDMA channel.\r\n *\r\n * A structure describing the eDMA channel status. The user can get the status by callback parameter\r\n * or by calling EDMA_DRV_getStatus() function.\r\n * Implements : edma_chn_status_t_Class\r\n */\r\ntypedef enum {\r\n    EDMA_CHN_NORMAL = 0U,           /*!< eDMA channel normal state. */\r\n    EDMA_CHN_ERROR                  /*!< An error occurred in the eDMA channel. */\r\n} edma_chn_status_t;\r\n\r\n/*!\r\n * @brief Definition for the eDMA channel callback function.\r\n *\r\n * Prototype for the callback function registered in the eDMA driver.\r\n * Implements : edma_callback_t_Class\r\n */\r\ntypedef void (*edma_callback_t)(void *parameter, edma_chn_status_t status);\r\n\r\n/*! @brief Data structure for the eDMA channel state.\r\n * Implements : edma_chn_state_t_Class\r\n */\r\ntypedef struct {\r\n    uint8_t virtChn;                     /*!< Virtual channel number. */\r\n    edma_callback_t callback;            /*!< Callback function pointer for the eDMA channel. It will\r\n                                              be called at the eDMA channel complete and eDMA channel\r\n                                              error. */\r\n    void *parameter;                     /*!< Parameter for the callback function pointer. */\r\n    volatile edma_chn_status_t status;   /*!< eDMA channel status. */\r\n} edma_chn_state_t;\r\n\r\n/*!\r\n * @brief The user configuration structure for the an eDMA driver channel.\r\n *\r\n * Use an instance of this structure with the EDMA_DRV_ChannelInit() function. This allows the user to configure\r\n * settings of the EDMA channel with a single function call.\r\n * Implements : edma_channel_config_t_Class\r\n */\r\ntypedef struct {\r\n#if FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U\r\n#ifdef FEATURE_DMA_HWV3\r\n    edma_group_priority_t groupPriority;     /*!< eDMA group priority. Used while eDMA\r\n                                              group arbitration is set to fixed priority. */\r\n#endif\r\n#endif\r\n    edma_channel_priority_t channelPriority; /*!< eDMA channel priority - only used when channel\r\n                                                  arbitration mode is 'Fixed priority'. */\r\n    uint8_t virtChnConfig;                   /*!< eDMA virtual channel number */\r\n#ifdef FEATURE_DMAMUX_AVAILABLE    \r\n    dma_request_source_t source;             /*!< Selects the source of the DMA request for this channel */\r\n#endif    \r\n    edma_callback_t callback;                /*!< Callback that will be registered for this channel */\r\n    void * callbackParam;                    /*!< Parameter passed to the channel callback */\r\n    bool enableTrigger;                      /*!< Enables the periodic trigger capability for the DMA channel. */\t\t\t\r\n} edma_channel_config_t;\r\n\r\n/*! @brief A type for the DMA transfer.\r\n * Implements : edma_transfer_type_t_Class\r\n */\r\ntypedef enum {\r\n    EDMA_TRANSFER_PERIPH2MEM = 0U,   /*!< Transfer from peripheral to memory */\r\n    EDMA_TRANSFER_MEM2PERIPH,        /*!< Transfer from memory to peripheral */\r\n    EDMA_TRANSFER_MEM2MEM,           /*!< Transfer from memory to memory */\r\n    EDMA_TRANSFER_PERIPH2PERIPH      /*!< Transfer from peripheral to peripheral */\r\n} edma_transfer_type_t;\r\n\r\n/*! @brief Data structure for configuring a discrete memory transfer.\r\n * Implements : edma_scatter_gather_list_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t address;           /*!< Address of buffer. */\r\n    uint32_t length;            /*!< Length of buffer. */\r\n    edma_transfer_type_t type;  /*!< Type of the DMA transfer */\r\n} edma_scatter_gather_list_t;\r\n\r\n/*!\r\n * @brief Runtime state structure for the eDMA driver.\r\n *\r\n * This structure holds data that is used by the eDMA peripheral driver to manage\r\n * multi eDMA channels.\r\n * The user passes the memory for this run-time state structure and the eDMA\r\n * driver populates the members.\r\n * Implements : edma_state_t_Class\r\n */\r\ntypedef struct {\r\n    edma_chn_state_t * volatile virtChnState[(uint32_t)FEATURE_DMA_VIRTUAL_CHANNELS];   /*!< Pointer array storing channel state. */\r\n} edma_state_t;\r\n\r\n/*!\r\n * @brief eDMA loop transfer configuration.\r\n *\r\n * This structure configures the basic minor/major loop attributes.\r\n * Implements : edma_loop_transfer_config_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t majorLoopIterationCount;       /*!< Number of major loop iterations. */\r\n    bool srcOffsetEnable;                   /*!< Selects whether the minor loop offset is applied to the\r\n                                                 source address upon minor loop completion. */\r\n    bool dstOffsetEnable;                   /*!< Selects whether the minor loop offset is applied to the\r\n                                                 destination address upon minor loop completion. */\r\n    int32_t minorLoopOffset;                /*!< Sign-extended offset applied to the source or destination address\r\n                                                 to form the next-state value after the minor loop completes. */\r\n    bool minorLoopChnLinkEnable;            /*!< Enables channel-to-channel linking on minor loop complete. */\r\n    uint8_t minorLoopChnLinkNumber;         /*!< The number of the next channel to be started by DMA\r\n                                                 engine when minor loop completes. */\r\n    bool majorLoopChnLinkEnable;            /*!< Enables channel-to-channel linking on major loop complete. */\r\n    uint8_t majorLoopChnLinkNumber;         /*!< The number of the next channel to be started by DMA\r\n                                                 engine when major loop completes. */\r\n} edma_loop_transfer_config_t;\r\n\r\n/*!\r\n * @brief eDMA transfer size configuration.\r\n *\r\n * This structure configures the basic source/destination transfer attribute.\r\n * Implements : edma_transfer_config_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t srcAddr;                                 /*!< Memory address pointing to the source data. */\r\n    uint32_t destAddr;                                /*!< Memory address pointing to the destination data. */\r\n    edma_transfer_size_t srcTransferSize;             /*!< Source data transfer size. */\r\n    edma_transfer_size_t destTransferSize;            /*!< Destination data transfer size. */\r\n    int16_t srcOffset;                                /*!< Sign-extended offset applied to the current source address\r\n                                                           to form the next-state value as each source read/write\r\n                                                           is completed. */\r\n    int16_t destOffset;                               /*!< Sign-extended offset applied to the current destination\r\n                                                           address to form the next-state value as each source\r\n                                                           read/write is completed. */\r\n    int32_t srcLastAddrAdjust;                        /*!< Last source address adjustment. */\r\n    int32_t destLastAddrAdjust;                       /*!< Last destination address adjustment. Note here it is only\r\n                                                           valid when scatter/gather feature is not enabled. */\r\n    edma_modulo_t srcModulo;                          /*!< Source address modulo. */\r\n    edma_modulo_t destModulo;                         /*!< Destination address modulo. */\r\n    uint32_t minorByteTransferCount;                  /*!< Number of bytes to be transferred in each service request\r\n                                                           of the channel. */\r\n    bool scatterGatherEnable;                         /*!< Enable scatter gather feature. */\r\n    uint32_t scatterGatherNextDescAddr;               /*!< The address of the next descriptor to be used, when\r\n                                                           scatter/gather feature is enabled.\r\n                                                           Note: this value is not used when scatter/gather\r\n                                                                 feature is disabled. */\r\n    bool interruptEnable;                             /*!< Enable the interrupt request when the major loop\r\n                                                           count completes */\r\n    edma_loop_transfer_config_t *loopTransferConfig;  /*!< Pointer to loop transfer configuration structure\r\n                                                           (defines minor/major loop attributes)\r\n                                                           Note: this field is only used when minor loop mapping is\r\n                                                                 enabled from DMA configuration. */\r\n} edma_transfer_config_t;\r\n\r\n#if (defined(CORE_LITTLE_ENDIAN))\r\n/*! @brief eDMA TCD\r\n * Implements : edma_software_tcd_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t SADDR;\r\n    int16_t SOFF;\r\n    uint16_t ATTR;\r\n    uint32_t NBYTES;\r\n    int32_t SLAST;\r\n    uint32_t DADDR;\r\n    int16_t DOFF;\r\n    uint16_t CITER;\r\n    int32_t DLAST_SGA;\r\n    uint16_t CSR;\r\n    uint16_t BITER;\r\n} edma_software_tcd_t;\r\n#elif (defined(CORE_BIG_ENDIAN))\r\n/*! @brief eDMA TCD\r\n * Implements : edma_software_tcd_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t SADDR;\r\n    uint16_t ATTR;\r\n    int16_t SOFF;\r\n    uint32_t NBYTES;\r\n    int32_t SLAST;\r\n    uint32_t DADDR;\r\n    uint16_t CITER;\r\n    int16_t DOFF;\r\n    int32_t DLAST_SGA;\r\n    uint16_t BITER;\r\n    uint16_t CSR;\r\n} edma_software_tcd_t;\r\n#else\r\n    #error \"Endianness not defined!\"\r\n#endif\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n  * @name eDMA Peripheral Driver\r\n  * @{\r\n  */\r\n\r\n/*!\r\n  * @name eDMA peripheral driver module level functions\r\n  * @{\r\n  */\r\n\r\n/*!\r\n * @brief Initializes the eDMA module.\r\n *\r\n * This function initializes the run-time state structure to provide the eDMA channel allocation\r\n * release, protect, and track the state for channels. This function also resets the eDMA modules,\r\n * initializes the module to user-defined settings and default settings.\r\n * @param edmaState The pointer to the eDMA peripheral driver state structure. The user passes\r\n * the memory for this run-time state structure and the eDMA peripheral driver populates the\r\n * members. This run-time state structure keeps track of the eDMA channels status. The memory must\r\n * be kept valid before calling the EDMA_DRV_DeInit.\r\n * @param userConfig User configuration structure for eDMA peripheral drivers. The user populates the\r\n * members of this structure and passes the pointer of this structure into the function.\r\n * @param chnStateArray Array of pointers to run-time state structures for eDMA channels;\r\n * will populate the state structures inside the eDMA driver state structure.\r\n * @param chnConfigArray Array of pointers to channel initialization structures.\r\n * @param chnCount The number of eDMA channels to be initialized.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_Init(edma_state_t * edmaState,\r\n                       const edma_user_config_t *userConfig,\r\n                       edma_chn_state_t * const chnStateArray[],\r\n                       const edma_channel_config_t * const chnConfigArray[],\r\n                       uint32_t chnCount);\r\n\r\n/*!\r\n * @brief De-initializes the eDMA module.\r\n *\r\n * This function resets the eDMA module to reset state and disables the interrupt to the core.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_Deinit(void);\r\n\r\n/*! @} */\r\n\r\n/*!\r\n  * @name eDMA peripheral driver channel management functions\r\n  * @{\r\n  */\r\n\r\n/*!\r\n * @brief Initializes an eDMA channel.\r\n *\r\n * This function initializes the run-time state structure for a eDMA channel, based on user\r\n * configuration. It will request the channel, set up the channel priority and install the\r\n * callback.\r\n *\r\n * @param edmaChannelState Pointer to the eDMA channel state structure. The user passes\r\n * the memory for this run-time state structure and the eDMA peripheral driver populates the\r\n * members. This run-time state structure keeps track of the eDMA channel status. The memory must\r\n * be kept valid before calling the EDMA_DRV_ReleaseChannel.\r\n * @param edmaChannelConfig User configuration structure for eDMA channel. The user populates the\r\n * members of this structure and passes the pointer of this structure into the function.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_ChannelInit(edma_chn_state_t *edmaChannelState,\r\n                              const edma_channel_config_t *edmaChannelConfig);\r\n\r\n/*!\r\n * @brief Releases an eDMA channel.\r\n *\r\n * This function stops the eDMA channel and disables the interrupt of this channel. The channel state\r\n * structure can be released after this function is called.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_ReleaseChannel(uint8_t virtualChannel);\r\n\r\n/*! @} */\r\n\r\n/*!\r\n  * @name eDMA peripheral driver transfer setup functions\r\n  * @{\r\n  */\r\n\r\n/*!\r\n * @brief Copies the channel configuration to the TCD registers.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param tcd Pointer to the channel configuration structure.\r\n */\r\nvoid EDMA_DRV_PushConfigToReg(uint8_t virtualChannel,\r\n                              const edma_transfer_config_t *tcd);\r\n\r\n/*!\r\n * @brief Copies the channel configuration to the software TCD structure.\r\n *\r\n * This function copies the properties from the channel configuration to the software TCD structure; the address\r\n * of the software TCD can be used to enable scatter/gather operation (pointer to the next TCD).\r\n\r\n * @param config Pointer to the channel configuration structure.\r\n * @param stcd Pointer to the software TCD structure.\r\n */\r\nvoid EDMA_DRV_PushConfigToSTCD(const edma_transfer_config_t *config,\r\n                               edma_software_tcd_t *stcd);\r\n\r\n/*!\r\n * @brief Configures a simple single block data transfer with DMA.\r\n *\r\n * This function configures the descriptor for a single block transfer.\r\n * The function considers contiguous memory blocks, thus it configures the TCD\r\n * source/destination offset fields to cover the data buffer without gaps,\r\n * according to \"transferSize\" parameter (the offset is equal to the number of\r\n * bytes transferred in a source read/destination write).\r\n *\r\n * NOTE: For memory-to-peripheral or peripheral-to-memory transfers, make sure\r\n * the transfer size is equal to the data buffer size of the peripheral used,\r\n * otherwise only truncated chunks of data may be transferred (e.g. for a\r\n * communication IP with an 8-bit data register the transfer size should be 1B,\r\n * whereas for a 32-bit data register, the transfer size should be 4B). The\r\n * rationale of this constraint is that, on the peripheral side, the address\r\n * offset is set to zero, allowing to read/write data from/to the peripheral\r\n * in a single source read/destination write operation.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param type Transfer type (M->M, P->M, M->P, P->P).\r\n * @param srcAddr A source register address or a source memory address.\r\n * @param destAddr A destination register address or a destination memory address.\r\n * @param transferSize The number of bytes to be transferred on every DMA write/read.\r\n *        Source/Dest share the same write/read size.\r\n * @param dataBufferSize The total number of bytes to be transferred.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS\r\n */\r\nstatus_t EDMA_DRV_ConfigSingleBlockTransfer(uint8_t virtualChannel,\r\n                                            edma_transfer_type_t type,\r\n                                            uint32_t srcAddr,\r\n                                            uint32_t destAddr,\r\n                                            edma_transfer_size_t transferSize,\r\n                                            uint32_t dataBufferSize);\r\n\r\n/*!\r\n * @brief Configures a multiple block data transfer with DMA.\r\n *\r\n * This function configures the descriptor for a multi-block transfer.\r\n * The function considers contiguous memory blocks, thus it configures the TCD\r\n * source/destination offset fields to cover the data buffer without gaps,\r\n * according to \"transferSize\" parameter (the offset is equal to the number of\r\n * bytes transferred in a source read/destination write). The buffer is divided\r\n * in multiple block, each block being transferred upon a single DMA request.\r\n *\r\n * NOTE: For transfers to/from peripherals, make sure\r\n * the transfer size is equal to the data buffer size of the peripheral used,\r\n * otherwise only truncated chunks of data may be transferred (e.g. for a\r\n * communication IP with an 8-bit data register the transfer size should be 1B,\r\n * whereas for a 32-bit data register, the transfer size should be 4B). The\r\n * rationale of this constraint is that, on the peripheral side, the address\r\n * offset is set to zero, allowing to read/write data from/to the peripheral\r\n * in a single source read/destination write operation.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param type Transfer type (M->M, P->M, M->P, P->P).\r\n * @param srcAddr A source register address or a source memory address.\r\n * @param destAddr A destination register address or a destination memory address.\r\n * @param transferSize The number of bytes to be transferred on every DMA write/read.\r\n *        Source/Dest share the same write/read size.\r\n * @param blockSize The total number of bytes inside a block.\r\n * @param blockCount The total number of data blocks (one block is transferred upon a DMA request).\r\n * @param disableReqOnCompletion This parameter specifies whether the DMA channel should\r\n *        be disabled when the transfer is complete (further requests will remain untreated).\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS\r\n */\r\nstatus_t EDMA_DRV_ConfigMultiBlockTransfer(uint8_t virtualChannel,\r\n                                           edma_transfer_type_t type,\r\n                                           uint32_t srcAddr,\r\n                                           uint32_t destAddr,\r\n                                           edma_transfer_size_t transferSize,\r\n                                           uint32_t blockSize,\r\n                                           uint32_t blockCount,\r\n                                           bool disableReqOnCompletion);\r\n\r\n/*!\r\n * @brief Configures the DMA transfer in loop mode.\r\n *\r\n * This function configures the DMA transfer in a loop chain. The user passes a block of memory into this\r\n * function that configures the loop transfer properties (minor/major loop count, address offsets, channel linking).\r\n * The DMA driver copies the configuration to TCD registers, only when the loop properties are set up correctly\r\n * and minor loop mapping is enabled for the eDMA module.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param transferConfig Pointer to the transfer configuration strucutre; this structure defines fields for setting\r\n * up the basic transfer and also a pointer to a memory strucure that defines the loop chain properties (minor/major).\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS\r\n */\r\nstatus_t EDMA_DRV_ConfigLoopTransfer(uint8_t virtualChannel,\r\n                                     const edma_transfer_config_t *transferConfig);\r\n\r\n/*!\r\n * @brief Configures the DMA transfer in a scatter-gather mode.\r\n *\r\n * This function configures the descriptors into a single-ended chain. The user passes blocks of memory into\r\n * this function. The interrupt is triggered only when the last memory block is completed. The memory block\r\n * information is passed with the edma_scatter_gather_list_t data structure, which can tell\r\n * the memory address and length.\r\n * The DMA driver configures the descriptor for each memory block, transfers the descriptor from the\r\n * first one to the last one, and stops.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param stcd Array of empty software TCD structures. The user must prepare this memory block. We don't need a\r\n * software TCD structure for the first descriptor, since the configuration is pushed directly to registers.The \"stcd\"\r\n * buffer must align with 32 bytes; if not, an error occurs in the eDMA driver. Thus, the required\r\n * memory size for \"stcd\" is equal to tcdCount * size_of(edma_software_tcd_t) - 1; the driver will take\r\n * care of the memory alignment if the provided memory buffer is big enough. For proper allocation of the\r\n * \"stcd\" buffer it is recommended to use STCD_SIZE macro.\r\n * @param transferSize The number of bytes to be transferred on every DMA write/read.\r\n * @param bytesOnEachRequest Bytes to be transferred in each DMA request.\r\n * @param srcList Data structure storing the address, length and type of transfer (M->M, M->P, P->M, P->P) for\r\n * the bytes to be transferred for source memory blocks. If the source memory is peripheral, the length\r\n * is not used.\r\n * @param destList Data structure storing the address, length and type of transfer (M->M, M->P, P->M, P->P) for\r\n * the bytes to be transferred for destination memory blocks. In the memory-to-memory transfer mode, the\r\n * user must ensure that the length of the destination scatter gather list is equal to the source\r\n * scatter gather list. If the destination memory is a peripheral register, the length is not used.\r\n * @param tcdCount The number of TCD memory blocks contained in the scatter gather list.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS\r\n */\r\nstatus_t EDMA_DRV_ConfigScatterGatherTransfer(uint8_t virtualChannel,\r\n                                              edma_software_tcd_t *stcd,\r\n                                              edma_transfer_size_t transferSize,\r\n                                              uint32_t bytesOnEachRequest,\r\n                                              const edma_scatter_gather_list_t *srcList,\r\n                                              const edma_scatter_gather_list_t *destList,\r\n                                              uint8_t tcdCount);\r\n\r\n/*!\r\n * @brief Cancel the running transfer.\r\n *\r\n * This function cancels the current transfer, optionally signalling an error.\r\n *\r\n * @param bool error If true, an error will be logged for the current transfer.\r\n */\r\nvoid EDMA_DRV_CancelTransfer(bool error);\r\n\r\n/*! @} */\r\n\r\n/*!\r\n  * @name eDMA Peripheral driver channel operation functions\r\n  * @{\r\n  */\r\n/*!\r\n * @brief Starts an eDMA channel.\r\n *\r\n * This function enables the eDMA channel DMA request.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_StartChannel(uint8_t virtualChannel);\r\n\r\n/*!\r\n * @brief Stops the eDMA channel.\r\n *\r\n * This function disables the eDMA channel DMA request.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_StopChannel(uint8_t virtualChannel);\r\n\r\n/*!\r\n * @brief Configures the DMA request for the eDMA channel.\r\n *\r\n * Selects which DMA source is routed to a DMA channel. The DMA sources are defined in the file\r\n * <MCU>_Features.h\r\n * Configures the periodic trigger capability for the triggered DMA channel.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param request DMA request source.\r\n * @param enableTrigger DMA channel periodic trigger.\r\n *\r\n * @return STATUS_SUCCESS or STATUS_UNSUPPORTED.\r\n */\r\nstatus_t EDMA_DRV_SetChannelRequestAndTrigger(uint8_t virtualChannel,\r\n                                              uint8_t request,\r\n                                              bool enableTrigger);\r\n\r\n/*!\r\n * @brief Clears all registers to 0 for the channel's TCD.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n */\r\nvoid EDMA_DRV_ClearTCD(uint8_t virtualChannel);\r\n\r\n/*!\r\n * @brief Configures the source address for the eDMA channel.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param address The pointer to the source memory address.\r\n */\r\nvoid EDMA_DRV_SetSrcAddr(uint8_t virtualChannel,\r\n                         uint32_t address);\r\n\r\n/*!\r\n * @brief Configures the source address signed offset for the eDMA channel.\r\n *\r\n * Sign-extended offset applied to the current source address to form the next-state value as each\r\n * source read is complete.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param offset Signed-offset for source address.\r\n */\r\nvoid EDMA_DRV_SetSrcOffset(uint8_t virtualChannel,\r\n                           int16_t offset);\r\n\r\n/*!\r\n * @brief Configures the source data chunk size (transferred in a read sequence).\r\n *\r\n * Source data read transfer size (1/2/4/16/32 bytes).\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param size Source transfer size.\r\n */\r\nvoid EDMA_DRV_SetSrcReadChunkSize(uint8_t virtualChannel,\r\n                                  edma_transfer_size_t size);\r\n\r\n/*!\r\n * @brief Configures the source address last adjustment.\r\n *\r\n * Adjustment value added to the source address at the completion of the major iteration count. This\r\n * value can be applied to restore the source address to the initial value, or adjust the address to\r\n * reference the next data structure.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param adjust Adjustment value.\r\n */\r\nvoid EDMA_DRV_SetSrcLastAddrAdjustment(uint8_t virtualChannel,\r\n                                       int32_t adjust);\r\n\r\n/*!\r\n * @brief Configures the destination address for the eDMA channel.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param address The pointer to the destination memory address.\r\n */\r\nvoid EDMA_DRV_SetDestAddr(uint8_t virtualChannel,\r\n                          uint32_t address);\r\n\r\n/*!\r\n * @brief Configures the destination address signed offset for the eDMA channel.\r\n *\r\n * Sign-extended offset applied to the current destination address to form the next-state value as each\r\n * destination write is complete.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param offset signed-offset\r\n */\r\nvoid EDMA_DRV_SetDestOffset(uint8_t virtualChannel,\r\n                            int16_t offset);\r\n\r\n/*!\r\n * @brief Configures the destination data chunk size (transferred in a write sequence).\r\n *\r\n * Destination data write transfer size (1/2/4/16/32 bytes).\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param size Destination transfer size.\r\n */\r\nvoid EDMA_DRV_SetDestWriteChunkSize(uint8_t virtualChannel,\r\n                                    edma_transfer_size_t size);\r\n\r\n/*!\r\n * @brief Configures the destination address last adjustment.\r\n *\r\n * Adjustment value added to the destination address at the completion of the major iteration count. This\r\n * value can be applied to restore the destination address to the initial value, or adjust the address to\r\n * reference the next data structure.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param adjust Adjustment value.\r\n */\r\nvoid EDMA_DRV_SetDestLastAddrAdjustment(uint8_t virtualChannel,\r\n                                        int32_t adjust);\r\n\r\n/*!\r\n * @brief Configures the number of bytes to be transferred in each service request of the channel.\r\n *\r\n * Sets the number of bytes to be transferred each time a request is received (one major loop iteration).\r\n * This number needs to be a multiple of the source/destination transfer size, as the data block will be\r\n * transferred within multiple read/write sequences (minor loops).\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param nbytes Number of bytes to be transferred in each service request of the channel\r\n */\r\nvoid EDMA_DRV_SetMinorLoopBlockSize(uint8_t virtualChannel,\r\n                                    uint32_t nbytes);\r\n\r\n/*!\r\n * @brief Configures the number of major loop iterations.\r\n *\r\n * Sets the number of major loop iterations; each major loop iteration will be served upon a request\r\n * for the current channel, transferring the data block configured for the minor loop (NBYTES).\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param majorLoopCount Number of major loop iterations.\r\n */\r\nvoid EDMA_DRV_SetMajorLoopIterationCount(uint8_t virtualChannel,\r\n                                         uint32_t majorLoopCount);\r\n\r\n/*!\r\n * @brief Returns the remaining major loop iteration count.\r\n *\r\n * Gets the number minor loops yet to be triggered (major loop iterations).\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @return number of major loop iterations yet to be triggered\r\n */\r\nuint32_t EDMA_DRV_GetRemainingMajorIterationsCount(uint8_t virtualChannel);\r\n\r\n/*!\r\n * @brief Configures the memory address of the next TCD, in scatter/gather mode.\r\n *\r\n * This function configures the address of the next TCD to be loaded form memory, when scatter/gather\r\n * feature is enabled. This address points to the beginning of a 0-modulo-32 byte region containing\r\n * the next transfer TCD to be loaded into this channel. The channel reload is performed as the\r\n * major iteration count completes. The scatter/gather address must be 0-modulo-32-byte. Otherwise,\r\n * a configuration error is reported.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param nextTCDAddr The address of the next TCD to be linked to this TCD.\r\n */\r\nvoid EDMA_DRV_SetScatterGatherLink(uint8_t virtualChannel,\r\n                                   uint32_t nextTCDAddr);\r\n\r\n/*!\r\n * @brief Disables/Enables the DMA request after the major loop completes for the TCD.\r\n *\r\n * If disabled, the eDMA hardware automatically clears the corresponding DMA request when the\r\n * current major iteration count reaches zero.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param disable Disable (true)/Enable (false) DMA request after TCD complete.\r\n */\r\nvoid EDMA_DRV_DisableRequestsOnTransferComplete(uint8_t virtualChannel,\r\n                                                bool disable);\r\n\r\n/*!\r\n * @brief Disables/Enables the channel interrupt requests.\r\n *\r\n * This function enables/disables error, half major loop and complete major loop interrupts\r\n * for the current channel.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param interrupt Interrupt event (error/half major loop/complete major loop).\r\n * @param enable Enable (true)/Disable (false) interrupts for the current channel.\r\n */\r\nvoid EDMA_DRV_ConfigureInterrupt(uint8_t virtualChannel,\r\n                                 edma_channel_interrupt_t intSrc,\r\n                                 bool enable);\r\n\r\n/*!\r\n * @brief Triggers a sw request for the current channel.\r\n *\r\n * This function starts a transfer using the current channel (sw request).\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n */\r\nvoid EDMA_DRV_TriggerSwRequest(uint8_t virtualChannel);\r\n\r\n/*! @} */\r\n\r\n/*!\r\n  * @name eDMA Peripheral callback and interrupt functions\r\n  * @{\r\n  */\r\n\r\n/*!\r\n * @brief Registers the callback function and the parameter for eDMA channel.\r\n *\r\n * This function registers the callback function and the parameter into the eDMA channel state structure.\r\n * The callback function is called when the channel is complete or a channel error occurs. The eDMA\r\n * driver passes the channel status to this callback function to indicate whether it is caused by the\r\n * channel complete event or the channel error event.\r\n *\r\n * To un-register the callback function, set the callback function to \"NULL\" and call this\r\n * function.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n * @param callback The pointer to the callback function.\r\n * @param parameter The pointer to the callback function's parameter.\r\n *\r\n * @return STATUS_ERROR or STATUS_SUCCESS.\r\n */\r\nstatus_t EDMA_DRV_InstallCallback(uint8_t virtualChannel,\r\n                                  edma_callback_t callback,\r\n                                  void *parameter);\r\n\r\n/*! @} */\r\n\r\n/*!\r\n  * @name eDMA Peripheral driver miscellaneous functions\r\n  * @{\r\n  */\r\n/*!\r\n * @brief Gets the eDMA channel status.\r\n *\r\n * @param virtualChannel eDMA virtual channel number.\r\n *\r\n * @return Channel status.\r\n */\r\nedma_chn_status_t EDMA_DRV_GetChannelStatus(uint8_t virtualChannel);\r\n\r\n/*! @} */\r\n\r\n/*! @} */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n#endif /* EDMA_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n\r\n"},{"name":"edma_hw_access.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file edma_hw_access.c\r\n */\r\n\r\n#include \"edma_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_Init\r\n * Description   : Initializes eDMA module to known state.\r\n *END**************************************************************************/\r\nvoid EDMA_Init(DMA_Type * base)\r\n{\r\n    uint8_t i;\r\n    /* Clear the bit of CR register */\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t regValTemp;\r\n    regValTemp = base->MP_CSR;\r\n    regValTemp &= ~(DMA_MP_CSR_EBW_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_EDBG_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_ERCA_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_HAE_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_HALT_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_ECL_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_EMI_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_ECX_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_CX_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_ACTIVE_ID_MASK);\r\n    regValTemp &= ~(DMA_MP_CSR_ACTIVE_MASK);\r\n    base->MP_CSR = regValTemp;\r\n\r\n    for (i = 0; i < FEATURE_DMA_CHANNELS; i++)\r\n    {\r\n        base->CH_GRPRI[i] = 0;\r\n    }\r\n#else\r\n    uint32_t regValTemp;\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_CLM_MASK);\r\n    regValTemp &= ~(DMA_CR_CX_MASK);\r\n    regValTemp &= ~(DMA_CR_ECX_MASK);\r\n    regValTemp &= ~(DMA_CR_EDBG_MASK);\r\n    regValTemp &= ~(DMA_CR_EMLM_MASK);\r\n    regValTemp &= ~(DMA_CR_ERCA_MASK);\r\n    base->CR = regValTemp;\r\n#endif\r\n    for (i = 0; i < FEATURE_DMA_CHANNELS; i++)\r\n    {\r\n        EDMA_TCDClearReg(base, i);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_CancelTransfer\r\n * Description   : Cancels the remaining data transfer.\r\n *END**************************************************************************/\r\nvoid EDMA_CancelTransfer(DMA_Type * base)\r\n{\r\n    uint32_t regValTemp;\r\n#ifdef FEATURE_DMA_HWV3\r\n    regValTemp = base->MP_CSR;\r\n    regValTemp &= ~(DMA_MP_CSR_CX_MASK);\r\n    regValTemp |= DMA_MP_CSR_CX(1U);\r\n    base->MP_CSR = regValTemp;\r\n    while ((base->MP_CSR & DMA_MP_CSR_CX_MASK) == DMA_MP_CSR_CX_MASK)\r\n    {}\r\n#else\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_CX_MASK);\r\n    regValTemp |= DMA_CR_CX(1U);\r\n    base->CR = regValTemp;\r\n    while (((base->CR & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT) != 0UL)\r\n    {}\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_CancelTransferWithError\r\n * Description   : Cancels the remaining data transfer and treat it as error.\r\n *END**************************************************************************/\r\nvoid EDMA_CancelTransferWithError(DMA_Type * base)\r\n{\r\n    uint32_t regValTemp;\r\n#ifdef FEATURE_DMA_HWV3\r\n    regValTemp = base->MP_CSR;\r\n    regValTemp &= ~(DMA_MP_CSR_ECX_MASK);\r\n    regValTemp |= DMA_MP_CSR_ECX(1U);\r\n    base->MP_CSR = regValTemp;\r\n    while ((base->MP_CSR & DMA_MP_CSR_ECX_MASK) == DMA_MP_CSR_ECX_MASK)\r\n    {}\r\n#else\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_ECX_MASK);\r\n    regValTemp |= DMA_CR_ECX(1U);\r\n    base->CR = regValTemp;\r\n    while (((base->CR & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT) != 0UL)\r\n    {}\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_SetErrorIntCmd\r\n * Description   : Enable/Disable error interrupt for channels.\r\n *END**************************************************************************/\r\nvoid EDMA_SetErrorIntCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t regValTemp;\r\n    regValTemp = base->TCD[channel].CH_CSR;\r\n    if (enable)\r\n    {\r\n        regValTemp |= DMA_TCD_CH_CSR_EEI_MASK;\r\n    }\r\n    else\r\n    {\r\n        regValTemp &= ~(DMA_TCD_CH_CSR_EEI_MASK);\r\n    }\r\n    base->TCD[channel].CH_CSR = regValTemp;\r\n#else\r\n    if (enable)\r\n    {\r\n        base->SEEI = channel;\r\n    }\r\n    else\r\n    {\r\n        base->CEEI = channel;\r\n    }\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_SetDmaRequestCmd\r\n * Description   : Enable/Disable dma request for channel or all channels.\r\n *END**************************************************************************/\r\nvoid EDMA_SetDmaRequestCmd(DMA_Type * base, uint8_t channel,bool enable)\r\n{\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t regValTemp;\r\n    regValTemp = base->TCD[channel].CH_CSR;\r\n    if (enable)\r\n    {\r\n        regValTemp |= DMA_TCD_CH_CSR_ERQ(1U);\r\n    }\r\n    else\r\n    {\r\n        regValTemp &= ~(DMA_TCD_CH_CSR_ERQ_MASK);\r\n    }\r\n    base->TCD[channel].CH_CSR = regValTemp;\r\n#else\r\n    if (enable)\r\n    {\r\n        base->SERQ = channel;\r\n    }\r\n    else\r\n    {\r\n        base->CERQ = channel;\r\n    }\r\n#endif\r\n}\r\n\r\n#if FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U\r\n#ifdef FEATURE_DMA_HWV3\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_SetChannelPriorityGroup\r\n * Description   : Configures DMA channel group priority.\r\n *END**************************************************************************/\r\nvoid EDMA_SetChannelPriorityGroup(DMA_Type * base, uint8_t channel, edma_group_priority_t channelPriorityGroup)\r\n{\r\n    base->CH_GRPRI[channel] = DMA_CH_GRPRI_GRPRI(channelPriorityGroup);\r\n}\r\n#else\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_SetGroupPriority\r\n * Description   : Configures DMA group priorities.\r\n *END**************************************************************************/\r\nvoid EDMA_SetGroupPriority(DMA_Type * base, edma_group_priority_t priority)\r\n{\r\n    uint32_t regValTemp;\r\n    uint32_t mask = DMA_CR_GRP0PRI_MASK | DMA_CR_GRP1PRI_MASK;\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~mask;\r\n    if (priority == EDMA_GRP0_PRIO_HIGH_GRP1_PRIO_LOW)\r\n    {\r\n        regValTemp |= DMA_CR_GRP0PRI_MASK;\r\n    }\r\n    else\r\n    {\r\n        regValTemp |= DMA_CR_GRP1PRI_MASK;\r\n    }\r\n\r\n    base->CR = regValTemp;\r\n}\r\n#endif\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDClearReg\r\n * Description   : Set registers to 0 for hardware TCD of eDMA channel.\r\n *END**************************************************************************/\r\nvoid EDMA_TCDClearReg(DMA_Type * base, uint8_t channel)\r\n{\r\n#ifdef FEATURE_DMA_HWV3\r\n    base->TCD[channel].CH_CSR = 0U;\r\n    base->TCD[channel].CH_ES |= DMA_TCD_CH_ES_ERR_MASK;\r\n    base->TCD[channel].CH_INT |= DMA_TCD_CH_INT_INT_MASK;\r\n    base->TCD[channel].CH_SBR = 0U;\r\n    base->TCD[channel].NBYTES.MLOFFNO = 0U;\r\n#else\r\n    base->TCD[channel].NBYTES.MLNO = 0U;\r\n#endif\r\n    base->TCD[channel].SADDR = 0U;\r\n    base->TCD[channel].SOFF = 0;\r\n    base->TCD[channel].ATTR = 0U;\r\n    base->TCD[channel].SLAST = 0;\r\n    base->TCD[channel].DADDR = 0U;\r\n    base->TCD[channel].DOFF = 0;\r\n    base->TCD[channel].CITER.ELINKNO = 0U;\r\n    base->TCD[channel].DLASTSGA = 0;\r\n    base->TCD[channel].CSR = 0U;\r\n    base->TCD[channel].BITER.ELINKNO = 0U;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDSetAttribute\r\n * Description   : Configures the transfer attribute for eDMA channel.\r\n *END**************************************************************************/\r\nvoid EDMA_TCDSetAttribute(\r\n                DMA_Type * base, uint8_t channel,\r\n                edma_modulo_t srcModulo, edma_modulo_t destModulo,\r\n                edma_transfer_size_t srcTransferSize, edma_transfer_size_t destTransferSize)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = (uint16_t)(DMA_TCD_ATTR_SMOD(srcModulo) | DMA_TCD_ATTR_SSIZE(srcTransferSize));\r\n    regValTemp |= (uint16_t)(DMA_TCD_ATTR_DMOD(destModulo) | DMA_TCD_ATTR_DSIZE(destTransferSize));\r\n    base->TCD[channel].ATTR = regValTemp;\r\n}\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDSetNbytes\r\n * Description   : Configures the nbytes for eDMA channel.\r\n *END**************************************************************************/\r\nvoid EDMA_TCDSetNbytes(DMA_Type * base, uint8_t channel, uint32_t nbytes)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t smloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT;\r\n    uint32_t dmloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT;\r\n    if ((smloe == 0UL) && (dmloe == 0UL))\r\n    {\r\n        base->TCD[channel].NBYTES.MLOFFNO = (nbytes & DMA_TCD_NBYTES_MLOFFNO_NBYTES_MASK);\r\n    }\r\n    else\r\n    {\r\n        uint32_t regValTemp;\r\n        regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n        regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_NBYTES_MASK);\r\n        regValTemp |= DMA_TCD_NBYTES_MLOFFYES_NBYTES(nbytes);\r\n        base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n    }\r\n#else\r\n    if (((base->CR & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT) != 0UL)\r\n    {\r\n        bool mlOffNo = false;\r\n        if (((base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT) == 0UL)\r\n        {\r\n            if (((base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT) == 0UL)\r\n            {\r\n                base->TCD[channel].NBYTES.MLOFFNO = (nbytes & DMA_TCD_NBYTES_MLOFFNO_NBYTES_MASK);\r\n                mlOffNo = true;\r\n            }\r\n        }\r\n        if (!mlOffNo)\r\n        {\r\n            uint32_t regValTemp;\r\n            regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n            regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_NBYTES_MASK);\r\n            regValTemp |= DMA_TCD_NBYTES_MLOFFYES_NBYTES(nbytes);\r\n            base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        base->TCD[channel].NBYTES.MLNO = nbytes;\r\n    }\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDSetMinorLoopOffset\r\n * Description   : Configures the minor loop offset for the TCD.\r\n *END**************************************************************************/\r\nvoid EDMA_TCDSetMinorLoopOffset(DMA_Type * base, uint8_t channel, int32_t offset)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t smloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT;\r\n    uint32_t dmloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT;\r\n    if ((smloe != 0UL) || (dmloe != 0UL))\r\n    {\r\n        uint32_t regValTemp;\r\n        regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n        regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_MLOFF_MASK);\r\n        regValTemp |= DMA_TCD_NBYTES_MLOFFYES_MLOFF(offset);\r\n        base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n    }\r\n#else\r\n    if (((base->CR & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT) != 0UL)\r\n    {\r\n        bool mlOffNo = false;\r\n        if (((base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT) != 0UL)\r\n        {\r\n            mlOffNo = true;\r\n        }\r\n        if (((base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT) != 0UL)\r\n        {\r\n            mlOffNo = true;\r\n        }\r\n        if (mlOffNo)\r\n        {\r\n            uint32_t regValTemp;\r\n            regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n            regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_MLOFF_MASK);\r\n            regValTemp |= DMA_TCD_NBYTES_MLOFFYES_MLOFF(offset);\r\n            base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n        }\r\n    }\r\n#endif\r\n}\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDSetScatterGatherLink\r\n * Description   : Configures the memory address of the next TCD, in Scatter/Gather mode.\r\n *\r\n *END**************************************************************************/\r\nvoid EDMA_TCDSetScatterGatherLink(DMA_Type * base, uint8_t channel, uint32_t nextTCDAddr)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].DLASTSGA = nextTCDAddr;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDSetChannelMinorLink\r\n * Description   : Set Channel minor link for hardware TCD.\r\n *END**************************************************************************/\r\nvoid EDMA_TCDSetChannelMinorLink(\r\n                DMA_Type * base, uint8_t channel, uint32_t linkChannel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n    DEV_ASSERT(linkChannel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint16_t regValTemp;\r\n    if (enable)\r\n    {\r\n        regValTemp = base->TCD[channel].BITER.ELINKYES;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_ELINK_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_ELINK(1);\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_LINKCH_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_LINKCH(linkChannel);\r\n        base->TCD[channel].BITER.ELINKYES = regValTemp;\r\n\r\n        regValTemp = base->TCD[channel].CITER.ELINKYES;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_ELINK_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_ELINK(1);\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_LINKCH_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_LINKCH(linkChannel);\r\n        base->TCD[channel].CITER.ELINKYES = regValTemp;\r\n    }\r\n    else\r\n    {\r\n        regValTemp = base->TCD[channel].BITER.ELINKNO;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_ELINK_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_ELINK(0);\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_LINKCH_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_LINKCH(linkChannel);\r\n        base->TCD[channel].BITER.ELINKNO = regValTemp;\r\n\r\n        regValTemp = base->TCD[channel].CITER.ELINKNO;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_ELINK_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_ELINK(0);\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_LINKCH_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_LINKCH(linkChannel);\r\n        base->TCD[channel].CITER.ELINKNO = regValTemp;\r\n    }\r\n#else\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].BITER.ELINKYES;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_ELINK_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_ELINK(enable ? 1UL : 0UL);\r\n    base->TCD[channel].BITER.ELINKYES = regValTemp;\r\n    regValTemp = base->TCD[channel].CITER.ELINKYES;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_ELINK_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_ELINK(enable ? 1UL : 0UL);\r\n    base->TCD[channel].CITER.ELINKYES = regValTemp;\r\n\r\n    if (enable)\r\n    {\r\n        regValTemp = base->TCD[channel].BITER.ELINKYES;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_LINKCH_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_LINKCH(linkChannel);\r\n        base->TCD[channel].BITER.ELINKYES = regValTemp;\r\n\r\n        regValTemp = base->TCD[channel].CITER.ELINKYES;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_LINKCH_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_LINKCH(linkChannel);\r\n        base->TCD[channel].CITER.ELINKYES = regValTemp;\r\n    }\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCD_TCDSetMajorCount\r\n * Description   : Sets the major iteration count according to minor loop\r\n * channel link setting.\r\n *END**************************************************************************/\r\nvoid EDMA_TCDSetMajorCount(DMA_Type * base, uint8_t channel, uint32_t count)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp = 0;\r\n    if ((base->TCD[channel].BITER.ELINKNO & DMA_TCD_BITER_ELINKNO_ELINK_MASK) == DMA_TCD_BITER_ELINKNO_ELINK_MASK)\r\n    {\r\n        regValTemp = base->TCD[channel].BITER.ELINKYES;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKYES_BITER_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKYES_BITER(count);\r\n        base->TCD[channel].BITER.ELINKYES = regValTemp;\r\n\r\n        regValTemp = base->TCD[channel].CITER.ELINKYES;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKYES_CITER_LE_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKYES_CITER_LE(count);\r\n        base->TCD[channel].CITER.ELINKYES = regValTemp;\r\n    }\r\n    else\r\n    {\r\n        regValTemp = base->TCD[channel].BITER.ELINKNO;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_BITER_ELINKNO_BITER_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_BITER_ELINKNO_BITER(count);\r\n        base->TCD[channel].BITER.ELINKNO = regValTemp;\r\n\r\n        regValTemp = base->TCD[channel].CITER.ELINKNO;\r\n        regValTemp &= (uint16_t)~(DMA_TCD_CITER_ELINKNO_CITER_MASK);\r\n        regValTemp |= (uint16_t)DMA_TCD_CITER_ELINKNO_CITER(count);\r\n        base->TCD[channel].CITER.ELINKNO = regValTemp;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : EDMA_TCDGetCurrentMajorCount\r\n * Description   : Gets the current major iteration count according to minor\r\n * loop channel link setting.\r\n *END**************************************************************************/\r\nuint32_t EDMA_TCDGetCurrentMajorCount(const DMA_Type * base, uint8_t channel)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t result = 0U;\r\n    if ((base->TCD[channel].BITER.ELINKNO & DMA_TCD_BITER_ELINKNO_ELINK_MASK) == DMA_TCD_BITER_ELINKNO_ELINK_MASK)\r\n    {\r\n        result = (uint16_t)((base->TCD[channel].CITER.ELINKYES & DMA_TCD_CITER_ELINKYES_CITER_LE_MASK) >> DMA_TCD_CITER_ELINKYES_CITER_LE_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        result = (uint16_t)((base->TCD[channel].CITER.ELINKNO & DMA_TCD_CITER_ELINKNO_CITER_MASK) >> DMA_TCD_CITER_ELINKNO_CITER_SHIFT);\r\n    }\r\n    return (uint32_t) result;\r\n}\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : DMAMUX_init\r\n * Description   : Initialize the dmamux module to the reset state.\r\n *END**************************************************************************/\r\nvoid DMAMUX_Init(DMAMUX_Type * base)\r\n{\r\n    uint8_t i;\r\n\r\n    for (i = 0; i < FEATURE_DMAMUX_CHANNELS; i++)\r\n    {\r\n        base->CHCFG[i] = 0;\r\n    }\r\n}\r\n#endif\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"edma_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file edma_hw_access.h\r\n */\r\n\r\n#ifndef EDMA_HW_ACCESS_H\r\n#define EDMA_HW_ACCESS_H\r\n\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include \"edma_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n#ifdef FEATURE_DMA_ENGINE_STALL \r\n/*!\r\n * @brief Specifies the number of cycles the DMA Engine is stalled.\r\n */\r\ntypedef enum {\r\n    EDMA_ENGINE_STALL_0_CYCLES = 0,\r\n    EDMA_ENGINE_STALL_4_CYCLES = 2,\r\n    EDMA_ENGINE_STALL_8_CYCLES = 3\r\n} edma_engine_stall_t;\r\n#endif\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name eDMA hw access module level functions\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Initializes eDMA module to known state.\r\n *\r\n * @param base Register base address for eDMA module.\r\n */\r\nvoid EDMA_Init(DMA_Type * base);\r\n\r\n/*!\r\n * @brief Cancels the remaining data transfer.\r\n *\r\n * This function stops the executing channel and forces the minor loop\r\n * to finish. The cancellation takes effect after the last write of the\r\n * current read/write sequence. The CX clears itself after the cancel has\r\n * been honored. This cancel retires the channel normally as if the minor\r\n * loop had completed.\r\n *\r\n * @param base Register base address for eDMA module.\r\n */\r\nvoid EDMA_CancelTransfer(DMA_Type * base);\r\n\r\n/*!\r\n * @brief Cancels the remaining data transfer and treats it as an error condition.\r\n *\r\n * This function stops the executing channel and forces the minor loop\r\n * to finish. The cancellation takes effect after the last write of the\r\n * current read/write sequence. The CX clears itself after the cancel has\r\n * been honoured. This cancel retires the channel normally as if the minor\r\n * loop had completed. Additional thing is to treat this operation as an error\r\n * condition.\r\n *\r\n * @param base Register base address for eDMA module.\r\n */\r\nvoid EDMA_CancelTransferWithError(DMA_Type * base);\r\n\r\n/*!\r\n * @brief Halts or does not halt the eDMA module when an error occurs.\r\n *\r\n * An error causes the HALT bit to be set. Subsequently, all service requests are ignored until the\r\n * HALT bit is cleared.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param haltOnError Halts (true) or not halt (false) eDMA module when an error occurs.\r\n */\r\nstatic inline void EDMA_SetHaltOnErrorCmd(DMA_Type * base, bool haltOnError)\r\n{\r\n    uint32_t regValTemp;\r\n#ifdef FEATURE_DMA_HWV3\r\n    regValTemp = base->MP_CSR;\r\n    regValTemp &= ~(DMA_MP_CSR_HAE_MASK);\r\n    regValTemp |= DMA_MP_CSR_HAE(haltOnError ? 1UL : 0UL);\r\n    base->MP_CSR = regValTemp;\r\n#else\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_HOE_MASK);\r\n    regValTemp |= DMA_CR_HOE(haltOnError ? 1UL : 0UL);\r\n    base->CR = regValTemp;\r\n#endif\r\n}\r\n\r\n/*! @} */\r\n\r\n/*!\r\n * @name eDMA HAL driver channel priority and arbitration configuration\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sets the eDMA channel priority.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param priority Priority of the DMA channel. Different channels should have different priority\r\n * setting inside a group.\r\n */\r\nstatic inline void EDMA_SetChannelPriority(DMA_Type * base, uint8_t channel, edma_channel_priority_t priority)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n\r\n#ifdef FEATURE_DMA_HWV3\r\n    volatile uint32_t regValTemp;\r\n    regValTemp = base->TCD[channel].CH_PRI;\r\n    regValTemp &= (uint32_t)~(DMA_TCD_CH_PRI_APL_MASK);\r\n    regValTemp |= (uint32_t)DMA_TCD_CH_PRI_APL(priority);\r\n    base->TCD[channel].CH_PRI = regValTemp;\r\n#else\r\n    uint8_t regValTemp;\r\n    uint8_t index = (uint8_t)FEATURE_DMA_CHN_TO_DCHPRI_INDEX(channel);\r\n    regValTemp = base->DCHPRI[index];\r\n    regValTemp &= (uint8_t)~(DMA_DCHPRI_CHPRI_MASK);\r\n    regValTemp |= (uint8_t)DMA_DCHPRI_CHPRI(priority);\r\n    base->DCHPRI[index] = regValTemp;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Sets the channel arbitration algorithm.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channelArbitration Round-Robin way or fixed priority way.\r\n */\r\nstatic inline void EDMA_SetChannelArbitrationMode(DMA_Type * base, edma_arbitration_algorithm_t channelArbitration)\r\n{\r\n    uint32_t regValTemp;\r\n#ifdef FEATURE_DMA_HWV3\r\n    regValTemp = base->MP_CSR;\r\n    regValTemp &= ~(DMA_MP_CSR_ERCA_MASK);\r\n    regValTemp |= DMA_MP_CSR_ERCA(channelArbitration);\r\n    base->MP_CSR = regValTemp;\r\n#else\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_ERCA_MASK);\r\n    regValTemp |= DMA_CR_ERCA(channelArbitration);\r\n    base->CR = regValTemp;\r\n#endif\r\n}\r\n\r\n\r\n/*!\r\n * @brief Gets the channel arbitration algorithm.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @return edma_arbitration_algorithm_t variable indicating the selected\r\n * channel arbitration: Round-Robin way or fixed priority way\r\n */\r\nstatic inline edma_arbitration_algorithm_t EDMA_GetChannelArbitrationMode(const DMA_Type * base)\r\n{\r\n    edma_arbitration_algorithm_t retVal;\r\n#ifdef FEATURE_DMA_HWV3\r\n    if (((base->MP_CSR >> DMA_MP_CSR_ERCA_SHIFT) & 1U) != 0U)\r\n#else\r\n    if (((base->CR >> DMA_CR_ERCA_SHIFT) & 1U) != 0U)\r\n#endif\r\n    {\r\n        retVal = EDMA_ARBITRATION_ROUND_ROBIN;\r\n    }\r\n    else\r\n    {\r\n        retVal = EDMA_ARBITRATION_FIXED_PRIORITY;\r\n    }\r\n    return retVal;\r\n}\r\n\r\n#if FEATURE_DMA_CHANNEL_GROUP_COUNT > 0x1U\r\n#ifdef FEATURE_DMA_HWV3\r\n/*!\r\n * @brief Sets the eDMA channel arbitration group.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel The DMA channel.\r\n * @param channelGroupPriority Specify in which group the channel is.\r\n */\r\nvoid EDMA_SetChannelPriorityGroup(DMA_Type * base, uint8_t channel, edma_group_priority_t channelPriorityGroup);\r\n#else\r\n/*!\r\n * @brief Sets the eDMA group priority.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param priority Priority of the DMA groups.\r\n */\r\nvoid EDMA_SetGroupPriority(DMA_Type * base, edma_group_priority_t priority);\r\n#endif\r\n\r\n/*!\r\n * @brief Sets the group arbitration algorithm.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param groupArbitrationMode Round-Robin way or fixed priority way.\r\n */\r\n#ifndef FEATURE_DMA_HWV3\r\nstatic inline void EDMA_SetGroupArbitrationMode(DMA_Type * base, edma_arbitration_algorithm_t groupArbitration)\r\n{\r\n    uint32_t regValTemp;\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_ERGA_MASK);\r\n    regValTemp |= DMA_CR_ERGA(groupArbitration);\r\n    base->CR = regValTemp;\r\n}\r\n#endif\r\n#endif\r\n\r\n/*!\r\n * @name eDMA HAL driver configuration and operation\r\n * @{\r\n */\r\n/*!\r\n * @brief Enables/Disables the minor loop mapping.\r\n *\r\n * This function enables/disables the minor loop mapping feature.\r\n * If enabled, the NBYTES is redefined to include the individual enable fields and the NBYTES field. The\r\n * individual enable fields allow the minor loop offset to be applied to the source address, the\r\n * destination address, or both. The NBYTES field is reduced when either offset is enabled.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param enable Enables (true) or Disable (false) minor loop mapping.\r\n */\r\n#ifdef FEATURE_DMA_HWV3\r\nstatic inline void EDMA_SetMinorLoopMappingCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n    uint32_t regValTemp;\r\n    regValTemp = base->TCD[channel].NBYTES.MLOFFNO;\r\n    regValTemp &= ~(DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK);\r\n    regValTemp &= ~(DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK);\r\n    regValTemp |= DMA_TCD_NBYTES_MLOFFNO_SMLOE(enable ? 1UL : 0UL);\r\n    regValTemp |= DMA_TCD_NBYTES_MLOFFNO_DMLOE(enable ? 1UL : 0UL);\r\n    base->TCD[channel].NBYTES.MLOFFNO = regValTemp;\r\n}\r\n#else\r\nstatic inline void EDMA_SetMinorLoopMappingCmd(DMA_Type * base, bool enable)\r\n{\r\n    uint32_t regValTemp;\r\n    regValTemp = base->CR;\r\n    regValTemp &= ~(DMA_CR_EMLM_MASK);\r\n    regValTemp |= DMA_CR_EMLM(enable ? 1UL : 0UL);\r\n    base->CR = regValTemp;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Enables/Disables the error interrupt for channels.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel Channel indicator.\r\n * @param enable Enable(true) or Disable (false) error interrupt.\r\n */\r\nvoid EDMA_SetErrorIntCmd(DMA_Type * base, uint8_t channel, bool enable);\r\n\r\n/*!\r\n * @brief Gets the eDMA error interrupt status.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @return 32 bit variable indicating error channels. If error happens on eDMA channel n, the bit n\r\n * of this variable is '1'. If not, the bit n of this variable is '0'.\r\n */\r\nstatic inline uint32_t EDMA_GetErrorIntStatusFlag(const DMA_Type * base)\r\n{\r\n#ifdef FEATURE_DMA_HWV3\r\n    return ((base->MP_ES & DMA_MP_ES_ERRCHN_MASK) >> DMA_MP_ES_ERRCHN_SHIFT);\r\n#else\r\n    return base->ERR;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Clears the error interrupt status for the eDMA channel or channels.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel Channel indicator.\r\n */\r\nstatic inline void EDMA_ClearErrorIntStatusFlag(DMA_Type * base, uint8_t channel)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n#ifdef FEATURE_DMA_HWV3\r\n    base->TCD[channel].CH_ES |= DMA_TCD_CH_ES_ERR_MASK;\r\n#else\r\n    base->CERR = (uint8_t)channel;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Enables/Disables the DMA request for the channel or all channels.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param enable Enable(true) or Disable (false) DMA request.\r\n * @param channel Channel indicator.\r\n */\r\nvoid EDMA_SetDmaRequestCmd(DMA_Type * base, uint8_t channel, bool enable);\r\n\r\n/*!\r\n * @brief Clears the done status for a channel or all channels.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel Channel indicator.\r\n */\r\nstatic inline void EDMA_ClearDoneStatusFlag(DMA_Type * base, uint8_t channel)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n#ifdef FEATURE_DMA_HWV3\r\n    base->TCD[channel].CH_CSR |= DMA_TCD_CH_CSR_DONE_MASK;\r\n#else\r\n    base->CDNE = (uint8_t)channel;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Triggers the eDMA channel.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel Channel indicator.\r\n */\r\nstatic inline void EDMA_TriggerChannelStart(DMA_Type * base, uint8_t channel)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n#ifdef FEATURE_DMA_HWV3\r\n    base->TCD[channel].CSR |= DMA_TCD_CSR_START_MASK;\r\n#else\r\n    base->SSRT = (uint8_t)channel;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Clears the interrupt status for the eDMA channel or all channels.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel Channel indicator.\r\n */\r\nstatic inline void EDMA_ClearIntStatusFlag(DMA_Type * base, uint8_t channel)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n#ifdef FEATURE_DMA_HWV3\r\n    base->TCD[channel].CH_INT |= DMA_TCD_CH_INT_INT_MASK;\r\n#else\r\n    base->CINT = (uint8_t)channel;\r\n#endif\r\n}\r\n\r\n/*! @} */\r\n\r\n/*!\r\n * @name eDMA HAL driver TCD configuration functions\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Clears all registers to 0 for the hardware TCD.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n */\r\nvoid EDMA_TCDClearReg(DMA_Type * base, uint8_t channel);\r\n\r\n#ifdef FEATURE_DMA_ENGINE_STALL\r\n/*!\r\n * @brief Configures DMA engine to stall for a number of cycles after each R/W.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel Channel indicator.\r\n * @param cycles Number of cycles the DMA engine is stalled after each R/W.\r\n */\r\nstatic inline void EDMA_TCDSetEngineStall(DMA_Type * base, uint8_t channel, edma_engine_stall_t cycles)\r\n{\r\n#ifdef DEV_ERROR_DETECT\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif    \r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= ~(DMA_TCD_CSR_BWC_MASK);    \r\n    regValTemp |= DMA_TCD_CSR_BWC(cycles);\r\n    base->TCD[channel].CSR = regValTemp;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Configures the source address for the hardware TCD.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param address The pointer to the source memory address.\r\n */\r\nstatic inline void EDMA_TCDSetSrcAddr(DMA_Type * base, uint8_t channel, uint32_t address)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].SADDR = address;\r\n}\r\n\r\n/*!\r\n * @brief Configures the source address signed offset for the hardware TCD.\r\n *\r\n * Sign-extended offset applied to the current source address to form the next-state value as each\r\n * source read is complete.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param offset signed-offset for source address.\r\n */\r\nstatic inline void EDMA_TCDSetSrcOffset(DMA_Type * base, uint8_t channel, int16_t offset)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].SOFF = (uint16_t)offset;\r\n}\r\n\r\n/*!\r\n * @brief Configures the transfer attribute for the eDMA channel.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param srcModulo enumeration type for an allowed source modulo. The value defines a specific address range\r\n * specified as the value after the SADDR + SOFF calculation is performed on the original register\r\n * value. Setting this field provides the ability to implement a circular data. For data queues\r\n * requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD\r\n * field should be set to the appropriate value for the queue, freezing the desired number of upper\r\n * address bits. The value programmed into this field specifies the number of the lower address bits\r\n * allowed to change. For a circular queue application, the SOFF is typically set to the transfer\r\n * size to implement post-increment addressing with SMOD function restricting the addresses to a\r\n * 0-modulo-size range.\r\n * @param destModulo Enum type for an allowed destination modulo.\r\n * @param srcTransferSize Enum type for source transfer size.\r\n * @param destTransferSize Enum type for destination transfer size.\r\n */\r\nvoid EDMA_TCDSetAttribute(\r\n                DMA_Type * base, uint8_t channel,\r\n                edma_modulo_t srcModulo, edma_modulo_t destModulo,\r\n                edma_transfer_size_t srcTransferSize, edma_transfer_size_t destTransferSize);\r\n\r\n/*!\r\n * @brief Sets the source transfer size.\r\n *\r\n * Configures the source data read transfer size (1/2/4/16/32 bytes).\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param size Source transfer size.\r\n */\r\nstatic inline void EDMA_TCDSetSrcTransferSize(DMA_Type * base, uint8_t channel, edma_transfer_size_t size)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].ATTR;\r\n    regValTemp &= (uint16_t)(~(DMA_TCD_ATTR_SSIZE_MASK));\r\n    regValTemp |= (uint16_t)(DMA_TCD_ATTR_SSIZE((uint16_t)size));\r\n    base->TCD[channel].ATTR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Sets the destination transfer size.\r\n *\r\n * Configures the destination data write transfer size (1/2/4/16/32 bytes).\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param size Destination transfer size.\r\n */\r\nstatic inline void EDMA_TCDSetDestTransferSize(DMA_Type * base, uint8_t channel, edma_transfer_size_t size)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].ATTR;\r\n    regValTemp &= (uint16_t)(~(DMA_TCD_ATTR_DSIZE_MASK));\r\n    regValTemp |= (uint16_t)(DMA_TCD_ATTR_DSIZE((uint16_t)size));\r\n    base->TCD[channel].ATTR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Configures the nbytes for the eDMA channel.\r\n *\r\n * Note here that user need firstly configure the minor loop mapping feature and then call this\r\n * function.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param nbytes Number of bytes to be transferred in each service request of the channel\r\n */\r\nvoid EDMA_TCDSetNbytes(DMA_Type * base, uint8_t channel, uint32_t nbytes);\r\n\r\n/*!\r\n * @brief Enables/disables the source minor loop offset feature for the TCD.\r\n *\r\n * Configures whether the minor loop offset is applied to the source address\r\n * upon minor loop completion.\r\n * NOTE: EMLM bit needs to be enabled prior to calling this function, otherwise\r\n * it has no effect.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param enable Enables (true) or disables (false) source minor loop offset.\r\n */\r\nstatic inline void EDMA_TCDSetSrcMinorLoopOffsetCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t smloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT;\r\n    uint32_t dmloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT;\r\n    if ((smloe != 0UL) || (dmloe != 0UL))\r\n    {\r\n        uint32_t regValTemp;\r\n        regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n        regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_SMLOE_MASK);\r\n        regValTemp |= DMA_TCD_NBYTES_MLOFFYES_SMLOE(enable ? 1UL : 0UL);\r\n        base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n    }\r\n#else\r\n    if (((base->CR >> DMA_CR_EMLM_SHIFT) & 1U) != 0U)\r\n    {\r\n        uint32_t regValTemp;\r\n        regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n        regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_SMLOE_MASK);\r\n        regValTemp |= DMA_TCD_NBYTES_MLOFFYES_SMLOE(enable ? 1UL : 0UL);\r\n        base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n    }\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Enables/disables the destination minor loop offset feature for the TCD.\r\n *\r\n * Configures whether the minor loop offset is applied to the destination address\r\n * upon minor loop completion.\r\n * NOTE: EMLM bit needs to be enabled prior to calling this function, otherwise\r\n * it has no effect.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param enable Enables (true) or disables (false) destination minor loop offset.\r\n */\r\nstatic inline void EDMA_TCDSetDestMinorLoopOffsetCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n#ifdef FEATURE_DMA_HWV3\r\n    uint32_t smloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_SMLOE_SHIFT;\r\n    uint32_t dmloe = (base->TCD[channel].NBYTES.MLOFFNO & DMA_TCD_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD_NBYTES_MLOFFNO_DMLOE_SHIFT;\r\n    if ((smloe != 0UL) || (dmloe != 0UL))\r\n    {\r\n        uint32_t regValTemp;\r\n        regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n        regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_DMLOE_MASK);\r\n        regValTemp |= DMA_TCD_NBYTES_MLOFFYES_DMLOE(enable ? 1UL : 0UL);\r\n        base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n    }\r\n#else\r\n    if (((base->CR >> DMA_CR_EMLM_SHIFT) & 1U) != 0U)\r\n    {\r\n        uint32_t regValTemp;\r\n        regValTemp = base->TCD[channel].NBYTES.MLOFFYES;\r\n        regValTemp &= ~(DMA_TCD_NBYTES_MLOFFYES_DMLOE_MASK);\r\n        regValTemp |= DMA_TCD_NBYTES_MLOFFYES_DMLOE(enable ? 1UL : 0UL);\r\n        base->TCD[channel].NBYTES.MLOFFYES = regValTemp;\r\n    }\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Configures the minor loop offset for the TCD.\r\n *\r\n * Configures the offset value. If neither source nor destination offset is enabled,\r\n * offset is not configured.\r\n * NOTE: EMLM bit needs to be enabled prior to calling this function, otherwise\r\n * it has no effect.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param offset Minor loop offset\r\n */\r\nvoid EDMA_TCDSetMinorLoopOffset(DMA_Type * base, uint8_t channel, int32_t offset);\r\n\r\n/*!\r\n * @brief Configures the last source address adjustment for the TCD.\r\n *\r\n * Adjustment value added to the source address at the completion of the major iteration count. This\r\n * value can be applied to restore the source address to the initial value, or adjust the address to\r\n * reference the next data structure.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param size adjustment value\r\n */\r\nstatic inline void EDMA_TCDSetSrcLastAdjust(DMA_Type * base, uint8_t channel, int32_t size)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].SLAST = (uint32_t)size;\r\n}\r\n\r\n/*!\r\n * @brief Configures the destination address for the TCD.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param address The pointer to the destination address.\r\n */\r\nstatic inline void EDMA_TCDSetDestAddr(DMA_Type * base, uint8_t channel, uint32_t address)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].DADDR = address;\r\n}\r\n\r\n/*!\r\n * @brief Configures the destination address signed offset for the TCD.\r\n *\r\n * Sign-extended offset applied to the current source address to form the next-state value as each\r\n * destination write is complete.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param offset signed-offset\r\n */\r\nstatic inline void EDMA_TCDSetDestOffset(DMA_Type * base, uint8_t channel, int16_t offset)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].DOFF = (uint16_t)offset;\r\n}\r\n\r\n/*!\r\n * @brief Configures the last source address adjustment.\r\n *\r\n * This function adds an adjustment value added to the source address at the completion of the major\r\n * iteration count. This value can be applied to restore the source address to the initial value, or\r\n * adjust the address to reference the next data structure.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param adjust adjustment value\r\n */\r\nstatic inline void EDMA_TCDSetDestLastAdjust(DMA_Type * base, uint8_t channel, int32_t adjust)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    base->TCD[channel].DLASTSGA = (uint32_t)adjust;\r\n}\r\n\r\n/*!\r\n * @brief Configures the memory address for the next transfer TCD for the TCD.\r\n *\r\n *\r\n * This function enables the scatter/gather feature for the TCD and configures the next\r\n * TCD's address. This address points to the beginning of a 0-modulo-32 byte region containing\r\n * the next transfer TCD to be loaded into this channel. The channel reload is performed as the\r\n * major iteration count completes. The scatter/gather address must be 0-modulo-32-byte. Otherwise,\r\n * a configuration error is reported.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param nextTCDAddr The address of the next TCD to be linked to this TCD.\r\n */\r\nvoid EDMA_TCDSetScatterGatherLink(DMA_Type * base, uint8_t channel, uint32_t nextTCDAddr);\r\n\r\n/*!\r\n * @brief Enables/Disables the scatter/gather feature for the TCD.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param enable Enables (true) /Disables (false) scatter/gather feature.\r\n */\r\nstatic inline void EDMA_TCDSetScatterGatherCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CSR_ESG_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CSR_ESG(enable ? 1UL : 0UL);\r\n    base->TCD[channel].CSR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Configures the major channel link the TCD.\r\n *\r\n * If the major link is enabled, after the major loop counter is exhausted, the eDMA engine initiates a\r\n * channel service request at the channel defined by these six bits by setting that channel start\r\n * bits.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param majorLinkChannel channel number for major link\r\n * @param enable Enables (true) or Disables (false) channel major link.\r\n */\r\nstatic inline void EDMA_TCDSetChannelMajorLink(DMA_Type * base, uint8_t channel, uint32_t majorLinkChannel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CSR_MAJORLINKCH_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CSR_MAJORLINKCH(majorLinkChannel);\r\n    base->TCD[channel].CSR = regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CSR_MAJORELINK_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CSR_MAJORELINK(enable ? 1UL : 0UL);\r\n    base->TCD[channel].CSR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Disables/Enables the DMA request after the major loop completes for the TCD.\r\n *\r\n * If disabled, the eDMA hardware automatically clears the corresponding DMA request when the\r\n * current major iteration count reaches zero.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param disable Disable (true)/Enable (false) DMA request after TCD complete.\r\n */\r\nstatic inline void EDMA_TCDSetDisableDmaRequestAfterTCDDoneCmd(DMA_Type * base, uint8_t channel, bool disable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CSR_DREQ_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CSR_DREQ(disable ? 1UL : 0UL);\r\n    base->TCD[channel].CSR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Enables/Disables the half complete interrupt for the TCD.\r\n *\r\n * If set, the channel generates an interrupt request by setting the appropriate bit in the\r\n * interrupt register when the current major iteration count reaches the halfway point. Specifically,\r\n * the comparison performed by the eDMA engine is (CITER == (BITER >> 1)). This half-way point\r\n * interrupt request is provided to support the double-buffered schemes or other types of data movement\r\n * where the processor needs an early indication of the transfer's process.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param enable Enable (true) /Disable (false) half complete interrupt.\r\n */\r\nstatic inline void EDMA_TCDSetMajorHalfCompleteIntCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CSR_INTHALF_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CSR_INTHALF(enable ? 1UL : 0UL);\r\n    base->TCD[channel].CSR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Enables/Disables the interrupt after the major loop completes for the TCD.\r\n *\r\n * If enabled, the channel generates an interrupt request by setting the appropriate bit in the\r\n * interrupt register when the current major iteration count reaches zero.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param enable Enable (true) /Disable (false) interrupt after TCD done.\r\n */\r\nstatic inline void EDMA_TCDSetMajorCompleteIntCmd(DMA_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMA_CHANNELS);\r\n#endif\r\n    uint16_t regValTemp;\r\n    regValTemp = base->TCD[channel].CSR;\r\n    regValTemp &= (uint16_t)~(DMA_TCD_CSR_INTMAJOR_MASK);\r\n    regValTemp |= (uint16_t)DMA_TCD_CSR_INTMAJOR(enable ? 1UL : 0UL);\r\n    base->TCD[channel].CSR = regValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Sets the channel minor link for the TCD.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param linkChannel Channel to be linked on minor loop complete.\r\n * @param enable Enable (true)/Disable (false) channel minor link.\r\n */\r\nvoid EDMA_TCDSetChannelMinorLink(DMA_Type * base, uint8_t channel, uint32_t linkChannel, bool enable);\r\n\r\n/*!\r\n * @brief Sets the major iteration count according to minor loop channel link setting.\r\n *\r\n * Note here that user need to first set the minor loop channel link and then call this function.\r\n * The execute flow inside this function is dependent on the minor loop channel link setting.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @param count major loop count\r\n */\r\nvoid EDMA_TCDSetMajorCount(DMA_Type * base, uint8_t channel, uint32_t count);\r\n\r\n/*!\r\n * @brief Returns the current major iteration count.\r\n *\r\n * Gets the current major iteration count according to minor loop channel link settings.\r\n *\r\n * @param base Register base address for eDMA module.\r\n * @param channel eDMA channel number.\r\n * @return current iteration count\r\n */\r\nuint32_t EDMA_TCDGetCurrentMajorCount(const DMA_Type * base, uint8_t channel);\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n/*!\r\n * @brief Initializes the DMAMUX module to the reset state.\r\n *\r\n * Initializes the DMAMUX module to the reset state.\r\n *\r\n * @param base Register base address for DMAMUX module.\r\n */\r\nvoid DMAMUX_Init(DMAMUX_Type * base);\r\n#endif\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n/*!\r\n * @brief Enables/Disables the DMAMUX channel.\r\n *\r\n * Enables the hardware request. If enabled, the hardware request is  sent to\r\n * the corresponding DMA channel.\r\n *\r\n * @param base Register base address for DMAMUX module.\r\n * @param channel DMAMUX channel number.\r\n * @param enable Enables (true) or Disables (false) DMAMUX channel.\r\n */\r\nstatic inline void DMAMUX_SetChannelCmd(DMAMUX_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMAMUX_CHANNELS);\r\n#endif\r\n    uint32_t regIndex = FEATURE_DMAMUX_CHN_REG_INDEX(channel);\r\n    uint8_t regValTemp = base->CHCFG[regIndex];\r\n    regValTemp &= (uint8_t)~(DMAMUX_CHCFG_ENBL_MASK);\r\n    regValTemp |= (uint8_t)DMAMUX_CHCFG_ENBL(enable ? 1U : 0U);\r\n    base->CHCFG[regIndex] = regValTemp;\r\n}\r\n#endif\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n#ifdef FEATURE_DMAMUX_HAS_TRIG\r\n/*!\r\n * @brief Configure DMA Channel Trigger bit in DMAMUX.\r\n *\r\n * Enables/Disables DMA Channel Trigger bit in DMAMUX.\r\n *\r\n * @param base Register base address for DMAMUX module.\r\n * @param channel DMAMUX channel number.\r\n * @param enable/disable command.\r\n */\r\nstatic inline void DMAMUX_SetChannelTrigger(DMAMUX_Type * base, uint8_t channel, bool enable)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMAMUX_CHANNELS);\r\n#endif\r\n    uint32_t regIndex = FEATURE_DMAMUX_CHN_REG_INDEX(channel);\r\n    uint8_t regValTemp;\r\n    regValTemp = base->CHCFG[regIndex];\r\n    regValTemp &= (uint8_t)~(DMAMUX_CHCFG_TRIG_MASK);\r\n    regValTemp |= (uint8_t)DMAMUX_CHCFG_TRIG(enable ? 1U : 0U);\r\n    base->CHCFG[regIndex] = regValTemp;\r\n}\r\n#endif\r\n#endif\r\n\r\n#ifdef FEATURE_DMAMUX_AVAILABLE\r\n/*!\r\n * @brief Configures the DMA request for the DMAMUX channel.\r\n *\r\n * Selects which DMA source is routed to a DMA channel. The DMA sources are defined in the file\r\n * <MCU>_Features.h\r\n *\r\n * @param base Register base address for DMAMUX module.\r\n * @param channel DMAMUX channel number.\r\n * @param source DMA request source.\r\n */\r\nstatic inline void DMAMUX_SetChannelSource(DMAMUX_Type * base, uint8_t channel, uint8_t source)\r\n{\r\n#if defined (CUSTOM_DEVASSERT) || defined (DEV_ERROR_DETECT)\r\n    DEV_ASSERT(channel < FEATURE_DMAMUX_CHANNELS);\r\n#endif\r\n    uint32_t regIndex = FEATURE_DMAMUX_CHN_REG_INDEX(channel);\r\n    uint8_t regValTemp;\r\n    regValTemp = base->CHCFG[regIndex];\r\n    regValTemp &= (uint8_t)~(DMAMUX_CHCFG_SOURCE_MASK);\r\n    regValTemp |= (uint8_t)DMAMUX_CHCFG_SOURCE(source);\r\n    base->CHCFG[regIndex] = regValTemp;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Returns DMA Register Base Address.\r\n *\r\n * Gets the address of the selected DMA module.\r\n *\r\n * @param instance DMA instance to be returned.\r\n * @return DMA register base address\r\n */\r\nDMA_Type * EDMA_DRV_GetDmaRegBaseAddr(uint32_t instance);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n#endif /* EDMA_HW_ACCESS_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n\r\n\r\n"},{"name":"edma_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file edma_irq.c\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, external symbol defined without a prior\r\n * declaration.\r\n * These are symbols weak symbols defined in platform startup files (.s).\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, external could be made static.\r\n * The functions are called by the interrupt controller when the appropriate event\r\n * occurs.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * This is required for initializing pointers to the module's memory map, which \r\n * is located at a fixed address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n */\r\n\r\n#include \"edma_irq.h\"\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n \r\n/*******************************************************************************\r\n * Prototypes\r\n ******************************************************************************/   \r\n#ifdef FEATURE_DMA_ORED_IRQ_LINES_16_CHN\r\n#ifdef FEATURE_DMA_HWV3\r\nvoid DMA0_Ch0_Ch15_IRQHandler(void);\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 16U)\r\nvoid DMA0_Ch16_Ch31_IRQHandler(void);\r\n#endif\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 32U)\r\nvoid DMA1_Ch0_Ch15_IRQHandler(void);\r\n#endif\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 48U)\r\nvoid DMA1_Ch16_Ch31_IRQHandler(void);\r\n#endif\r\n#else\r\nvoid DMA0_15_IRQHandler(void);\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 16U)\r\nvoid DMA16_31_IRQHandler(void);\r\n#endif\r\n#endif\r\n#endif\r\n \r\n#ifdef FEATURE_DMA_SEPARATE_IRQ_LINES_PER_CHN\r\nvoid DMA0_IRQHandler(void);\r\nvoid DMA1_IRQHandler(void);\r\nvoid DMA2_IRQHandler(void);\r\nvoid DMA3_IRQHandler(void);\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 4U)\r\nvoid DMA4_IRQHandler(void);\r\nvoid DMA5_IRQHandler(void);\r\nvoid DMA6_IRQHandler(void);\r\nvoid DMA7_IRQHandler(void);\r\n#endif\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 8U)\r\nvoid DMA8_IRQHandler(void);\r\nvoid DMA9_IRQHandler(void);\r\nvoid DMA10_IRQHandler(void);\r\nvoid DMA11_IRQHandler(void);\r\nvoid DMA12_IRQHandler(void);\r\nvoid DMA13_IRQHandler(void);\r\nvoid DMA14_IRQHandler(void);\r\nvoid DMA15_IRQHandler(void);\r\n#endif\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 16U)\r\nvoid DMA16_IRQHandler(void);\r\nvoid DMA17_IRQHandler(void);\r\nvoid DMA18_IRQHandler(void);\r\nvoid DMA19_IRQHandler(void);\r\nvoid DMA20_IRQHandler(void);\r\nvoid DMA21_IRQHandler(void);\r\nvoid DMA22_IRQHandler(void);\r\nvoid DMA23_IRQHandler(void);\r\nvoid DMA24_IRQHandler(void);\r\nvoid DMA25_IRQHandler(void);\r\nvoid DMA26_IRQHandler(void);\r\nvoid DMA27_IRQHandler(void);\r\nvoid DMA28_IRQHandler(void);\r\nvoid DMA29_IRQHandler(void);\r\nvoid DMA30_IRQHandler(void);\r\nvoid DMA31_IRQHandler(void);\r\n#endif\r\n#endif\r\n\r\n#ifdef FEATURE_DMA_HAS_ERROR_IRQ\r\n#ifdef FEATURE_DMA_HWV3\r\n#if (DMA_INSTANCE_COUNT <= 1U)\r\nvoid DMA_Error_IRQHandler(void);\r\n#else\r\nvoid DMA0_Error_IRQHandler(void);\r\nvoid DMA1_Error_IRQHandler(void);\r\n#endif\r\n#else\r\nvoid DMA_Error_IRQHandler(void);\r\n#endif\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n#ifdef FEATURE_DMA_ORED_IRQ_LINES_16_CHN\r\n#ifdef FEATURE_DMA_HWV3\r\n/*! @brief DMA0_Ch0_Ch15_IRQHandler with the same name in the startup code*/\r\nvoid DMA0_Ch0_Ch15_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = 0U;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = 0U; virtualChannel <= 15U; virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_INT & DMA_TCD_CH_INT_INT_MASK) == DMA_TCD_CH_INT_INT_MASK)\r\n        {\r\n            EDMA_DRV_IRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 16U)\r\n/*! @brief DMA0_Ch16_Ch31_IRQHandler with the same name in the startup code*/\r\nvoid DMA0_Ch16_Ch31_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = 16U;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = 16U; virtualChannel <= 31U; virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_INT & DMA_TCD_CH_INT_INT_MASK) == DMA_TCD_CH_INT_INT_MASK)\r\n        {\r\n            EDMA_DRV_IRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 16U) */\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 32U)\r\n/*! @brief DMA1_Ch0_Ch15_IRQHandler with the same name in the startup code*/\r\nvoid DMA1_Ch0_Ch15_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = 32U;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(1U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = 32U; virtualChannel <= 47U; virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_INT & DMA_TCD_CH_INT_INT_MASK) == DMA_TCD_CH_INT_INT_MASK)\r\n        {\r\n            EDMA_DRV_IRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 32U) */\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 48U)\r\n/*! @brief DMA1_Ch16_Ch31_IRQHandler with the same name in the startup code*/\r\nvoid DMA1_Ch16_Ch31_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = 48U;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(1U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = 48U; virtualChannel <= 63U; virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_INT & DMA_TCD_CH_INT_INT_MASK) == DMA_TCD_CH_INT_INT_MASK)\r\n        {\r\n            EDMA_DRV_IRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 48U) */\r\n#else /* FEATURE_DMA_HWV3 */\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA0_15_IRQHandler(void)\r\n{\r\n    /* Read the status flags register */\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    uint32_t mask = 0xFFFF;\r\n    uint32_t flags = edmaRegBase->INT;\r\n    uint8_t virtualChannel = 0U;\r\n    flags &= mask;\r\n    /* Check all the flags from 0 to 15 and call the handler for the appropriate channel */\r\n    while (flags > 0U)\r\n    {\r\n       if ((flags & 1U) > 0U)\r\n       {\r\n           EDMA_DRV_IRQHandler(virtualChannel);\r\n       }\r\n       virtualChannel++;\r\n       flags >>= 1U;\r\n    }\r\n}\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 16U)\r\n/*! @brief DMA16_31_IRQn IRQ handler with the same name in the startup code*/\r\nvoid DMA16_31_IRQHandler(void)\r\n{\r\n    /* Read the status flags register */\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    uint32_t flags = edmaRegBase->INT;\r\n    uint8_t virtualChannel = 16U;\r\n    flags >>= 16U;\r\n    /* Check all the flags from 16 to 31 and call the handler for the appropriate channel */\r\n    while (flags > 0U)\r\n    {\r\n       if ((flags & 1U) > 0U)\r\n       {\r\n           EDMA_DRV_IRQHandler(virtualChannel);\r\n       }\r\n       virtualChannel++;\r\n       flags >>= 1U;\r\n    }\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 16U) */\r\n#endif /* FEATURE_DMA_HWV3 */\r\n#endif /* FEATURE_DMA_ORED_IRQ_LINES_16_CHN */\r\n\r\n#ifdef FEATURE_DMA_SEPARATE_IRQ_LINES_PER_CHN\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA0_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(0U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA1_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(1U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA2_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(2U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA3_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(3U);\r\n}\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 4U)\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA4_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(4U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA5_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(5U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA6_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(6U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA7_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(7U);\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 4U) */\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 8U)\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA8_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(8U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA9_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(9U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA10_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(10U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA11_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(11U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA12_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(12U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA13_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(13U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA14_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(14U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA15_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(15U);\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 8U) */\r\n#if (FEATURE_DMA_VIRTUAL_CHANNELS > 16U)\r\nvoid DMA16_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(16U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA17_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(17U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA18_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(18U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA19_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(19U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA20_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(20U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA21_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(21U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA22_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(22U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA23_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(23U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA24_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(24U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA25_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(25U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA26_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(26U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA27_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(27U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA28_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(28U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA29_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(29U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA30_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(30U);\r\n}\r\n\r\n/*! @brief DMA IRQ handler with the same name in the startup code*/\r\nvoid DMA31_IRQHandler(void)\r\n{\r\n    EDMA_DRV_IRQHandler(31U);\r\n}\r\n#endif /* (FEATURE_DMA_VIRTUAL_CHANNELS > 16U) */\r\n#endif /* FEATURE_DMA_SEPARATE_IRQ_LINES_PER_CHN */\r\n\r\n#ifdef FEATURE_DMA_HAS_ERROR_IRQ\r\n#ifdef FEATURE_DMA_HWV3\r\n#if (DMA_INSTANCE_COUNT <= 1U)\r\n/*! @brief DMA ERROR IRQ handler with the same name in the startup code*/\r\nvoid DMA_Error_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = 0U;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = 0U; virtualChannel < FEATURE_DMA_CHANNELS; virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_ES & DMA_TCD_CH_ES_ERR_MASK) == DMA_TCD_CH_ES_ERR_MASK)\r\n        {\r\n            EDMA_DRV_ErrorIRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n#else /* (DMA_INSTANCE_COUNT <= 1U) */\r\n/*! @brief DMA ERROR IRQ handler with the same name in the startup code*/\r\nvoid DMA0_Error_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = 0U;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = 0U; virtualChannel < FEATURE_DMA_CHANNELS; virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_ES & DMA_TCD_CH_ES_ERR_MASK) == DMA_TCD_CH_ES_ERR_MASK)\r\n        {\r\n            EDMA_DRV_ErrorIRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n\r\n/*! @brief DMA ERROR IRQ handler with the same name in the startup code*/\r\nvoid DMA1_Error_IRQHandler(void)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t virtualChannel = FEATURE_DMA_CHANNELS;\r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(1U);\r\n    /* Check all the flags and call the handler for the appropriate channel */\r\n    for(virtualChannel = FEATURE_DMA_CHANNELS; virtualChannel < (2U * FEATURE_DMA_CHANNELS); virtualChannel++)\r\n    {\r\n        if ((edmaRegBase->TCD[index].CH_ES & DMA_TCD_CH_ES_ERR_MASK) == DMA_TCD_CH_ES_ERR_MASK)\r\n        {\r\n            EDMA_DRV_ErrorIRQHandler(virtualChannel);\r\n        }\r\n        index++;\r\n    }\r\n}\r\n#endif /* (DMA_INSTANCE_COUNT <= 1U) */\r\n#else /* FEATURE_DMA_HWV3 */\r\n/*! @brief DMA ERROR IRQ handler with the same name in the startup code*/\r\nvoid DMA_Error_IRQHandler(void)\r\n{    \r\n    const DMA_Type * edmaRegBase = EDMA_DRV_GetDmaRegBaseAddr(0U);\r\n    uint32_t error = EDMA_GetErrorIntStatusFlag(edmaRegBase);\r\n    uint8_t virtualChannel = 0U;\r\n\r\n    for (virtualChannel = 0U;\r\n         virtualChannel < FEATURE_DMA_VIRTUAL_CHANNELS;\r\n         virtualChannel++)\r\n    {\r\n        if((error & EDMA_ERR_LSB_MASK) != 0UL)\r\n        {\r\n            EDMA_DRV_ErrorIRQHandler(virtualChannel);\r\n        }\r\n        error = error >> 1U;\r\n    }\r\n}\r\n#endif /* FEATURE_DMA_HWV3 */\r\n#endif /* FEATURE_DMA_HAS_ERROR_IRQ */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"edma_irq.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file edma_irq.h\r\n */\r\n\r\n#include \"edma_hw_access.h\"\r\n\r\n/*! @brief DMA channel interrupt handler, implemented in driver c file. */\r\nvoid EDMA_DRV_IRQHandler(uint8_t virtualChannel);\r\n#ifdef FEATURE_DMA_HAS_ERROR_IRQ\r\n/*! @brief DMA error interrupt handler, implemented in driver c file. */\r\nvoid EDMA_DRV_ErrorIRQHandler(uint8_t virtualChannel);\r\n#endif\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"fcan0_s32k_rx_isr.c","type":"source","group":"","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: fcan0_s32k_rx_isr.c\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flexcan_driver.h\"\r\n#include \"fcan0_s32k_rx_isr.h\"\r\n#include \"Final_project_template.h\"\r\n#include \"Final_project_template_private.h\"\r\n\r\nvoid fcan0_s32k_rx_isr(uint8_t instance, flexcan_event_type_t eventType,\r\n  uint32_t buffIdx, flexcan_state_t *flexcanState)\r\n{\r\n  if (eventType == FLEXCAN_EVENT_RX_COMPLETE) {\r\n    uint8_t i;\r\n    flexcan_msgbuff_t* mb_message = flexcanState->mbs[buffIdx].mb_message;\r\n    rtB.FCAN_Isr_o2 = buffIdx;\r\n    rtB.FCAN_Isr_o3 = mb_message->msgId;\r\n    rtB.FCAN_Isr_o5 = mb_message->dataLen;\r\n    for (i = 0; i < mb_message->dataLen; i++) {\r\n      (&rtB.FCAN_Isr_o4[0])[i] = mb_message->data[i];\r\n    }\r\n\r\n    rtB.FCAN_Isr_o6 = (mb_message->cs & CAN_CS_TIME_STAMP_MASK) >>\r\n      CAN_CS_TIME_STAMP_SHIFT;\r\n\r\n    /* Output and update for function-call system: '<S1>/Extract CAN data' */\r\n\r\n    /* If: '<S7>/If' incorporates:\r\n     *  Constant: '<S1>/Array of 6 base IDs'\r\n     *  Sum: '<S7>/Subtract'\r\n     */\r\n    if ((real_T)rtB.FCAN_Isr_o3 - 10.0 == 5.0) {\r\n      /* Outputs for IfAction SubSystem: '<S7>/Switch Case Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S13>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem2(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_m,\r\n        &rtB.ByteUnpacking_o2_k);\r\n\r\n      /* End of Outputs for SubSystem: '<S7>/Switch Case Action Subsystem2' */\r\n    } else if ((real_T)rtB.FCAN_Isr_o3 - 10.0 == 6.0) {\r\n      /* Outputs for IfAction SubSystem: '<S7>/Switch Case Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S14>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem3(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_b,\r\n        &rtB.ByteUnpacking_o2_nz);\r\n\r\n      /* End of Outputs for SubSystem: '<S7>/Switch Case Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S7>/If' */\r\n\r\n    /* If: '<S8>/If' incorporates:\r\n     *  Constant: '<S1>/Array of 6 base IDs'\r\n     *  Sum: '<S8>/Subtract'\r\n     */\r\n    if ((real_T)rtB.FCAN_Isr_o3 - 20.0 == 5.0) {\r\n      /* Outputs for IfAction SubSystem: '<S8>/Switch Case Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S15>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem2(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_o3,\r\n        &rtB.ByteUnpacking_o2_h);\r\n\r\n      /* End of Outputs for SubSystem: '<S8>/Switch Case Action Subsystem2' */\r\n    } else if ((real_T)rtB.FCAN_Isr_o3 - 20.0 == 6.0) {\r\n      /* Outputs for IfAction SubSystem: '<S8>/Switch Case Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S16>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem3(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_az,\r\n        &rtB.ByteUnpacking_o2_b);\r\n\r\n      /* End of Outputs for SubSystem: '<S8>/Switch Case Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S8>/If' */\r\n\r\n    /* If: '<S9>/If' incorporates:\r\n     *  Constant: '<S1>/Array of 6 base IDs'\r\n     *  Sum: '<S9>/Subtract'\r\n     */\r\n    if ((real_T)rtB.FCAN_Isr_o3 - 30.0 == 5.0) {\r\n      /* Outputs for IfAction SubSystem: '<S9>/Switch Case Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S17>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem2(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_i,\r\n        &rtB.ByteUnpacking_o2_i);\r\n\r\n      /* End of Outputs for SubSystem: '<S9>/Switch Case Action Subsystem2' */\r\n    } else if ((real_T)rtB.FCAN_Isr_o3 - 30.0 == 6.0) {\r\n      /* Outputs for IfAction SubSystem: '<S9>/Switch Case Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S18>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem3(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_a,\r\n        &rtB.ByteUnpacking_o2_j1);\r\n\r\n      /* End of Outputs for SubSystem: '<S9>/Switch Case Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S9>/If' */\r\n\r\n    /* If: '<S10>/If' incorporates:\r\n     *  Constant: '<S1>/Array of 6 base IDs'\r\n     *  Sum: '<S10>/Subtract'\r\n     */\r\n    if ((real_T)rtB.FCAN_Isr_o3 - 40.0 == 5.0) {\r\n      /* Outputs for IfAction SubSystem: '<S10>/Switch Case Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S19>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem2(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_o0,\r\n        &rtB.ByteUnpacking_o2_p);\r\n\r\n      /* End of Outputs for SubSystem: '<S10>/Switch Case Action Subsystem2' */\r\n    } else if ((real_T)rtB.FCAN_Isr_o3 - 40.0 == 6.0) {\r\n      /* Outputs for IfAction SubSystem: '<S10>/Switch Case Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S20>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem3(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_c,\r\n        &rtB.ByteUnpacking_o2_c);\r\n\r\n      /* End of Outputs for SubSystem: '<S10>/Switch Case Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S10>/If' */\r\n\r\n    /* If: '<S11>/If' incorporates:\r\n     *  Constant: '<S1>/Array of 6 base IDs'\r\n     *  Sum: '<S11>/Subtract'\r\n     */\r\n    if ((real_T)rtB.FCAN_Isr_o3 - 50.0 == 5.0) {\r\n      /* Outputs for IfAction SubSystem: '<S11>/Switch Case Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S21>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem2(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_o,\r\n        &rtB.ByteUnpacking_o2_j);\r\n\r\n      /* End of Outputs for SubSystem: '<S11>/Switch Case Action Subsystem2' */\r\n    } else if ((real_T)rtB.FCAN_Isr_o3 - 50.0 == 6.0) {\r\n      /* Outputs for IfAction SubSystem: '<S11>/Switch Case Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S22>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem3(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_f4,\r\n        &rtB.ByteUnpacking_o2_m);\r\n\r\n      /* End of Outputs for SubSystem: '<S11>/Switch Case Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S11>/If' */\r\n\r\n    /* If: '<S12>/If' incorporates:\r\n     *  Constant: '<S1>/Array of 6 base IDs'\r\n     *  Sum: '<S12>/Subtract'\r\n     */\r\n    if ((real_T)rtB.FCAN_Isr_o3 - 70.0 == 5.0) {\r\n      /* Outputs for IfAction SubSystem: '<S12>/Switch Case Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S23>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem2(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1_f,\r\n        &rtB.ByteUnpacking_o2_n);\r\n\r\n      /* End of Outputs for SubSystem: '<S12>/Switch Case Action Subsystem2' */\r\n    } else if ((real_T)rtB.FCAN_Isr_o3 - 70.0 == 6.0) {\r\n      /* Outputs for IfAction SubSystem: '<S12>/Switch Case Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S24>/Action Port'\r\n       */\r\n      SwitchCaseActionSubsystem3(rtB.FCAN_Isr_o4, &rtB.ByteUnpacking_o1,\r\n        &rtB.ByteUnpacking_o2);\r\n\r\n      /* End of Outputs for SubSystem: '<S12>/Switch Case Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S12>/If' */\r\n    return;\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"fcan0_s32k_rx_isr.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef fcan0_s32k_rx_isr_h\r\n#define fcan0_s32k_rx_isr_h\r\n\r\nextern flexcan_msgbuff_t canCom0_recvBuffFifo;\r\nextern void fcan0_s32k_rx_isr(uint8_t instance, flexcan_event_type_t eventType,\r\n  uint32_t buffIdx, flexcan_state_t *flexcanState);\r\n\r\n#endif\r\n"},{"name":"flexcan_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file flexcan_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 15.5, Return statement before end of function.\r\n * The return statement before end of function is used for simpler code structure\r\n * and better readability.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, Taking address of near auto variable\r\n * The code is not dynamically linked. An absolute stack address is obtained when\r\n * taking the address of the near auto variable. A source of error in writing\r\n * dynamic code is that the stack segment may be different from the data segment.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, cast from unsigned char to pointer\r\n * The cast is needed for a function which has a generic parameter of type void*.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, conversion between a pointer and integer\r\n * type.\r\n * The cast is needed to obtain an address for a DMA call.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, cast from pointer to unsigned long\r\n * The cast is needed to obtain an address for a DMA call.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 2.2, Highest operation, function\r\n * 'FLEXCAN_UnlockRxMsgBuff', lacks side-effects.\r\n * The function is used to unlock the mailbox, which is done by reading the\r\n * free running timer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.3, cast performed between a pointer to\r\n * object type and a pointer to a different object type\r\n * The cast is used for casting a bytes buffer into an words buffer in order to\r\n * optimize copying data to/from the message buffer.\r\n */\r\n\r\n#include \"flexcan_hw_access.h\"\r\n#include \"flexcan_irq.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"clock_manager.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n#define FLEXCAN_MB_HANDLE_RXFIFO    0U\r\n\r\n/* CAN bit timing values */\r\n#define FLEXCAN_NUM_TQ_MIN     8U\r\n#define FLEXCAN_NUM_TQ_MAX    26U\r\n#define FLEXCAN_PRESDIV_MAX  256U\r\n#define FLEXCAN_PSEG1_MAX      8U\r\n#define FLEXCAN_PSEG2_MIN      1U\r\n#define FLEXCAN_PSEG2_MAX      8U\r\n#define FLEXCAN_PROPSEG_MAX    8U\r\n#define FLEXCAN_TSEG1_MIN      2U\r\n#define FLEXCAN_TSEG1_MAX     17U\r\n#define FLEXCAN_TSEG2_MIN      2U\r\n#define FLEXCAN_TSEG2_MAX      9U\r\n#define FLEXCAN_RJW_MAX        3U\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/* Table of base addresses for CAN instances. */\r\nstatic CAN_Type * const g_flexcanBase[] = CAN_BASE_PTRS;\r\n\r\n/* Tables to save CAN IRQ enum numbers defined in CMSIS header file. */\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\nstatic const IRQn_Type g_flexcanWakeUpIrqId[] = CAN_Wake_Up_IRQS;\r\n#endif\r\nstatic const IRQn_Type g_flexcanErrorIrqId[] = CAN_Error_IRQS;\r\nstatic const IRQn_Type g_flexcanBusOffIrqId[] = CAN_Bus_Off_IRQS;\r\nstatic const IRQn_Type g_flexcanOredMessageBufferIrqId[FEATURE_CAN_MB_IRQS_MAX_COUNT][CAN_INSTANCE_COUNT] \r\n                        = FEATURE_CAN_MB_IRQS;\r\n\r\n/* Pointer to runtime state structure.*/\r\nstatic flexcan_state_t * g_flexcanStatePtr[CAN_INSTANCE_COUNT] = { NULL };\r\n\r\n/*******************************************************************************\r\n * Private Functions\r\n ******************************************************************************/\r\nstatic status_t FLEXCAN_StartSendData(\r\n                    uint8_t instance,\r\n                    uint8_t mb_idx,\r\n                    const flexcan_data_info_t *tx_info,\r\n                    uint32_t msg_id,\r\n                    const uint8_t *mb_data,\r\n                    bool isBlocking\r\n                    );\r\nstatic status_t FLEXCAN_StartRxMessageBufferData(\r\n                    uint8_t instance,\r\n                    uint8_t mb_idx,\r\n                    flexcan_msgbuff_t *data,\r\n                    bool isBlocking\r\n                    );\r\nstatic status_t FLEXCAN_StartRxMessageFifoData(\r\n                    uint8_t instance,\r\n                    flexcan_msgbuff_t *data,\r\n                    bool isBlocking\r\n                    );\r\nstatic void FLEXCAN_CompleteTransfer(uint8_t instance, uint32_t mb_idx);\r\nstatic void FLEXCAN_CompleteRxMessageFifoData(uint8_t instance);\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\nstatic void FLEXCAN_CompleteRxFifoDataDMA(void *parameter,\r\n                                          edma_chn_status_t status);\r\n#endif\r\nstatic uint32_t FLEXCAN_BitrateToTimeSeg(uint32_t bitrate,\r\n                                         uint32_t clkFreq,\r\n\t\t\t\t\t\t\t\t\t\t flexcan_time_segment_t *timeSeg);\r\nstatic inline void FLEXCAN_IRQHandlerRxFIFO(uint8_t instance, uint32_t mb_idx);\r\nstatic void FLEXCAN_IRQHandlerRxMB(uint8_t instance, uint32_t mb_idx);\r\nstatic inline void FLEXCAN_EnableIRQs(uint8_t instance);\r\n#ifdef ERRATA_E10368\r\n#if FEATURE_CAN_HAS_FD\r\nstatic inline void FLEXCAN_Errata10368(uint8_t instance,\r\n                                       const flexcan_user_config_t *data);\r\n#endif /* FEATURE_CAN_HAS_FD */\r\n#endif /* ERRATA_E10368 */\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetBitrate\r\n * Description   : Set FlexCAN baudrate.\r\n * This function will set up all the time segment values for classical frames or the\r\n * extended time segments for the arbitration phase of FD frames. Those time segment\r\n * values are passed in by the user and are based on the required baudrate.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetBitrate_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetBitrate(uint8_t instance, const flexcan_time_segment_t *bitrate)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(bitrate != NULL);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n#if FEATURE_CAN_HAS_FD\r\n    bool fdEnabled = FLEXCAN_IsFDEnabled(base);\r\n#endif\r\n    bool freeze = FLEXCAN_GetFreezeMode(base);\r\n\r\n    if (freeze == false)\r\n    {\r\n    \tFLEXCAN_EnterFreezeMode(base);\r\n    }\r\n#if FEATURE_CAN_HAS_FD\r\n    if (fdEnabled)\r\n    {\r\n        /* Set extended time segments*/\r\n        FLEXCAN_SetExtendedTimeSegments(base, bitrate);\r\n    }\r\n    else\r\n#endif\r\n    {\r\n        /* Set time segments*/\r\n        FLEXCAN_SetTimeSegments(base, bitrate);\r\n    }\r\n\r\n    if (freeze == false)\r\n    {\r\n    \tFLEXCAN_ExitFreezeMode(base);\r\n    }\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetBitrateCbt\r\n * Description   : Set FlexCAN bitrate.\r\n * This function will set up all the time segment values for the data phase of\r\n * FD frames. Those time segment values are passed in by the user and are based\r\n * on the required baudrate.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetBitrateCbt_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetBitrateCbt(uint8_t instance, const flexcan_time_segment_t *bitrate)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(bitrate != NULL);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    bool freeze = FLEXCAN_GetFreezeMode(base);\r\n\r\n    if (freeze == false)\r\n    {\r\n    \tFLEXCAN_EnterFreezeMode(base);\r\n    }\r\n\r\n    /* Set time segments*/\r\n    FLEXCAN_SetFDTimeSegments(base, bitrate);\r\n    if (freeze == false)\r\n    {\r\n    \tFLEXCAN_ExitFreezeMode(base);\r\n    }\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetBitrate\r\n * Description   : Get FlexCAN baudrate.\r\n * This function will be return the current bit rate settings for classical frames\r\n * or the arbitration phase of FD frames.\r\n *\r\n * Implements    : FLEXCAN_DRV_GetBitrate_Activity\r\n *END**************************************************************************/\r\nvoid  FLEXCAN_DRV_GetBitrate(uint8_t instance, flexcan_time_segment_t *bitrate)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(bitrate != NULL);\r\n\r\n    const CAN_Type * base = g_flexcanBase[instance];\r\n#if FEATURE_CAN_HAS_FD\r\n    if (true == FLEXCAN_IsFDEnabled(base))\r\n    {\r\n    \t/* Get the Extended time segments*/\r\n    \tFLEXCAN_GetExtendedTimeSegments(base, bitrate);\r\n    }\r\n    else\r\n#endif\r\n    {\r\n    \t/* Get the time segments*/\r\n    \tFLEXCAN_GetTimeSegments(base, bitrate);\r\n    }\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetBitrateFD\r\n * Description   : Get FlexCAN baudrate.\r\n * This function will be return the current bit rate settings for the data phase\r\n * of FD frames.\r\n *\r\n * Implements    : FLEXCAN_DRV_GetBitrateFD_Activity\r\n *END**************************************************************************/\r\nvoid  FLEXCAN_DRV_GetBitrateFD(uint8_t instance, flexcan_time_segment_t *bitrate)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(bitrate != NULL);\r\n\r\n    const CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    /* Get the time segments*/\r\n    FLEXCAN_GetFDTimeSegments(base, bitrate);\r\n\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetMasktype\r\n * Description   : Set RX masking type.\r\n * This function will set RX masking type as RX global mask or RX individual\r\n * mask.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetRxMaskType_Activity\r\n *END**************************************************************************/\r\nvoid  FLEXCAN_DRV_SetRxMaskType(uint8_t instance, flexcan_rx_mask_type_t type)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    FLEXCAN_SetRxMaskType(base, type);\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetRxFifoGlobalMask\r\n * Description   : Set Rx FIFO global mask as the 11-bit standard mask or the\r\n * 29-bit extended mask.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetRxFifoGlobalMask_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetRxFifoGlobalMask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    flexcan_rx_fifo_id_element_format_t formatType;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    uint32_t calcMask = 0U;\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    if (true == FLEXCAN_IsRxFifoEnabled(base))\r\n    {\r\n\t\tformatType = FLEXCAN_GetRxFifoIdFormat(base);\r\n\t\tcalcMask = FLEXCAN_GetRxFifoMask(id_type, formatType, mask);\r\n\r\n\t\tswitch (formatType)\r\n\t\t{\r\n\t\t\tcase FLEXCAN_RX_FIFO_ID_FORMAT_A :\r\n\t\t\t\tFLEXCAN_SetRxFifoGlobalMask(base, calcMask);\r\n\t\t\t\tbreak;\r\n\t\t\tcase FLEXCAN_RX_FIFO_ID_FORMAT_B :\r\n\t\t\t\tFLEXCAN_SetRxFifoGlobalMask(base, (calcMask | (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1)));\r\n\t\t\t\tbreak;\r\n\t\t\tcase FLEXCAN_RX_FIFO_ID_FORMAT_C :\r\n\t\t\t\tFLEXCAN_SetRxFifoGlobalMask(base, (calcMask | (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT1) |\r\n\t\t\t\t\t\t\t\t\t\t\t\t  \t  \t  \t  (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT2) |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT3)));\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :\r\n\t\t\t\t/* Will Enable all filter fields mask */\r\n\t\t\t\tFLEXCAN_SetRxFifoGlobalMask(base, 0xFFFFFFFFU);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n    }\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetRxMbGlobalMask\r\n * Description   : Set Rx Message Buffer global mask as the 11-bit standard mask\r\n * or the 29-bit extended mask.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetRxMbGlobalMask_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetRxMbGlobalMask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    if (id_type == FLEXCAN_MSG_ID_STD)\r\n    {\r\n        /* Set standard global mask for RX MB*/\r\n        FLEXCAN_SetRxMsgBuffGlobalStdMask(base, mask);\r\n    }\r\n    else if (id_type == FLEXCAN_MSG_ID_EXT)\r\n    {\r\n        /* Set extended global mask for RX MB*/\r\n        FLEXCAN_SetRxMsgBuffGlobalExtMask(base, mask);\r\n    }\r\n    else {\r\n        /* Should not get here */\r\n    }\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetRxMb14Mask\r\n * Description   : Set Rx Message Buffer 14 mask as the 11-bit standard mask\r\n * or the 29-bit extended mask.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetRxMb14Mask_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetRxMb14Mask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    if (id_type == FLEXCAN_MSG_ID_STD)\r\n    {\r\n        /* Set standard global mask for RX MB*/\r\n        FLEXCAN_SetRxMsgBuff14StdMask(base, mask);\r\n    }\r\n    else if (id_type == FLEXCAN_MSG_ID_EXT)\r\n    {\r\n        /* Set extended global mask for RX MB*/\r\n        FLEXCAN_SetRxMsgBuff14ExtMask(base, mask);\r\n    }\r\n    else {\r\n        /* Should not get here */\r\n    }\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetRxMb15Mask\r\n * Description   : Set Rx Message Buffer 15 mask as the 11-bit standard mask\r\n * or the 29-bit extended mask.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetRxMb15Mask_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetRxMb15Mask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    if (id_type == FLEXCAN_MSG_ID_STD)\r\n    {\r\n        /* Set standard global mask for RX MB*/\r\n        FLEXCAN_SetRxMsgBuff15StdMask(base, mask);\r\n    }\r\n    else if (id_type == FLEXCAN_MSG_ID_EXT)\r\n    {\r\n        /* Set extended global mask for RX MB*/\r\n        FLEXCAN_SetRxMsgBuff15ExtMask(base, mask);\r\n    }\r\n    else {\r\n        /* Should not get here */\r\n    }\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetRxIndividualMask\r\n * Description   : Set Rx individual mask as the 11-bit standard mask or the\r\n * 29-bit extended mask.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetRxIndividualMask_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_SetRxIndividualMask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint8_t mb_idx,\r\n    uint32_t mask)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    \r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    if ((mb_idx > FLEXCAN_GetMaxMsgBuffNum(base)) || (mb_idx >= CAN_RXIMR_COUNT))\r\n    {\r\n        FLEXCAN_ExitFreezeMode(base);\r\n        return STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    if (false == FLEXCAN_IsRxFifoEnabled(base))\r\n    {\r\n\t\tif (id_type == FLEXCAN_MSG_ID_STD)\r\n\t\t{\r\n\t\t\t/* Set standard individual mask*/\r\n\t\t\tFLEXCAN_SetRxIndividualStdMask(base, mb_idx, mask);\r\n\t\t}\r\n\t\telse if (id_type == FLEXCAN_MSG_ID_EXT)\r\n\t\t{\r\n\t\t\t/* Set extended individual mask*/\r\n\t\t\tFLEXCAN_SetRxIndividualExtMask(base, mb_idx, mask);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t/* Should not get here */\r\n\t\t}\r\n    }\r\n    else\r\n    {\r\n\t\tif (mb_idx <= FLEXCAN_GetNoOfIndividualMBsRxFIFO(base))\r\n\t\t{\r\n\t\t\t/* In FIFO Mode get the Id Filter Format already configured by FLEXCAN_DRV_ConfigRxFifo */\r\n\t\t\tflexcan_rx_fifo_id_element_format_t formatType = FLEXCAN_GetRxFifoIdFormat(base);\r\n\t\t\tuint32_t calcMask = FLEXCAN_GetRxFifoMask(id_type, formatType, mask);\r\n\r\n\t\t\tswitch (formatType)\r\n\t\t\t{\r\n\t\t\t\tcase FLEXCAN_RX_FIFO_ID_FORMAT_A :\r\n\t\t\t\t\tFLEXCAN_SetRxIndividualMask(base, mb_idx, calcMask);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase FLEXCAN_RX_FIFO_ID_FORMAT_B :\r\n\t\t\t\t\tFLEXCAN_SetRxIndividualMask(base, mb_idx, (calcMask | (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1)));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase FLEXCAN_RX_FIFO_ID_FORMAT_C :\r\n\t\t\t\t\tFLEXCAN_SetRxIndividualMask(base, mb_idx, (calcMask | (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT1) |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t  \t  (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT2) |\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (calcMask >> FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT3)));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault :\r\n\t\t\t\t\t/* Will Enable all filter fields mask */\r\n\t\t\t\t\tFLEXCAN_SetRxIndividualMask(base, mb_idx, 0xFFFFFFFFU);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n    \telse\r\n    \t{\r\n    \t\tif (id_type == FLEXCAN_MSG_ID_STD)\r\n    \t\t{\r\n    \t\t\t/* Set standard individual mask*/\r\n    \t\t\tFLEXCAN_SetRxIndividualStdMask(base, mb_idx, mask);\r\n    \t\t}\r\n    \t\telse if (id_type == FLEXCAN_MSG_ID_EXT)\r\n    \t\t{\r\n    \t\t\t/* Set extended individual mask*/\r\n    \t\t\tFLEXCAN_SetRxIndividualExtMask(base, mb_idx, mask);\r\n    \t\t}\r\n    \t\telse\r\n    \t\t{\r\n    \t\t\t/* Should not get here */\r\n    \t\t}\r\n    \t}\r\n\t\t\r\n    }\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_EnableIRQs\r\n * Description   : This function enable FLEXCAN instance Interrupts\r\n *\r\n *END**************************************************************************/\r\nstatic inline void FLEXCAN_EnableIRQs(uint8_t instance)\r\n{\r\n\tuint8_t i;\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n    if (g_flexcanWakeUpIrqId[instance] != NotAvail_IRQn)\r\n    {\r\n        INT_SYS_EnableIRQ(g_flexcanWakeUpIrqId[instance]);\r\n    }\r\n#endif\r\n    INT_SYS_EnableIRQ(g_flexcanErrorIrqId[instance]);\r\n    INT_SYS_EnableIRQ(g_flexcanBusOffIrqId[instance]);\r\n    for (i = 0; i < FEATURE_CAN_MB_IRQS_MAX_COUNT; i++)\r\n    {\r\n        if (g_flexcanOredMessageBufferIrqId[i][instance] != NotAvail_IRQn)\r\n        {\r\n            INT_SYS_EnableIRQ(g_flexcanOredMessageBufferIrqId[i][instance]);\r\n        }\r\n    }\r\n}\r\n\r\n#ifdef ERRATA_E10368\r\n#if FEATURE_CAN_HAS_FD\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_Errata10368\r\n * Description   : Implements errata 10368. This errata applies to mask 0N78S for MPC5748G CPU.\r\n *\r\n *END**************************************************************************/\r\nstatic inline void FLEXCAN_Errata10368(uint8_t instance,\r\n                                       const flexcan_user_config_t *data)\r\n{\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_time_segment_t bitrate;\r\n    \r\n\tif (data->fd_enable)\r\n\t{\r\n\t\tflexcan_msgbuff_code_status_t messageBuff={\r\n\t\t\t\t.code = FLEXCAN_TX_REMOTE,\r\n\t\t\t\t.msgIdType = FLEXCAN_MSG_ID_STD,\r\n\t\t\t\t.dataLen = 1U,\r\n\t\t\t\t.fd_enable = false,\r\n\t\t\t\t.fd_padding = 0U,\r\n\t\t\t\t.enable_brs = false\r\n\t\t};\r\n\t\tuint8_t dummy_data[16];\r\n\t\t/* Enable Self Reception */\r\n\t\tFLEXCAN_SetSelfReception(base, true);\r\n\r\n\t\t/* Select Loopback mode */\r\n\t\tFLEXCAN_SetOperationMode(base, FLEXCAN_LOOPBACK_MODE);\r\n\t\t/* Dummy transmission on MB0 */\r\n\t\t(void)FLEXCAN_SetTxMsgBuff(base, 0U, &messageBuff, 0x1U, dummy_data, false);\r\n\t\tFLEXCAN_SetFDEnabled(base, true);\r\n\t\tbitrate = data->bitrate;\r\n\t\tFLEXCAN_SetExtendedTimeSegments(base, &bitrate);\r\n\t\tbitrate = data->bitrate_cbt;\r\n\t\tFLEXCAN_SetFDTimeSegments(base, &bitrate);\r\n\t\tFLEXCAN_ExitFreezeMode(base);\r\n\t\t/* Wait transmission of MB0 to complete */\r\n\t\twhile((base->IFLAG1 & 0x1U) != 0x1U) {};\r\n\t\t/* Clear Transmission Complete */\r\n\t\tbase->IFLAG1 = base->IFLAG1 | 0x1U;\r\n\t\tFLEXCAN_EnterFreezeMode(base);\r\n\t}    \r\n}\r\n#endif /* FEATURE_CAN_HAS_FD */\r\n#endif /* ERRATA_E10368 */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_Init\r\n * Description   : Initialize FlexCAN driver.\r\n * This function will select a source clock, reset FlexCAN module, set maximum\r\n * number of message buffers, initialize all message buffers as inactive, enable\r\n * RX FIFO if needed, mask all mask bits, disable all MB interrupts, enable\r\n * FlexCAN normal mode, and enable all the error interrupts if needed.\r\n *\r\n * Implements    : FLEXCAN_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_Init(\r\n   uint8_t instance,\r\n   flexcan_state_t *state,\r\n   const flexcan_user_config_t *data)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(state != NULL);\r\n    DEV_ASSERT(g_flexcanStatePtr[instance] == NULL);\r\n#ifdef ERRATA_E10595\r\n    if (instance != 0U)\r\n    {\r\n    \tDEV_ASSERT((MC_ME->GS & MC_ME_GS_S_FXOSC_MASK) != 0U);\r\n    }\r\n#endif\r\n\r\n    status_t result;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_time_segment_t bitrate;\r\n    status_t osifStat;\r\n    uint32_t i, j;\r\n\r\n    if(FLEXCAN_IsEnabled(base))\r\n    {\r\n        /* To enter Disable Mode requires FreezMode first */\r\n        FLEXCAN_EnterFreezeMode(base);\r\n        FLEXCAN_Disable(base);\r\n    }\r\n\r\n#if FEATURE_CAN_HAS_PE_CLKSRC_SELECT\r\n    /* Select a source clock for the FlexCAN engine */\r\n    FLEXCAN_SelectClock(base, data->pe_clock);\r\n#endif\r\n\r\n    /* Enable the CAN clock */\r\n    FLEXCAN_Enable(base);\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    /* Initialize FLEXCAN device */\r\n    FLEXCAN_Init(base);\r\n\r\n#ifdef ERRATA_E10368\r\n#if FEATURE_CAN_HAS_FD\r\n    if (FLEXCAN_InstanceHasFD(instance))\r\n    {\r\n        FLEXCAN_Errata10368(instance, data);\r\n    }\r\n#endif /* FEATURE_CAN_HAS_FD */\r\n#endif /* ERRATA_E10368 */\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    if (FLEXCAN_InstanceHasFD(instance))\r\n    {\r\n        /* Enable/Disable FD and check FD was set as expected. Setting FD as enabled\r\n        * might fail if the current CAN instance does not support FD. */\r\n        FLEXCAN_SetFDEnabled(base, data->fd_enable);\r\n        if (FLEXCAN_IsFDEnabled(base) != data->fd_enable)\r\n        {\r\n            return STATUS_ERROR;\r\n        }\r\n\r\n        /* If the FD feature is enabled, enable the Stuff Bit Count, in order to be\r\n        * ISO-compliant. */\r\n        FLEXCAN_SetStuffBitCount(base, data->fd_enable);\r\n    }\r\n    else if (data->fd_enable)\r\n    {\r\n        /* Return STATUS_ERROR when instance doesn't support FD but fd_enable is set \r\n        * to True by user. */\r\n        return STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Do Nothing */\r\n    }\r\n#endif\r\n\r\n    /* Disable the self reception feature if FlexCAN is not in loopback mode. */\r\n    if (data->flexcanMode != FLEXCAN_LOOPBACK_MODE)\r\n    {\r\n        FLEXCAN_SetSelfReception(base, false);\r\n    }\r\n\r\n    /* Enable RxFIFO feature, if requested. This might fail if the FD mode is\r\n     * enabled. */\r\n    if (data->is_rx_fifo_needed)\r\n    {\r\n        result = FLEXCAN_EnableRxFifo(base, (uint32_t)data->num_id_filters);\r\n        if (result != STATUS_SUCCESS)\r\n        {\r\n            return result;\r\n        }\r\n    }\r\n\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    /* Enable DMA support for RxFIFO transfer, if requested. */\r\n    if (data->transfer_type == FLEXCAN_RXFIFO_USING_DMA)\r\n    {\r\n        if (FLEXCAN_IsRxFifoEnabled(base))\r\n        {\r\n            FLEXCAN_SetRxFifoDMA(base, true);\r\n        }\r\n        else\r\n        {\r\n            return STATUS_ERROR;\r\n        }\r\n    }\r\n    if (data->transfer_type == FLEXCAN_RXFIFO_USING_INTERRUPTS)\r\n    {\r\n    \tFLEXCAN_SetRxFifoDMA(base, false);\r\n    }\r\n#endif\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    /* Set payload size. */\r\n    FLEXCAN_SetPayloadSize(base, data->payload);\r\n#endif\r\n\r\n    result = FLEXCAN_SetMaxMsgBuffNum(base, data->max_num_mb);\r\n    if (result != STATUS_SUCCESS)\r\n    {\r\n        return result;\r\n    }\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    /* Set bit rate. */\r\n    if (FLEXCAN_IsFDEnabled(base))\r\n    {\r\n        bitrate = data->bitrate;\r\n        FLEXCAN_SetExtendedTimeSegments(base, &bitrate);\r\n        bitrate = data->bitrate_cbt;\r\n        FLEXCAN_SetFDTimeSegments(base, &bitrate);\r\n    }\r\n    else\r\n#endif\r\n    {\r\n        bitrate = data->bitrate;\r\n        FLEXCAN_SetTimeSegments(base, &bitrate);\r\n    }\r\n\r\n    /* Select mode */\r\n    FLEXCAN_SetOperationMode(base, data->flexcanMode);\r\n\r\n    if (data->flexcanMode != FLEXCAN_FREEZE_MODE)\r\n    {\r\n    \tFLEXCAN_ExitFreezeMode(base);\r\n    }\r\n\r\n    /* Enable FlexCAN interrupts.*/\r\n    FLEXCAN_EnableIRQs(instance);\r\n\r\n    for (i = 0; i < FEATURE_CAN_MAX_MB_NUM; i++)\r\n    {\r\n        osifStat = OSIF_SemaCreate(&state->mbs[i].mbSema, 0U);\r\n        if (osifStat != STATUS_SUCCESS)\r\n        {\r\n            for (j = 0; j < i; j++)\r\n            {\r\n                (void)OSIF_SemaDestroy(&state->mbs[j].mbSema);\r\n            }\r\n            return STATUS_ERROR;\r\n        }\r\n        state->mbs[i].isBlocking = false;\r\n        state->mbs[i].mb_message = NULL;\r\n        state->mbs[i].state = FLEXCAN_MB_IDLE;\r\n    }\r\n#if FEATURE_CAN_HAS_MEM_ERR_DET\r\n    FLEXCAN_DisableMemErrorDetection(base);\r\n#endif\r\n\r\n    /* Store transfer type and DMA channel number used in transfer */\r\n    state->transferType = data->transfer_type;\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    state->rxFifoDMAChannel = data->rxFifoDMAChannel;\r\n#endif\r\n\r\n    /* Clear Callbacks in case of autovariables garbage */\r\n    state->callback = NULL;\r\n    state->callbackParam = NULL;\r\n    state->error_callback = NULL;\r\n    state->errorCallbackParam = NULL;\r\n\r\n    /* Save runtime structure pointers so irq handler can point to the correct state structure */\r\n    g_flexcanStatePtr[instance] = state;\r\n\r\n    return (STATUS_SUCCESS);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ConfigTxMb\r\n * Description   : Configure a Tx message buffer.\r\n * This function will first check if RX FIFO is enabled. If RX FIFO is enabled,\r\n * the function will make sure if the MB requested is not occupied by RX FIFO\r\n * and ID filter table. Then this function will set up the message buffer fields,\r\n * configure the message buffer code for Tx buffer as INACTIVE, and enable the\r\n * Message Buffer interrupt.\r\n *\r\n * Implements    : FLEXCAN_DRV_ConfigTxMb_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_ConfigTxMb(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(tx_info != NULL);\r\n\r\n    flexcan_msgbuff_code_status_t cs;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    /* Initialize transmit mb*/\r\n    cs.dataLen = tx_info->data_length;\r\n    cs.msgIdType = tx_info->msg_id_type;\r\n#if FEATURE_CAN_HAS_FD\r\n    cs.enable_brs = tx_info->enable_brs;\r\n    cs.fd_enable = tx_info->fd_enable;\r\n    cs.fd_padding = tx_info->fd_padding;\r\n#endif\r\n\r\n    cs.code = (uint32_t)FLEXCAN_TX_INACTIVE;\r\n\r\n    return FLEXCAN_SetTxMsgBuff(base, mb_idx, &cs, msg_id, NULL, false);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ConfigRemoteResponseMb\r\n * Description   : Configures a transmit message buffer for remote frame\r\n * response. This function will first check if RX FIFO is enabled. If RX FIFO is\r\n * enabled, the function will make sure if the MB requested is not occupied by\r\n * the RX FIFO and ID filter table. Then this function will set up the message\r\n * buffer fields, configure the message buffer code for Tx buffer as RX_RANSWER,\r\n * and enable the Message Buffer interrupt.\r\n *\r\n * Implements    : FLEXCAN_DRV_ConfigRemoteResponseMb_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_ConfigRemoteResponseMb(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id,\r\n    const uint8_t *mb_data)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(tx_info != NULL);\r\n\r\n    flexcan_msgbuff_code_status_t cs;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    if (mb_idx > (((base->MCR) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT))\r\n    {\r\n        return STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    /* Initialize transmit mb*/\r\n    cs.dataLen = tx_info->data_length;\r\n    cs.msgIdType = tx_info->msg_id_type;\r\n    cs.code = (uint32_t)FLEXCAN_RX_RANSWER;\r\n\r\n    FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n    return FLEXCAN_SetTxMsgBuff(base, mb_idx, &cs, msg_id, mb_data, tx_info->is_remote);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SendBlocking\r\n * Description   : This function sends a CAN frame using a configured message\r\n * buffer. The function blocks until either the frame was sent, or the specified\r\n * timeout expired.\r\n *\r\n * Implements    : FLEXCAN_DRV_SendBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_SendBlocking(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id,\r\n    const uint8_t *mb_data,\r\n    uint32_t timeout_ms)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(tx_info != NULL);\r\n\r\n    status_t result;\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    CAN_Type * base  = g_flexcanBase[instance];\r\n\r\n    result = FLEXCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data, true);\r\n\r\n    if (result == STATUS_SUCCESS)\r\n    {\r\n        status_t status;\r\n\r\n        /* Enable message buffer interrupt*/\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, mb_idx, true);\r\n\r\n        status = OSIF_SemaWait(&state->mbs[mb_idx].mbSema, timeout_ms);\r\n\r\n        if (status == STATUS_TIMEOUT)\r\n        {\r\n        \tif (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)\r\n        \t{\r\n        \t    /* Disable message buffer interrupt */\r\n                (void)FLEXCAN_SetMsgBuffIntCmd(base, mb_idx, false);\r\n                /* Clear message buffer flag */\r\n                FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\t\t\t\tFLEXCAN_AbortTxMsgBuff(base, mb_idx);\r\n\t\t\t\tuint32_t flexcan_mb_config;\r\n\r\n#ifndef ERRATA_E9527\r\n\t\t\t\t/* Wait to finish abort operation */\r\n\t\t\t\twhile(FLEXCAN_GetBuffStatusFlag(base, mb_idx) == 0U)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* Do Nothing wait for the flag */\r\n\t\t\t\t}\r\n#endif\r\n\t\t\t\tvolatile const uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, mb_idx);\r\n\t\t\t\tflexcan_mb_config = * flexcan_mb;\r\n\t\t\t\t/* Check if the MBs have been safely Inactivated */\r\n\t\t\t\tif (((flexcan_mb_config & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT) == (uint32_t)FLEXCAN_TX_INACTIVE)\r\n\t\t\t\t{\r\n#ifndef ERRATA_E9527\r\n\t\t\t\t\t/* Transmission have occurred */\r\n\t\t\t\t\tresult = STATUS_SUCCESS;\r\n#else\r\n\t     \t\t\t/* Transmission have not occurred because it uses the inactivation operation */\r\n\t\t\t\t\tif (FLEXCAN_GetBuffStatusFlag(base, mb_idx) == 0U)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = STATUS_TIMEOUT;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = STATUS_SUCCESS;\r\n\t\t\t\t\t}\r\n#endif\r\n\t\t\t\t}\r\n\t\t\t\tif (((flexcan_mb_config & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT) == (uint32_t)FLEXCAN_TX_ABORT)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* Transmission have occurred */\r\n\t\t\t\t\t\tresult = STATUS_TIMEOUT;\r\n\t\t\t\t}\r\n\t\t\t\t/* Clear message buffer flag */\r\n\t\t\t\tFLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\t\t\t\tstate->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n\t\t\t}\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_Send\r\n * Description   : This function sends a CAN frame using a configured message\r\n * buffer. The function returns immediately. If a callback is installed, it will\r\n * be invoked after the frame was sent.\r\n *\r\n * Implements    : FLEXCAN_DRV_Send_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_Send(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id,\r\n    const uint8_t *mb_data)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(tx_info != NULL);\r\n\r\n    status_t result;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    result = FLEXCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data, false);\r\n    if(result == STATUS_SUCCESS)\r\n    {\r\n        /* Enable message buffer interrupt*/\r\n        result = FLEXCAN_SetMsgBuffIntCmd(base, mb_idx, true);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ConfigMb\r\n * Description   : Configure a Rx message buffer.\r\n * This function will first check if RX FIFO is enabled. If RX FIFO is enabled,\r\n * the function will make sure if the MB requested is not occupied by RX FIFO\r\n * and ID filter table. Then this function will set up the message buffer fields,\r\n * configure the message buffer code for Rx message buffer as NOT_USED, enable\r\n * the Message Buffer interrupt, configure the message buffer code for Rx\r\n * message buffer as INACTIVE, copy user's buffer into the message buffer data\r\n * area, and configure the message buffer code for Rx message buffer as EMPTY.\r\n *\r\n * Implements    : FLEXCAN_DRV_ConfigRxMb_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_ConfigRxMb(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *rx_info,\r\n    uint32_t msg_id)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(rx_info != NULL);\r\n\r\n    status_t result;\r\n    flexcan_msgbuff_code_status_t cs;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    cs.dataLen = rx_info->data_length;\r\n    cs.msgIdType = rx_info->msg_id_type;\r\n#if FEATURE_CAN_HAS_FD\r\n    cs.fd_enable = rx_info->fd_enable;\r\n#endif\r\n    /* Clear the message buffer flag if previous remained triggered*/\r\n    FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n    /* Initialize rx mb*/\r\n    cs.code = (uint32_t)FLEXCAN_RX_NOT_USED;\r\n    result = FLEXCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);\r\n\r\n    if (result == STATUS_SUCCESS)\r\n    {\r\n\t\t/* Initialize receive MB*/\r\n\t\tcs.code = (uint32_t)FLEXCAN_RX_INACTIVE;\r\n\t\tresult = FLEXCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);\r\n    }\r\n\r\n    if (result == STATUS_SUCCESS)\r\n    {\r\n    \t /* Set up FlexCAN message buffer fields for receiving data*/\r\n    \t cs.code = (uint32_t)FLEXCAN_RX_EMPTY;\r\n    \t result = FLEXCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);\r\n    }\r\n    if (result == STATUS_SUCCESS)\r\n    {\r\n        /* Clear the message buffer flag if previous remained triggered*/\r\n        FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ConfigRxFifo\r\n * Description   : Confgure RX FIFO ID filter table elements.\r\n * This function will confgure RX FIFO ID filter table elements, and enable RX\r\n * FIFO interrupts.\r\n *\r\n * Implements    : FLEXCAN_DRV_ConfigRxFifo_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_ConfigRxFifo(\r\n    uint8_t instance,\r\n    flexcan_rx_fifo_id_element_format_t id_format,\r\n    const flexcan_id_table_t *id_filter_table)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    /* Initialize rx fifo*/\r\n    FLEXCAN_SetRxFifoFilter(base, id_format, id_filter_table);\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ReceiveBlocking\r\n * Description   : This function receives a CAN frame into a configured message\r\n * buffer. The function blocks until either a frame was received, or the\r\n * specified timeout expired.\r\n *\r\n * Implements    : FLEXCAN_DRV_ReceiveBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_ReceiveBlocking(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    flexcan_msgbuff_t *data,\r\n    uint32_t timeout_ms)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    status_t result;\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    result = FLEXCAN_StartRxMessageBufferData(instance, mb_idx, data, true);\r\n\r\n    if(result == STATUS_SUCCESS)\r\n    {\r\n        status_t status;\r\n\r\n        status = OSIF_SemaWait(&state->mbs[mb_idx].mbSema, timeout_ms);\r\n\r\n        if (status == STATUS_TIMEOUT)\r\n        {\r\n            /* If the flag is set Successful reception else report TimeOut */\r\n\t\t\tif(FLEXCAN_GetMsgBuffIntStatusFlag(base,mb_idx) == (uint8_t)0U)\r\n\t\t\t{\r\n\t\t\t\tresult = STATUS_TIMEOUT;\r\n\t\t\t}\r\n\t\t\t/* Disable message buffer interrupt */\r\n\t\t\t(void)FLEXCAN_SetMsgBuffIntCmd(base, mb_idx, false);\r\n        }\r\n        /* Consider the MB state has been changed by interrupt as frame received */ \r\n        if (state->mbs[mb_idx].state == FLEXCAN_MB_IDLE)\r\n        {\r\n        \treturn STATUS_SUCCESS;\r\n        }\r\n\r\n        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_Receive\r\n * Description   : This function receives a CAN frame into a configured message\r\n * buffer. The function returns immediately. If a callback is installed, it will\r\n * be invoked after the frame was received and read into the specified buffer.\r\n *\r\n * Implements    : FLEXCAN_DRV_Receive_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_Receive(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    flexcan_msgbuff_t *data)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    status_t result;\r\n\r\n    result = FLEXCAN_StartRxMessageBufferData(instance, mb_idx, data, false);\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_RxFifoBlocking\r\n * Description   : This function receives a CAN frame using the Rx FIFO. The\r\n * function blocks until either a frame was received, or the specified timeout\r\n * expired.\r\n *\r\n * Implements    : FLEXCAN_DRV_RxFifoBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_RxFifoBlocking(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_t *data,\r\n    uint32_t timeout_ms)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    status_t result;\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    result = FLEXCAN_StartRxMessageFifoData(instance, data, true);\r\n\r\n    if (result == STATUS_SUCCESS)\r\n    {\r\n        result = OSIF_SemaWait(&state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mbSema, timeout_ms);\r\n\r\n        if (result == STATUS_TIMEOUT)\r\n        {\r\n        \t /* If the status is updated reception successful else report TimeOut */\r\n\t\t\tif (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_IDLE)\r\n\t\t\t{\r\n\t\t\t\tresult = STATUS_SUCCESS;\r\n\t\t\t}\r\n            /* Disable RX FIFO interrupts*/\r\n            (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_FRAME_AVAILABLE, false);\r\n            (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_WARNING, false);\r\n            (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_OVERFLOW, false);\r\n            \r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n            /* Check if transfer is done over DMA and stop transfer */\r\n            if ((state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_RX_BUSY) && (state->transferType == FLEXCAN_RXFIFO_USING_DMA))\r\n            {\r\n                /* This function always return status success */\r\n                (void)EDMA_DRV_StopChannel(state->rxFifoDMAChannel);\r\n            }\r\n#endif\r\n        }\r\n        state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_RxFifo\r\n * Description   : This function receives a CAN frame using the Rx FIFO. The\r\n * function returns immediately. If a callback is installed, it will be invoked\r\n * after the frame was received and read into the specified buffer.\r\n *\r\n * Implements    : FLEXCAN_DRV_RxFifo_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_RxFifo(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_t *data)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    status_t result;\r\n\r\n    result = FLEXCAN_StartRxMessageFifoData(instance, data, false);\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_Deinit\r\n * Description   : Shutdown a FlexCAN module.\r\n * This function will disable all FlexCAN interrupts, and disable the FlexCAN.\r\n *\r\n * Implements    : FLEXCAN_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_Deinit(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    const flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    status_t result = STATUS_SUCCESS;\r\n    status_t osifStat;\r\n    uint32_t i;\r\n\r\n\r\n    /* Disable FlexCAN interrupts.*/\r\n    if (state != NULL)\r\n    {\r\n\t\tif (state->error_callback != NULL)\r\n\t\t{\r\n\t\t\tFLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_ERR, false);\r\n\t\t\tFLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_RX_WARNING, false);\r\n\t\t\tFLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_TX_WARNING, false);\r\n\t\t\tFLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_BUSOFF, false);\r\n\t\t}\r\n    }\r\n\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n    if (g_flexcanWakeUpIrqId[instance] != NotAvail_IRQn)\r\n    {\r\n        INT_SYS_DisableIRQ(g_flexcanWakeUpIrqId[instance]);\r\n    }\r\n#endif\r\n    INT_SYS_DisableIRQ(g_flexcanErrorIrqId[instance]);\r\n    INT_SYS_DisableIRQ(g_flexcanBusOffIrqId[instance]);\r\n    for (i = 0; i < FEATURE_CAN_MB_IRQS_MAX_COUNT; i++)\r\n    {\r\n        if (g_flexcanOredMessageBufferIrqId[i][instance] != NotAvail_IRQn)\r\n        {\r\n            INT_SYS_DisableIRQ(g_flexcanOredMessageBufferIrqId[i][instance]);\r\n        }\r\n    }\r\n\r\n    if(FLEXCAN_IsEnabled(g_flexcanBase[instance]))\r\n    {\r\n        /* Enter Freeze Mode Required before to enter Disabled Mode */\r\n        FLEXCAN_EnterFreezeMode(g_flexcanBase[instance]);\r\n        /* Disable FlexCAN.*/\r\n        FLEXCAN_Disable(g_flexcanBase[instance]);\r\n        /* Check if the state have been initialized */\r\n    }\r\n\r\n    if (state != NULL)\r\n    {\r\n\t\tfor (i = 0; i < FEATURE_CAN_MAX_MB_NUM; i++)\r\n\t\t{\r\n\t\t\tosifStat = OSIF_SemaDestroy(&state->mbs[i].mbSema);\r\n\t\t\tif (osifStat != STATUS_SUCCESS)\r\n\t\t\t{\r\n\t\t\t\tresult = STATUS_ERROR;\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\r\n    if (result == STATUS_SUCCESS)\r\n    {\r\n    \t/* Clear state pointer that is checked by FLEXCAN_DRV_Init */\r\n    \tg_flexcanStatePtr[instance] = NULL;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_SetTDCOffset\r\n * Description   : Enables/Disables the Transceiver Delay Compensation feature and sets\r\n * the Transceiver Delay Compensation Offset.\r\n *\r\n * Implements    : FLEXCAN_DRV_SetTDCOffset_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_SetTDCOffset(uint8_t instance, bool enable, uint8_t offset)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    /* Enable/Disable TDC and set the TDC Offset */\r\n    FLEXCAN_SetTDCOffset(base, enable, offset);\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetTDCValue\r\n * Description   : Gets the value of the Transceiver Delay Compensation.\r\n *\r\n * Implements    : FLEXCAN_DRV_GetTDCValue_Activity\r\n *END**************************************************************************/\r\nuint8_t FLEXCAN_DRV_GetTDCValue(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    const CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    return (uint8_t)((base->FDCTRL & CAN_FDCTRL_TDCVAL_MASK) >> CAN_FDCTRL_TDCVAL_SHIFT);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetTDCFail\r\n * Description   : Gets the value of the TDC Fail flag.\r\n *\r\n * Implements    : FLEXCAN_DRV_GetTDCFail_Activity\r\n *END**************************************************************************/\r\nbool FLEXCAN_DRV_GetTDCFail(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    const CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    return (((base->FDCTRL & CAN_FDCTRL_TDCFAIL_MASK) >> CAN_FDCTRL_TDCFAIL_SHIFT) != 0U);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ClearTDCFail\r\n * Description   : Clears the TDC Fail flag.\r\n *\r\n * Implements    : FLEXCAN_DRV_ClearTDCFail_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_ClearTDCFail(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    base->FDCTRL = base->FDCTRL | CAN_FDCTRL_TDCFAIL_MASK;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_IRQHandlerRxFIFO\r\n * Description   : Process IRQHandler in case of RxFIFO mode selection for CAN interface.\r\n *\r\n * Implements    : FLEXCAN_IRQHandlerRxFIFO_Activity\r\n *END**************************************************************************/\r\nstatic inline void FLEXCAN_IRQHandlerRxFIFO(uint8_t instance, uint32_t mb_idx)\r\n{\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    \r\n    if (mb_idx == FEATURE_CAN_RXFIFO_FRAME_AVAILABLE) \r\n            {\r\n                if (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_RX_BUSY)\r\n                {\r\n                    /* Get RX FIFO field values */\r\n                    FLEXCAN_ReadRxFifo(base, state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mb_message);\r\n\r\n                    FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n                    state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n\r\n                    /* Invoke callback */\r\n                    if (state->callback != NULL)\r\n                    {\r\n                        state->callback(instance,\r\n                                        FLEXCAN_EVENT_RXFIFO_COMPLETE,\r\n                                        FLEXCAN_MB_HANDLE_RXFIFO,\r\n                                        state);\r\n                    }\r\n\r\n                    if (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_IDLE)\r\n                    {\r\n                        /* Complete receive data */\r\n                        FLEXCAN_CompleteRxMessageFifoData(instance);\r\n                    }\r\n                }\r\n            }\r\n            else if (mb_idx == FEATURE_CAN_RXFIFO_WARNING)\r\n            {\r\n                FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n                /* Invoke callback */\r\n                if (state->callback != NULL)\r\n                {\r\n                    state->callback(instance,\r\n                                    FLEXCAN_EVENT_RXFIFO_WARNING,\r\n                                    FLEXCAN_MB_HANDLE_RXFIFO,\r\n                                    state);\r\n                }\r\n            }\r\n            else if (mb_idx == FEATURE_CAN_RXFIFO_OVERFLOW)\r\n            {\r\n                FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n                /* Invoke callback */\r\n                if (state->callback != NULL)\r\n                {\r\n                    state->callback(instance,\r\n                                    FLEXCAN_EVENT_RXFIFO_OVERFLOW,\r\n                                    FLEXCAN_MB_HANDLE_RXFIFO,\r\n                                    state);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Do Nothing */\r\n            }\r\n\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_IRQHandlerRxMB\r\n * Description   : Process IRQHandler in case of Rx MessageBuffer selection\r\n * for CAN interface.\r\n *\r\n * This is not a public API as it is called whenever an interrupt and receive\r\n * individual MB occurs\r\n *END**************************************************************************/\r\nstatic void FLEXCAN_IRQHandlerRxMB(uint8_t instance, uint32_t mb_idx)\r\n{\r\n\t CAN_Type * base = g_flexcanBase[instance];\r\n\t flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n\t /* Lock RX message buffer and RX FIFO*/\r\n\t FLEXCAN_LockRxMsgBuff(base, mb_idx);\r\n\r\n\t /* Get RX MB field values*/\r\n\t FLEXCAN_GetMsgBuff(base, mb_idx, state->mbs[mb_idx].mb_message);\r\n\r\n     FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n     \r\n\t /* Unlock RX message buffer and RX FIFO*/\r\n\t FLEXCAN_UnlockRxMsgBuff(base);\r\n     \r\n     state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n\r\n\t /* Invoke callback */\r\n\t if (state->callback != NULL)\r\n\t {\r\n\t\t state->callback(instance, FLEXCAN_EVENT_RX_COMPLETE, mb_idx, state);\r\n\t }\r\n\r\n     if (state->mbs[mb_idx].state == FLEXCAN_MB_IDLE)\r\n     {\r\n         /* Complete receive data */\r\n         FLEXCAN_CompleteTransfer(instance, mb_idx);\r\n     }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_BusOff_IRQHandler\r\n * Description   : BusOff and Tx/Rx Warning interrupt handler for FLEXCAN.\r\n * This handler only provides a error status report and invokes the user callback,\r\n * and then clears the interrupt flags.\r\n * This is not a public API as it is called whenever an interrupt occurs.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_BusOff_IRQHandler(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    /* Invoke callback */\r\n    if (state->error_callback != NULL)\r\n    {\r\n        state->error_callback(instance, FLEXCAN_EVENT_ERROR, state);\r\n    }\r\n\r\n    /* Clear all BusOff and Tx/Rx Warning interrupts in ESR1 register */\r\n    FLEXCAN_ClearBusOffIntStatusFlag(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_IRQHandler\r\n * Description   : Interrupt handler for FLEXCAN.\r\n * This handler read data from MB or FIFO, and then clear the interrupt flags.\r\n * This is not a public API as it is called whenever an interrupt occurs.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_IRQHandler(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    uint32_t flag_reg = 0;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    /* Get the interrupts that are enabled and ready */\r\n    uint32_t mb_idx = 0;\r\n    flag_reg = FLEXCAN_GetMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n    while ((flag_reg & 1U) == 0U)\r\n    {\r\n        mb_idx++;\r\n        flag_reg = FLEXCAN_GetMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n        if (mb_idx >= FEATURE_CAN_MAX_MB_NUM)\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    /* Check Tx/Rx interrupt flag and clear the interrupt */\r\n    if(flag_reg != 0U)\r\n    {\r\n        if (FLEXCAN_IsRxFifoEnabled(base) && (mb_idx <= FEATURE_CAN_RXFIFO_OVERFLOW))\r\n        {\r\n            FLEXCAN_IRQHandlerRxFIFO(instance, mb_idx);\r\n        }\r\n        else\r\n        {\r\n            /* Check mailbox completed reception */\r\n            if (state->mbs[mb_idx].state == FLEXCAN_MB_RX_BUSY)\r\n            {\r\n            \tFLEXCAN_IRQHandlerRxMB(instance, mb_idx);\r\n            }\r\n        }\r\n\r\n        /* Check mailbox completed transmission */\r\n        if (state->mbs[mb_idx].state == FLEXCAN_MB_TX_BUSY)\r\n        {\r\n            if (state->mbs[mb_idx].isRemote)\r\n            {\r\n                /* If the frame was a remote frame, clear the flag only if the response was\r\n                 * not received yet. If the response was received, leave the flag set in order\r\n                 * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */\r\n                flexcan_msgbuff_t mb;\r\n                FLEXCAN_LockRxMsgBuff(base, mb_idx);\r\n                FLEXCAN_GetMsgBuff(base, mb_idx, &mb);\r\n                FLEXCAN_UnlockRxMsgBuff(base);\r\n\r\n                if (((mb.cs & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT) == (uint32_t)FLEXCAN_RX_EMPTY)\r\n                {\r\n                    FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n            }\r\n\r\n            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n\r\n            /* Invoke callback */\r\n            if (state->callback != NULL)\r\n            {\r\n                state->callback(instance, FLEXCAN_EVENT_TX_COMPLETE, mb_idx, state);\r\n            }\r\n\r\n            if (state->mbs[mb_idx].state == FLEXCAN_MB_IDLE)\r\n            {\r\n                /* Complete transmit data */\r\n                FLEXCAN_CompleteTransfer(instance, mb_idx);\r\n            }\r\n        }\r\n\r\n        if (FLEXCAN_GetMsgBuffIntStatusFlag(base, mb_idx) != 0U)\r\n        {\r\n        \tif (FLEXCAN_IsRxFifoEnabled(base) && (mb_idx <= FEATURE_CAN_RXFIFO_OVERFLOW))\r\n        \t{\r\n        \t\tif (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_IDLE)\r\n        \t\t{\r\n                /* In case of desynchronized status of the MB to avoid trapping in ISR\r\n                 * clear the MB flag */\r\n                FLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n        \t\t}\r\n        \t}\r\n        \telse\r\n        \t{\r\n        \t\tif (state->mbs[mb_idx].state == FLEXCAN_MB_IDLE)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* In case of desynchronized status of the MB to avoid trapping in ISR\r\n\t\t\t\t\t * clear the MB flag */\r\n\t\t\t\t\tFLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\t\t\t\t}\r\n        \t}\r\n        }\r\n    }\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n    else\r\n    {\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n\t\t/* The pretending Network Feature is present on all CPUs\r\n\t\t * only on FLEXCAN Instance 0   */\r\n\t\tif (instance == 0U)\r\n\t\t{\r\n\t\t\tuint8_t wtof = FLEXCAN_GetWTOF(base);\r\n\t\t\tuint8_t wumf = FLEXCAN_GetWUMF(base);\r\n\r\n\t\t\t/* Check if wake-up event occurred */\r\n\t\t\tif ((wtof != 0U) || (wumf != 0U))\r\n\t\t\t{\r\n\t\t\t\tFLEXCAN_WakeUpHandler(instance);\r\n\t\t\t}\r\n\t\t}\r\n#endif /* FEATURE_CAN_HAS_PRETENDED_NETWORKING */\r\n        uint32_t ecr = FLEXCAN_GetErrorCounters(base);\r\n\r\n        /* Check if any error occurred */\r\n        if (ecr != 0U)\r\n        {\r\n            FLEXCAN_Error_IRQHandler(instance);\r\n        }\r\n    }\r\n#endif /* (defined(CPU_S32K116) || defined(CPU_S32K118)) */\r\n    return;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_Error_IRQHandler\r\n * Description   : Error interrupt handler for FLEXCAN.\r\n * This handler read data from MB or FIFO, and then clear the interrupt flags.\r\n * This is not a public API as it is called whenever an interrupt occurs.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_Error_IRQHandler(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    /* Invoke callback */\r\n    if (state->error_callback != NULL)\r\n    {\r\n        state->error_callback(instance, FLEXCAN_EVENT_ERROR, state);\r\n    }\r\n\r\n    /* Clear all other interrupts in ESR1 register (Error, Wakeup) */\r\n    FLEXCAN_ClearErrIntStatusFlag(base);\r\n\r\n    return;\r\n}\r\n\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_WakeUpHandler\r\n * Description   : Wake up handler for FLEXCAN.\r\n * This handler verifies the event which caused the wake up and invokes the\r\n * user callback, if configured.\r\n * This is not a public API as it is called whenever an wake up event occurs.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_WakeUpHandler(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n        if (FLEXCAN_IsPNEnabled(base))\r\n        {\r\n            if (FLEXCAN_GetWTOF(base) != 0U)\r\n            {\r\n                FLEXCAN_ClearWTOF(base);\r\n                /* Invoke callback */\r\n                if (state->callback != NULL)\r\n                {\r\n                \tstate->callback(instance, FLEXCAN_EVENT_WAKEUP_TIMEOUT, 0U, state);\r\n                }\r\n            }\r\n            if (FLEXCAN_GetWUMF(base) != 0U)\r\n            {\r\n                FLEXCAN_ClearWUMF(base);\r\n                /* Invoke callback */\r\n                if (state->callback != NULL)\r\n                {\r\n                \tstate->callback(instance, FLEXCAN_EVENT_WAKEUP_MATCH, 0U, state);\r\n                }\r\n            }\r\n        }\r\n#endif\r\n}\r\n#endif /* FEATURE_CAN_HAS_WAKE_UP_IRQ */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetTransferStatus\r\n * Description   : This function returns whether the previous FLEXCAN receive is\r\n *                 completed.\r\n * When performing a non-blocking receive, the user can call this function to\r\n * ascertain the state of the current receive progress: in progress (or busy)\r\n * or complete (success).\r\n *\r\n * Implements    : FLEXCAN_DRV_GetTransferStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_GetTransferStatus(uint8_t instance, uint8_t mb_idx)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    const flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    status_t status;\r\n\r\n    if (state->mbs[mb_idx].state == FLEXCAN_MB_IDLE)\r\n    {\r\n        status = STATUS_SUCCESS;\r\n    }\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    else if (state->mbs[mb_idx].state == FLEXCAN_MB_DMA_ERROR)\r\n    {\r\n        status = STATUS_ERROR;\r\n    }\r\n#endif\r\n    else\r\n    {\r\n       \tstatus = STATUS_BUSY;\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetErrorStatus\r\n * Description   : Reports various error conditions detected in the reception and\r\n *                 transmission of a CAN frame and some general status of the device.\r\n *\r\n * Implements    : FLEXCAN_DRV_GetErrorStatus_Activity\r\n *END**************************************************************************/\r\nuint32_t FLEXCAN_DRV_GetErrorStatus(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    const CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    return ((uint32_t)(base->ESR1));\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_AbortTransfer\r\n * Description   : This function shuts down the FLEXCAN by disabling interrupts and\r\n *                 the transmitter/receiver.\r\n * This function disables the FLEXCAN interrupts, disables the transmitter and\r\n * receiver.\r\n *\r\n * Implements    : FLEXCAN_DRV_AbortTransfer_Activity\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_DRV_AbortTransfer(uint8_t instance, uint8_t mb_idx)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    /* Check if a transfer is running. */\r\n    if (state->mbs[mb_idx].state == FLEXCAN_MB_IDLE)\r\n    {\r\n        return STATUS_CAN_NO_TRANSFER_IN_PROGRESS;\r\n    }\r\n\r\n    if (state->mbs[mb_idx].state == FLEXCAN_MB_TX_BUSY)\r\n    {\r\n    \tstatus_t result = STATUS_SUCCESS;\r\n\t\t/* Stop the running transfer. */\r\n\t\tFLEXCAN_CompleteTransfer(instance, mb_idx);\r\n    \t/* Clear message buffer flag */\r\n    \tFLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n        FLEXCAN_AbortTxMsgBuff(base, mb_idx);\r\n\t\tuint32_t flexcan_mb_config;\r\n\r\n#ifndef ERRATA_E9527\r\n\t\t/* Wait to finish abort operation */\r\n\t\twhile(FLEXCAN_GetBuffStatusFlag(base, mb_idx) == 0U)\r\n\t\t{\r\n\t\t\t/* Do Nothing wait for the flag */\r\n\t\t}\r\n#endif\r\n\t\tvolatile const uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, mb_idx);\r\n\t\tflexcan_mb_config = * flexcan_mb;\r\n\t\t/* Check if the MBs have been safely Inactivated */\r\n\t\tif (((flexcan_mb_config & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT) == (uint32_t)FLEXCAN_TX_INACTIVE)\r\n\t\t{\r\n#ifndef ERRATA_E9527\r\n\t\t\t/* Transmission have occurred */\r\n\t\t\tresult = STATUS_CAN_NO_TRANSFER_IN_PROGRESS;\r\n#else\r\n \t\t\t/* Transmission have not occurred because it uses the inactivation operation */\r\n\t\t\tif (FLEXCAN_GetBuffStatusFlag(base, mb_idx) == 0U)\r\n\t\t\t{\r\n\t\t\t\tresult = STATUS_SUCCESS;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult = STATUS_CAN_NO_TRANSFER_IN_PROGRESS;\r\n\t\t\t}\r\n#endif\r\n\t\t}\r\n\t\tif (((flexcan_mb_config & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT) == (uint32_t)FLEXCAN_TX_ABORT)\r\n\t\t{\r\n\t\t\t/* Transmission have been aborted */\r\n\t\t\t\tresult = STATUS_SUCCESS;\r\n\t\t}\r\n\t\t/* Clear message buffer flag */\r\n\t\tFLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\t\tstate->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n\t\treturn result;\r\n    }\r\n\r\n    if (state->mbs[mb_idx].state == FLEXCAN_MB_RX_BUSY)\r\n    {\r\n\t\t/* Stop the running transfer. */\r\n\t\tFLEXCAN_CompleteTransfer(instance, mb_idx);\r\n\r\n    \tif(FLEXCAN_IsRxFifoEnabled(base) == true)\r\n        {\r\n\r\n    \t\t/* Get the number of RX FIFO Filters*/\r\n    \t\tuint32_t val1 = (((base->CTRL2) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT);\r\n    \t\t/* Get the number if MBs occupied by RX FIFO and ID filter table*/\r\n    \t\t/* the Rx FIFO occupies the memory space originally reserved for MB0-5*/\r\n\t\t\t/* Every number of RFFN means 8 number of RX FIFO filters*/\r\n\t\t\t/* and every 4 number of RX FIFO filters occupied one MB*/\r\n    \t\tuint32_t val2 = RxFifoOcuppiedLastMsgBuff(val1);\r\n\t\t\tif(mb_idx > val2)\r\n\t\t\t{\r\n\t\t\t\t/* This operation is not allowed for MB that are part of RxFIFO */\r\n\t\t\t\tFLEXCAN_ResetRxMsgBuff(base, mb_idx);\r\n\t\t\t}\r\n\t\t\tif (mb_idx == FLEXCAN_MB_HANDLE_RXFIFO)\r\n\t\t\t{\r\n\t\t        /* Disable RX FIFO interrupts*/\r\n\t\t        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_FRAME_AVAILABLE, false);\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n\t\t        if (state->transferType == FLEXCAN_RXFIFO_USING_DMA)\r\n\t\t        {\r\n\t\t        \t(void) EDMA_DRV_StopChannel(state->rxFifoDMAChannel);\r\n\t\t        }\r\n#endif\r\n\t\t\t}\r\n        }\r\n    \telse\r\n    \t{\r\n    \t\t/* This operation is not allowed for MB that are part of RxFIFO */\r\n    \t\tFLEXCAN_ResetRxMsgBuff(base, mb_idx);\r\n    \t}\r\n    }\r\n\r\n    if (FLEXCAN_GetMsgBuffIntStatus(base, mb_idx) == 1U)\r\n    {\r\n\t\t/* Stop the running transfer. */\r\n\t\tFLEXCAN_CompleteTransfer(instance, mb_idx);\r\n\t\t/* Clear message buffer flag */\r\n\t\tFLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n    }\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_StartSendData\r\n * Description   : Initiate (start) a transmit by beginning the process of\r\n * sending data.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t FLEXCAN_StartSendData(\r\n                    uint8_t instance,\r\n                    uint8_t mb_idx,\r\n                    const flexcan_data_info_t *tx_info,\r\n                    uint32_t msg_id,\r\n                    const uint8_t *mb_data,\r\n                    bool isBlocking\r\n                    )\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(tx_info != NULL);\r\n\r\n    status_t result;\r\n    flexcan_msgbuff_code_status_t cs;\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    if(mb_idx >= FLEXCAN_GetMaxMbNum(base))\r\n    {\r\n    \treturn STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    /* Clear message buffer flag */\r\n\tFLEXCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);\r\n\r\n    state->mbs[mb_idx].state = FLEXCAN_MB_TX_BUSY;\r\n    state->mbs[mb_idx].isBlocking = isBlocking;\r\n    state->mbs[mb_idx].isRemote = tx_info->is_remote;\r\n\r\n    cs.dataLen = tx_info->data_length;\r\n    cs.msgIdType = tx_info->msg_id_type;\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    cs.fd_enable = tx_info->fd_enable;\r\n    cs.fd_padding = tx_info->fd_padding;\r\n    cs.enable_brs = tx_info->enable_brs;\r\n#endif\r\n\r\n    if (tx_info->is_remote)\r\n    {\r\n        cs.code = (uint32_t)FLEXCAN_TX_REMOTE;\r\n    }\r\n    else\r\n    {\r\n        cs.code = (uint32_t)FLEXCAN_TX_DATA;\r\n    }\r\n    result = FLEXCAN_SetTxMsgBuff(base, mb_idx, &cs, msg_id, mb_data, false);\r\n\r\n    if (result != STATUS_SUCCESS)\r\n    {\r\n        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_StartRxMessageBufferData\r\n * Description   : Initiate (start) a receive by beginning the process of\r\n * receiving data and enabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t FLEXCAN_StartRxMessageBufferData(\r\n                    uint8_t instance,\r\n                    uint8_t mb_idx,\r\n                    flexcan_msgbuff_t *data,\r\n                    bool isBlocking\r\n                    )\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    status_t result = STATUS_SUCCESS;\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    /* Check if the MB index is in range */\r\n    if(mb_idx >= FLEXCAN_GetMaxMbNum(base))\r\n    {\r\n    \treturn STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    /* Check if RX FIFO is enabled*/\r\n    if (FLEXCAN_IsRxFifoEnabled(base) == true)\r\n    {\r\n    \tuint32_t val1, val2;\r\n        /* Get the number of RX FIFO Filters*/\r\n        val1 = (((base->CTRL2) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT);\r\n        /* Get the number if MBs occupied by RX FIFO and ID filter table*/\r\n        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/\r\n        /* Every number of RFFN means 8 number of RX FIFO filters*/\r\n        /* and every 4 number of RX FIFO filters occupied one MB*/\r\n        val2 = RxFifoOcuppiedLastMsgBuff(val1);\r\n\r\n        if (mb_idx <= val2)\r\n        {\r\n        \treturn STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n        }\r\n    }\r\n\r\n    /* Start receiving mailbox */\r\n    if(state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n    state->mbs[mb_idx].state = FLEXCAN_MB_RX_BUSY;\r\n    state->mbs[mb_idx].mb_message = data;\r\n    state->mbs[mb_idx].isBlocking = isBlocking;\r\n\r\n    /* Enable MB interrupt*/\r\n    result = FLEXCAN_SetMsgBuffIntCmd(base, mb_idx, true);\r\n\r\n    if (result != STATUS_SUCCESS)\r\n    {\r\n        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_StartRxMessageFifoData\r\n * Description   : Initiate (start) a receive by beginning the process of\r\n * receiving data and enabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t FLEXCAN_StartRxMessageFifoData(\r\n                    uint8_t instance,\r\n                    flexcan_msgbuff_t *data,\r\n                    bool isBlocking\r\n                    )\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    status_t edmaStat;\r\n\r\n    if (state->transferType == FLEXCAN_RXFIFO_USING_DMA)\r\n    {\r\n    \tif (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_DMA_ERROR)\r\n    \t{\r\n\t\t\t/* Check if FIFO has Pending Request that generated error,\r\n\t\t\t * the RxFIFO need to be empty to activate DMA */\r\n\t\t\tif (FLEXCAN_GetBuffStatusFlag(base,FEATURE_CAN_RXFIFO_FRAME_AVAILABLE) == (uint8_t)1U)\r\n\t\t\t{\r\n\t\t\t\t/* Enter CAN in freeze Mode to allow FIFO Clear */\r\n\t\t\t\tFLEXCAN_EnterFreezeMode(base);\r\n\r\n\t\t\t\tFLEXCAN_ClearFIFO(base);\r\n\t\t\t\tdo\r\n\t\t\t\t{\t/* Read Offset 0x8C to clear DMA pending request */\r\n\t\t\t\t\t(void) base->RAMn[3];\r\n\t\t\t\t}\r\n\t\t\t\twhile (FLEXCAN_GetBuffStatusFlag(base,FEATURE_CAN_RXFIFO_FRAME_AVAILABLE) == (uint8_t)1U);\r\n\r\n\t\t\t\t/* Return CAN to normal Mode */\r\n\t\t\t\tFLEXCAN_ExitFreezeMode(base);\r\n\t\t\t}\r\n\t\t\t/* Change status of MB to be reconfigured with DMA transfer */\r\n\t\t\tstate->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n    \t}\r\n    }\r\n#endif /* FEATURE_CAN_HAS_DMA_ENABLE */\r\n\r\n    /* Start receiving fifo */\r\n    if (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state != FLEXCAN_MB_IDLE)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n    /* Check if RxFIFO feature is enabled */\r\n    if (!FLEXCAN_IsRxFifoEnabled(base))\r\n    {\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n    state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_RX_BUSY;\r\n\r\n    state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].isBlocking = isBlocking;\r\n\r\n    /* This will get filled by the interrupt handler */\r\n    state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mb_message = data;\r\n    \r\n    if (state->transferType == FLEXCAN_RXFIFO_USING_INTERRUPTS)\r\n    {\r\n        /* Enable RX FIFO interrupts*/\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_WARNING, true);\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_OVERFLOW, true);\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_FRAME_AVAILABLE, true);\r\n    }\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    if (state->transferType == FLEXCAN_RXFIFO_USING_DMA)\r\n    {\r\n        status_t edmaStatus;\r\n\r\n        edmaStatus = EDMA_DRV_InstallCallback(state->rxFifoDMAChannel,\r\n                                              FLEXCAN_CompleteRxFifoDataDMA,\r\n                                              (void *)((uint32_t)instance));\r\n\r\n        if (edmaStatus != STATUS_SUCCESS)\r\n        {\r\n            state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n            return STATUS_ERROR;\r\n        }\r\n\r\n        edmaStatus = EDMA_DRV_ConfigSingleBlockTransfer(state->rxFifoDMAChannel,\r\n                                                        EDMA_TRANSFER_MEM2MEM,\r\n                                                        (uint32_t)(base->RAMn),\r\n                                                        (uint32_t)(state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mb_message),\r\n                                                        EDMA_TRANSFER_SIZE_4B,\r\n                                                        16U);\r\n\r\n        if (edmaStatus != STATUS_SUCCESS)\r\n        {\r\n            state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n            return STATUS_ERROR;\r\n        }\r\n\r\n        EDMA_DRV_DisableRequestsOnTransferComplete(state->rxFifoDMAChannel, true);\r\n\r\n        edmaStat = EDMA_DRV_StartChannel(state->rxFifoDMAChannel);\r\n        if (edmaStat != STATUS_SUCCESS)\r\n        {\r\n            state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n            return STATUS_ERROR;\r\n        }\r\n    }\r\n#endif\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_CompleteTransfer\r\n * Description   : Finish up a transmit by completing the process of sending\r\n * data and disabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void FLEXCAN_CompleteTransfer(uint8_t instance, uint32_t mb_idx)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    /* Disable the transmitter data register empty interrupt */\r\n    (void)FLEXCAN_SetMsgBuffIntCmd(base, mb_idx, false);\r\n\r\n    /* Update the information of the module driver state */\r\n    if (state->mbs[mb_idx].isBlocking)\r\n    {\r\n        (void)OSIF_SemaPost(&state->mbs[mb_idx].mbSema);\r\n    }\r\n    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;\r\n}\r\n\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_CompleteRxFifoDataDMA\r\n * Description   : Finish up a DMA transfer (this is just a wrapper over\r\n * FLEXCAN_DRV_CompleteRxMessageFifoData).\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void FLEXCAN_CompleteRxFifoDataDMA(void *parameter, edma_chn_status_t status)\r\n{\r\n    uint32_t instance = (uint32_t)parameter;\r\n\r\n    if(status == EDMA_CHN_ERROR)\r\n    {\r\n    \tflexcan_state_t * state = g_flexcanStatePtr[instance];\r\n    \tstate->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_DMA_ERROR;\r\n        if\t(state->callback != NULL)\r\n    \t{\r\n        \tstate->callback((uint8_t)instance,\r\n        \t\t\t\t\tFLEXCAN_EVENT_DMA_ERROR,\r\n\t\t\t\t\t\t\tFLEXCAN_MB_HANDLE_RXFIFO,\r\n\t\t\t\t\t\t\tstate);\r\n    \t}\r\n    }\r\n    FLEXCAN_CompleteRxMessageFifoData((uint8_t)instance);\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_CompleteRxMessageFifoData\r\n * Description   : Finish up a receive by completing the process of receiving\r\n * data and disabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void FLEXCAN_CompleteRxMessageFifoData(uint8_t instance)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    if (state->transferType == FLEXCAN_RXFIFO_USING_INTERRUPTS)\r\n    {\r\n        /* Disable RX FIFO interrupts*/\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_FRAME_AVAILABLE, false);\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_WARNING, false);\r\n        (void)FLEXCAN_SetMsgBuffIntCmd(base, FEATURE_CAN_RXFIFO_OVERFLOW, false);\r\n    }\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n    \tif (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state != FLEXCAN_MB_DMA_ERROR)\r\n    \t{\r\n\t\t\tflexcan_msgbuff_t *fifo_message = state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mb_message;\r\n\t\t\tuint32_t *msgData_32 = (uint32_t *)fifo_message->data;\r\n\r\n\t\t\t(void) EDMA_DRV_StopChannel(state->rxFifoDMAChannel);\r\n\t\t\t/* Adjust the ID if it is not extended */\r\n\t\t\tif (((fifo_message->cs) & CAN_CS_IDE_MASK) == 0U)\r\n\t\t\t{\r\n\t\t\t\tfifo_message->msgId = fifo_message->msgId  >> CAN_ID_STD_SHIFT;\r\n\t\t\t}\r\n\t\t\t/* Extract the data length */\r\n\t\t\tfifo_message->dataLen = (uint8_t)((fifo_message->cs & CAN_CS_DLC_MASK) >> CAN_CS_DLC_SHIFT);\r\n\t\t\t/* Reverse the endianness */\r\n\t\t\tFlexcanSwapBytesInWord(msgData_32[0], msgData_32[0]);\r\n\t\t\tFlexcanSwapBytesInWord(msgData_32[1], msgData_32[1]);\r\n    \t}\r\n    }\r\n#endif\r\n    /* Clear fifo message*/\r\n    state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mb_message = NULL;\r\n\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    if (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state != FLEXCAN_MB_DMA_ERROR)\r\n    {\r\n    \tstate->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n    \tif ((state->callback != NULL) && (state->transferType == FLEXCAN_RXFIFO_USING_DMA))\r\n        {\r\n            state->callback(instance,\r\n                            FLEXCAN_EVENT_DMA_COMPLETE,\r\n                            FLEXCAN_MB_HANDLE_RXFIFO,\r\n                            state);\r\n        }\r\n    }\r\n#else\r\n    state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;\r\n#endif\r\n\r\n    /* Update status for receive by using fifo*/\r\n    if (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].isBlocking == true)\r\n    {\r\n        if (state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_IDLE)\r\n        {\r\n            status_t status = OSIF_SemaPost(&state->mbs[FLEXCAN_MB_HANDLE_RXFIFO].mbSema);\r\n            DEV_ASSERT(status == STATUS_SUCCESS);\r\n            (void)status;\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_InstallEventCallback\r\n * Description   : Installs a callback function for the IRQ handler.\r\n *\r\n * Implements    : FLEXCAN_DRV_InstallEventCallback_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_InstallEventCallback(uint8_t instance,\r\n                                      flexcan_callback_t callback,\r\n                                      void *callbackParam)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    state->callback = callback;\r\n    state->callbackParam = callbackParam;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_InstallErrorCallback\r\n * Description   : Installs an error callback function for the IRQ handler and enables/disables\r\n *                 error interrupts.\r\n *\r\n * Implements    : FLEXCAN_DRV_InstallErrorCallback_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_InstallErrorCallback(uint8_t instance,\r\n                                      flexcan_error_callback_t callback,\r\n                                      void *callbackParam)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n    flexcan_state_t * state = g_flexcanStatePtr[instance];\r\n\r\n    state->error_callback = callback;\r\n    state->errorCallbackParam = callbackParam;\r\n    FLEXCAN_EnterFreezeMode(base);\r\n    if (callback != NULL)\r\n    {\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_ERR, true);\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_RX_WARNING, true);\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_TX_WARNING, true);\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_BUSOFF, true);\r\n    }\r\n    else\r\n    {\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_ERR, false);\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_RX_WARNING, false);\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_TX_WARNING, false);\r\n        FLEXCAN_SetErrIntCmd(base, FLEXCAN_INT_BUSOFF, false);\r\n    }\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_ConfigPN\r\n * Description   : Configures Pretended Networking settings.\r\n *\r\n * Implements    : FLEXCAN_DRV_ConfigPN_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_ConfigPN(uint8_t instance, bool enable, const flexcan_pn_config_t *pnConfig)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n\r\n    CAN_Type * base = g_flexcanBase[instance];\r\n\r\n    FLEXCAN_EnterFreezeMode(base);\r\n\r\n    if (enable)\r\n    {\r\n        FLEXCAN_ConfigPN(base, pnConfig);\r\n#if FEATURE_CAN_HAS_SELF_WAKE_UP\r\n        (void)FLEXCAN_SetSelfWakeUp(base, false);\r\n#endif\r\n    }\r\n\r\n    FLEXCAN_SetPN(base, enable);\r\n\r\n    FLEXCAN_ExitFreezeMode(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetWMB\r\n * Description   : Extracts one of the frames which triggered the wake up event.\r\n *\r\n * Implements    : FLEXCAN_DRV_GetWMB_Activity\r\n *END**************************************************************************/\r\nvoid FLEXCAN_DRV_GetWMB(uint8_t instance, uint8_t wmbIndex, flexcan_msgbuff_t *wmb)\r\n{\r\n    DEV_ASSERT(instance < CAN_INSTANCE_COUNT);\r\n    DEV_ASSERT(wmb != NULL);\r\n    const CAN_Type *base  =  g_flexcanBase[instance];\r\n    uint32_t *tmp, wmbData;\r\n\r\n    tmp = (uint32_t *)&wmb->data[0];\r\n    wmbData = base->WMB[wmbIndex].WMBn_D03;\r\n    FlexcanSwapBytesInWord(wmbData, *tmp);\r\n\r\n    tmp = (uint32_t *)&wmb->data[4];\r\n    wmbData = base->WMB[wmbIndex].WMBn_D47;\r\n    FlexcanSwapBytesInWord(wmbData, *tmp);\r\n\r\n    wmb->cs = base->WMB[wmbIndex].WMBn_CS;\r\n\r\n    if ((wmb->cs & CAN_CS_IDE_MASK) != 0U)\r\n    {\r\n        wmb->msgId = base->WMB[wmbIndex].WMBn_ID;\r\n    }\r\n    else\r\n    {\r\n        wmb->msgId = base->WMB[wmbIndex].WMBn_ID >> CAN_ID_STD_SHIFT;\r\n    }\r\n\r\n    wmb->dataLen = (uint8_t)((wmb->cs & CAN_CS_DLC_MASK) >> 16);\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_PRETENDED_NETWORKING */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_CheckDsample\r\n * Description   : Check the Sample value\r\n *\r\n *END**************************************************************************/\r\nstatic inline uint32_t FLEXCAN_CheckDsample(uint32_t tmpSample, uint32_t samplePoint)\r\n{\r\n    if (tmpSample > samplePoint)\r\n    {\r\n        return (tmpSample - samplePoint);\r\n    }\r\n    return (samplePoint - tmpSample);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_CheckdBitrate\r\n * Description   : Check the Bitrate value\r\n *\r\n *END**************************************************************************/\r\nstatic inline uint32_t FLEXCAN_CheckdBitrate(uint32_t tmpBitrate, uint32_t bitrate)\r\n{\r\n    if (tmpBitrate > bitrate)\r\n    {\r\n        return (tmpBitrate - bitrate);\r\n    }\r\n    return (bitrate - tmpBitrate);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_CheckJumpwidth\r\n * Description   : Check the JumpWidth value\r\n *\r\n *END**************************************************************************/\r\nstatic inline uint32_t FLEXCAN_CheckJumpwidth(uint32_t pseg1)\r\n{\r\n    if (pseg1 < FLEXCAN_RJW_MAX)\r\n    {\r\n        return pseg1;\r\n    }\r\n    return FLEXCAN_RJW_MAX;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ProccessTSeg\r\n * Description   : Calculate Tseg value\r\n *\r\n *END**************************************************************************/\r\nstatic inline void FLEXCAN_ProccessTSeg(uint32_t * tSeg1, uint32_t * tSeg2)\r\n{\r\n    /* Adjust time segment 1 and time segment 2 */\r\n    while ((*tSeg1 >= FLEXCAN_TSEG1_MAX) || (*tSeg2 < FLEXCAN_TSEG2_MIN))\r\n    {\r\n        *tSeg2 = *tSeg2 + 1U;\r\n        *tSeg1 = *tSeg1 - 1U;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ProccessPSeg\r\n * Description   : Calculate Pseg value\r\n *\r\n *END**************************************************************************/\r\nstatic inline void FLEXCAN_ProccessPSeg(uint32_t * tmpPropseg, uint32_t * tmpPseg1)\r\n{\r\n    while (*tmpPropseg <= 0U)\r\n    {\r\n        *tmpPropseg = *tmpPropseg + 1U;\r\n        *tmpPseg1 = *tmpPseg1 - 1U;\r\n    }\r\n    \r\n    while (*tmpPropseg >= FLEXCAN_PROPSEG_MAX)\r\n    {\r\n        *tmpPropseg = *tmpPropseg - 1U;\r\n        *tmpPseg1 = *tmpPseg1 + 1U;\r\n    }\r\n}    \r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_BitrateToTimeSeg\r\n * Description   : Converts a bitrate (kbit/s) in time segment values for\r\n *                 standard CAN frame.\r\n *\r\n *END**************************************************************************/\r\nstatic uint32_t FLEXCAN_BitrateToTimeSeg(uint32_t bitrate,\r\n                                     uint32_t clkFreq,\r\n                                     flexcan_time_segment_t *timeSeg)\r\n{\r\n    uint32_t dBitrate, tmpBitrate, dBitrateMin, tmpPresdiv, tmpSample,\r\n             dSampleMin, dSample, samplePoint, numTq, pseg1, pseg2, propseg,\r\n             presdiv, tSeg1, tSeg2, tmpPseg1, tmpPseg2, tmpPropseg;\r\n\r\n    presdiv = 0U;\r\n    propseg = 0U;\r\n    pseg1 = 0U;\r\n    pseg2 = 0U;\r\n\r\n    dSampleMin = 100U;\r\n    dBitrateMin = 1000000U;\r\n    samplePoint = 88U;\r\n\r\n    for (tmpPresdiv = 0U; tmpPresdiv < FLEXCAN_PRESDIV_MAX; tmpPresdiv++) {\r\n\r\n        /* Compute the number of time quanta in 1 bit time */\r\n        numTq = clkFreq / ((tmpPresdiv + 1U) * bitrate);\r\n        /* Compute the real bitrate resulted */\r\n        tmpBitrate = clkFreq / ((tmpPresdiv + 1U) * numTq);\r\n\r\n        /* The number of time quanta in 1 bit time must be lower than the one supported */\r\n        if ((numTq >= FLEXCAN_NUM_TQ_MIN) && (numTq < FLEXCAN_NUM_TQ_MAX))\r\n        {\r\n            /* Compute time segments based on the value of the sampling point */\r\n            tSeg1 = (numTq * samplePoint / 100U) - 1U;\r\n            tSeg2 = numTq - 1U - tSeg1;\r\n\r\n            /* Adjust time segment 1 and time segment 2 */\r\n            FLEXCAN_ProccessTSeg(&tSeg1, &tSeg2);\r\n\r\n            tmpPseg2 = tSeg2 - 1U;\r\n\r\n            /* Start from pseg1 = pseg2 and adjust until propseg is valid */\r\n            tmpPseg1 = tmpPseg2;\r\n            tmpPropseg = tSeg1 - tmpPseg1 - 2U;\r\n\r\n            FLEXCAN_ProccessPSeg(&tmpPropseg, &tmpPseg1);\r\n            \r\n\r\n            if (((tSeg1 >= FLEXCAN_TSEG1_MAX) || (tSeg2 >= FLEXCAN_TSEG2_MAX) || (tSeg2 < FLEXCAN_TSEG2_MIN) || (tSeg1 < FLEXCAN_TSEG1_MIN)) ||\r\n               ((tmpPropseg >= FLEXCAN_PROPSEG_MAX) || (tmpPseg1 >= FLEXCAN_PSEG1_MAX) || (tmpPseg2 < FLEXCAN_PSEG2_MIN) || (tmpPseg2 >= FLEXCAN_PSEG2_MAX)))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            tmpSample = ((tSeg1 + 1U) * 100U) / numTq;\r\n            dSample = FLEXCAN_CheckDsample(tmpSample , samplePoint);\r\n            dBitrate = FLEXCAN_CheckdBitrate(tmpBitrate , bitrate);\r\n\r\n            if ((dBitrate < dBitrateMin) ||\r\n                ((dBitrate == dBitrateMin) && (dSample < dSampleMin)))\r\n            {\r\n                dSampleMin = dSample;\r\n                dBitrateMin = dBitrate;\r\n                pseg1 = tmpPseg1;\r\n                pseg2 = tmpPseg2;\r\n                presdiv = tmpPresdiv;\r\n                propseg = tmpPropseg;\r\n\r\n                if ((dBitrate == 0U) && (dSample <= 1U))\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    timeSeg->phaseSeg1 = pseg1;\r\n    timeSeg->phaseSeg2 = pseg2;\r\n    timeSeg->preDivider = presdiv;\r\n    timeSeg->propSeg = propseg;\r\n    timeSeg->rJumpwidth = FLEXCAN_CheckJumpwidth(pseg1);\r\n    return tmpBitrate;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DRV_GetDefaultConfig\r\n * Description   : Gets the default configuration structure\r\n *\r\n * Implements    : FLEXCAN_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nuint32_t FLEXCAN_DRV_GetDefaultConfig(flexcan_user_config_t *config)\r\n{\r\n    /* Checks input parameter. */\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    uint32_t clkFreq, bitrate;\r\n    flexcan_time_segment_t timeSeg;\r\n\r\n    /* Get the PE clock frequency */\r\n    (void) CLOCK_SYS_GetFreq(FEATURE_CAN_PE_OSC_CLK_NAME, &clkFreq);\r\n    /* Means Clock Gate is off */\r\n    DEV_ASSERT(clkFreq > 0U);\r\n    /* Time segments computed for PE bitrate = 500 Kbit/s, sample point = 87.5 */\r\n    bitrate = FLEXCAN_BitrateToTimeSeg(500000U, clkFreq, &timeSeg);\r\n\r\n    /* Maximum number of message buffers */\r\n    config->max_num_mb = 16;\r\n    /* Rx FIFO is disabled */\r\n    config->is_rx_fifo_needed = false;\r\n    /* Number of Rx FIFO ID filters */\r\n    config->num_id_filters = FLEXCAN_RX_FIFO_ID_FILTERS_8;\r\n    /* Normal operation mode */\r\n    config->flexcanMode = FLEXCAN_NORMAL_MODE;\r\n#if FEATURE_CAN_HAS_PE_CLKSRC_SELECT\r\n    /* Protocol engine clock is System Oscillator div 2 */\r\n    config->pe_clock = FLEXCAN_CLK_SOURCE_OSC;\r\n#endif\r\n    /* Time segments for the arbitration phase */\r\n    config->bitrate = timeSeg;\r\n#if FEATURE_CAN_HAS_FD\r\n    /* Payload size */\r\n    config->payload = FLEXCAN_PAYLOAD_SIZE_8;\r\n    /* Flexible data rate is disabled */\r\n    config->fd_enable = false;\r\n    /* Time segments for the data phase of FD frames */\r\n    config->bitrate_cbt = timeSeg;\r\n#endif\r\n    /* Rx FIFO transfer type */\r\n    config->transfer_type = FLEXCAN_RXFIFO_USING_INTERRUPTS;\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    /* Rx FIFO DMA channel */\r\n    config->rxFifoDMAChannel = 0U;\r\n#endif\r\n    return bitrate;\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"flexcan_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef FLEXCAN_DRIVER_H\r\n#define FLEXCAN_DRIVER_H\r\n\r\n#include \"device_registers.h\"\r\n#include \"osif.h\"\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n#include \"edma_driver.h\"\r\n#endif\r\n\r\n/*!\r\n * @defgroup flexcan_driver FlexCAN Driver\r\n * @ingroup flexcan\r\n * @addtogroup flexcan_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*! @brief The type of the RxFIFO transfer (interrupts/DMA).\r\n * Implements : flexcan_rxfifo_transfer_type_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_RXFIFO_USING_INTERRUPTS,    /*!< Use interrupts for RxFIFO. */\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    FLEXCAN_RXFIFO_USING_DMA            /*!< Use DMA for RxFIFO. */\r\n#endif\r\n} flexcan_rxfifo_transfer_type_t;\r\n\r\n/*! @brief The type of the event which occurred when the callback was invoked.\r\n * Implements : flexcan_event_type_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_EVENT_RX_COMPLETE,     /*!< A frame was received in the configured Rx MB. */\r\n    FLEXCAN_EVENT_RXFIFO_COMPLETE, /*!< A frame was received in the Rx FIFO. */\r\n    FLEXCAN_EVENT_RXFIFO_WARNING,  /*!< Rx FIFO is almost full (5 frames). */\r\n    FLEXCAN_EVENT_RXFIFO_OVERFLOW, /*!< Rx FIFO is full (incoming message was lost). */\r\n    FLEXCAN_EVENT_TX_COMPLETE,     /*!< A frame was sent from the configured Tx MB. */\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n    FLEXCAN_EVENT_WAKEUP_TIMEOUT,  /*!< An wake up event occurred due to timeout. */\r\n    FLEXCAN_EVENT_WAKEUP_MATCH,    /*!< An wake up event occurred due to matching. */\r\n    FLEXCAN_EVENT_SELF_WAKEUP,     /*!< A self wake up event occurred. */\r\n#endif /* FEATURE_CAN_HAS_WAKE_UP_IRQ */\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n\tFLEXCAN_EVENT_DMA_COMPLETE,\t  /*!< A complete transfer occurred on DMA */\r\n\tFLEXCAN_EVENT_DMA_ERROR,\t  /*!< A DMA transfer fail, because of a DMA channel error */\r\n#endif /* FEATURE_CAN_HAS_DMA_ENABLE */\r\n    FLEXCAN_EVENT_ERROR\r\n} flexcan_event_type_t;\r\n\r\n/*! @brief The state of a given MB (idle/Rx busy/Tx busy).\r\n * Implements : flexcan_mb_state_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_MB_IDLE,      /*!< The MB is not used by any transfer. */\r\n    FLEXCAN_MB_RX_BUSY,   /*!< The MB is used for a reception. */\r\n    FLEXCAN_MB_TX_BUSY,   /*!< The MB is used for a transmission. */\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n\tFLEXCAN_MB_DMA_ERROR /*!< The MB is used as DMA source and fail to transfer */\r\n#endif\r\n} flexcan_mb_state_t;\r\n\r\n/*! @brief FlexCAN Message Buffer ID type\r\n * Implements : flexcan_msgbuff_id_type_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_MSG_ID_STD,         /*!< Standard ID*/\r\n    FLEXCAN_MSG_ID_EXT          /*!< Extended ID*/\r\n} flexcan_msgbuff_id_type_t;\r\n\r\n#if FEATURE_CAN_HAS_PE_CLKSRC_SELECT\r\n/*! @brief FlexCAN PE clock sources\r\n * Implements : flexcan_clk_source_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_CLK_SOURCE_OSC    = 0U,  /*!< The CAN engine clock source is the oscillator clock. */\r\n    FLEXCAN_CLK_SOURCE_PERIPH = 1U   /*!< The CAN engine clock source is the peripheral clock. */\r\n} flexcan_clk_source_t;\r\n#endif\r\n\r\n/*! @brief FlexCAN message buffer structure\r\n * Implements : flexcan_msgbuff_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t cs;                        /*!< Code and Status*/\r\n    uint32_t msgId;                     /*!< Message Buffer ID*/\r\n    uint8_t data[64];                   /*!< Data bytes of the FlexCAN message*/\r\n    uint8_t dataLen;                    /*!< Length of data in bytes */\r\n} flexcan_msgbuff_t;\r\n\r\n/*! @brief Information needed for internal handling of a given MB.\r\n * Implements : flexcan_mb_handle_t_Class\r\n */\r\ntypedef struct {\r\n    flexcan_msgbuff_t *mb_message;       /*!< The FlexCAN MB structure */\r\n    semaphore_t mbSema;                  /*!< Semaphore used for signaling completion of a blocking transfer */\r\n    volatile flexcan_mb_state_t state;   /*!< The state of the current MB (idle/Rx busy/Tx busy) */\r\n    bool isBlocking;                     /*!< True if the transfer is blocking */\r\n    bool isRemote;                       /*!< True if the frame is a remote frame */\r\n} flexcan_mb_handle_t;\r\n\r\n/*!\r\n * @brief Internal driver state information.\r\n *\r\n * @note The contents of this structure are internal to the driver and should not be\r\n *      modified by users. Also, contents of the structure are subject to change in\r\n *      future releases.\r\n * Implements : flexcan_state_t_Class\r\n */\r\ntypedef struct FlexCANState {\r\n    flexcan_mb_handle_t mbs[FEATURE_CAN_MAX_MB_NUM];           /*!< Array containing information\r\n                                                                    related to each MB */\r\n    void (*callback)(uint8_t instance,\r\n                     flexcan_event_type_t eventType,\r\n                     uint32_t buffIdx,\r\n                     struct FlexCANState *driverState);        /*!< IRQ handler callback function. */\r\n    void *callbackParam;                                       /*!< Parameter used to pass user data\r\n                                                                    when invoking the callback\r\n                                                                    function. */\r\n    void (*error_callback)(uint8_t instance,\r\n                           flexcan_event_type_t eventType,\r\n                           struct FlexCANState *driverState);  /*!< Error IRQ handler callback\r\n                                                                    function. */\r\n    void *errorCallbackParam;                                  /*!< Parameter used to pass user data\r\n                                                                    when invoking the error callback\r\n                                                                    function. */\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    uint8_t rxFifoDMAChannel;                                  /*!< DMA channel number used for\r\n                                                                    transfers. */\r\n#endif\r\n    flexcan_rxfifo_transfer_type_t transferType;               /*!< Type of RxFIFO transfer. */\r\n} flexcan_state_t;\r\n\r\n/*! @brief FlexCAN data info from user\r\n * Implements : flexcan_data_info_t_Class\r\n */\r\ntypedef struct {\r\n    flexcan_msgbuff_id_type_t msg_id_type;  /*!< Type of message ID (standard or extended)*/\r\n    uint32_t data_length;                   /*!< Length of Data in Bytes*/\r\n#if FEATURE_CAN_HAS_FD\r\n    bool fd_enable;                         /*!< Enable or disable FD*/\r\n    uint8_t fd_padding;                     /*!< Set a value for padding. It will be used when the data length code (DLC)\r\n                                                 specifies a bigger payload size than data_length to fill the MB */\r\n    bool enable_brs;                        /*!< Enable bit rate switch inside a CAN FD format frame*/\r\n#endif\r\n    bool is_remote;                         /*!< Specifies if the frame is standard or remote */\r\n} flexcan_data_info_t;\r\n\r\n/*! @brief FlexCAN Rx FIFO filters number\r\n * Implements : flexcan_rx_fifo_id_filter_num_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_8   = 0x0,         /*!<   8 Rx FIFO Filters. @internal gui name=\"8 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_16  = 0x1,         /*!<  16 Rx FIFO Filters. @internal gui name=\"16 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_24  = 0x2,         /*!<  24 Rx FIFO Filters. @internal gui name=\"24 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_32  = 0x3,         /*!<  32 Rx FIFO Filters. @internal gui name=\"32 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_40  = 0x4,         /*!<  40 Rx FIFO Filters. @internal gui name=\"40 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_48  = 0x5,         /*!<  48 Rx FIFO Filters. @internal gui name=\"48 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_56  = 0x6,         /*!<  56 Rx FIFO Filters. @internal gui name=\"56 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_64  = 0x7,         /*!<  64 Rx FIFO Filters. @internal gui name=\"64 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_72  = 0x8,         /*!<  72 Rx FIFO Filters. @internal gui name=\"72 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_80  = 0x9,         /*!<  80 Rx FIFO Filters. @internal gui name=\"80 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_88  = 0xA,         /*!<  88 Rx FIFO Filters. @internal gui name=\"88 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_96  = 0xB,         /*!<  96 Rx FIFO Filters. @internal gui name=\"96 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_104 = 0xC,         /*!< 104 Rx FIFO Filters. @internal gui name=\"104 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_112 = 0xD,         /*!< 112 Rx FIFO Filters. @internal gui name=\"112 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_120 = 0xE,         /*!< 120 Rx FIFO Filters. @internal gui name=\"120 Rx FIFO Filters\" */\r\n    FLEXCAN_RX_FIFO_ID_FILTERS_128 = 0xF          /*!< 128 Rx FIFO Filters. @internal gui name=\"128 Rx FIFO Filters\" */\r\n} flexcan_rx_fifo_id_filter_num_t;\r\n\r\n/*! @brief FlexCAN Rx mask type.\r\n * Implements : flexcan_rx_mask_type_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_RX_MASK_GLOBAL,      /*!< Rx global mask*/\r\n    FLEXCAN_RX_MASK_INDIVIDUAL   /*!< Rx individual mask*/\r\n} flexcan_rx_mask_type_t;\r\n\r\n/*! @brief ID formats for Rx FIFO\r\n * Implements : flexcan_rx_fifo_id_element_format_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_RX_FIFO_ID_FORMAT_A, /*!< One full ID (standard and extended) per ID Filter Table element.*/\r\n    FLEXCAN_RX_FIFO_ID_FORMAT_B, /*!< Two full standard IDs or two partial 14-bit (standard and\r\n                                      extended) IDs per ID Filter Table element.*/\r\n    FLEXCAN_RX_FIFO_ID_FORMAT_C, /*!< Four partial 8-bit Standard IDs per ID Filter Table element.*/\r\n    FLEXCAN_RX_FIFO_ID_FORMAT_D  /*!< All frames rejected.*/\r\n} flexcan_rx_fifo_id_element_format_t;\r\n\r\n/*! @brief FlexCAN Rx FIFO ID filter table structure\r\n * Implements : flexcan_id_table_t_Class\r\n */\r\ntypedef struct {\r\n    bool isRemoteFrame;      /*!< Remote frame*/\r\n    bool isExtendedFrame;    /*!< Extended frame*/\r\n    uint32_t id;             /*!< Rx FIFO ID filter element*/\r\n} flexcan_id_table_t;\r\n\r\n/*! @brief FlexCAN operation modes\r\n * Implements : flexcan_operation_modes_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_NORMAL_MODE,        /*!< Normal mode or user mode @internal gui name=\"Normal\" */\r\n    FLEXCAN_LISTEN_ONLY_MODE,   /*!< Listen-only mode @internal gui name=\"Listen-only\" */\r\n    FLEXCAN_LOOPBACK_MODE,      /*!< Loop-back mode @internal gui name=\"Loop back\" */\r\n    FLEXCAN_FREEZE_MODE,        /*!< Freeze mode @internal gui name=\"Freeze\" */\r\n    FLEXCAN_DISABLE_MODE        /*!< Module disable mode @internal gui name=\"Disabled\" */\r\n} flexcan_operation_modes_t;\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*! @brief FlexCAN payload sizes\r\n * Implements : flexcan_fd_payload_size_t_Class\r\n */\r\ntypedef enum {\r\n    FLEXCAN_PAYLOAD_SIZE_8 = 0,  /*!< FlexCAN message buffer payload size in bytes*/\r\n    FLEXCAN_PAYLOAD_SIZE_16 ,    /*!< FlexCAN message buffer payload size in bytes*/\r\n    FLEXCAN_PAYLOAD_SIZE_32 ,    /*!< FlexCAN message buffer payload size in bytes*/\r\n    FLEXCAN_PAYLOAD_SIZE_64      /*!< FlexCAN message buffer payload size in bytes*/\r\n} flexcan_fd_payload_size_t;\r\n#endif\r\n\r\n/*! @brief FlexCAN bitrate related structures\r\n * Implements : flexcan_time_segment_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t propSeg;         /*!< Propagation segment*/\r\n    uint32_t phaseSeg1;       /*!< Phase segment 1*/\r\n    uint32_t phaseSeg2;       /*!< Phase segment 2*/\r\n    uint32_t preDivider;      /*!< Clock prescaler division factor*/\r\n    uint32_t rJumpwidth;      /*!< Resync jump width*/\r\n} flexcan_time_segment_t;\r\n\r\n/*! @brief FlexCAN configuration\r\n * @internal gui name=\"Common configuration\" id=\"flexcanCfg\"\r\n * Implements : flexcan_user_config_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t max_num_mb;                            /*!< The maximum number of Message Buffers\r\n                                                         @internal gui name=\"Maximum number of message buffers\" id=\"max_num_mb\" */\r\n    flexcan_rx_fifo_id_filter_num_t num_id_filters; /*!< The number of RX FIFO ID filters needed\r\n                                                         @internal gui name=\"Number of RX FIFO ID filters\" id=\"num_id_filters\" */\r\n    bool is_rx_fifo_needed;                         /*!< 1 if needed; 0 if not. This controls whether the Rx FIFO feature is enabled or not.\r\n                                                         @internal gui name=\"Use rx fifo\" id=\"is_rx_fifo_needed\" */\r\n    flexcan_operation_modes_t flexcanMode;          /*!< User configurable FlexCAN operation modes.\r\n                                                         @internal gui name=\"Flexcan Operation Mode\" id=\"flexcanMode\"*/\r\n#if FEATURE_CAN_HAS_FD\r\n    flexcan_fd_payload_size_t payload;              /*!< The payload size of the mailboxes specified in bytes. */\r\n    bool fd_enable;                                 /*!< Enable/Disable the Flexible Data Rate feature. */\r\n#endif\r\n#if FEATURE_CAN_HAS_PE_CLKSRC_SELECT\r\n    flexcan_clk_source_t pe_clock;                  /*!< The clock source of the CAN Protocol Engine (PE). */\r\n#endif\r\n    flexcan_time_segment_t bitrate;                 /*!< The bitrate used for standard frames or for the arbitration phase of FD frames. */\r\n#if FEATURE_CAN_HAS_FD\r\n    flexcan_time_segment_t bitrate_cbt;             /*!< The bitrate used for the data phase of FD frames. */\r\n#endif\r\n    flexcan_rxfifo_transfer_type_t transfer_type;   /*!< Specifies if the Rx FIFO uses interrupts or DMA. */\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n    uint8_t rxFifoDMAChannel;                       /*!< Specifies the DMA channel number to be used for DMA transfers. */\r\n#endif\r\n} flexcan_user_config_t;\r\n\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n\r\n/*! @brief Pretended Networking ID filter */\r\ntypedef struct {\r\n    bool extendedId;    /*!< Specifies if the ID is standard or extended. */\r\n    bool remoteFrame;   /*!< Specifies if the frame is standard or remote. */\r\n    uint32_t id;        /*!< Specifies the ID value. */\r\n} flexcan_pn_id_filter_t;\r\n\r\n/*! @brief Pretended Networking payload filter */\r\ntypedef struct {\r\n    uint8_t dlcLow;       /*!< Specifies the lower limit of the payload size. */\r\n    uint8_t dlcHigh;      /*!< Specifies the upper limit of the payload size. */\r\n    uint8_t payload1[8U]; /*!< Specifies the payload to be matched (for MATCH_EXACT), the lower limit\r\n                              (for MATCH_GEQ and MATCH_RANGE) or the upper limit (for MATCH_LEQ). */\r\n    uint8_t payload2[8U]; /*!< Specifies the mask (for MATCH_EXACT) or the upper limit (for MATCH_RANGE). */\r\n} flexcan_pn_payload_filter_t;\r\n\r\n/*! @brief Pretended Networking filtering combinations */\r\ntypedef enum {\r\n    FLEXCAN_FILTER_ID,                  /*!< Message ID filtering only */\r\n    FLEXCAN_FILTER_ID_PAYLOAD,          /*!< Message ID and payload filtering */\r\n    FLEXCAN_FILTER_ID_NTIMES,           /*!< Message ID filtering occurring a specified number of times */\r\n    FLEXCAN_FILTER_ID_PAYLOAD_NTIMES    /*!< Message ID and payload filtering  occurring a specified number of times */\r\n} flexcan_pn_filter_combination_t;\r\n\r\n/*! @brief Pretended Networking matching schemes */\r\ntypedef enum {\r\n    FLEXCAN_FILTER_MATCH_EXACT,   /*!< Match an exact target value. */\r\n    FLEXCAN_FILTER_MATCH_GEQ,     /*!< Match greater than or equal to a specified target value. */\r\n    FLEXCAN_FILTER_MATCH_LEQ,     /*!< Match less than or equal to a specified target value. */\r\n    FLEXCAN_FILTER_MATCH_RANGE    /*!< Match inside a range, greater than or equal to a specified lower limit and smaller than or\r\n                                      equal to a specified upper limit. */\r\n} flexcan_pn_filter_selection_t;\r\n\r\n/*! @brief Pretended Networking configuration structure\r\n * Implements : flexcan_pn_config_t_Class\r\n */\r\ntypedef struct {\r\n    bool wakeUpTimeout;                               /*!< Specifies if an wake up event is triggered on timeout. */\r\n    bool wakeUpMatch;                                 /*!< Specifies if an wake up event is triggered on match. */\r\n    uint16_t numMatches;                              /*!< The number of matches needed before generating an wake up event. */\r\n    uint16_t matchTimeout;                            /*!< Defines a timeout value that generates an wake up event if wakeUpTimeout is true. */\r\n    flexcan_pn_filter_combination_t filterComb;       /*!< Defines the filtering scheme used. */\r\n    flexcan_pn_id_filter_t idFilter1;                 /*!< The configuration of the first ID filter (match exact / lower limit / upper limit). */\r\n    flexcan_pn_id_filter_t idFilter2;                 /*!< The configuration of the second ID filter (mask / upper limit). */\r\n    flexcan_pn_filter_selection_t idFilterType;       /*!< Defines the ID filtering scheme. */\r\n    flexcan_pn_filter_selection_t payloadFilterType;  /*!< Defines the payload filtering scheme. */\r\n    flexcan_pn_payload_filter_t payloadFilter;        /*!< The configuration of the payload filter. */\r\n} flexcan_pn_config_t;\r\n\r\n#endif /* FEATURE_CAN_HAS_PRETENDED_NETWORKING */\r\n\r\n/*! @brief FlexCAN Driver callback function type\r\n * Implements : flexcan_callback_t_Class\r\n */\r\ntypedef void (*flexcan_callback_t)(uint8_t instance, flexcan_event_type_t eventType,\r\n                                   uint32_t buffIdx, flexcan_state_t *flexcanState);\r\n\r\n/*! @brief FlexCAN Driver error callback function type\r\n * Implements : flexcan_error_callback_t_Class\r\n */\r\ntypedef void (*flexcan_error_callback_t)(uint8_t instance, flexcan_event_type_t eventType,\r\n                                         flexcan_state_t *flexcanState);\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name Bit rate\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sets the FlexCAN bit rate for standard frames or the arbitration phase of FD frames.\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   bitrate     A pointer to the FlexCAN bit rate settings.\r\n */\r\nvoid FLEXCAN_DRV_SetBitrate(uint8_t instance, const flexcan_time_segment_t *bitrate);\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Sets the FlexCAN bit rate for the data phase of FD frames (BRS enabled).\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   bitrate     A pointer to the FlexCAN bit rate settings.\r\n */\r\nvoid FLEXCAN_DRV_SetBitrateCbt(uint8_t instance, const flexcan_time_segment_t *bitrate);\r\n#endif\r\n\r\n/*!\r\n * @brief Gets the FlexCAN bit rate for standard frames or the arbitration phase of FD frames.\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   bitrate     A pointer to a variable for returning the FlexCAN bit rate settings\r\n */\r\nvoid FLEXCAN_DRV_GetBitrate(uint8_t instance, flexcan_time_segment_t *bitrate);\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Gets the FlexCAN bit rate for the data phase of FD frames (BRS enabled).\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   bitrate     A pointer to a variable for returning the FlexCAN bit rate settings\r\n */\r\nvoid FLEXCAN_DRV_GetBitrateFD(uint8_t instance, flexcan_time_segment_t *bitrate);\r\n#endif\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Rx MB and Rx FIFO masks\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sets the Rx masking type.\r\n *\r\n * @param   instance     A FlexCAN instance number\r\n * @param   type         The FlexCAN RX mask type\r\n */\r\nvoid FLEXCAN_DRV_SetRxMaskType(uint8_t instance, flexcan_rx_mask_type_t type);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx FIFO global mask (standard or extended).\r\n * This mask is applied to all filters ID regardless the ID Filter format.\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   id_type     Standard ID or extended ID mask type\r\n * @param   mask        Mask Value. In FIFO mode, when using ID Format A or B, \r\n                        bit 31 encodes RTR check and bit 30 encodes IDE check respectively. \r\n                        For ID Format C, bits 31 and 30 are ignored.\r\n */\r\nvoid FLEXCAN_DRV_SetRxFifoGlobalMask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx MB global mask (standard or extended).\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   id_type     Standard ID or extended ID\r\n * @param   mask        Mask value\r\n */\r\nvoid FLEXCAN_DRV_SetRxMbGlobalMask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx MB 14 mask (standard or extended).\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   id_type     Standard ID or extended ID\r\n * @param   mask        Mask value\r\n */\r\nvoid FLEXCAN_DRV_SetRxMb14Mask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx MB 15 mask (standard or extended).\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   id_type     Standard ID or extended ID\r\n * @param   mask        Mask value\r\n */\r\nvoid FLEXCAN_DRV_SetRxMb15Mask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint32_t mask);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx individual mask (standard or extended).\r\n *\r\n * @param   instance  A FlexCAN instance number\r\n * @param   id_type   A standard ID or an extended ID\r\n * @param   mb_idx    Index of the message buffer\r\n * @param   mask      Mask Value. In FIFO mode, when using ID Format A or B, \r\n                      bit 31 encodes RTR check and bit 30 encodes IDE check respectively. \r\n                      For ID Format C, bits 31 and 30 are ignored.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of the\r\n *          message buffer is invalid.\r\n */\r\nstatus_t FLEXCAN_DRV_SetRxIndividualMask(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_id_type_t id_type,\r\n    uint8_t mb_idx,\r\n    uint32_t mask);\r\n    \r\n/*@}*/\r\n \r\n/*!\r\n * @name Initialization and Shutdown\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Gets the default configuration structure\r\n *\r\n * This function gets the default configuration structure, with the following settings:\r\n * - 16 message buffers\r\n * - flexible data rate disabled\r\n * - Rx FIFO disabled\r\n * - normal operation mode\r\n * - 8 byte payload size\r\n * - Protocol Engine clock = Oscillator clock\r\n * - bitrate of 500 Kbit/s (computed for sample point = 87.5)\r\n *\r\n * @param[out] config The configuration structure\r\n * @return The bitrate for generated configuration structure.\r\n */\r\nuint32_t FLEXCAN_DRV_GetDefaultConfig(flexcan_user_config_t *config);\r\n\r\n/*!\r\n * @brief Initializes the FlexCAN peripheral.\r\n *\r\n * This function initializes\r\n * @param   instance                   A FlexCAN instance number\r\n * @param   state                      Pointer to the FlexCAN driver state structure.\r\n * @param   data                       The FlexCAN platform data\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of a message buffer is invalid;\r\n *          STATUS_ERROR if other error occurred\r\n */\r\nstatus_t FLEXCAN_DRV_Init(\r\n       uint8_t instance,\r\n       flexcan_state_t *state,\r\n       const flexcan_user_config_t *data);\r\n\r\n/*!\r\n * @brief Shuts down a FlexCAN instance.\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_ERROR if failed\r\n */\r\nstatus_t FLEXCAN_DRV_Deinit(uint8_t instance);\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Enables/Disables the Transceiver Delay Compensation feature and sets\r\n * the Transceiver Delay Compensation Offset (offset value to be added to the\r\n * measured transceiver's loop delay in order to define the position of the\r\n * delayed comparison point when bit rate switching is active).\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   enable Enable/Disable Transceiver Delay Compensation\r\n * @param   offset Transceiver Delay Compensation Offset\r\n */\r\nvoid FLEXCAN_DRV_SetTDCOffset(uint8_t instance, bool enable, uint8_t offset);\r\n\r\n/*!\r\n * @brief Gets the value of the Transceiver Delay Compensation.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  The value of the transceiver loop delay measured from the transmitted\r\n * EDL to R0 transition edge to the respective received one added to the TDCOFF\r\n * value specified by FLEXCAN_HAL_SetTDCOffset.\r\n */\r\nuint8_t FLEXCAN_DRV_GetTDCValue(uint8_t instance);\r\n\r\n/*!\r\n * @brief Gets the value of the TDC Fail flag.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  If true, indicates that the TDC mechanism is out of range, unable to\r\n * compensate the transceiver's loop delay and successfully compare the delayed\r\n * received bits to the transmitted ones.\r\n */\r\nbool FLEXCAN_DRV_GetTDCFail(uint8_t instance);\r\n\r\n/*!\r\n * @brief Clears the TDC Fail flag.\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nvoid FLEXCAN_DRV_ClearTDCFail(uint8_t instance);\r\n#endif\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Send configuration\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief FlexCAN transmit message buffer field configuration.\r\n *\r\n * @param   instance                   A FlexCAN instance number\r\n * @param   mb_idx                     Index of the message buffer\r\n * @param   tx_info                    Data info\r\n * @param   msg_id                     ID of the message to transmit\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of the message buffer is invalid\r\n */\r\nstatus_t FLEXCAN_DRV_ConfigTxMb(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id);\r\n\r\n/*!\r\n * @brief Configures a transmit message buffer for remote frame response.\r\n *\r\n * @param   instance                   A FlexCAN instance number\r\n * @param   mb_idx                     Index of the message buffer\r\n * @param   tx_info                    Data info\r\n * @param   msg_id                     ID of the message to transmit\r\n * @param   mb_data                    Bytes of the FlexCAN message\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of the message buffer\r\n *          is invalid\r\n */\r\nstatus_t FLEXCAN_DRV_ConfigRemoteResponseMb(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id,\r\n    const uint8_t *mb_data);\r\n\r\n/*!\r\n * @brief Sends a CAN frame using the specified message buffer, in a blocking manner.\r\n *\r\n * This function sends a CAN frame using a configured message buffer. The function\r\n * blocks until either the frame was sent, or the specified timeout expired.\r\n *\r\n * @param   instance   A FlexCAN instance number\r\n * @param   mb_idx     Index of the message buffer\r\n * @param   tx_info    Data info\r\n * @param   msg_id     ID of the message to transmit\r\n * @param   mb_data    Bytes of the FlexCAN message\r\n * @param   timeout_ms A timeout for the transfer in milliseconds.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of a message buffer is invalid;\r\n *          STATUS_BUSY if a resource is busy;\r\n *          STATUS_TIMEOUT if the timeout is reached\r\n */\r\nstatus_t FLEXCAN_DRV_SendBlocking(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id,\r\n    const uint8_t *mb_data,\r\n    uint32_t timeout_ms);\r\n\r\n/*!\r\n * @brief Sends a CAN frame using the specified message buffer.\r\n *\r\n * This function sends a CAN frame using a configured message buffer. The function\r\n * returns immediately. If a callback is installed, it will be invoked after\r\n * the frame was sent.\r\n *\r\n * @param   instance   A FlexCAN instance number\r\n * @param   mb_idx     Index of the message buffer\r\n * @param   tx_info    Data info\r\n * @param   msg_id     ID of the message to transmit\r\n * @param   mb_data    Bytes of the FlexCAN message.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of a message buffer is invalid;\r\n *          STATUS_BUSY if a resource is busy\r\n */\r\nstatus_t FLEXCAN_DRV_Send(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *tx_info,\r\n    uint32_t msg_id,\r\n    const uint8_t *mb_data);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Receive configuration\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief FlexCAN receive message buffer field configuration\r\n *\r\n * @param   instance                   A FlexCAN instance number\r\n * @param   mb_idx                     Index of the message buffer\r\n * @param   rx_info                    Data info\r\n * @param   msg_id                     ID of the message to transmit\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of a message buffer is invalid;\r\n */\r\nstatus_t FLEXCAN_DRV_ConfigRxMb(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    const flexcan_data_info_t *rx_info,\r\n    uint32_t msg_id);\r\n\r\n/*!\r\n * @brief FlexCAN Rx FIFO field configuration\r\n *\r\n * @note The number of elements in the ID filter table is defined by the\r\n *       following formula:\r\n *       - for format A: the number of Rx FIFO ID filters\r\n *       - for format B: twice the number of Rx FIFO ID filters\r\n *       - for format C: four times the number of Rx FIFO ID filters\r\n *       The user must provide the exact number of elements in order to avoid\r\n *       any misconfiguration.\r\n *\r\n *       Each element in the ID filter table specifies an ID to be used as\r\n *       acceptance criteria for the FIFO as follows:\r\n *       - for format A: In the standard frame format, bits 10 to 0 of the ID\r\n *         are used for frame identification. In the extended frame format, bits\r\n *         28 to 0 are used.\r\n *       - for format B: In the standard frame format, bits 10 to 0 of the ID\r\n *         are used for frame identification. In the extended frame format, only\r\n *         the 14 most significant bits (28 to 15) of the ID are compared to the\r\n *         14 most significant bits (28 to 15) of the received ID.\r\n *       - for format C: In both standard and extended frame formats, only the 8\r\n *         most significant bits (7 to 0 for standard, 28 to 21 for extended) of\r\n *         the ID are compared to the 8 most significant bits (7 to 0 for\r\n *         standard, 28 to 21 for extended) of the received ID.\r\n *\r\n * @param   instance           A FlexCAN instance number\r\n * @param   id_format          The format of the Rx FIFO ID Filter Table Elements\r\n * @param   id_filter_table    The ID filter table elements which contain RTR\r\n *                             bit, IDE bit, and Rx message ID\r\n */\r\nvoid FLEXCAN_DRV_ConfigRxFifo(\r\n    uint8_t instance,\r\n    flexcan_rx_fifo_id_element_format_t id_format,\r\n    const flexcan_id_table_t *id_filter_table);\r\n\r\n/*!\r\n * @brief Receives a CAN frame using the specified message buffer, in a blocking manner.\r\n *\r\n * This function receives a CAN frame using a configured message buffer. The function\r\n * blocks until either a frame was received, or the specified timeout expired.\r\n *\r\n * @param   instance   A FlexCAN instance number\r\n * @param   mb_idx     Index of the message buffer\r\n * @param   data       The FlexCAN receive message buffer data.\r\n * @param   timeout_ms A timeout for the transfer in milliseconds.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of a message buffer is invalid;\r\n *          STATUS_BUSY if a resource is busy;\r\n *          STATUS_TIMEOUT if the timeout is reached\r\n */\r\nstatus_t FLEXCAN_DRV_ReceiveBlocking(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    flexcan_msgbuff_t *data,\r\n    uint32_t timeout_ms);\r\n\r\n/*!\r\n * @brief Receives a CAN frame using the specified message buffer.\r\n *\r\n * This function receives a CAN frame using a configured message buffer. The function\r\n * returns immediately. If a callback is installed, it will be invoked after\r\n * the frame was received and read into the specified buffer.\r\n *\r\n * @param   instance   A FlexCAN instance number\r\n * @param   mb_idx     Index of the message buffer\r\n * @param   data       The FlexCAN receive message buffer data.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_BUFF_OUT_OF_RANGE if the index of a message buffer is invalid;\r\n *          STATUS_BUSY if a resource is busy\r\n */\r\nstatus_t FLEXCAN_DRV_Receive(\r\n    uint8_t instance,\r\n    uint8_t mb_idx,\r\n    flexcan_msgbuff_t *data);\r\n\r\n/*!\r\n * @brief Receives a CAN frame using the message FIFO, in a blocking manner.\r\n *\r\n * This function receives a CAN frame using the Rx FIFO. The function blocks until\r\n * either a frame was received, or the specified timeout expired.\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   data        The FlexCAN receive message buffer data.\r\n * @param   timeout_ms  A timeout for the transfer in milliseconds.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_BUSY if a resource is busy;\r\n *          STATUS_TIMEOUT if the timeout is reached;\r\n *          STATUS_ERROR if other error occurred\r\n */\r\nstatus_t FLEXCAN_DRV_RxFifoBlocking(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_t *data,\r\n    uint32_t timeout_ms);\r\n\r\n/*!\r\n * @brief Receives a CAN frame using the message FIFO.\r\n *\r\n * This function receives a CAN frame using the Rx FIFO. The function returns\r\n * immediately. If a callback is installed, it will be invoked after the frame\r\n * was received and read into the specified buffer.\r\n *\r\n * @param   instance    A FlexCAN instance number\r\n * @param   data        The FlexCAN receive message buffer data.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_BUSY if a resource is busy;\r\n *          STATUS_ERROR if other error occurred\r\n */\r\nstatus_t FLEXCAN_DRV_RxFifo(\r\n    uint8_t instance,\r\n    flexcan_msgbuff_t *data);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Transfer status\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Ends a non-blocking FlexCAN transfer early.\r\n *\r\n * @param   instance   A FlexCAN instance number\r\n * @param   mb_idx     The index of the message buffer\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_CAN_NO_TRANSFER_IN_PROGRESS if no transfer was running\r\n */\r\nstatus_t FLEXCAN_DRV_AbortTransfer(uint8_t instance, uint8_t mb_idx);\r\n\r\n/*!\r\n * @brief Returns whether the previous FlexCAN transfer has finished.\r\n *\r\n * When performing an async transfer, call this function to ascertain the state of the\r\n * current transfer: in progress (or busy) or complete (success).\r\n *\r\n * @param instance The FlexCAN instance number.\r\n * @param mb_idx The index of the message buffer.\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_BUSY if a resource is busy;\r\n *         STATUS_ERROR in case of a DMA error transfer;\r\n */\r\nstatus_t FLEXCAN_DRV_GetTransferStatus(uint8_t instance, uint8_t mb_idx);\r\n\r\n/*!\r\n * @brief Returns reported error conditions.\r\n *\r\n * Reports various error conditions detected in the reception and transmission of a CAN frame\r\n * and some general status of the device.\r\n *\r\n * @param instance The FlexCAN instance number.\r\n * @return value of the Error and Status 1 register;\r\n */\r\nuint32_t FLEXCAN_DRV_GetErrorStatus(uint8_t instance);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name IRQ handler callback\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Installs a callback function for the IRQ handler.\r\n *\r\n * @param instance The FlexCAN instance number.\r\n * @param callback The callback function.\r\n * @param callbackParam User parameter passed to the callback function through the state parameter.\r\n */\r\nvoid FLEXCAN_DRV_InstallEventCallback(uint8_t instance,\r\n                                      flexcan_callback_t callback,\r\n                                      void *callbackParam);\r\n\r\n/*!\r\n * @brief Installs an error callback function for the IRQ handler and enables error interrupts.\r\n *\r\n * @param instance The FlexCAN instance number.\r\n * @param callback The error callback function.\r\n * @param callbackParam User parameter passed to the error callback function through the state\r\n *                      parameter.\r\n */\r\nvoid FLEXCAN_DRV_InstallErrorCallback(uint8_t instance,\r\n                                      flexcan_error_callback_t callback,\r\n                                      void *callbackParam);\r\n\r\n/*@}*/\r\n\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n\r\n/*!\r\n * @name Pretended Networking\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Configures Pretended Networking settings.\r\n *\r\n * @param instance The FlexCAN instance number.\r\n * @param enable Enable/Disable Pretended Networking mode.\r\n * @param pnConfig Pointer to the Pretended Networking configuration structure.\r\n */\r\nvoid FLEXCAN_DRV_ConfigPN(uint8_t instance, bool enable, const flexcan_pn_config_t *pnConfig);\r\n\r\n/*!\r\n * @brief Extracts one of the frames which triggered the wake up event.\r\n *\r\n * @param   instance    The FlexCAN instance number.\r\n * @param   wmbIndex  The index of the message buffer to be extracted.\r\n * @param   wmb  Pointer to the message buffer structure where the frame will be saved.\r\n */\r\nvoid FLEXCAN_DRV_GetWMB(uint8_t instance, uint8_t wmbIndex, flexcan_msgbuff_t *wmb);\r\n\r\n/*@}*/\r\n\r\n#endif /* FEATURE_CAN_HAS_PRETENDED_NETWORKING */\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* FLEXCAN_DRIVER_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"flexcan_hw_access.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file flexcan_hw_access.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 15.5, Return statement before end of function.\r\n * The return statement before end of function is used for simpler code structure\r\n * and better readability.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.3, cast performed between a pointer to\r\n * object type and a pointer to a different object type\r\n * The cast is used for casting a bytes buffer into an words buffer in order to\r\n * optimize copying data to/from the message buffer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 2.2, Last value assigned to variable not\r\n * used\r\n * The values of the reported variables are changed by the REV_BYTES_32 macro,\r\n * which uses inline assembly.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be\r\n * performed between a pointer to object and an integer type.\r\n * The cast is required as CAN instance base addresses are defined as unsigned\r\n * integers in the header file, but the registers are accessed via pointers to\r\n * structures.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A conversion should not be\r\n * performed between a pointer to object and an integer type.\r\n * The cast is required as CAN instance base addresses are defined as unsigned\r\n * integers in the header file, but the registers are accessed via pointers to\r\n * structures.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, Variable not defined with external linkage\r\n * The variables are defined in the driver header file to make transition to other\r\n * platforms easier.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro\r\n * Function-like macros are used instead of inline functions in order to ensure\r\n * that the performance will not be decreased if the functions will not be\r\n * inlined by the compiler.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, Taking address of near auto variable\r\n * The code is not dynamically linked. An absolute stack address is obtained when\r\n * taking the address of the near auto variable. A source of error in writing\r\n * dynamic code is that the stack segment may be different from the data segment.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 18.1, Possible creation of out-of-bounds pointer.\r\n * The function FlexcanSwapBytesInWordIndex guards the index to don't exceed the MB\r\n * space\r\n *\r\n */\r\n\r\n#include \"flexcan_hw_access.h\"\r\n\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n \r\n#define FLEXCAN_ALL_INT                                  (0x3B0006U)    /*!< Masks for wakeup, error, bus off*/\r\n#define BUS_OFF_INT\t\t\t\t\t\t\t\t\t\t (0xB0004U)\t\t/*!< Masks for busOff, Tx/Rx Warning */\r\n#if !(defined(CPU_S32K116) || defined(CPU_S32K118))\r\n#define ERROR_INT\t\t\t\t\t\t\t\t\t\t (0x300002U)\t/*!< Masks for ErrorOvr, ErrorFast, Error */\r\n#endif\r\n\r\n/* CAN FD extended data length DLC encoding */\r\n#define CAN_DLC_VALUE_12_BYTES                   9U\r\n#define CAN_DLC_VALUE_16_BYTES                   10U\r\n#define CAN_DLC_VALUE_20_BYTES                   11U\r\n#define CAN_DLC_VALUE_24_BYTES                   12U\r\n#define CAN_DLC_VALUE_32_BYTES                   13U\r\n#define CAN_DLC_VALUE_48_BYTES                   14U\r\n#define CAN_DLC_VALUE_64_BYTES                   15U\r\n\r\n#define RxFifoFilterTableOffset         0x18U\r\n\r\n#define FlexCanRxFifoAcceptRemoteFrame   1UL\r\n#define FlexCanRxFifoAcceptExtFrame      1UL\r\n\r\n/*******************************************************************************\r\n * Private Functions\r\n ******************************************************************************/\r\n\r\nstatic uint8_t FLEXCAN_ComputeDLCValue(uint8_t payloadSize);\r\nstatic uint8_t FLEXCAN_ComputePayloadSize(uint8_t dlcValue);\r\nstatic void FLEXCAN_ClearRAM(CAN_Type * base);\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\nstatic uint32_t FLEXCAN_DeserializeUint32(const uint8_t *buffer);\r\n\r\nstatic uint32_t FLEXCAN_DeserializeUint32(const uint8_t *buffer)\r\n{\r\n    uint32_t value = 0;\r\n\r\n    #ifdef CORE_LITTLE_ENDIAN\r\n        value |= (uint32_t)buffer[3] << 24U;\r\n        value |= (uint32_t)buffer[2] << 16U;\r\n        value |= (uint32_t)buffer[1] << 8U;\r\n        value |= (uint32_t)buffer[0];\r\n    #elif (defined CORE_BIG_ENDIAN)\r\n        value |= (uint32_t)buffer[0] << 24U;\r\n        value |= (uint32_t)buffer[1] << 16U;\r\n        value |= (uint32_t)buffer[2] << 8U;\r\n        value |= (uint32_t)buffer[3];\r\n    #endif\r\n        return value;\r\n}\r\ninline static uint32_t FLEXCAN_DataTransferTxMsgBuff(volatile uint32_t *flexcan_mb_data_32,\r\n\t\t\t\t\t\t\t\t\t\t\t\t const flexcan_msgbuff_code_status_t *cs,\r\n\t\t\t\t\t\t\t\t\t\t\t\t const uint8_t *msgData);\r\n#endif\r\n\r\n/* Determines the RxFIFO Filter element number */\r\n#define RxFifoFilterElementNum(x) (((x) + 1U) * 8U)\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_GetRxFifoMask\r\n * Description   : Calculate the Global Mask as format ID type in FIFO Mode.\r\n * Based on the ID format type and Mask Type will calculate the and set accordingly\r\n * the Rx FIFO Individual\\Global Mask register.\r\n *\r\n *END**************************************************************************/\r\nuint32_t FLEXCAN_GetRxFifoMask(\t flexcan_msgbuff_id_type_t id_type,\r\n                                 flexcan_rx_fifo_id_element_format_t formatType,\r\n                                 uint32_t mask)\r\n{\r\n    uint32_t val=0;\r\n    \r\n    switch (formatType)\r\n\t    {\r\n\t\tcase (FLEXCAN_RX_FIFO_ID_FORMAT_A):\r\n\t\t\t/* Set RTR bit encoded as bit 31 and IDE bit encoded as bit 30 in mask */\r\n\t\t\tval = mask & ((1UL<<FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT) | (1UL<<FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT));\r\n\t\t\tif (id_type == FLEXCAN_MSG_ID_STD)\r\n\t\t\t{\r\n\t\t\t\t/* Set standard global mask for RX FIFO and IDE will be 1 and check the FIFO filter ide */\r\n\t\t\t\tval |= ((mask << FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT) & FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_STD_MASK);\r\n\r\n\t\t\t}\r\n\t\t\telse if (id_type == FLEXCAN_MSG_ID_EXT)\r\n\t\t\t{\r\n\t\t\t\t/* Set extended global mask for RX FIFO and IDE will be 0 and don't check the FIFO filter ide */\r\n\t\t\t\tval |= ((mask << FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT) & FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t/* Should not get here */\r\n\t\t\t}\r\n\t\tbreak;\r\n\t\tcase (FLEXCAN_RX_FIFO_ID_FORMAT_B):\r\n\t\t\t/* Set RTR bit encoded as bit 31 and IDE bit encoded as bit 30 in mask */\r\n\t\t\tval = mask & ((1UL<<FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT) | (1UL<<FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT));\r\n\t\t\tif (id_type == FLEXCAN_MSG_ID_STD)\r\n\t\t\t{\r\n\t\t\t\t/* Set standard global mask for RX FIFO  */\r\n\t\t\t\tval |= ((mask & FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) << FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1);\r\n\r\n\t\t\t}\r\n\t\t\telse if (id_type == FLEXCAN_MSG_ID_EXT)\r\n\t\t\t{\r\n\t\t\t\t/* Set extended global mask for RX FIFO  */\r\n\t\t\t\tval |= ((mask & FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK1) <<  FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t/* Should not get here */\r\n\t\t\t}\r\n\t\tbreak;\r\n\t\tcase (FLEXCAN_RX_FIFO_ID_FORMAT_C):\r\n\t\t\tif ((id_type == FLEXCAN_MSG_ID_EXT) || (id_type == FLEXCAN_MSG_ID_STD))\r\n\t\t\t{\r\n\t\t\t\tval |= ((mask & FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_MASK) << FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT1);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t/* Should not get here */\r\n\t\t\t}\r\n\t\tbreak;\r\n\t\tcase (FLEXCAN_RX_FIFO_ID_FORMAT_D):\r\n\t\t\t\t/* Format not supported.*/\r\n\t\tbreak;\r\n        default:\r\n            /* Should not get here */\r\n        break;\r\n\t    }/* End Switch */\r\n\r\n    return val;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name: FLEXCAN_ComputeDLCValue\r\n * Description  : Computes the DLC field value, given a payload size (in bytes).\r\n *\r\n *END**************************************************************************/\r\nstatic uint8_t FLEXCAN_ComputeDLCValue(\r\n        uint8_t payloadSize)\r\n{\r\n    uint32_t ret = 0xFFU;     \t\t\t\t/* 0,  1,  2,  3,  4,  5,  6,  7,  8, */\r\n    static const uint8_t payload_code[65] = { 0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U,\r\n    \t\t\t\t\t\t/* 9 to 12 payload have DLC Code 12 Bytes */\r\n    \t\t\t\t\tCAN_DLC_VALUE_12_BYTES, CAN_DLC_VALUE_12_BYTES, CAN_DLC_VALUE_12_BYTES, CAN_DLC_VALUE_12_BYTES,\r\n\t\t\t\t\t\t\t/* 13 to 16 payload have DLC Code 16 Bytes */\r\n\t\t\t\t\t\tCAN_DLC_VALUE_16_BYTES, CAN_DLC_VALUE_16_BYTES, CAN_DLC_VALUE_16_BYTES, CAN_DLC_VALUE_16_BYTES,\r\n    \t\t\t\t\t\t/* 17 to 20 payload have DLC Code 20 Bytes */\r\n\t\t\t\t\t\tCAN_DLC_VALUE_20_BYTES, CAN_DLC_VALUE_20_BYTES, CAN_DLC_VALUE_20_BYTES, CAN_DLC_VALUE_20_BYTES,\r\n\t\t\t\t\t\t\t/* 21 to 24 payload have DLC Code 24 Bytes */\r\n\t\t\t\t\t\tCAN_DLC_VALUE_24_BYTES, CAN_DLC_VALUE_24_BYTES, CAN_DLC_VALUE_24_BYTES, CAN_DLC_VALUE_24_BYTES,\r\n\t\t\t\t\t\t\t/* 25 to 32 payload have DLC Code 32 Bytes */\r\n\t\t\t\t\t\tCAN_DLC_VALUE_32_BYTES, CAN_DLC_VALUE_32_BYTES, CAN_DLC_VALUE_32_BYTES, CAN_DLC_VALUE_32_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_32_BYTES, CAN_DLC_VALUE_32_BYTES, CAN_DLC_VALUE_32_BYTES, CAN_DLC_VALUE_32_BYTES,\r\n\t\t\t\t\t\t\t/* 33 to 48 payload have DLC Code 48 Bytes */\r\n\t\t\t\t\t\tCAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES, CAN_DLC_VALUE_48_BYTES,\r\n\t\t\t\t\t\t\t/* 49 to 64 payload have DLC Code 64 Bytes */\r\n\t\t\t\t\t\tCAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES,\r\n\t\t\t\t\t\tCAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES, CAN_DLC_VALUE_64_BYTES };\r\n\r\n    if (payloadSize <= 64U)\r\n    {\r\n    \tret = payload_code[payloadSize];\r\n    }\r\n    else\r\n    {\r\n        /* The argument is not a valid payload size will return 0xFF*/\r\n    }\r\n\r\n    return (uint8_t)ret;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ComputePayloadSize\r\n * Description   : Computes the maximum payload size (in bytes), given a DLC\r\n * field value.\r\n *\r\n *END**************************************************************************/\r\nstatic uint8_t FLEXCAN_ComputePayloadSize(\r\n        uint8_t dlcValue)\r\n{\r\n    uint8_t ret=0U;\r\n\r\n    if (dlcValue <= 8U)\r\n    {\r\n        ret = dlcValue;\r\n    }\r\n    else\r\n    {\r\n        switch (dlcValue) {\r\n        case CAN_DLC_VALUE_12_BYTES:\r\n            ret = 12U;\r\n            break;\r\n        case CAN_DLC_VALUE_16_BYTES:\r\n            ret = 16U;\r\n            break;\r\n        case CAN_DLC_VALUE_20_BYTES:\r\n            ret = 20U;\r\n            break;\r\n        case CAN_DLC_VALUE_24_BYTES:\r\n            ret = 24U;\r\n            break;\r\n        case CAN_DLC_VALUE_32_BYTES:\r\n            ret = 32U;\r\n            break;\r\n        case CAN_DLC_VALUE_48_BYTES:\r\n            ret = 48U;\r\n            break;\r\n        case CAN_DLC_VALUE_64_BYTES:\r\n            ret = 64U;\r\n            break;\r\n        default:\r\n            /* The argument is not a valid DLC size */\r\n            break;\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_GetMaxMbNum\r\n * Description   : Computes the maximum RAM size occupied by MBs.\r\n *\r\n *END**************************************************************************/\r\nuint32_t FLEXCAN_GetMaxMbNum(const CAN_Type * base)\r\n{\r\n    uint32_t i, ret = 0;\r\n    static CAN_Type * const flexcanBase[] = CAN_BASE_PTRS;\r\n    static const uint32_t maxMbNum[] = FEATURE_CAN_MAX_MB_NUM_ARRAY;\r\n\r\n    for (i = 0; i < CAN_INSTANCE_COUNT; i++)\r\n    {\r\n        if (base == flexcanBase[i])\r\n        {\r\n            ret = maxMbNum[i];\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ClearRAM\r\n * Description   : Clears FlexCAN memory positions that require initialization.\r\n *\r\n *END**************************************************************************/\r\nstatic void FLEXCAN_ClearRAM(CAN_Type * base)\r\n{\r\n    uint32_t databyte;\r\n    uint32_t RAM_size = FLEXCAN_GetMaxMbNum(base) * 4U;\r\n    uint32_t RXIMR_size = FLEXCAN_GetMaxMbNum(base);\r\n    volatile uint32_t *RAM = base->RAMn;\r\n\r\n    /* Clear MB region */\r\n    for (databyte = 0; databyte < RAM_size; databyte++) {\r\n        RAM[databyte] = 0x0;\r\n    }\r\n\r\n    RAM = base->RXIMR;\r\n\r\n    /* Clear RXIMR region */\r\n    for (databyte = 0; databyte < RXIMR_size; databyte++) {\r\n        RAM[databyte] = 0x0;\r\n    }\r\n\r\n#if defined(S32V23x_SERIES)\r\n\r\n    /* Set WRMFRZ bit in CTRL2 Register to grant write access to memory */\r\n    base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_WRMFRZ_MASK) | CAN_CTRL2_WRMFRZ(1U);\r\n\r\n    uint32_t ram_addr = (uint32_t)base + (uint32_t)FEATURE_CAN_RAM_OFFSET;\r\n    RAM = (volatile uint32_t *)ram_addr;\r\n\r\n    /* Clear RXMGMASK, RXFGMASK, RX14MASK, RX15MASK RAM mapping */\r\n    RAM[FEATURE_CAN_RXMGMASK_RAM_ADDRESS_OFFSET] = 0;\r\n    RAM[FEATURE_CAN_RXFGMASK_RAM_ADDRESS_OFFSET] = 0;\r\n    RAM[FEATURE_CAN_RX14MASK_RAM_ADDRESS_OFFSET] = 0;\r\n    RAM[FEATURE_CAN_RX15MASK_RAM_ADDRESS_OFFSET] = 0;\r\n    \r\n    /* Clear SMB FD region */\r\n    for (databyte = FEATURE_CAN_SMB_FD_START_ADDRESS_OFFSET; databyte < (uint32_t)FEATURE_CAN_SMB_FD_END_ADDRESS_OFFSET; databyte++) {\r\n            RAM[databyte] = 0;\r\n    }\r\n\r\n    /* Clear WRMFRZ bit in CTRL2 Register to restrict write access to memory */\r\n    base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_WRMFRZ_MASK) | CAN_CTRL2_WRMFRZ(0U);\r\n\r\n#endif\r\n}\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n \r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_GetMsgBuffRegion\r\n * Description   : Returns the start of a MB area, based on its index.\r\n *\r\n *END**************************************************************************/\r\nvolatile uint32_t* FLEXCAN_GetMsgBuffRegion(\r\n        CAN_Type * base,\r\n        uint32_t msgBuffIdx)\r\n{\r\n#if FEATURE_CAN_HAS_FD\r\n    uint8_t payload_size = FLEXCAN_GetPayloadSize(base);\r\n#else\r\n    uint8_t payload_size = 8U;\r\n#endif\r\n\r\n    uint8_t arbitration_field_size = 8U;\r\n    uint32_t ramBlockSize = 512U;\r\n    uint32_t ramBlockOffset;\r\n\r\n    uint8_t mb_size = (uint8_t)(payload_size + arbitration_field_size);\r\n    uint8_t maxMbNum = (uint8_t)(ramBlockSize / mb_size);\r\n\r\n    ramBlockOffset = 128U * (msgBuffIdx / (uint32_t)maxMbNum);\r\n\r\n    /* Multiply the MB index by the MB size (in words) */\r\n    uint32_t mb_index = ramBlockOffset + ((msgBuffIdx % (uint32_t)maxMbNum) * ((uint32_t)mb_size >> 2U));\r\n\r\n    return &(base->RAMn[mb_index]);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_Enable\r\n * Description   : Enable FlexCAN module.\r\n * This function will enable FlexCAN module.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_Enable(CAN_Type * base)\r\n{\r\n    /* Check for low power mode */\r\n    if(((base->MCR & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT) == 1U)\r\n    {\r\n        /* Enable clock */\r\n        base->MCR = (base->MCR & ~CAN_MCR_MDIS_MASK) | CAN_MCR_MDIS(0U);\r\n        base->MCR = (base->MCR & ~CAN_MCR_FRZ_MASK) | CAN_MCR_FRZ(0U);\r\n        base->MCR = (base->MCR & ~CAN_MCR_HALT_MASK) | CAN_MCR_HALT(0U);\r\n        /* Wait until enabled */\r\n        while (((base->MCR & CAN_MCR_NOTRDY_MASK) >> CAN_MCR_NOTRDY_SHIFT) != 0U) {}\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_Disable\r\n * Description   : Disable FlexCAN module.\r\n * This function will disable FlexCAN module.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_Disable(CAN_Type * base)\r\n{\r\n    /* To access the memory mapped registers */\r\n    /* Entre disable mode (hard reset). */\r\n    if(((base->MCR & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT) == 0U)\r\n    {\r\n        /* Clock disable (module) */\r\n        base->MCR = (base->MCR & ~CAN_MCR_MDIS_MASK) | CAN_MCR_MDIS(1U);\r\n\r\n        /* Wait until disable mode acknowledged */\r\n        while (((base->MCR & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT) == 0U) {}\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_Init\r\n * Description   : Initialize FlexCAN module.\r\n * This function will reset FlexCAN module, set maximum number of message\r\n * buffers, initialize all message buffers as inactive, enable RX FIFO\r\n * if needed, mask all mask bits, and disable all MB interrupts.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_Init(CAN_Type * base)\r\n{\r\n    /* Reset the FLEXCAN */\r\n    base->MCR = (base->MCR & ~CAN_MCR_SOFTRST_MASK) | CAN_MCR_SOFTRST(1U);\r\n\r\n    /* Wait for reset cycle to complete */\r\n    while (((base->MCR & CAN_MCR_SOFTRST_MASK) >> CAN_MCR_SOFTRST_SHIFT) != 0U) {}\r\n\r\n    /* Enable abort */\r\n#ifndef ERRATA_E9527\r\n    /* Avoid Abort Transmission, use Inactive MB */\r\n    base->MCR = (base->MCR & ~CAN_MCR_AEN_MASK) | CAN_MCR_AEN(1U);\r\n#endif\r\n\r\n    /* Clear FlexCAN memory */\r\n    FLEXCAN_ClearRAM(base);\r\n\r\n    /* Rx global mask*/\r\n    (base->RXMGMASK) = (uint32_t)(CAN_RXMGMASK_MG_MASK);\r\n\r\n    /* Rx reg 14 mask*/\r\n    (base->RX14MASK) =  (uint32_t)(CAN_RX14MASK_RX14M_MASK);\r\n\r\n    /* Rx reg 15 mask*/\r\n    (base->RX15MASK) = (uint32_t)(CAN_RX15MASK_RX15M_MASK);\r\n\r\n    /* Disable all MB interrupts */\r\n    (base->IMASK1) = 0x0;\r\n    /* Clear all MB interrupt flags */\r\n    (base->IFLAG1) = CAN_IMASK1_BUF31TO0M_MASK;\r\n#if FEATURE_CAN_MAX_MB_NUM > 32U\r\n    if (FLEXCAN_GetMaxMbNum(base) > 32U)\r\n    {\r\n\t\t(base->IMASK2) = 0x0;\r\n\t\t(base->IFLAG2) = CAN_IMASK2_BUF63TO32M_MASK;\r\n\t}\r\n#endif\t\r\n#if FEATURE_CAN_MAX_MB_NUM > 64U\r\n    if (FLEXCAN_GetMaxMbNum(base) > 64U)\r\n    {\r\n    \t(base->IMASK3) = 0x0;\r\n    \t(base->IFLAG3) = CAN_IMASK3_BUF95TO64M_MASK;\r\n    }\r\n#endif\t\r\n    /* Clear all error interrupt flags */\r\n    (base->ESR1) = FLEXCAN_ALL_INT;\r\n}\r\n\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_DataTransferTxMsgBuff\r\n * Description   : Transfer Payload data in message buffer, in case of unaligned\r\n * buffer it makes a byte alignment.\r\n * This function is private.\r\n *\r\n *END**************************************************************************/\r\ninline static uint32_t FLEXCAN_DataTransferTxMsgBuff(volatile uint32_t *flexcan_mb_data_32,\r\n\t\t\t\t\t\t\t\t\t\t\t\t const flexcan_msgbuff_code_status_t *cs,\r\n\t\t\t\t\t\t\t\t\t\t\t\t const uint8_t *msgData)\r\n{\r\n    uint32_t databyte;\r\n    const uint32_t *msgData_32 = (const uint32_t *)msgData;\r\n\r\n    /* Check if the buffer address is aligned */\r\n    if (((uint32_t)msgData_32&0x3U) != 0U)\r\n    {\r\n        for (databyte = 0U; databyte < (cs->dataLen & ~3U); databyte += 4U)\r\n        {\r\n            uint32_t x = FLEXCAN_DeserializeUint32(&msgData[databyte]);\r\n            FlexcanSwapBytesInWord(x, flexcan_mb_data_32[databyte >> 2U]);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (databyte = 0U; databyte < (cs->dataLen & ~3U); databyte += 4U)\r\n        {\r\n            FlexcanSwapBytesInWord(msgData_32[databyte >> 2U], flexcan_mb_data_32[databyte >> 2U]);\r\n        }\r\n    }\r\n    return databyte;\r\n}\r\n#endif /* defined(CPU_S32K116) || defined(CPU_S32K118) */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetTxMsgBuff\r\n * Description   : Configure a message buffer for transmission.\r\n * This function will first check if RX FIFO is enabled. If RX FIFO is enabled,\r\n * the function will make sure if the MB requested is not occupied by RX FIFO\r\n * and ID filter table. Then this function will copy user's buffer into the\r\n * message buffer data area and configure the message buffer as required for\r\n * transmission.\r\n *\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_SetTxMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    const flexcan_msgbuff_code_status_t *cs,\r\n    uint32_t msgId,\r\n    const uint8_t *msgData,\r\n    const bool isRemote)\r\n{\r\n    DEV_ASSERT(cs != NULL);\r\n\r\n    uint32_t val1, val2 = 1;\r\n    uint32_t flexcan_mb_config = 0;\r\n    uint32_t databyte;\r\n    uint8_t dlc_value;\r\n    status_t stat = STATUS_SUCCESS;\r\n\r\n    volatile uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n\r\n    volatile uint32_t *flexcan_mb_id   = &flexcan_mb[1];\r\n    volatile uint8_t  *flexcan_mb_data = (volatile uint8_t *)(&flexcan_mb[2]);\r\n    volatile uint32_t *flexcan_mb_data_32 = &flexcan_mb[2];\r\n    const uint32_t *msgData_32 = (const uint32_t *)msgData;\r\n\r\n    if (msgBuffIdx > (((base->MCR) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT) )\r\n    {\r\n        stat = STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    /* Check if RX FIFO is enabled*/\r\n    if (((base->MCR & CAN_MCR_RFEN_MASK) >> CAN_MCR_RFEN_SHIFT) != 0U)\r\n    {\r\n        /* Get the number of RX FIFO Filters*/\r\n        val1 = (((base->CTRL2) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT);\r\n        /* Get the number if MBs occupied by RX FIFO and ID filter table*/\r\n        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/\r\n        /* Every number of RFFN means 8 number of RX FIFO filters*/\r\n        /* and every 4 number of RX FIFO filters occupied one MB*/\r\n        val2 = RxFifoOcuppiedLastMsgBuff(val1);\r\n\r\n        if (msgBuffIdx <= val2) {\r\n            stat =  STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n        }\r\n    }\r\n\r\n    if (stat == STATUS_SUCCESS)\r\n    {\r\n#if FEATURE_CAN_HAS_FD\r\n        /* Make sure the BRS bit will not be ignored */\r\n        if (FLEXCAN_IsFDEnabled(base) && cs->enable_brs)\r\n        {\r\n            base->FDCTRL = (base->FDCTRL & ~CAN_FDCTRL_FDRATE_MASK) | CAN_FDCTRL_FDRATE(1U);\r\n        }\r\n        /* Check if the Payload Size is smaller than the payload configured */\r\n        DEV_ASSERT((uint8_t)cs->dataLen <= FLEXCAN_GetPayloadSize(base));\r\n#else\r\n        DEV_ASSERT((uint8_t)cs->dataLen <= 8U);\r\n#endif\r\n\r\n        /* Compute the value of the DLC field */\r\n        dlc_value = FLEXCAN_ComputeDLCValue((uint8_t)cs->dataLen);\r\n\r\n        /* Copy user's buffer into the message buffer data area */\r\n        if (msgData != NULL)\r\n        {\r\n            uint8_t payload_size = FLEXCAN_ComputePayloadSize(dlc_value);\r\n\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n            (void) msgData_32;\r\n            databyte = FLEXCAN_DataTransferTxMsgBuff( flexcan_mb_data_32, cs, msgData);\r\n#else\r\n            for (databyte = 0; databyte < (cs->dataLen & ~3U); databyte += 4U)\r\n\t\t\t{\r\n\t\t\t\tFlexcanSwapBytesInWord(msgData_32[databyte >> 2U], flexcan_mb_data_32[databyte >> 2U]);\r\n\t\t\t}\r\n#endif\r\n            for ( ; databyte < cs->dataLen; databyte++)\r\n            {\r\n                flexcan_mb_data[FlexcanSwapBytesInWordIndex(databyte)] =  msgData[databyte];\r\n            }\r\n            /* Add padding, if needed */\r\n            for (databyte = cs->dataLen; databyte < payload_size; databyte++)\r\n            {\r\n                flexcan_mb_data[FlexcanSwapBytesInWordIndex(databyte)] = cs->fd_padding;\r\n            }\r\n        }\r\n\r\n        /* Clean up the arbitration field area */\r\n        *flexcan_mb = 0;\r\n        *flexcan_mb_id = 0;\r\n\r\n        /* Set the ID according the format structure */\r\n        if (cs->msgIdType == FLEXCAN_MSG_ID_EXT)\r\n        {\r\n            /* ID [28-0] */\r\n            *flexcan_mb_id &= ~(CAN_ID_STD_MASK | CAN_ID_EXT_MASK);\r\n            *flexcan_mb_id |= (msgId & (CAN_ID_STD_MASK | CAN_ID_EXT_MASK));\r\n\r\n            /* Set IDE */\r\n            flexcan_mb_config |= CAN_CS_IDE_MASK;\r\n\r\n            /* Clear SRR bit */\r\n            flexcan_mb_config &= ~CAN_CS_SRR_MASK;\r\n        }\r\n        if(cs->msgIdType == FLEXCAN_MSG_ID_STD)\r\n        {\r\n            /* ID[28-18] */\r\n            *flexcan_mb_id &= ~CAN_ID_STD_MASK;\r\n            *flexcan_mb_id |= (msgId << CAN_ID_STD_SHIFT) & CAN_ID_STD_MASK;\r\n\r\n            /* make sure IDE and SRR are not set */\r\n            flexcan_mb_config &= ~(CAN_CS_IDE_MASK | CAN_CS_SRR_MASK);\r\n        }\r\n\r\n        /* Set the length of data in bytes */\r\n        flexcan_mb_config &= ~CAN_CS_DLC_MASK;\r\n        flexcan_mb_config |= ((uint32_t)dlc_value << CAN_CS_DLC_SHIFT) & CAN_CS_DLC_MASK;\r\n\r\n        /* Set MB CODE */\r\n        if (cs->code != (uint32_t)FLEXCAN_TX_NOT_USED)\r\n        {\r\n            if (cs->code == (uint32_t)FLEXCAN_TX_REMOTE)\r\n            {\r\n                /* Set RTR bit */\r\n                flexcan_mb_config |= CAN_CS_RTR_MASK;\r\n            }\r\n            else\r\n            {\r\n                if (isRemote == true)\r\n                {\r\n                    /* Set RTR bit */\r\n                    flexcan_mb_config |= CAN_CS_RTR_MASK;\r\n                }\r\n            }\r\n\r\n            /* Reset the code */\r\n            flexcan_mb_config &= ~CAN_CS_CODE_MASK;\r\n\r\n            /* Set the code */\r\n            if (cs->fd_enable)\r\n            {\r\n                flexcan_mb_config |= ((cs->code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK) | CAN_MB_EDL_MASK;\r\n            }\r\n            else\r\n            {\r\n                flexcan_mb_config |= (cs->code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;\r\n            }\r\n\r\n            if (cs->enable_brs)\r\n            {\r\n                flexcan_mb_config |= CAN_MB_BRS_MASK;\r\n            }\r\n\r\n            *flexcan_mb |= flexcan_mb_config;\r\n        }\r\n    }\r\n\r\n    return stat;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_AbortTxMsgBuff\r\n * Description   : Writes the abort code into the CODE field of the requested\r\n * Tx message buffer.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_AbortTxMsgBuff(CAN_Type * base, uint32_t msgBuffIdx)\r\n{\r\n    uint32_t flexcan_mb_config = 0;\r\n    uint32_t code = FLEXCAN_TX_ABORT;\r\n\r\n    volatile uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n    flexcan_mb_config = *flexcan_mb;\r\n\r\n    /* Reset the code */\r\n    flexcan_mb_config &= (~CAN_CS_CODE_MASK);\r\n\r\n    /* Write the abort code */\r\n#ifdef ERRATA_E9527\r\n    /* Use instead Abort Code the Inactive Code */\r\n    code = FLEXCAN_TX_INACTIVE;\r\n#endif\r\n    flexcan_mb_config |= (code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;\r\n\r\n    *flexcan_mb = flexcan_mb_config;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ResetRxMsgBuff\r\n * Description   : Writes the Inactive Rx code into the CODE field of the requested\r\n * Rx message buffer and restore the MB to active Rx. This will force even the unlock of the RxMB.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ResetRxMsgBuff(CAN_Type * base, uint32_t msgBuffIdx)\r\n{\r\n\tuint32_t flexcan_mb_config = 0;\r\n\tuint32_t code = FLEXCAN_RX_INACTIVE;\r\n\r\n\tvolatile uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n\tflexcan_mb_config = *flexcan_mb;\r\n\r\n\t/* Reset the code and unlock the MB */\r\n\tflexcan_mb_config &= (~CAN_CS_CODE_MASK);\r\n    flexcan_mb_config |= (code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;\r\n    *flexcan_mb = flexcan_mb_config;\r\n\r\n    /* Reconfigure The MB as left by RxMBconfig */\r\n    code = FLEXCAN_RX_EMPTY;\r\n    flexcan_mb_config &= (~CAN_CS_CODE_MASK);\r\n    flexcan_mb_config |= (code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;\r\n    *flexcan_mb = flexcan_mb_config;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetRxMsgBuff\r\n * Description   : Configure a message buffer for receiving.\r\n * This function will first check if RX FIFO is enabled. If RX FIFO is enabled,\r\n * the function will make sure if the MB requested is not occupied by RX FIFO\r\n * and ID filter table. Then this function will configure the message buffer as\r\n * required for receiving.\r\n *\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_SetRxMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    const flexcan_msgbuff_code_status_t *cs,\r\n    uint32_t msgId)\r\n{\r\n    DEV_ASSERT(cs != NULL);\r\n\r\n    uint32_t val1, val2 = 1;\r\n\r\n    volatile uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n    volatile uint32_t *flexcan_mb_id = &flexcan_mb[1];\r\n    status_t stat = STATUS_SUCCESS;\r\n\r\n    if (msgBuffIdx > (((base->MCR) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT))\r\n    {\r\n        stat = STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    /* Check if RX FIFO is enabled */\r\n    if (((base->MCR & CAN_MCR_RFEN_MASK) >> CAN_MCR_RFEN_SHIFT) != 0U)\r\n    {\r\n        /* Get the number of RX FIFO Filters*/\r\n        val1 = (((base->CTRL2) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT);\r\n        /* Get the number if MBs occupied by RX FIFO and ID filter table*/\r\n        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/\r\n        /* Every number of RFFN means 8 number of RX FIFO filters*/\r\n        /* and every 4 number of RX FIFO filters occupied one MB*/\r\n        val2 = RxFifoOcuppiedLastMsgBuff(val1);\r\n\r\n        if (msgBuffIdx <= val2) {\r\n            stat =  STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n        }\r\n    }\r\n\r\n    if (stat == STATUS_SUCCESS)\r\n    {\r\n        /* Clean up the arbitration field area */\r\n        *flexcan_mb = 0;\r\n        *flexcan_mb_id = 0;\r\n\r\n        /* Set the ID according the format structure */\r\n        if (cs->msgIdType == FLEXCAN_MSG_ID_EXT)\r\n        {\r\n            /* Set IDE */\r\n            *flexcan_mb |= CAN_CS_IDE_MASK;\r\n\r\n            /* Clear SRR bit */\r\n            *flexcan_mb &= ~CAN_CS_SRR_MASK;\r\n\r\n            /* ID [28-0] */\r\n            *flexcan_mb_id &= ~(CAN_ID_STD_MASK | CAN_ID_EXT_MASK);\r\n            *flexcan_mb_id |= (msgId & (CAN_ID_STD_MASK | CAN_ID_EXT_MASK));\r\n        }\r\n        if (cs->msgIdType == FLEXCAN_MSG_ID_STD)\r\n        {\r\n            /* Make sure IDE and SRR are not set */\r\n            *flexcan_mb &= ~(CAN_CS_IDE_MASK | CAN_CS_SRR_MASK);\r\n\r\n            /* ID[28-18] */\r\n            *flexcan_mb_id &= ~CAN_ID_STD_MASK;\r\n            *flexcan_mb_id |= (msgId << CAN_ID_STD_SHIFT) & CAN_ID_STD_MASK;\r\n        }\r\n\r\n        /* Set MB CODE */\r\n        if (cs->code != (uint32_t)FLEXCAN_RX_NOT_USED)\r\n        {\r\n             *flexcan_mb &= ~CAN_CS_CODE_MASK;\r\n             *flexcan_mb |= (cs->code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;\r\n        }\r\n    }\r\n\r\n    return stat;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_GetMsgBuff\r\n * Description   : Get a message buffer field values.\r\n * This function will first check if RX FIFO is enabled. If RX FIFO is enabled,\r\n * the function will make sure if the MB requested is not occupied by RX FIFO\r\n * and ID filter table. Then this function will get the message buffer field\r\n * values and copy the MB data field into user's buffer.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_GetMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    flexcan_msgbuff_t *msgBuff)\r\n{\r\n    DEV_ASSERT(msgBuff != NULL);\r\n\r\n    uint8_t i;\r\n\r\n    volatile const uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n    volatile const uint32_t *flexcan_mb_id   = &flexcan_mb[1];\r\n    volatile const uint8_t  *flexcan_mb_data = (volatile const uint8_t *)(&flexcan_mb[2]);\r\n    volatile const uint32_t *flexcan_mb_data_32 = &flexcan_mb[2];\r\n    uint32_t *msgBuff_data_32 = (uint32_t *)(msgBuff->data);\r\n    uint32_t mbWord;\r\n\r\n    uint8_t flexcan_mb_dlc_value = (uint8_t)(((*flexcan_mb) & CAN_CS_DLC_MASK) >> 16);\r\n    uint8_t payload_size = FLEXCAN_ComputePayloadSize(flexcan_mb_dlc_value);\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    if (payload_size > FLEXCAN_GetPayloadSize(base))\r\n    {\r\n        payload_size = FLEXCAN_GetPayloadSize(base);\r\n    }\r\n#endif /* FEATURE_CAN_HAS_FD */\r\n\r\n\tmsgBuff->dataLen = payload_size;\r\n\r\n    /* Get a MB field values */\r\n    msgBuff->cs = *flexcan_mb;\r\n    if ((msgBuff->cs & CAN_CS_IDE_MASK) != 0U)\r\n    {\r\n        msgBuff->msgId = (*flexcan_mb_id);\r\n    }\r\n    else\r\n    {\r\n        msgBuff->msgId = (*flexcan_mb_id) >> CAN_ID_STD_SHIFT;\r\n    }\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n    /* Check if the buffer address is aligned */\r\n    if (((uint32_t)msgBuff_data_32&0x3U) != 0U)\r\n    {\r\n        /* Copy MB data field into user's buffer */\r\n        for (i = 0U ; i < (payload_size & ~3U); i += 4U)\r\n        {\r\n            mbWord = flexcan_mb_data_32[i >> 2U];\r\n            uint8_t index;\r\n            uint32_t x;\r\n            const uint8_t * p;\r\n            FlexcanSwapBytesInWord(mbWord, x);\r\n            p = (uint8_t *)&x;\r\n            for (index=0; index < 4U; index++)\r\n            {\r\n                msgBuff->data[i+index]= p[index];\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (i = 0U ; i < (payload_size & ~3U); i += 4U)\r\n        {\r\n            mbWord = flexcan_mb_data_32[i >> 2U];\r\n            FlexcanSwapBytesInWord(mbWord, msgBuff_data_32[i >> 2U]);\r\n        }\r\n    }\r\n#else\r\n    for (i = 0U ; i < (payload_size & ~3U); i += 4U)\r\n    {\r\n        mbWord = flexcan_mb_data_32[i >> 2U];\r\n        FlexcanSwapBytesInWord(mbWord, msgBuff_data_32[i >> 2U]);\r\n    }\r\n#endif\r\n    for ( ; i < payload_size ; i++)\r\n    {\t/* Max allowed value for index is 63 */\r\n        msgBuff->data[i] = flexcan_mb_data[FlexcanSwapBytesInWordIndex(i)];\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_LockRxMsgBuff\r\n * Description   : Lock the RX message buffer.\r\n * This function will lock the RX message buffer.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_LockRxMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx)\r\n{\r\n    volatile const uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n\r\n    /* Lock the mailbox by reading it */\r\n    (void)*flexcan_mb;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_EnableRxFifo\r\n * Description   : Enable Rx FIFO feature.\r\n * This function will enable the Rx FIFO feature.\r\n *\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_EnableRxFifo(CAN_Type * base, uint32_t numOfFilters)\r\n{\r\n    uint32_t i;\r\n    uint16_t noOfMbx= (uint16_t)FLEXCAN_GetMaxMbNum(base);\r\n    status_t stat = STATUS_SUCCESS;\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    /* RxFIFO cannot be enabled if FD is enabled */\r\n    if (FLEXCAN_IsFDEnabled(base))\r\n    {\r\n        stat = STATUS_ERROR;\r\n    }\r\n\r\n    if (stat == STATUS_SUCCESS)\r\n#endif\r\n    {\r\n        /* Enable RX FIFO */\r\n        base->MCR = (base->MCR & ~CAN_MCR_RFEN_MASK) | CAN_MCR_RFEN(1U);\r\n        /* Set the number of the RX FIFO filters needed */\r\n        base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_RFFN_MASK) | ((numOfFilters << CAN_CTRL2_RFFN_SHIFT) & CAN_CTRL2_RFFN_MASK);\r\n        /* RX FIFO global mask, take in consideration all filter fields*/\r\n        (base->RXFGMASK) = CAN_RXFGMASK_FGM_MASK;\r\n\r\n        for (i = 0; i < noOfMbx; i++)\r\n        {\r\n            /* RX individual mask */\r\n            base->RXIMR[i] = (CAN_RXIMR_MI_MASK << CAN_ID_EXT_SHIFT) & (CAN_ID_STD_MASK | CAN_ID_EXT_MASK);\r\n        }\r\n    }\r\n\r\n    return stat;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetMaxMsgBuffNum\r\n * Description   : Set the number of the last Message Buffers.\r\n * This function will define the number of the last Message Buffers\r\n *\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_SetMaxMsgBuffNum(\r\n    CAN_Type * base,\r\n    uint32_t maxMsgBuffNum)\r\n{\r\n    uint8_t msgBuffIdx;\r\n    uint32_t databyte;\r\n\r\n    DEV_ASSERT(maxMsgBuffNum>0U);\r\n#if FEATURE_CAN_HAS_FD\r\n    uint8_t can_real_payload = FLEXCAN_GetPayloadSize(base);\r\n#else\r\n    uint8_t can_real_payload = 8U;\r\n#endif\r\n    status_t status = STATUS_SUCCESS;\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n    uint8_t arbitration_field_size = 8U;\r\n    /* Check that the number of MBs is supported based on the payload size*/\r\n    volatile uint32_t * valEndMbPointer =FLEXCAN_GetMsgBuffRegion(base, (maxMsgBuffNum-1U));\r\n    uint32_t valEndMb = (uint32_t)valEndMbPointer + can_real_payload + arbitration_field_size;\r\n    if ((valEndMb > (uint32_t)&base->RAMn[CAN_RAMn_COUNT]) || (maxMsgBuffNum > FLEXCAN_GetMaxMbNum(base)))\r\n#else\r\n    /* Check that the number of MBs is supported based on features defined */\r\n    if (maxMsgBuffNum > FLEXCAN_GetMaxMbNum(base))\r\n#endif\r\n    {\r\n    \tstatus = STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    if (status == STATUS_SUCCESS)\r\n    {\r\n        /* Set the maximum number of MBs*/\r\n        base->MCR = (base->MCR & ~CAN_MCR_MAXMB_MASK) | (((maxMsgBuffNum-1U) << CAN_MCR_MAXMB_SHIFT) & CAN_MCR_MAXMB_MASK);\r\n\r\n        if (!FLEXCAN_IsRxFifoEnabled(base))\r\n        {\r\n            /* Initialize all message buffers as inactive */\r\n            for (msgBuffIdx = 0; msgBuffIdx < maxMsgBuffNum; msgBuffIdx++)\r\n            {\r\n                volatile uint32_t *flexcan_mb = FLEXCAN_GetMsgBuffRegion(base, msgBuffIdx);\r\n                volatile uint32_t *flexcan_mb_id   = &flexcan_mb[1];\r\n                volatile uint8_t  *flexcan_mb_data = (volatile uint8_t *)(&flexcan_mb[2]);\r\n\r\n                *flexcan_mb = 0x0;\r\n                *flexcan_mb_id = 0x0;\r\n                for (databyte = 0; databyte < can_real_payload; databyte++)\r\n                {\r\n                   flexcan_mb_data[databyte] = 0x0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetRxFifoFilter\r\n * Description   : Configure RX FIFO ID filter table elements.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_SetRxFifoFilter(\r\n    CAN_Type * base,\r\n    flexcan_rx_fifo_id_element_format_t idFormat,\r\n    const flexcan_id_table_t *idFilterTable)\r\n{\r\n    DEV_ASSERT(idFilterTable != NULL);\r\n\r\n    /* Set RX FIFO ID filter table elements*/\r\n    uint32_t i, j, numOfFilters;\r\n    uint32_t val1 = 0, val2 = 0, val = 0;\r\n\r\n    volatile uint32_t *filterTable = &base->RAMn[RxFifoFilterTableOffset];\r\n\r\n    numOfFilters = (((base->CTRL2) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT);\r\n\r\n    switch(idFormat)\r\n    {\r\n        case (FLEXCAN_RX_FIFO_ID_FORMAT_A):\r\n            /* One full ID (standard and extended) per ID Filter Table element.*/\r\n            (base->MCR) = (((base->MCR) & ~(CAN_MCR_IDAM_MASK)) | ( (((uint32_t)(((uint32_t)(FLEXCAN_RX_FIFO_ID_FORMAT_A))<<CAN_MCR_IDAM_SHIFT))&CAN_MCR_IDAM_MASK)));\r\n\r\n            for (i = 0; i < RxFifoFilterElementNum(numOfFilters); i++)\r\n            {\r\n                val = 0;\r\n\r\n                if (idFilterTable[i].isRemoteFrame)\r\n                {\r\n                    val = FlexCanRxFifoAcceptRemoteFrame << FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;\r\n                }\r\n                if(idFilterTable[i].isExtendedFrame)\r\n                {\r\n                    val |= FlexCanRxFifoAcceptExtFrame << FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;\r\n                    filterTable[i] = val + ((idFilterTable[i].id <<\r\n                                             FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT) &\r\n                                             FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] = val + ((idFilterTable[i].id <<\r\n                                             FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT) &\r\n                                             FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_STD_MASK);\r\n                }\r\n            }\r\n            break;\r\n        case (FLEXCAN_RX_FIFO_ID_FORMAT_B):\r\n            /* Two full standard IDs or two partial 14-bit (standard and extended) IDs*/\r\n            /* per ID Filter Table element.*/\r\n           (base->MCR) = (((base->MCR) & ~(CAN_MCR_IDAM_MASK)) | ( (((uint32_t)(((uint32_t)(FLEXCAN_RX_FIFO_ID_FORMAT_B))<<CAN_MCR_IDAM_SHIFT))&CAN_MCR_IDAM_MASK)));\r\n\r\n            j = 0;\r\n            for (i = 0; i < RxFifoFilterElementNum(numOfFilters); i++)\r\n            {\r\n                val1 = 0;\r\n                val2 = 0;\r\n\r\n                if (idFilterTable[j].isRemoteFrame)\r\n                {\r\n                    val1 = FlexCanRxFifoAcceptRemoteFrame << FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;\r\n                }\r\n                if (idFilterTable[j + 1U].isRemoteFrame)\r\n                {\r\n                    val2 = FlexCanRxFifoAcceptRemoteFrame << FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;\r\n                }\r\n                if (idFilterTable[j].isExtendedFrame)\r\n                {\r\n                    val1 |= FlexCanRxFifoAcceptExtFrame << FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;\r\n\r\n                    filterTable[i] = val1 + (((idFilterTable[j].id &\r\n                                               FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>\r\n                                               FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) <<\r\n                                               FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] = val1 + ((idFilterTable[j].id &\r\n                                              FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<\r\n                                              FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1);\r\n                }\r\n                if (idFilterTable[j + 1U].isExtendedFrame)\r\n                {\r\n                    val2 |= FlexCanRxFifoAcceptExtFrame << FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;\r\n\r\n                    filterTable[i] |= val2 + (((idFilterTable[j + 1U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] |= val2 + ((idFilterTable[j + 1U].id &\r\n                                               FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<\r\n                                               FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2);\r\n                }\r\n                j = j + 2U;\r\n            }\r\n            break;\r\n        case (FLEXCAN_RX_FIFO_ID_FORMAT_C):\r\n            /* Four partial 8-bit Standard IDs per ID Filter Table element.*/\r\n            (base->MCR) = (((base->MCR) & ~(CAN_MCR_IDAM_MASK)) | ( (((uint32_t)(((uint32_t)(FLEXCAN_RX_FIFO_ID_FORMAT_C))<<CAN_MCR_IDAM_SHIFT))&CAN_MCR_IDAM_MASK)));\r\n            j = 0;\r\n            for (i = 0; i < RxFifoFilterElementNum(numOfFilters); i++)\r\n            {\r\n                if (idFilterTable[j].isExtendedFrame)\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT1);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT1);\r\n                }\r\n                if (idFilterTable[j + 1U].isExtendedFrame)\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j + 1U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT2);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j + 1U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT2);\r\n                }\r\n                if (idFilterTable[j + 2U].isExtendedFrame)\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j + 2U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT3);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j + 2U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT3);\r\n                }\r\n                if (idFilterTable[j + 3U].isExtendedFrame)\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j + 3U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT4);\r\n                }\r\n                else\r\n                {\r\n                    filterTable[i] |= val1 + (((idFilterTable[j + 3U].id &\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) <<\r\n                                                FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT4);\r\n                }\r\n                j = j + 4U;\r\n            }\r\n            break;\r\n        case (FLEXCAN_RX_FIFO_ID_FORMAT_D):\r\n            /* All frames rejected.*/\r\n            (base->MCR) = (((base->MCR) & ~(CAN_MCR_IDAM_MASK)) | ( (((uint32_t)(((uint32_t)(FLEXCAN_RX_FIFO_ID_FORMAT_D))<<CAN_MCR_IDAM_SHIFT))&CAN_MCR_IDAM_MASK)));\r\n            break;\r\n        default:\r\n            /* Should not get here */\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetMsgBuffIntCmd\r\n * Description   : Enable/Disable the corresponding Message Buffer interrupt.\r\n *\r\n *END**************************************************************************/\r\nstatus_t FLEXCAN_SetMsgBuffIntCmd(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx, bool enable)\r\n{\r\n    uint32_t temp;\r\n    status_t stat = STATUS_SUCCESS;\r\n\r\n    if (msgBuffIdx > (((base->MCR) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT))\r\n    {\r\n        stat = STATUS_CAN_BUFF_OUT_OF_RANGE;\r\n    }\r\n\r\n    if (stat == STATUS_SUCCESS)\r\n    {\r\n        /* Enable the corresponding message buffer Interrupt */\r\n        temp = 1UL << (msgBuffIdx % 32U);\r\n        if (msgBuffIdx  < 32U)\r\n        {\r\n            if (enable)\r\n            {\r\n                (base->IMASK1) = ((base ->IMASK1) | (temp));\r\n            }\r\n            else\r\n            {\r\n                (base->IMASK1) = ((base->IMASK1) & ~(temp));\r\n            }\r\n        }\r\n#if FEATURE_CAN_MAX_MB_NUM > 32U\r\n        if ((msgBuffIdx >= 32U) && (msgBuffIdx < 64U))\r\n        {\r\n            if (enable)\r\n            {\r\n                (base->IMASK2) = ((base ->IMASK2) | (temp));\r\n            }\r\n            else\r\n            {\r\n                (base->IMASK2) = ((base->IMASK2) & ~(temp));\r\n            }\r\n        }\r\n#endif\r\n#if FEATURE_CAN_MAX_MB_NUM > 64U\r\n        if (msgBuffIdx >= 64U)\r\n        {\r\n            if (enable)\r\n            {\r\n                (base->IMASK3) = ((base ->IMASK3) | (temp));\r\n            }\r\n            else\r\n            {\r\n                (base->IMASK3) = ((base->IMASK3) & ~(temp));\r\n            }\r\n        }\r\n#endif\r\n    }\r\n\r\n    return stat;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetErrIntCmd\r\n * Description   : Enable the error interrupts.\r\n * This function will enable Error interrupt.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_SetErrIntCmd(CAN_Type * base, flexcan_int_type_t errType, bool enable)\r\n{\r\n    uint32_t temp = (uint32_t)errType;\r\n    if (enable)\r\n    {\r\n        if((errType == FLEXCAN_INT_RX_WARNING) || (errType == FLEXCAN_INT_TX_WARNING))\r\n        {\r\n           base->MCR = (base->MCR & ~CAN_MCR_WRNEN_MASK) | CAN_MCR_WRNEN(1U);\r\n        }\r\n#if FEATURE_CAN_HAS_FD\r\n        if (errType == FLEXCAN_INT_ERR)\r\n        {\r\n           base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_ERRMSK_FAST_MASK) | CAN_CTRL2_ERRMSK_FAST(1U);\r\n        }\r\n#endif\r\n        (base->CTRL1) = ((base->CTRL1) | (temp));\r\n    }\r\n    else\r\n    {\r\n    \t(base->CTRL1) = ((base->CTRL1) & ~(temp));\r\n#if FEATURE_CAN_HAS_FD\r\n                if (errType == FLEXCAN_INT_ERR)\r\n                {\r\n                   base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_ERRMSK_FAST_MASK) | CAN_CTRL2_ERRMSK_FAST(0U);\r\n                }\r\n#endif\r\n        temp = base->CTRL1;\r\n\t\tif (((temp & (uint32_t)FLEXCAN_INT_RX_WARNING) == 0U) && ((temp & (uint32_t)FLEXCAN_INT_TX_WARNING) == 0U))\r\n\t\t{\r\n\t\t   /* If WRNEN disabled then both FLEXCAN_INT_RX_WARNING and FLEXCAN_INT_TX_WARNING will be disabled */\r\n\t\t   base->MCR = (base->MCR & ~CAN_MCR_WRNEN_MASK) | CAN_MCR_WRNEN(0U);\r\n\t\t}\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ExitFreezeMode\r\n * Description   : Exit of freeze mode.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ExitFreezeMode(CAN_Type * base)\r\n{\r\n    base->MCR = (base->MCR & ~CAN_MCR_HALT_MASK) | CAN_MCR_HALT(0U);\r\n    base->MCR = (base->MCR & ~CAN_MCR_FRZ_MASK) | CAN_MCR_FRZ(0U);\r\n\r\n    /* Wait till exit freeze mode */\r\n    while (((base->MCR & CAN_MCR_FRZACK_MASK) >> CAN_MCR_FRZACK_SHIFT) != 0U) {}\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_EnterFreezeMode\r\n * Description   : Enter the freeze mode.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_EnterFreezeMode(CAN_Type * base)\r\n{\r\n\tbool enabled = false;\r\n\r\n    base->MCR = (base->MCR & ~CAN_MCR_FRZ_MASK) | CAN_MCR_FRZ(1U);\r\n    base->MCR = (base->MCR & ~CAN_MCR_HALT_MASK) | CAN_MCR_HALT(1U);\r\n    if (((base->MCR & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT) == 0U)\r\n\t{\r\n\t\tenabled = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbase->MCR &= ~CAN_MCR_MDIS_MASK;\r\n\t}\r\n#ifdef ERRATA_E9595\r\n    /* Check Low-Power Mode Acknowledge Cleared */\r\n    while (((base->MCR & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT) == 1U) {}\r\n    /* Check if is a Bus-Off Error corresponding to 1x */\r\n    if ((((base->ESR1 & CAN_ESR1_FLTCONF_MASK) >> CAN_ESR1_FLTCONF_SHIFT) & 2U) != 0U)\r\n    {\r\n    \t/* Save registers before Soft Reset */\r\n    \tuint32_t tempIMSK[2],tempMCR;\r\n    \ttempIMSK[0] = base->IMASK1;\r\n    \ttempIMSK[1] = base->IMASK2;\r\n    \ttempMCR = base->MCR;\r\n    \t/* Soft Reset FlexCan */\r\n    \tbase->MCR |= CAN_MCR_SOFTRST(1U);\r\n    \twhile (((base->MCR & CAN_MCR_SOFTRST_MASK) >> CAN_MCR_SOFTRST_SHIFT) == 0U) {}\r\n    \t/* Restore registers after Soft Reset */\r\n    \tbase->IMASK1 = tempIMSK[0];\r\n    \tbase->IMASK2 = tempIMSK[1];\r\n    \tbase->MCR = tempMCR;\r\n    }\r\n    else\r\n    {\r\n    \tbase->MCR = (base->MCR & ~CAN_MCR_HALT_MASK) | CAN_MCR_HALT(1U);\r\n    }\r\n#endif\r\n    /* Wait for entering the freeze mode */\r\n    while (((base->MCR & CAN_MCR_FRZACK_MASK) >> CAN_MCR_FRZACK_SHIFT) == 0U) {}\r\n    if (false == enabled)\r\n    {\r\n    \tbase->MCR |= CAN_MCR_MDIS_MASK;\r\n    \t/* Wait until disable mode acknowledged */\r\n        while (((base->MCR & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT) == 0U) {}\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ClearErrIntStatusFlag\r\n * Description   : Clear all error interrupt status.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ClearErrIntStatusFlag(CAN_Type * base)\r\n{\r\n    if((base->ESR1 & FLEXCAN_ALL_INT) != 0U)\r\n    {\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n        (base->ESR1) = FLEXCAN_ALL_INT;\r\n#else\r\n        (base->ESR1) = ERROR_INT;\r\n#endif\r\n#ifdef ERRATA_E9005\r\n        /* Dummy read as a workaround for errata e9005 to ensure the flags are\r\n        cleared before continuing. */\r\n        (void)(base->ESR1);\r\n#endif\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ClearBusOffIntStatusFlag\r\n * Description   : Clear all busOff and Tx/Rx Warning interrupt status.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ClearBusOffIntStatusFlag(CAN_Type * base)\r\n{\r\n    if ((base->ESR1 & BUS_OFF_INT) != 0U)\r\n    {\r\n    \tbase->ESR1 = BUS_OFF_INT;\r\n#ifdef ERRATA_E9005\r\n        (void)(base->ESR1);\r\n#endif\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ReadRxFifo\r\n * Description   : Read Rx FIFO data.\r\n * This function will copy MB[0] data field into user's buffer.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ReadRxFifo(\r\n    const CAN_Type * base,\r\n    flexcan_msgbuff_t *rxFifo)\r\n{\r\n    DEV_ASSERT(rxFifo != NULL);\r\n\r\n    uint32_t databyte;\r\n    uint32_t mbWord;\r\n\r\n    volatile const uint32_t *flexcan_mb = base->RAMn;\r\n    volatile const uint32_t *flexcan_mb_id = &base->RAMn[1];\r\n    volatile const uint32_t *flexcan_mb_data_32 = &flexcan_mb[2];\r\n    uint32_t *msgData_32 = (uint32_t *)(rxFifo->data);\r\n\r\n    uint8_t flexcan_mb_dlc_value = (uint8_t)(((*flexcan_mb) & CAN_CS_DLC_MASK) >> 16);\r\n    uint8_t can_real_payload = FLEXCAN_ComputePayloadSize(flexcan_mb_dlc_value);\r\n\r\n    rxFifo->dataLen = can_real_payload;\r\n    rxFifo->cs = *flexcan_mb;\r\n\r\n    if ((rxFifo->cs & CAN_CS_IDE_MASK) != 0U)\r\n    {\r\n        rxFifo->msgId = *flexcan_mb_id;\r\n    }\r\n    else\r\n    {\r\n        rxFifo->msgId = (*flexcan_mb_id) >> CAN_ID_STD_SHIFT;\r\n    }\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n    /* Check if the buffer address is aligned */\r\n    if (((uint32_t)msgData_32&0x3U) != 0U)\r\n\t{\r\n\t\t/* Copy MB[0] data field into user's buffer */\r\n\t\tfor (databyte = 0U; databyte < can_real_payload; databyte += 4U)\r\n\t\t{\r\n\t\t\tmbWord = flexcan_mb_data_32[databyte >> 2U];\r\n\t\t\tuint32_t x;\r\n\t\t\tuint8_t index;\r\n\t\t\tconst uint8_t * p;\r\n\t\t\tFlexcanSwapBytesInWord(mbWord, x);\r\n\t\t\tp = (uint8_t *)&x;\r\n\t\t\tfor (index = 0U; index < 4U; index++)\r\n\t\t\t{\r\n\t\t\t\trxFifo->data[databyte+index] = p[index];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t/* Copy MB[0] data field into user's buffer */\r\n\t\tfor (databyte = 0U; databyte < can_real_payload; databyte += 4U)\r\n\t\t{\r\n\t\t\tmbWord = flexcan_mb_data_32[databyte >> 2U];\r\n\t\t\tFlexcanSwapBytesInWord(mbWord, msgData_32[databyte >> 2U]);\r\n\t\t}\r\n\t}\r\n#else\r\n      /* Copy MB[0] data field into user's buffer */\r\n      for (databyte = 0U; databyte < can_real_payload; databyte += 4U)\r\n      {\r\n          mbWord = flexcan_mb_data_32[databyte >> 2U];\r\n          FlexcanSwapBytesInWord(mbWord, msgData_32[databyte >> 2U]);\r\n      }\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetOperationMode\r\n * Description   : Enable a FlexCAN operation mode.\r\n * This function will enable one of the modes listed in flexcan_operation_modes_t.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_SetOperationMode(\r\n    CAN_Type * base,\r\n    flexcan_operation_modes_t mode)\r\n{\r\n\r\n\tswitch (mode)\r\n\t{\r\n\tcase FLEXCAN_FREEZE_MODE:\r\n        /* Debug mode, Halt and Freeze*/\r\n        FLEXCAN_EnterFreezeMode(base);\r\n\tbreak;\r\n\tcase FLEXCAN_DISABLE_MODE:\r\n\t\t/* Debug mode, Halt and Freeze */\r\n\t\tbase->MCR = (base->MCR & ~CAN_MCR_MDIS_MASK) | CAN_MCR_MDIS(1U);\r\n\tbreak;\r\n\tcase FLEXCAN_NORMAL_MODE:\r\n        base->MCR = (base->MCR & ~CAN_MCR_SUPV_MASK) | CAN_MCR_SUPV(0U);\r\n        base->CTRL1 = (base->CTRL1 & ~CAN_CTRL1_LOM_MASK) | CAN_CTRL1_LOM(0U);\r\n        base->CTRL1 = (base->CTRL1 & ~CAN_CTRL1_LPB_MASK) | CAN_CTRL1_LPB(0U);\r\n    break;\r\n\tcase FLEXCAN_LISTEN_ONLY_MODE:\r\n        base->CTRL1 = (base->CTRL1 & ~CAN_CTRL1_LOM_MASK) | CAN_CTRL1_LOM(1U);\r\n    break;\r\n\tcase FLEXCAN_LOOPBACK_MODE:\r\n        base->CTRL1 = (base->CTRL1 & ~CAN_CTRL1_LPB_MASK) | CAN_CTRL1_LPB(1U);\r\n        base->CTRL1 = (base->CTRL1 & ~CAN_CTRL1_LOM_MASK) | CAN_CTRL1_LOM(0U);\r\n        /* Enable Self Reception */\r\n        FLEXCAN_SetSelfReception(base, true);\r\n    break;\r\n\tdefault :\r\n\t\t /* Should not get here */\r\n\tbreak;\r\n\t}\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_SetPayloadSize\r\n * Description   : Sets the payload size of the MBs.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_SetPayloadSize(\r\n    CAN_Type * base,\r\n    flexcan_fd_payload_size_t payloadSize)\r\n{\r\n    uint32_t tmp;\r\n\r\n    DEV_ASSERT(FLEXCAN_IsFDEnabled(base) || (payloadSize == FLEXCAN_PAYLOAD_SIZE_8));\r\n\r\n    /* If FD is not enabled, only 8 bytes payload is supported */\r\n    if (FLEXCAN_IsFDEnabled(base))\r\n    {\r\n        tmp = base->FDCTRL;\r\n        tmp &= ~(CAN_FDCTRL_MBDSR0_MASK);\r\n        tmp |= ((uint32_t)payloadSize) << CAN_FDCTRL_MBDSR0_SHIFT;\r\n#if FEATURE_CAN_HAS_MBDSR1\r\n        tmp &= ~(CAN_FDCTRL_MBDSR1_MASK);\r\n        tmp |= ((uint32_t)payloadSize) << CAN_FDCTRL_MBDSR1_SHIFT;\r\n#endif\r\n#if FEATURE_CAN_HAS_MBDSR2\r\n        tmp &= ~(CAN_FDCTRL_MBDSR2_MASK);\r\n        tmp |= ((uint32_t)payloadSize) << CAN_FDCTRL_MBDSR2_SHIFT;\r\n#endif\r\n\r\n        base->FDCTRL = tmp;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_GetPayloadSize\r\n * Description   : Returns the payload size of the MBs (in bytes).\r\n *\r\n *END**************************************************************************/\r\nuint8_t FLEXCAN_GetPayloadSize(const CAN_Type * base)\r\n{\r\n    uint32_t payloadSize;\r\n\r\n    /* The standard payload size is 8 bytes */\r\n    if (!FLEXCAN_IsFDEnabled(base))\r\n    {\r\n        payloadSize = 8U;\r\n    }\r\n    else\r\n    {\r\n        payloadSize = 1UL << (((base->FDCTRL & CAN_FDCTRL_MBDSR0_MASK) >> CAN_FDCTRL_MBDSR0_SHIFT) + 3U);\r\n    }\r\n\r\n    return (uint8_t)payloadSize;\r\n}\r\n#endif  /* End FEATURE_CAN_HAS_FD */\r\n\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FLEXCAN_ConfigPN\r\n * Description   : Configures the Pretended Networking mode.\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ConfigPN(CAN_Type * base, const flexcan_pn_config_t *pnConfig)\r\n{\r\n    DEV_ASSERT(pnConfig != NULL);\r\n\r\n    /* Configure specific pretended networking settings */\r\n    FLEXCAN_SetPNFilteringSelection(base,\r\n                                    pnConfig->wakeUpTimeout,\r\n                                    pnConfig->wakeUpMatch,\r\n                                    pnConfig->numMatches,\r\n                                    pnConfig->filterComb,\r\n                                    pnConfig->idFilterType,\r\n                                    pnConfig->payloadFilterType);\r\n\r\n    FLEXCAN_SetPNTimeoutValue(base, pnConfig->matchTimeout);\r\n\r\n    /* Configure ID filtering */\r\n    FLEXCAN_SetPNIdFilter1(base, pnConfig->idFilter1);\r\n\r\n    /* Configure the second ID, if needed (as mask for exact matching or higher limit for range matching) */\r\n    if ((pnConfig->idFilterType == FLEXCAN_FILTER_MATCH_EXACT) || (pnConfig->idFilterType == FLEXCAN_FILTER_MATCH_RANGE))\r\n    {\r\n        FLEXCAN_SetPNIdFilter2(base, pnConfig);\r\n    }\r\n    else\r\n    {\r\n    \t/* In other case need only to check the IDE and RTR match the ID_MASK is not considered */\r\n    \tFLEXCAN_SetPNIdFilter2Check(base);\r\n    }\r\n\r\n    /* Configure payload filtering, if requested */\r\n    if ((pnConfig->filterComb == FLEXCAN_FILTER_ID_PAYLOAD) || (pnConfig->filterComb == FLEXCAN_FILTER_ID_PAYLOAD_NTIMES))\r\n    {\r\n        FLEXCAN_SetPNDlcFilter(base,\r\n                               pnConfig->payloadFilter.dlcLow,\r\n                               pnConfig->payloadFilter.dlcHigh);\r\n\r\n        FLEXCAN_SetPNPayloadHighFilter1(base, pnConfig->payloadFilter.payload1);\r\n        FLEXCAN_SetPNPayloadLowFilter1(base, pnConfig->payloadFilter.payload1);\r\n\r\n        /* Configure the second payload, if needed (as mask for exact matching or higher limit for range matching) */\r\n        if ((pnConfig->payloadFilterType == FLEXCAN_FILTER_MATCH_EXACT) || (pnConfig->payloadFilterType == FLEXCAN_FILTER_MATCH_RANGE))\r\n        {\r\n            FLEXCAN_SetPNPayloadHighFilter2(base, pnConfig->payloadFilter.payload2);\r\n            FLEXCAN_SetPNPayloadLowFilter2(base, pnConfig->payloadFilter.payload2);\r\n        }\r\n    }\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_PRETENDED_NETWORKING */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"flexcan_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file flexcan_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, global macro not referenced\r\n * There are some global macros used for accessing different fields of CAN frames\r\n * which might also be useful to the user.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro\r\n * Function-like macros are used instead of inline functions in order to ensure\r\n * that the performance will not be decreased if the functions will not be\r\n * inlined by the compiler.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n */\r\n\r\n#ifndef FLEXCAN_HW_ACCESS_H\r\n#define FLEXCAN_HW_ACCESS_H\r\n\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n#include \"flexcan_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*! @brief FlexCAN message buffer CODE for Rx buffers*/\r\nenum {\r\n    FLEXCAN_RX_INACTIVE  = 0x0, /*!< MB is not active.*/\r\n    FLEXCAN_RX_FULL      = 0x2, /*!< MB is full.*/\r\n    FLEXCAN_RX_EMPTY     = 0x4, /*!< MB is active and empty.*/\r\n    FLEXCAN_RX_OVERRUN   = 0x6, /*!< MB is overwritten into a full buffer.*/\r\n    FLEXCAN_RX_BUSY      = 0x8, /*!< FlexCAN is updating the contents of the MB.*/\r\n                                /*!  The CPU must not access the MB.*/\r\n    FLEXCAN_RX_RANSWER   = 0xA, /*!< A frame was configured to recognize a Remote Request Frame*/\r\n                                /*!  and transmit a Response Frame in return.*/\r\n    FLEXCAN_RX_NOT_USED   = 0xF /*!< Not used*/\r\n};\r\n\r\n/*! @brief FlexCAN message buffer CODE FOR Tx buffers*/\r\nenum {\r\n    FLEXCAN_TX_INACTIVE  = 0x08, /*!< MB is not active.*/\r\n    FLEXCAN_TX_ABORT     = 0x09, /*!< MB is aborted.*/\r\n    FLEXCAN_TX_DATA      = 0x0C, /*!< MB is a TX Data Frame(MB RTR must be 0).*/\r\n    FLEXCAN_TX_REMOTE    = 0x1C, /*!< MB is a TX Remote Request Frame (MB RTR must be 1).*/\r\n    FLEXCAN_TX_TANSWER   = 0x0E, /*!< MB is a TX Response Request Frame from.*/\r\n                                 /*!  an incoming Remote Request Frame.*/\r\n    FLEXCAN_TX_NOT_USED   = 0xF  /*!< Not used*/\r\n};\r\n\r\n/*! @brief FlexCAN message buffer transmission types*/\r\nenum {\r\n    FLEXCAN_MB_STATUS_TYPE_TX,          /*!< Transmit MB*/\r\n    FLEXCAN_MB_STATUS_TYPE_TX_REMOTE,   /*!< Transmit remote request MB*/\r\n    FLEXCAN_MB_STATUS_TYPE_RX,          /*!< Receive MB*/\r\n    FLEXCAN_MB_STATUS_TYPE_RX_REMOTE,   /*!< Receive remote request MB*/\r\n    FLEXCAN_MB_STATUS_TYPE_RX_TX_REMOTE /*!< FlexCAN remote frame receives remote request and*/\r\n                                        /*!  transmits MB.*/\r\n};\r\n\r\n/*! @brief FlexCAN error interrupt types\r\n */\r\ntypedef enum {\r\n    FLEXCAN_INT_RX_WARNING = CAN_CTRL1_RWRNMSK_MASK,     /*!< RX warning interrupt*/\r\n    FLEXCAN_INT_TX_WARNING = CAN_CTRL1_TWRNMSK_MASK,     /*!< TX warning interrupt*/\r\n    FLEXCAN_INT_ERR        = CAN_CTRL1_ERRMSK_MASK,      /*!< Error interrupt*/\r\n    FLEXCAN_INT_BUSOFF     = CAN_CTRL1_BOFFMSK_MASK,     /*!< Bus off interrupt*/\r\n} flexcan_int_type_t;\r\n\r\n/*! @brief FlexCAN Message Buffer code and status for transmit and receive\r\n */\r\ntypedef struct {\r\n    uint32_t code;                        /*!< MB code for TX or RX buffers.*/\r\n                                          /*! Defined by flexcan_mb_code_rx_t and flexcan_mb_code_tx_t */\r\n    flexcan_msgbuff_id_type_t msgIdType;  /*!< Type of message ID (standard or extended)*/\r\n    uint32_t dataLen;                     /*!< Length of Data in Bytes*/\r\n    bool fd_enable;\r\n    uint8_t fd_padding;\r\n    bool enable_brs;                   /* Enable bit rate switch*/\r\n} flexcan_msgbuff_code_status_t;\r\n\r\n#define CAN_ID_EXT_MASK                          0x3FFFFu\r\n#define CAN_ID_EXT_SHIFT                         0\r\n#define CAN_ID_EXT_WIDTH                         18\r\n\r\n#define CAN_ID_STD_MASK                          0x1FFC0000u\r\n#define CAN_ID_STD_SHIFT                         18\r\n#define CAN_ID_STD_WIDTH                         11\r\n\r\n#define CAN_ID_PRIO_MASK                         0xE0000000u\r\n#define CAN_ID_PRIO_SHIFT                        29\r\n#define CAN_ID_PRIO_WIDTH                        3\r\n/* CS Bit Fields */\r\n#define CAN_CS_TIME_STAMP_MASK                   0xFFFFu\r\n#define CAN_CS_TIME_STAMP_SHIFT                  0\r\n#define CAN_CS_TIME_STAMP_WIDTH                  16\r\n\r\n#define CAN_CS_DLC_MASK                          0xF0000u\r\n#define CAN_CS_DLC_SHIFT                         16\r\n#define CAN_CS_DLC_WIDTH                         4\r\n\r\n#define CAN_CS_RTR_MASK                          0x100000u\r\n#define CAN_CS_RTR_SHIFT                         20\r\n#define CAN_CS_RTR_WIDTH                         1\r\n\r\n#define CAN_CS_IDE_MASK                          0x200000u\r\n#define CAN_CS_IDE_SHIFT                         21\r\n#define CAN_CS_IDE_WIDTH                         1\r\n\r\n#define CAN_CS_SRR_MASK                          0x400000u\r\n#define CAN_CS_SRR_SHIFT                         22\r\n#define CAN_CS_SRR_WIDTH                         1\r\n\r\n#define CAN_CS_CODE_MASK                         0xF000000u\r\n#define CAN_CS_CODE_SHIFT                        24\r\n#define CAN_CS_CODE_WIDTH                        4\r\n\r\n#define CAN_MB_EDL_MASK                          0x80000000u\r\n#define CAN_MB_BRS_MASK                          0x40000000u\r\n\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT     (31U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format A&B RTR mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT     (30U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format A&B IDE mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT      (15U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B RTR-2 mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT      (14U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B IDE-2 mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK       (0x3FFFFFFFU)  /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format A extended mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT      (1U)           /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format A extended shift.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_STD_MASK       (0x3FF80000U)  /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format A standard mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT      (19U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format A standard shift.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK       (0x1FFF8000U)  /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B extended mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK1\t\t (0x3FFFU)\t\t/*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B extended mask1.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1     (16U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B extended shift 1.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2     (0U)           /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B extended shift 2.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_MASK       (0x7FFU)       /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B standard mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1     (19U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B standard shift1.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2     (3U)           /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B standard shift2.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT  (15U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format B extended compare shift.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK       (0x1FE00000U)  /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_MASK       (0x7F8U)       /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C mask.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT1         (24U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C shift1.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT2         (16U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C shift2.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT3         (8U)           /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C shift3.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_SHIFT4         (0U)           /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C shift4.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT  (21U)          /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C extended compare shift.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT  (3U)           /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C standard compare shift.*/\r\n#define FLEXCAN_RX_FIFO_ID_FILTER_FORMATC_MASK         \t (0xFFU)        /*!< FlexCAN RX FIFO ID filter*/\r\n                                                                        /*! format C mask.*/\r\n\r\n/*! @brief FlexCAN endianness handling */\r\n#ifdef CORE_BIG_ENDIAN\r\n    #define FlexcanSwapBytesInWordIndex(index) (index)\r\n    #define FlexcanSwapBytesInWord(a, b) (b = a)\r\n#elif defined CORE_LITTLE_ENDIAN\r\n    #define FlexcanSwapBytesInWordIndex(index) (((index) & ~3U) + (3U - ((index) & 3U)))\r\n    #define FlexcanSwapBytesInWord(a, b) REV_BYTES_32(a, b)\r\n#else\r\n    #error \"No endianness defined!\"\r\n#endif\r\n\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name Configuration\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Get The Max no of MBs allowed on CAN instance.\r\n *\r\n * @param   base    The FlexCAN base address\r\n * @return  The Max No of MBs on the CAN instance;\r\n */\r\nuint32_t FLEXCAN_GetMaxMbNum(const CAN_Type * base);\r\n\r\n /*!\r\n *  @brief Calculate the Individual\\Global Mask as format ID type in FIFO Mode.\r\n *\r\n *  @param id_type  A standard ID or an extended ID\r\n *  @param formatType Filter Table Format\r\n *  @param mask Mask ID aligned LSB\r\n *  @return Mask calculated according to format type\r\n *\r\n */\r\nuint32_t FLEXCAN_GetRxFifoMask(\t flexcan_msgbuff_id_type_t id_type,\r\n                                 flexcan_rx_fifo_id_element_format_t formatType,\r\n                                 uint32_t mask);\r\n\r\n/*!\r\n * @brief Enables FlexCAN controller.\r\n *\r\n * @param   base    The FlexCAN base address\r\n */\r\nvoid FLEXCAN_Enable(CAN_Type * base);\r\n\r\n/*!\r\n * @brief Disables FlexCAN controller.\r\n *\r\n * @param   base    The FlexCAN base address\r\n */\r\nvoid FLEXCAN_Disable(CAN_Type * base);\r\n\r\n/*!\r\n * @brief Return last Message Buffer Occupied By RxFIFO\r\n *\r\n * @param   x    Number of Configured RxFIFO Filters\r\n * @return  number of last MB occupied by RxFIFO\r\n */\r\nstatic inline uint32_t RxFifoOcuppiedLastMsgBuff(uint32_t x)\r\n{\r\n    return (5U + ((((x) + 1U) * 8U) / 4U));\r\n}\r\n\r\n/*!\r\n * @brief Checks if the FlexCAN is enabled.\r\n *\r\n * @param   base    The FlexCAN base address\r\n * @return  true if enabled; false if disabled\r\n */\r\nstatic inline bool FLEXCAN_IsEnabled(const CAN_Type * base)\r\n{\r\n    return ((((base->MCR & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT) != 0U) ? false : true);\r\n}\r\n\r\n#if FEATURE_CAN_HAS_PE_CLKSRC_SELECT\r\n/*!\r\n * @brief Selects the clock source for FlexCAN.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   clk         The FlexCAN clock source\r\n */\r\nstatic inline void FLEXCAN_SelectClock(CAN_Type * base, flexcan_clk_source_t clk)\r\n{\r\n    base->CTRL1 = (base->CTRL1 & ~CAN_CTRL1_CLKSRC_MASK) | CAN_CTRL1_CLKSRC(clk);\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Initializes the FlexCAN controller.\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nvoid FLEXCAN_Init(CAN_Type * base);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN time segments for setting up bit rate.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.\r\n */\r\nstatic inline void FLEXCAN_SetTimeSegments(CAN_Type * base, const flexcan_time_segment_t *timeSeg)\r\n{\r\n    DEV_ASSERT(timeSeg != NULL);\r\n\r\n    (base->CTRL1) = ((base->CTRL1) & ~((CAN_CTRL1_PROPSEG_MASK | CAN_CTRL1_PSEG2_MASK |\r\n                                        CAN_CTRL1_PSEG1_MASK | CAN_CTRL1_PRESDIV_MASK) |\r\n                                        CAN_CTRL1_RJW_MASK));\r\n\r\n    (base->CTRL1) = ((base->CTRL1) | (CAN_CTRL1_PROPSEG(timeSeg->propSeg) |\r\n                                      CAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |\r\n                                      CAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |\r\n                                      CAN_CTRL1_PRESDIV(timeSeg->preDivider) |\r\n                                      CAN_CTRL1_RJW(timeSeg->rJumpwidth)));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx individual mask for ID filtering in the Rx Message Buffers and the Rx FIFO.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @param   mask     Individual mask\r\n */\r\nstatic inline void FLEXCAN_SetRxIndividualMask(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    uint32_t mask)\r\n{\r\n    base->RXIMR[msgBuffIdx] = mask;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN RX FIFO global mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   Mask     Sets mask\r\n */\r\nstatic inline void FLEXCAN_SetRxFifoGlobalMask(CAN_Type * base, uint32_t Mask)\r\n{\r\n    (base->RXFGMASK) = Mask;\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Sets the FlexCAN extended time segments for setting up bit rate.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.\r\n */\r\nstatic inline void FLEXCAN_SetExtendedTimeSegments(CAN_Type * base, const flexcan_time_segment_t *timeSeg)\r\n{\r\n    DEV_ASSERT(timeSeg != NULL);\r\n\r\n    /* If extended bit time definitions are enabled, use CBT register */\r\n    (base->CBT) = ((base->CBT) & ~((CAN_CBT_EPROPSEG_MASK | CAN_CBT_EPSEG2_MASK |\r\n                                    CAN_CBT_EPSEG1_MASK | CAN_CBT_EPRESDIV_MASK) |\r\n                                    CAN_CBT_ERJW_MASK));\r\n\r\n    (base->CBT) = ((base->CBT) | (CAN_CBT_EPROPSEG(timeSeg->propSeg) |\r\n                                  CAN_CBT_EPSEG2(timeSeg->phaseSeg2) |\r\n                                  CAN_CBT_EPSEG1(timeSeg->phaseSeg1) |\r\n                                  CAN_CBT_EPRESDIV(timeSeg->preDivider) |\r\n                                  CAN_CBT_ERJW(timeSeg->rJumpwidth)));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN time segments for setting up bit rate for FD BRS.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.\r\n */\r\nstatic inline void FLEXCAN_SetFDTimeSegments(CAN_Type * base, const flexcan_time_segment_t *timeSeg)\r\n{\r\n    DEV_ASSERT(timeSeg != NULL);\r\n\r\n    /* Set FlexCAN time segments*/\r\n    (base->FDCBT) = ((base->FDCBT) & ~((CAN_FDCBT_FPROPSEG_MASK | CAN_FDCBT_FPSEG2_MASK |\r\n                                        CAN_FDCBT_FPSEG1_MASK | CAN_FDCBT_FPRESDIV_MASK) |\r\n                                        CAN_FDCBT_FRJW_MASK));\r\n\r\n    (base->FDCBT) = ((base->FDCBT) | (CAN_FDCBT_FPROPSEG(timeSeg->propSeg) |\r\n                                      CAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |\r\n                                      CAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |\r\n                                      CAN_FDCBT_FPRESDIV(timeSeg->preDivider) |\r\n                                      CAN_FDCBT_FRJW(timeSeg->rJumpwidth)));\r\n}\r\n\r\n/*!\r\n * @brief Gets the FlexCAN extended time segments used for setting up bit rate.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   timeSeg    FlexCAN time segments read for bit rate\r\n */\r\nstatic inline void FLEXCAN_GetExtendedTimeSegments(const CAN_Type * base, flexcan_time_segment_t *timeSeg)\r\n{\r\n\tDEV_ASSERT(timeSeg != NULL);\r\n\r\n\ttimeSeg->preDivider = ((base->CBT) & CAN_CBT_EPRESDIV_MASK) >> CAN_CBT_EPRESDIV_SHIFT;\r\n\ttimeSeg->propSeg = ((base->CBT) & CAN_CBT_EPROPSEG_MASK) >> CAN_CBT_EPROPSEG_SHIFT;\r\n\ttimeSeg->phaseSeg1 = ((base->CBT) & CAN_CBT_EPSEG1_MASK) >> CAN_CBT_EPSEG1_SHIFT;\r\n\ttimeSeg->phaseSeg2 = ((base->CBT) & CAN_CBT_EPSEG2_MASK) >> CAN_CBT_EPSEG2_SHIFT;\r\n\ttimeSeg->rJumpwidth = ((base->CBT) & CAN_CBT_ERJW_MASK) >> CAN_CBT_ERJW_SHIFT;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Gets the FlexCAN time segments to calculate the bit rate.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   timeSeg    FlexCAN time segments read for bit rate\r\n */\r\nstatic inline void FLEXCAN_GetTimeSegments(const CAN_Type * base, flexcan_time_segment_t *timeSeg)\r\n{\r\n    DEV_ASSERT(timeSeg != NULL);\r\n\r\n    timeSeg->preDivider = ((base->CTRL1) & CAN_CTRL1_PRESDIV_MASK) >> CAN_CTRL1_PRESDIV_SHIFT;\r\n    timeSeg->propSeg = ((base->CTRL1) & CAN_CTRL1_PROPSEG_MASK) >> CAN_CTRL1_PROPSEG_SHIFT;\r\n    timeSeg->phaseSeg1 = ((base->CTRL1) & CAN_CTRL1_PSEG1_MASK) >> CAN_CTRL1_PSEG1_SHIFT;\r\n    timeSeg->phaseSeg2 = ((base->CTRL1) & CAN_CTRL1_PSEG2_MASK) >> CAN_CTRL1_PSEG2_SHIFT;\r\n    timeSeg->rJumpwidth = ((base->CTRL1) & CAN_CTRL1_RJW_MASK) >> CAN_CTRL1_RJW_SHIFT;\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Gets the  FlexCAN time segments for FD BRS to calculate the bit rate.\r\n *\r\n * @param   base The FlexCAN base address\r\n * @param   timeSeg    FlexCAN time segments read for bit rate\r\n */\r\nstatic inline void FLEXCAN_GetFDTimeSegments(const CAN_Type * base, flexcan_time_segment_t *timeSeg)\r\n{\r\n    DEV_ASSERT(timeSeg != NULL);\r\n\r\n    timeSeg->preDivider = ((base->FDCBT) & CAN_FDCBT_FPRESDIV_MASK) >> CAN_FDCBT_FPRESDIV_SHIFT;\r\n    timeSeg->propSeg = ((base->FDCBT) & CAN_FDCBT_FPROPSEG_MASK) >> CAN_FDCBT_FPROPSEG_SHIFT;\r\n    timeSeg->phaseSeg1 = ((base->FDCBT) & CAN_FDCBT_FPSEG1_MASK) >> CAN_FDCBT_FPSEG1_SHIFT;\r\n    timeSeg->phaseSeg2 = ((base->FDCBT) & CAN_FDCBT_FPSEG2_MASK) >> CAN_FDCBT_FPSEG2_SHIFT;\r\n    timeSeg->rJumpwidth = ((base->FDCBT) & CAN_FDCBT_FRJW_MASK) >> CAN_FDCBT_FRJW_SHIFT;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Get freeze status of the FlexCAN module.\r\n *\r\n * @param   base     The FlexCAN base address\r\n * @return  true if module is in freeze mode; false if module is not in freeze mode\r\n */\r\nstatic inline bool FLEXCAN_GetFreezeMode(const CAN_Type * base)\r\n{\r\n\treturn ((base->MCR & CAN_MCR_FRZACK_MASK) == CAN_MCR_FRZACK_MASK);\r\n}\r\n\r\n/*!\r\n * @brief Un freezes the FlexCAN module.\r\n *\r\n * @param   base     The FlexCAN base address\r\n */\r\nvoid FLEXCAN_ExitFreezeMode(CAN_Type * base);\r\n\r\n/*!\r\n * @brief Freezes the FlexCAN module.\r\n * In case of Bus-Off error  this function can Soft reset,\r\n * the FlexCan interface, check errata 9595\r\n *\r\n * @param   base     The FlexCAN base address\r\n */\r\nvoid FLEXCAN_EnterFreezeMode(CAN_Type * base);\r\n\r\n/*!\r\n * @brief Set operation mode.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   mode  Set an operation mode\r\n */\r\nvoid FLEXCAN_SetOperationMode(\r\n    CAN_Type * base,\r\n    flexcan_operation_modes_t mode);\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Enables/Disables Flexible Data rate (if supported).\r\n *\r\n * @param   base    The FlexCAN base address\r\n * @param   enable  true to enable; false to disable\r\n */\r\nstatic inline void FLEXCAN_SetFDEnabled(CAN_Type * base, bool enable)\r\n{\r\n    base->MCR = (base->MCR & ~CAN_MCR_FDEN_MASK) | CAN_MCR_FDEN(enable? 1UL : 0UL);\r\n\r\n    /* Enable the use of extended bit time definitions */\r\n    base->CBT = (base->CBT & ~CAN_CBT_BTF_MASK) | CAN_CBT_BTF(enable? 1UL : 0UL);\r\n\r\n    /* Disable Transmission Delay Compensation by default */\r\n    base->FDCTRL &= ~(CAN_FDCTRL_TDCEN_MASK | CAN_FDCTRL_TDCOFF_MASK);\r\n}\r\n\r\n/*!\r\n * @brief Checks if the Flexible Data rate feature is enabled.\r\n *\r\n * @param   base    The FlexCAN base address\r\n * @return  true if enabled; false if disabled\r\n */\r\nstatic inline bool FLEXCAN_IsFDEnabled(const CAN_Type * base)\r\n{\r\n    return (((base->MCR & CAN_MCR_FDEN_MASK) >> CAN_MCR_FDEN_SHIFT) != 0U);\r\n}\r\n\r\n/*!\r\n * @brief Sets the payload size of the MBs.\r\n *\r\n * @param   base         The FlexCAN base address\r\n * @param   payloadSize  The payload size\r\n */\r\nvoid FLEXCAN_SetPayloadSize(\r\n    CAN_Type * base,\r\n    flexcan_fd_payload_size_t payloadSize);\r\n\r\n/*!\r\n * @brief Gets the payload size of the MBs.\r\n *\r\n * @param   base         The FlexCAN base address\r\n * @return  The payload size in bytes\r\n */\r\nuint8_t FLEXCAN_GetPayloadSize(const CAN_Type * base);\r\n#endif /* FEATURE_CAN_HAS_FD */\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Data transfer\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sets the FlexCAN message buffer fields for transmitting.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @return  Pointer to the beginning of the MBs space address\r\n */\r\nvolatile uint32_t* FLEXCAN_GetMsgBuffRegion(\r\n        CAN_Type * base,\r\n        uint32_t msgBuffIdx);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN message buffer fields for transmitting.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx   Index of the message buffer\r\n * @param   cs           CODE/status values (TX)\r\n * @param   msgId        ID of the message to transmit\r\n * @param   msgData      Bytes of the FlexCAN message\r\n * @param   isRemote     Will set RTR remote Flag\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_FLEXCAN_MB_OUT_OF_RANGE if the index of the\r\n *          message buffer is invalid\r\n */\r\nstatus_t FLEXCAN_SetTxMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    const flexcan_msgbuff_code_status_t *cs,\r\n    uint32_t msgId,\r\n    const uint8_t *msgData,\r\n    const bool isRemote);\r\n\r\n/*!\r\n * @brief Writes the abort code into the CODE field of the requested Tx message\r\n * buffer.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx Index of the message buffer\r\n */\r\nvoid FLEXCAN_AbortTxMsgBuff(CAN_Type * base, uint32_t msgBuffIdx);\r\n\r\n/*!\r\n * @brief   : Writes the Inactive Rx code into the CODE field of the requested\r\n * Rx message buffer the MB to active Rx. This will force even the unlock of the RxMB.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx Index of the message buffer\r\n *\r\n *END**************************************************************************/\r\nvoid FLEXCAN_ResetRxMsgBuff(CAN_Type * base, uint32_t msgBuffIdx);\r\n\r\n/*!\r\n * @brief Sets the FlexCAN message buffer fields for receiving.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @param   cs           CODE/status values (RX)\r\n * @param   msgId       ID of the message to receive\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_FLEXCAN_MB_OUT_OF_RANGE if the index of the\r\n *          message buffer is invalid\r\n */\r\nstatus_t FLEXCAN_SetRxMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    const flexcan_msgbuff_code_status_t *cs,\r\n    uint32_t msgId);\r\n\r\n/*!\r\n * @brief Gets the FlexCAN message buffer fields.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @param   msgBuff           The fields of the message buffer\r\n */\r\nvoid FLEXCAN_GetMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    flexcan_msgbuff_t *msgBuff);\r\n\r\n/*!\r\n * @brief Locks the FlexCAN Rx message buffer.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n *\r\n */\r\nvoid FLEXCAN_LockRxMsgBuff(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx);\r\n\r\n/*!\r\n * @brief Unlocks the FlexCAN Rx message buffer.\r\n *\r\n * @param   base     The FlexCAN base address\r\n */\r\nstatic inline void FLEXCAN_UnlockRxMsgBuff(const CAN_Type * base)\r\n{\r\n    /* Unlock the mailbox by reading the free running timer */\r\n    (void)base->TIMER;\r\n}\r\n\r\n/*!\r\n * @brief Enables the Rx FIFO.\r\n *\r\n * @param   base     The FlexCAN base address\r\n * @param   numOfFilters    The number of Rx FIFO filters\r\n * @return  The status of the operation\r\n * @retval  STATUS_SUCCESS RxFIFO was successfully enabled\r\n * @retval  STATUS_ERROR RxFIFO could not be enabled (e.g. the FD feature\r\n *          was enabled, and these two features are not compatible)\r\n */\r\nstatus_t FLEXCAN_EnableRxFifo(CAN_Type * base, uint32_t numOfFilters);\r\n\r\n/*!\r\n * @brief Checks if Rx FIFO is enabled.\r\n *\r\n * @param   base     The FlexCAN base address\r\n * @return  RxFifo status (true = enabled / false = disabled)\r\n */\r\nstatic inline bool FLEXCAN_IsRxFifoEnabled(const CAN_Type * base)\r\n{\r\n    return (((base->MCR & CAN_MCR_RFEN_MASK) >> CAN_MCR_RFEN_SHIFT) != 0U);\r\n}\r\n\r\n/*!\r\n * @brief Return Rx FIFO Id Format.\r\n *\r\n * @param   base     The FlexCAN base address\r\n * @return  RxFifo Id Format\r\n */\r\nstatic inline flexcan_rx_fifo_id_element_format_t FLEXCAN_GetRxFifoIdFormat(const CAN_Type * base)\r\n{\r\n\tflexcan_rx_fifo_id_element_format_t id_type=FLEXCAN_RX_FIFO_ID_FORMAT_A;\r\n    switch((base->MCR & CAN_MCR_IDAM_MASK) >> CAN_MCR_IDAM_SHIFT)\r\n    {\r\n\t\tcase 0U:\r\n\t\t\tid_type=FLEXCAN_RX_FIFO_ID_FORMAT_A;\r\n\t\t\tbreak;\r\n\t\tcase 1U:\r\n\t\t\tid_type=FLEXCAN_RX_FIFO_ID_FORMAT_B;\r\n\t\t\tbreak;\r\n\t\tcase 2U:\r\n\t\t\tid_type=FLEXCAN_RX_FIFO_ID_FORMAT_C;\r\n\t\t\tbreak;\r\n\t\tcase 3U:\r\n\t\t\tid_type=FLEXCAN_RX_FIFO_ID_FORMAT_D;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t{\r\n\t\t\t/* This case should never be reached */\r\n\t\t\tDEV_ASSERT(false);\r\n\t\t\tbreak;\r\n\t\t}\r\n    }\r\n    return id_type;\r\n}\r\n\r\n/*!\r\n * @brief Sets  the maximum number of Message Buffers.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   maxMsgBuffNum     Maximum number of message buffers\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_FLEXCAN_MB_OUT_OF_RANGE if the index of the\r\n *          message buffer is invalid\r\n */\r\nstatus_t FLEXCAN_SetMaxMsgBuffNum(\r\n    CAN_Type * base,\r\n    uint32_t maxMsgBuffNum);\r\n\r\n/*!\r\n * @brief Gets the maximum number of Message Buffers.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  the configured number of message buffers\r\n */\r\nstatic inline uint32_t FLEXCAN_GetMaxMsgBuffNum(const CAN_Type * base)\r\n{\r\n    return (((base->MCR) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx FIFO fields.\r\n *\r\n * @param   base             The FlexCAN base address\r\n * @param   idFormat         The format of the Rx FIFO ID Filter Table Elements\r\n * @param   idFilterTable    The ID filter table elements which contain RTR bit,\r\n *                           IDE bit, and RX message ID.\r\n */\r\nvoid FLEXCAN_SetRxFifoFilter(\r\n    CAN_Type * base,\r\n    flexcan_rx_fifo_id_element_format_t idFormat,\r\n    const flexcan_id_table_t *idFilterTable);\r\n\r\n/*!\r\n * @brief Gets the FlexCAN Rx FIFO data.\r\n *\r\n * @param   base    The FlexCAN base address\r\n * @param   rxFifo  The FlexCAN receive FIFO data\r\n */\r\nvoid FLEXCAN_ReadRxFifo(\r\n    const CAN_Type * base,\r\n    flexcan_msgbuff_t *rxFifo);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Interrupts\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Enables/Disables the FlexCAN Message Buffer interrupt.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @param   enable       choose enable or disable\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_FLEXCAN_MB_OUT_OF_RANGE if the index of the\r\n *          message buffer is invalid\r\n */\r\nstatus_t FLEXCAN_SetMsgBuffIntCmd(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx, bool enable);\r\n\r\n/*!\r\n * @brief Enables error interrupt of the FlexCAN module.\r\n * @param   base     The FlexCAN base address\r\n * @param   errType     The interrupt type\r\n * @param   enable       choose enable or disable\r\n */\r\nvoid FLEXCAN_SetErrIntCmd(CAN_Type * base, flexcan_int_type_t errType, bool enable);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Status\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Get the interrupt enable\\disabled of the message buffers.\r\n *\r\n * @param   base  \t\tThe FlexCAN base address\r\n * @param   msgBuffIdx  Index of the message buffer\r\n * @return  flag        The value of interrupt of the message buffer.\r\n * \t\t\t\t\t\t1 - interrupt enabled;\r\n * \t\t\t\t\t\t0 - interrupt disabled;\r\n */\r\nstatic inline uint8_t FLEXCAN_GetMsgBuffIntStatus(const CAN_Type * base, uint32_t msgBuffIdx)\r\n{\r\n\tuint32_t flag = 0U;\r\n\r\n    if (msgBuffIdx < 32U)\r\n    {\r\n        flag = ((base->IMASK1 & ((uint32_t)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));\r\n    }\r\n#if FEATURE_CAN_MAX_MB_NUM > 32U\r\n    if ((msgBuffIdx >= 32U) && (msgBuffIdx < 64U))\r\n    {\r\n    \tflag = ((base->IMASK2 & ((uint32_t)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));\r\n    }\r\n#endif\r\n#if FEATURE_CAN_MAX_MB_NUM > 64U\r\n    if (msgBuffIdx >= 64U)\r\n    {\r\n    \tflag = ((base->IMASK3 & ((uint32_t)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));\r\n    }\r\n#endif\r\n    return (uint8_t)flag;\r\n}\r\n\r\n/*!\r\n * @brief Gets the individual FlexCAN MB interrupt flag.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @return  the individual Message Buffer interrupt flag (0 and 1 are the flag value)\r\n */\r\nstatic inline uint8_t FLEXCAN_GetMsgBuffIntStatusFlag(const CAN_Type * base, uint32_t msgBuffIdx)\r\n{\r\n    uint8_t flag = 0;\r\n    uint32_t mask;\r\n\r\n    if (msgBuffIdx < 32U)\r\n    {\r\n        mask = base->IMASK1 & CAN_IMASK1_BUF31TO0M_MASK;\r\n        flag = (uint8_t)(((base->IFLAG1 & mask) >> (msgBuffIdx % 32U)) & 1U);\r\n    }\r\n#if FEATURE_CAN_MAX_MB_NUM > 32U\r\n    if ((msgBuffIdx >= 32U) && (msgBuffIdx < 64U))\r\n    {\r\n        mask = base->IMASK2 & CAN_IMASK2_BUF63TO32M_MASK;\r\n        flag = (uint8_t)(((base->IFLAG2 & mask) >> (msgBuffIdx % 32U)) & 1U);\r\n    }\r\n#endif\r\n#if FEATURE_CAN_MAX_MB_NUM > 64U\r\n    if (msgBuffIdx >= 64U)\r\n    {\r\n        mask = base->IMASK3 & CAN_IMASK3_BUF95TO64M_MASK;\r\n        flag = (uint8_t)(((base->IFLAG3 & mask) >> (msgBuffIdx % 32U)) & 1U);\r\n    }\r\n#endif\r\n\r\n    return flag;\r\n}\r\n\r\n/*!\r\n * @brief Clears the FIFO\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nstatic inline void FLEXCAN_ClearFIFO(CAN_Type * base)\r\n{\r\n    base->IFLAG1 = CAN_IFLAG1_BUF0I_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Clears the interrupt flag of the message buffers.\r\n *\r\n * @param   base  \t\tThe FlexCAN base address\r\n * @param   msgBuffIdx  Index of the message buffer\r\n */\r\nstatic inline void FLEXCAN_ClearMsgBuffIntStatusFlag(CAN_Type * base, uint32_t msgBuffIdx)\r\n{\r\n    uint32_t flag = ((uint32_t)1U << (msgBuffIdx % 32U));\r\n\r\n    /* Clear the corresponding message buffer interrupt flag*/\r\n    if (msgBuffIdx < 32U)\r\n    {\r\n        (base->IFLAG1) = (flag);\r\n    }\r\n#if FEATURE_CAN_MAX_MB_NUM > 32U\r\n    if ((msgBuffIdx >= 32U) && (msgBuffIdx < 64U))\r\n    {\r\n        (base->IFLAG2) = (flag);\r\n    }\r\n#endif\r\n#if FEATURE_CAN_MAX_MB_NUM > 64U\r\n    if (msgBuffIdx >= 64U)\r\n    {\r\n        (base->IFLAG3) = (flag);\r\n    }\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Get the interrupt flag of the message buffers.\r\n *\r\n * @param   base  \t\tThe FlexCAN base address\r\n * @param   msgBuffIdx  Index of the message buffer\r\n * @return  flag        The value of interrupt flag of the message buffer.\r\n */\r\nstatic inline uint8_t FLEXCAN_GetBuffStatusFlag(const CAN_Type * base, uint32_t msgBuffIdx)\r\n{\r\n\tuint32_t flag = 0U;\r\n\r\n    if (msgBuffIdx < 32U)\r\n    {\r\n        flag = ((base->IFLAG1 & ((uint32_t)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));\r\n    }\r\n#if FEATURE_CAN_MAX_MB_NUM > 32U\r\n    if ((msgBuffIdx >= 32U) && (msgBuffIdx < 64U))\r\n    {\r\n    \tflag = ((base->IFLAG2 & ((uint32_t)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));\r\n    }\r\n#endif\r\n#if FEATURE_CAN_MAX_MB_NUM > 64U\r\n    if (msgBuffIdx >= 64U)\r\n    {\r\n    \tflag = ((base->IFLAG3 & ((uint32_t)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));\r\n    }\r\n#endif\r\n    return (uint8_t)flag;\r\n}\r\n\r\n/*!\r\n * @brief Clears all other interrupts in ERRSTAT register (Error, Busoff, Wakeup).\r\n *\r\n * @param   base     The FlexCAN base address\r\n */\r\nvoid FLEXCAN_ClearErrIntStatusFlag(CAN_Type * base);\r\n\r\n/*!\r\n * @brief Clears BusOff interrupts in ESR register\r\n *\r\n * @param   base     The FlexCAN base address\r\n */\r\nvoid FLEXCAN_ClearBusOffIntStatusFlag(CAN_Type * base);\r\n\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n/*!\r\n * @brief Gets the error counters.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  the value of the FlexCAN error counters\r\n */\r\nstatic inline uint32_t FLEXCAN_GetErrorCounters(const CAN_Type * base)\r\n{\r\n    return base->ECR;\r\n}\r\n#endif\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name Mask\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sets the Rx masking type.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   type         The FlexCAN Rx mask type\r\n */\r\nstatic inline void FLEXCAN_SetRxMaskType(CAN_Type * base, flexcan_rx_mask_type_t type)\r\n{\r\n    /* Set RX masking type (RX global mask or RX individual mask)*/\r\n    if (type == FLEXCAN_RX_MASK_GLOBAL)\r\n    {\r\n        /* Enable Global RX masking */\r\n        base->MCR = (base->MCR & ~CAN_MCR_IRMQ_MASK) | CAN_MCR_IRMQ(0U);\r\n    }\r\n    else\r\n    {\r\n        /* Enable Individual Rx Masking and Queue */\r\n        base->MCR = (base->MCR & ~CAN_MCR_IRMQ_MASK) | CAN_MCR_IRMQ(1U);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Get the no of Rx FIFO ID Filter Table Elements Affected by Rx Individual Masks\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  the max no of elements affected by Rx Individual Mask register RXMIR in RxFIFO Mode\r\n */\r\nstatic inline uint8_t FLEXCAN_GetNoOfIndividualMBsRxFIFO(const CAN_Type * base)\r\n{\r\n\t/* Get the number of RX FIFO Filters*/\r\n\tuint8_t ret = (uint8_t)(((base->CTRL2) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT);\r\n\t/* Max filters configured by individual mask are (7 + RFFN * 2) depends on the FIFO size,\r\n\t * max allowed value is 31 RXIMR */\r\n\tret = (uint8_t)(7u + ((uint32_t)ret << 1u));\r\n\r\n\treturn ret;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx individual standard mask for ID filtering in the Rx MBs and the Rx FIFO.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @param   stdMask     Individual standard mask\r\n */\r\nstatic inline void FLEXCAN_SetRxIndividualStdMask(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    uint32_t stdMask)\r\n{\r\n    (base->RXIMR[msgBuffIdx]) = (stdMask << CAN_ID_STD_SHIFT) & CAN_ID_STD_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx individual extended mask for ID filtering in the Rx Message Buffers and the Rx FIFO.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   msgBuffIdx       Index of the message buffer\r\n * @param   extMask     Individual extended mask\r\n */\r\nstatic inline void FLEXCAN_SetRxIndividualExtMask(\r\n    CAN_Type * base,\r\n    uint32_t msgBuffIdx,\r\n    uint32_t extMask)\r\n{\r\n    base->RXIMR[msgBuffIdx] = (extMask << CAN_ID_EXT_SHIFT) & (CAN_ID_STD_MASK | CAN_ID_EXT_MASK);\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx Message Buffer global standard mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   stdMask     Standard mask\r\n */\r\nstatic inline void FLEXCAN_SetRxMsgBuffGlobalStdMask(CAN_Type * base, uint32_t stdMask)\r\n{\r\n    (base->RXMGMASK) = (((uint32_t)(((uint32_t)(stdMask)) << CAN_ID_STD_SHIFT)) & CAN_ID_STD_MASK);\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN RX Message Buffer global extended mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   extMask     Extended mask\r\n */\r\nstatic inline void FLEXCAN_SetRxMsgBuffGlobalExtMask(CAN_Type * base, uint32_t extMask)\r\n{\r\n    (base->RXMGMASK) = (((uint32_t)(((uint32_t)(extMask)) << CAN_ID_EXT_SHIFT)) &\r\n                        (CAN_ID_STD_MASK | CAN_ID_EXT_MASK));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx Message Buffer 14 standard mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   stdMask     Standard mask\r\n */\r\nstatic inline void FLEXCAN_SetRxMsgBuff14StdMask(CAN_Type * base, uint32_t stdMask)\r\n{\r\n    (base->RX14MASK) = (((uint32_t)(((uint32_t)(stdMask)) << CAN_ID_STD_SHIFT)) & CAN_ID_STD_MASK);\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN RX Message Buffer 14 extended mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   extMask     Extended mask\r\n */\r\nstatic inline void FLEXCAN_SetRxMsgBuff14ExtMask(CAN_Type * base, uint32_t extMask)\r\n{\r\n    (base->RX14MASK) = (((uint32_t)(((uint32_t)(extMask)) << CAN_ID_EXT_SHIFT)) &\r\n                        (CAN_ID_STD_MASK | CAN_ID_EXT_MASK));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN Rx Message Buffer 15 standard mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   stdMask     Standard mask\r\n */\r\nstatic inline void FLEXCAN_SetRxMsgBuff15StdMask(CAN_Type * base, uint32_t stdMask)\r\n{\r\n    (base->RX15MASK) = (((uint32_t)(((uint32_t)(stdMask)) << CAN_ID_STD_SHIFT)) & CAN_ID_STD_MASK);\r\n}\r\n\r\n/*!\r\n * @brief Sets the FlexCAN RX Message Buffer 15 extended mask.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   extMask     Extended mask\r\n */\r\nstatic inline void FLEXCAN_SetRxMsgBuff15ExtMask(CAN_Type * base, uint32_t extMask)\r\n{\r\n    (base->RX15MASK) = (((uint32_t)(((uint32_t)(extMask)) << CAN_ID_EXT_SHIFT)) &\r\n                        (CAN_ID_STD_MASK | CAN_ID_EXT_MASK));\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Enables/Disables the Stuff Bit Count for CAN FD frames.\r\n *\r\n * If enabled, the modulo 8 count of variable stuff bits inserted plus the respective\r\n * parity bit (even parity calculated over the 3-bit modulo 8 count) are combined as\r\n * the 4-bit Stuff Count field and inserted before the CRC Sequence field. CRC\r\n * calculation extends beyond the end of Data field and takes the Stuff Count field bits\r\n * into account.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   enable Enable/Disable Stuff Bit Count\r\n */\r\nstatic inline void FLEXCAN_SetStuffBitCount(CAN_Type * base, bool enable)\r\n{\r\n#if FEATURE_CAN_HAS_STFCNTEN_ENABLE\r\n    base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_STFCNTEN_MASK) | CAN_CTRL2_STFCNTEN(enable? 1UL : 0UL);\r\n#elif FEATURE_CAN_HAS_ISOCANFDEN_ENABLE\r\n    base->CTRL2 = (base->CTRL2 & ~CAN_CTRL2_ISOCANFDEN_MASK) |\r\n                   CAN_CTRL2_ISOCANFDEN(enable? 1UL : 0UL);\r\n\r\n#ifdef ERRATA_E8759\r\n    uint8_t flag = (uint8_t)(((base->CTRL2) & CAN_CTRL2_ISOCANFDEN_MASK) >> CAN_CTRL2_ISOCANFDEN_SHIFT);\r\n\r\n    DEV_ASSERT((enable == false) || (flag == 1UL));\r\n    (void)flag;\r\n#endif\r\n\r\n#endif\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Enables/Disables the Self Reception feature.\r\n *\r\n * If enabled, FlexCAN is allowed to receive frames transmitted by itself.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   enable Enable/Disable Self Reception\r\n */\r\nstatic inline void FLEXCAN_SetSelfReception(CAN_Type * base, bool enable)\r\n{\r\n    base->MCR = (base->MCR & ~CAN_MCR_SRXDIS_MASK) | CAN_MCR_SRXDIS(enable? 0UL : 1UL);\r\n}\r\n\r\n#if FEATURE_CAN_HAS_FD\r\n/*!\r\n * @brief Enables/Disables the Transceiver Delay Compensation feature and sets\r\n * the Transceiver Delay Compensation Offset (offset value to be added to the\r\n * measured transceiver's loop delay in order to define the position of the\r\n * delayed comparison point when bit rate switching is active).\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   enable Enable/Disable Transceiver Delay Compensation\r\n * @param   offset Transceiver Delay Compensation Offset\r\n */\r\nstatic inline void FLEXCAN_SetTDCOffset(CAN_Type * base, bool enable, uint8_t offset)\r\n{\r\n    uint32_t tmp;\r\n\r\n    tmp = base->FDCTRL;\r\n    tmp &= ~(CAN_FDCTRL_TDCEN_MASK | CAN_FDCTRL_TDCOFF_MASK);\r\n\r\n    if (enable)\r\n    {\r\n        tmp = tmp | CAN_FDCTRL_TDCEN_MASK;\r\n        tmp = tmp | CAN_FDCTRL_TDCOFF(offset);\r\n    }\r\n\r\n    base->FDCTRL = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Check if selected instance support FD feature or not?\r\n * this function shall return True if selected instance support FD and False\r\n * otherwise\r\n *\r\n * @param   instance  The FlexCAN instance id\r\n */\r\nstatic inline bool FLEXCAN_InstanceHasFD(uint8_t instance)\r\n{\r\n    static const bool fdInstances[] = FEATURE_CAN_INSTANCES_HAS_FD;\r\n    return fdInstances[instance];\r\n}\r\n#endif\r\n\r\n#if FEATURE_CAN_HAS_DMA_ENABLE\r\n/*!\r\n * @brief Enables/Disables the DMA support for RxFIFO.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   enable Enable/Disable DMA support\r\n */\r\nstatic inline void FLEXCAN_SetRxFifoDMA(CAN_Type * base, bool enable)\r\n{\r\n    base->MCR = (base->MCR & ~CAN_MCR_DMA_MASK) | CAN_MCR_DMA(enable? 1UL : 0UL);\r\n}\r\n#endif\r\n\r\n#if FEATURE_CAN_HAS_PRETENDED_NETWORKING\r\n\r\n/*!\r\n * @brief Configures Pretended Networking mode filtering selection.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   wakeUpTimeout  enable/disable wake up by timeout\r\n * @param   wakeUpMatch  enable/disable wake up by match\r\n * @param   numMatches  set number of messages matching the same filtering criteria\r\n * @param   filterComb  set filtering combination selection\r\n * @param   idFilterType  set ID filtering selection\r\n * @param   payloadFilterType  set payload filtering selection\r\n *\r\n */\r\nstatic inline void FLEXCAN_SetPNFilteringSelection(\r\n        CAN_Type * base,\r\n        bool wakeUpTimeout,\r\n        bool wakeUpMatch,\r\n        uint16_t numMatches,\r\n        flexcan_pn_filter_combination_t filterComb,\r\n        flexcan_pn_filter_selection_t idFilterType,\r\n        flexcan_pn_filter_selection_t payloadFilterType)\r\n{\r\n    uint32_t tmp;\r\n\r\n    tmp = base->CTRL1_PN;\r\n    tmp &= ~(CAN_CTRL1_PN_WTOF_MSK_MASK |\r\n             CAN_CTRL1_PN_WUMF_MSK_MASK |\r\n             CAN_CTRL1_PN_NMATCH_MASK |\r\n             CAN_CTRL1_PN_PLFS_MASK |\r\n             CAN_CTRL1_PN_IDFS_MASK |\r\n             CAN_CTRL1_PN_FCS_MASK);\r\n    tmp |= CAN_CTRL1_PN_WTOF_MSK(wakeUpTimeout ? 1UL : 0UL);\r\n    tmp |= CAN_CTRL1_PN_WUMF_MSK(wakeUpMatch ? 1UL : 0UL);\r\n    tmp |= CAN_CTRL1_PN_NMATCH(numMatches);\r\n    tmp |= CAN_CTRL1_PN_FCS(filterComb);\r\n    tmp |= CAN_CTRL1_PN_IDFS(idFilterType);\r\n    tmp |= CAN_CTRL1_PN_PLFS(payloadFilterType);\r\n    base->CTRL1_PN = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Set PN timeout value.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   timeoutValue  timeout for no message matching\r\n */\r\nstatic inline void FLEXCAN_SetPNTimeoutValue(CAN_Type * base, uint16_t timeoutValue)\r\n{\r\n    base->CTRL2_PN = (base->CTRL2_PN & ~CAN_CTRL2_PN_MATCHTO_MASK) |\r\n                      CAN_CTRL2_PN_MATCHTO(timeoutValue);\r\n}\r\n\r\n/*!\r\n * @brief Configures the Pretended Networking ID Filter 1.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   idFilter  The ID Filter configuration\r\n */\r\nstatic inline void FLEXCAN_SetPNIdFilter1(CAN_Type * base, flexcan_pn_id_filter_t idFilter)\r\n{\r\n    uint32_t tmp;\r\n\r\n    tmp = base->FLT_ID1;\r\n    tmp &= ~(CAN_FLT_ID1_FLT_IDE_MASK | CAN_FLT_ID1_FLT_RTR_MASK | CAN_FLT_ID1_FLT_ID1_MASK);\r\n    tmp |= CAN_FLT_ID1_FLT_IDE(idFilter.extendedId ? 1UL : 0UL);\r\n    tmp |= CAN_FLT_ID1_FLT_RTR(idFilter.remoteFrame ? 1UL : 0UL);\r\n    if (idFilter.extendedId)\r\n    {\r\n        tmp |= CAN_FLT_ID1_FLT_ID1(idFilter.id);\r\n    }\r\n    else\r\n    {\r\n        tmp |= CAN_FLT_ID1_FLT_ID1(idFilter.id << CAN_ID_STD_SHIFT);\r\n    }\r\n    base->FLT_ID1 = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Configures the Pretended Networking ID Filter 2 Check IDE&RTR.\r\n *\r\n * @param   base  The FlexCAN base address\r\n\r\n */\r\nstatic inline void FLEXCAN_SetPNIdFilter2Check(CAN_Type * base)\r\n{\r\n\tbase->FLT_ID2_IDMASK |= CAN_FLT_ID2_IDMASK_IDE_MSK_MASK|CAN_FLT_ID2_IDMASK_RTR_MSK_MASK;\r\n}\r\n/*!\r\n * @brief Configures the Pretended Networking ID Filter 2.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   pnConfig  The pretended networking configuration\r\n */\r\nstatic inline void FLEXCAN_SetPNIdFilter2(CAN_Type * base, const flexcan_pn_config_t *pnConfig)\r\n{\r\n    uint32_t tmp;\r\n\r\n    tmp = base->FLT_ID2_IDMASK;\r\n    tmp &= ~(CAN_FLT_ID2_IDMASK_IDE_MSK_MASK | CAN_FLT_ID2_IDMASK_RTR_MSK_MASK | CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_MASK);\r\n    tmp |= CAN_FLT_ID2_IDMASK_IDE_MSK(pnConfig->idFilter2.extendedId ? 1UL : 0UL);\r\n    tmp |= CAN_FLT_ID2_IDMASK_RTR_MSK(pnConfig->idFilter2.remoteFrame ? 1UL : 0UL);\r\n    /* Check if idFilter1 is extended and apply accordingly mask */\r\n    if (pnConfig->idFilter1.extendedId)\r\n    {\r\n        tmp |= CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK(pnConfig->idFilter2.id);\r\n    }\r\n    else\r\n    {\r\n        tmp |= CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK(pnConfig->idFilter2.id << CAN_ID_STD_SHIFT);\r\n    }\r\n    base->FLT_ID2_IDMASK = tmp;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Set PN DLC Filter.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   timeoutValue  timeout for no message matching\r\n */\r\nstatic inline void FLEXCAN_SetPNDlcFilter(CAN_Type * base, uint8_t dlcLow, uint8_t dlcHigh)\r\n{\r\n    uint32_t tmp;\r\n\r\n    tmp = base->FLT_DLC;\r\n    tmp &= ~(CAN_FLT_DLC_FLT_DLC_HI_MASK | CAN_FLT_DLC_FLT_DLC_HI_MASK);\r\n    tmp |= CAN_FLT_DLC_FLT_DLC_HI(dlcHigh);\r\n    tmp |= CAN_FLT_DLC_FLT_DLC_LO(dlcLow);\r\n    base->FLT_DLC = tmp;\r\n}\r\n\r\n/*!\r\n * @brief Set PN Payload High Filter 1.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   payload  message payload filter\r\n */\r\nstatic inline void FLEXCAN_SetPNPayloadHighFilter1(CAN_Type * base, const uint8_t *payload)\r\n{\r\n    base->PL1_HI = CAN_PL1_HI_Data_byte_4(payload[4]) |\r\n                   CAN_PL1_HI_Data_byte_5(payload[5]) |\r\n                   CAN_PL1_HI_Data_byte_6(payload[6]) |\r\n                   CAN_PL1_HI_Data_byte_7(payload[7]);\r\n}\r\n\r\n/*!\r\n * @brief Set PN Payload Low Filter 1.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   payload  message payload filter\r\n */\r\nstatic inline void FLEXCAN_SetPNPayloadLowFilter1(CAN_Type * base, const uint8_t *payload)\r\n{\r\n    base->PL1_LO = CAN_PL1_LO_Data_byte_0(payload[0]) |\r\n                   CAN_PL1_LO_Data_byte_1(payload[1]) |\r\n                   CAN_PL1_LO_Data_byte_2(payload[2]) |\r\n                   CAN_PL1_LO_Data_byte_3(payload[3]);\r\n}\r\n\r\n/*!\r\n * @brief Set PN Payload High Filter 2.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   payload  message payload filter\r\n */\r\nstatic inline void FLEXCAN_SetPNPayloadHighFilter2(CAN_Type * base, const uint8_t *payload)\r\n{\r\n    base->PL2_PLMASK_HI = CAN_PL2_PLMASK_HI_Data_byte_4(payload[4]) |\r\n                          CAN_PL2_PLMASK_HI_Data_byte_5(payload[5]) |\r\n                          CAN_PL2_PLMASK_HI_Data_byte_6(payload[6]) |\r\n                          CAN_PL2_PLMASK_HI_Data_byte_7(payload[7]);\r\n}\r\n\r\n/*!\r\n * @brief Set PN Payload Low Filter 2.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   payload  message payload filter\r\n */\r\nstatic inline void FLEXCAN_SetPNPayloadLowFilter2(CAN_Type * base, const uint8_t *payload)\r\n{\r\n    base->PL2_PLMASK_LO = CAN_PL2_PLMASK_LO_Data_byte_0(payload[0]) |\r\n                          CAN_PL2_PLMASK_LO_Data_byte_1(payload[1]) |\r\n                          CAN_PL2_PLMASK_LO_Data_byte_2(payload[2]) |\r\n                          CAN_PL2_PLMASK_LO_Data_byte_3(payload[3]);\r\n}\r\n\r\n/*!\r\n * @brief Configures the Pretended Networking mode.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   pnConfig  The pretended networking configuration\r\n */\r\nvoid FLEXCAN_ConfigPN(CAN_Type * base, const flexcan_pn_config_t *pnConfig);\r\n\r\n/*!\r\n * @brief Enables/Disables the Pretended Networking mode.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   enable  Enable/Disable Pretending Networking\r\n */\r\nstatic inline void FLEXCAN_SetPN(CAN_Type * base, bool enable)\r\n{\r\n    base->MCR = (base->MCR & ~CAN_MCR_PNET_EN_MASK) | CAN_MCR_PNET_EN(enable ? 1UL : 0UL);\r\n}\r\n\r\n/*!\r\n * @brief Checks if the Pretended Networking mode is enabled/disabled.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  false if Pretended Networking mode is disabled;\r\n *          true if Pretended Networking mode is enabled\r\n */\r\nstatic inline bool FLEXCAN_IsPNEnabled(const CAN_Type * base)\r\n{\r\n    return (((base->MCR & CAN_MCR_PNET_EN_MASK) >> CAN_MCR_PNET_EN_SHIFT) != 0U);\r\n}\r\n\r\n/*!\r\n * @brief Gets the Wake Up by Timeout Flag Bit.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  the Wake Up by Timeout Flag Bit\r\n */\r\nstatic inline uint8_t FLEXCAN_GetWTOF(const CAN_Type * base)\r\n{\r\n    return (uint8_t)((base->WU_MTC & CAN_WU_MTC_WTOF_MASK) >> CAN_WU_MTC_WTOF_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears the Wake Up by Timeout Flag Bit.\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nstatic inline void FLEXCAN_ClearWTOF(CAN_Type * base)\r\n{\r\n    base->WU_MTC |= CAN_WU_MTC_WTOF_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Wake Up by Match Flag Bit.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  the Wake Up by Match Flag Bit\r\n */\r\nstatic inline uint8_t FLEXCAN_GetWUMF(const CAN_Type * base)\r\n{\r\n    return (uint8_t)((base->WU_MTC & CAN_WU_MTC_WUMF_MASK) >> CAN_WU_MTC_WUMF_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears the Wake Up by Match Flag Bit.\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nstatic inline void FLEXCAN_ClearWUMF(CAN_Type * base)\r\n{\r\n    base->WU_MTC |= CAN_WU_MTC_WUMF_MASK;\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_PRETENDED_NETWORKING */\r\n\r\n#if FEATURE_CAN_HAS_SELF_WAKE_UP\r\n\r\n/*!\r\n * @brief Enables/Disables the Self Wake Up mode.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @param   enable  Enable/Disable Self Wake Up\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_ERROR if Self Wake Up mode could not be enabled\r\n */\r\nstatic inline status_t FLEXCAN_SetSelfWakeUp(CAN_Type * base, bool enable)\r\n{\r\n    uint32_t flag;\r\n    status_t status = STATUS_SUCCESS;\r\n\r\n    /* Enable Self Wake Up */\r\n    base->MCR = (base->MCR & ~CAN_MCR_SLFWAK_MASK) | CAN_MCR_SLFWAK(enable ? 1UL : 0UL);\r\n\r\n    /* Check if Self Wake Up was successfully enabled */\r\n    flag = ((base->MCR & CAN_MCR_SLFWAK_MASK) >> CAN_MCR_SLFWAK_SHIFT);\r\n\r\n    if (enable && (flag != 1U))\r\n    {\r\n        status = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Enable Wake Up Interrupt */\r\n        base->MCR = (base->MCR & ~CAN_MCR_WAKMSK_MASK) | CAN_MCR_WAKMSK(enable ? 1UL : 0UL);\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Wake-Up Interrupt Flag.\r\n *\r\n * @param   base  The FlexCAN base address\r\n * @return  the  Wake-Up Interrupt Flag\r\n */\r\nstatic inline uint8_t FLEXCAN_GetWAKINT(const CAN_Type * base)\r\n{\r\n    return (uint8_t)((base->ESR1 & CAN_ESR1_WAKINT_MASK) >> CAN_ESR1_WAKINT_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears the Wake-Up Interrupt Flag.\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nstatic inline void FLEXCAN_ClearWAKINT(CAN_Type * base)\r\n{\r\n    base->ESR1 |= CAN_ESR1_WAKINT_MASK;\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_SELF_WAKE_UP */\r\n\r\n#if FEATURE_CAN_HAS_MEM_ERR_DET\r\n/*!\r\n * @brief Disable Error Detection and Correction of Memory Errors.\r\n *\r\n * @param   base  The FlexCAN base address\r\n */\r\nstatic inline void FLEXCAN_DisableMemErrorDetection(CAN_Type * base)\r\n{\r\n\t/* Enable write of MECR register */\r\n\tbase->CTRL2 |=  CAN_CTRL2_ECRWRE(1);\r\n\t/* Enable write of MECR */\r\n\tbase->MECR = CAN_MECR_ECRWRDIS(0);\r\n\t/* Disable Error Detection and Correction mechanism,\r\n\t * that will set CAN in Freez Mode in case of trigger */\r\n\tbase->MECR = CAN_MECR_NCEFAFRZ(0);\r\n\t/* Disable write of MECR */\r\n\tbase->CTRL2 |=  CAN_CTRL2_ECRWRE(0);\r\n}\r\n#endif /* FEATURE_CAN_HAS_MEM_ERR_DET */\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n#endif /* FLEXCAN_HW_ACCESS_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"flexcan_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n \r\n /*!\r\n * @file flexcan_irq.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, Function not defined with external linkage.\r\n * The functions are not defined static because they are referenced in .s startup files.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, could define variable at block scope\r\n * The variable is defined in the common source file to make transition to other\r\n * platforms easier.\r\n */\r\n\r\n#include \"flexcan_irq.h\"\r\n\r\n#if (defined(CPU_S32K116) || defined(CPU_S32K118))\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n#if (CAN_INSTANCE_COUNT > 0U)\r\n/* Implementation of CAN0 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning, Error, Wakeup). */\r\nvoid CAN0_ORed_Err_Wakeup_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-31. */\r\nvoid CAN0_ORed_0_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 0U) */\r\n\r\n#elif (defined (CPU_S32K142) || defined (CPU_S32K144HFT0VLLT) || defined (CPU_S32K144LFT0MLLT) ||\\\r\n    defined (CPU_S32K146) || defined (CPU_S32K148) || defined (CPU_S32MTV) || defined (CPU_S32K116)\\\r\n    || defined (CPU_S32K118) || defined (CPU_S32K144W) || defined (CPU_S32K142W))\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n#if (CAN_INSTANCE_COUNT > 0U)\r\n/* Implementation of CAN0 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN0_ORed_IRQHandler(void)\r\n{\r\n\tFLEXCAN_BusOff_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN0_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(0U);\r\n}\r\n\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a wake up\r\nevent. */\r\nvoid CAN0_Wake_Up_IRQHandler(void)\r\n{\r\n    FLEXCAN_WakeUpHandler(0U);\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_WAKE_UP_IRQ */\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-15. */\r\nvoid CAN0_ORed_0_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN0_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n#if (defined (CPU_S32K144W) || defined (CPU_S32K142W))\r\nvoid CAN0_ORed_32_47_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\nvoid CAN0_ORed_48_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n#endif /* defined (CPU_S32K144W) || defined (CPU_S32K142W) */\r\n#endif /* (CAN_INSTANCE_COUNT > 0U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n/* Implementation of CAN1 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN1_ORed_IRQHandler(void)\r\n{\r\n\tFLEXCAN_BusOff_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN1_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-15. */\r\nvoid CAN1_ORed_0_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN1_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n#if (defined (CPU_S32K144W) || defined (CPU_S32K142W))\r\nvoid CAN1_ORed_32_47_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\nvoid CAN1_ORed_48_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n#endif /* defined (CPU_S32K144W) || defined (CPU_S32K142W) */\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 2U)\r\n/* Implementation of CAN2 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN2_ORed_IRQHandler(void)\r\n{\r\n\tFLEXCAN_BusOff_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN2_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-15. */\r\nvoid CAN2_ORed_0_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 2U) */\r\n\r\n#elif defined(CPU_S32V234)\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n#if (CAN_INSTANCE_COUNT > 0U)\r\n/* Implementation of CAN0 handler named in startup code. */\r\nvoid CAN0_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 handler named in startup code. */\r\nvoid CAN0_Buff_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 0U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n/* Implementation of CAN1 handler named in startup code. */\r\nvoid CAN1_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 handler named in startup code. */\r\nvoid CAN1_Buff_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#elif (defined(CPU_MPC5748G) || defined(CPU_MPC5746C) || defined(CPU_MPC5744B) || \\\r\n       defined(CPU_MPC5745B) || defined(CPU_MPC5746B) || defined(CPU_MPC5744C) || \\\r\n       defined(CPU_MPC5745C) || defined(CPU_MPC5747C) || defined(CPU_MPC5748C) || \\\r\n       defined(CPU_MPC5746G) || defined(CPU_MPC5747G))\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n#if (CAN_INSTANCE_COUNT > 0U)\r\n/* Implementation of CAN0 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN0_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN0_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(0U);\r\n}\r\n\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a wake up\r\nevent. */\r\nvoid CAN0_Wake_Up_IRQHandler(void)\r\n{\r\n    FLEXCAN_WakeUpHandler(0U);\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_WAKE_UP_IRQ */\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN0_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN0_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN0_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN0_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN0_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN0_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN0_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 0U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n/* Implementation of CAN1 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN1_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN1_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN1_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN1_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN1_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN1_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN1_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN1_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN1_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 2U)\r\n/* Implementation of CAN2 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN2_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN2_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN2_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN2_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN2_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN2_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN2_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN2_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 2U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 3U)\r\n/* Implementation of CAN3 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN3_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN3_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN3_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN3_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN3_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN3_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN3_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN3_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n\r\n/* Implementation of CAN3 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN3_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(3U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 3) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 4U)\r\n/* Implementation of CAN4 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN4_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN4_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN4_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN4_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN4_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN4_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN4_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN4_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n\r\n/* Implementation of CAN4 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN4_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(4U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 4) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 5U)\r\n/* Implementation of CAN5 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN5_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN5_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN5_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN5_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN5_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN5_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN5_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN5_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n\r\n/* Implementation of CAN5 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN5_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(5U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 5) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 6U)\r\n/* Implementation of CAN6 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN6_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN6_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN6_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN6_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN6_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN6_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN6_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN6_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n\r\n/* Implementation of CAN6 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN6_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(6U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 6) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 7U)\r\n/* Implementation of CAN7 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN7_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN7_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN7_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN7_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN7_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN7_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN7_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-63. */\r\nvoid CAN7_ORed_32_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n\r\n/* Implementation of CAN7 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-95. */\r\nvoid CAN7_ORed_64_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(7U);\r\n}\r\n#endif /* (CAN_INSTANCE_COUNT > 7) */\r\n\r\n#elif (defined(CPU_MPC5741P) || defined(CPU_MPC5742P) || defined(CPU_MPC5743P) || \\\r\n       defined(CPU_MPC5744P) || defined(CPU_S32R372) || defined(CPU_S32R274))\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n#if (CAN_INSTANCE_COUNT > 0U)\r\n/* Implementation of CAN0 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN0_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN0_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(0U);\r\n}\r\n\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a wake up\r\nevent. */\r\nvoid CAN0_Wake_Up_IRQHandler(void)\r\n{\r\n    FLEXCAN_WakeUpHandler(0U);\r\n}\r\n\r\n#endif /* FEATURE_CAN_HAS_WAKE_UP_IRQ */\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN0_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN0_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN0_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN0_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN0_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-39. */\r\nvoid CAN0_ORed_32_39_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 40-47. */\r\nvoid CAN0_ORed_40_47_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 48-55. */\r\nvoid CAN0_ORed_48_55_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 56-63. */\r\nvoid CAN0_ORed_56_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n#if (defined(CPU_S32R372) || defined(CPU_S32R274))\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-79. */\r\nvoid CAN0_ORed_64_79_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 80-95. */\r\nvoid CAN0_ORed_80_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(0U);\r\n}\r\n#endif /* (CPU_S32R372) */\r\n#endif /* (CAN_INSTANCE_COUNT > 0U) */\r\n\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n/* Implementation of CAN1 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_Error_IRQHandler(void)\r\n#else\r\nvoid CAN1_Error_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_Error_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_00_03_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_00_03_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_04_07_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_04_07_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_08_11_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_08_11_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_12_15_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_12_15_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN1 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_16_31_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-39. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_32_39_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_32_39_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 40-47. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_40_47_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_40_47_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 48-55. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_48_55_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_48_55_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 56-63. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\n#if defined(CPU_S32R372)\r\nvoid CAN2_ORed_56_63_MB_IRQHandler(void)\r\n#else\r\nvoid CAN1_ORed_56_63_MB_IRQHandler(void)\r\n#endif\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n#if defined(CPU_S32R372)\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-79. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\nvoid CAN2_ORed_64_79_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 80-95. For S32R372 the instance is no is 1 \r\nand the can as peripheral is CAN2*/\r\nvoid CAN2_ORed_80_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(1U);\r\n}\r\n#endif /* (CPU_S32R372) */\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 2U)\r\n/* Implementation of CAN2 IRQ handler for OR'ed interrupts (Bus Off,\r\nTransmit Warning, Receive Warning). */\r\nvoid CAN2_ORed_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating that errors were\r\ndetected on the CAN bus. */\r\nvoid CAN2_Error_IRQHandler(void)\r\n{\r\n    FLEXCAN_Error_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 0-3. */\r\nvoid CAN2_ORed_00_03_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 4-7. */\r\nvoid CAN2_ORed_04_07_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 08-11. */\r\nvoid CAN2_ORed_08_11_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 12-15. */\r\nvoid CAN2_ORed_12_15_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 16-31. */\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 32-39. */\r\nvoid CAN2_ORed_32_39_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 40-47. */\r\nvoid CAN2_ORed_40_47_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 48-55. */\r\nvoid CAN2_ORed_48_55_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN0 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 56-63. */\r\nvoid CAN2_ORed_56_63_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n#if defined(CPU_S32R274)\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 64-79. */\r\nvoid CAN2_ORed_64_79_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n\r\n/* Implementation of CAN2 IRQ handler for interrupts indicating a successful\r\ntransmission or reception for Message Buffers 80-95. */\r\nvoid CAN2_ORed_80_95_MB_IRQHandler(void)\r\n{\r\n    FLEXCAN_IRQHandler(2U);\r\n}\r\n#endif /* (CPU_S32R274) */\r\n#endif /* (CAN_INSTANCE_COUNT > 2U) */\r\n\r\n#else\r\n    #error \"No valid CPU defined!\"\r\n#endif\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"flexcan_irq.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef FLEXCAN_IRQ_H\r\n#define FLEXCAN_IRQ_H\r\n\r\n#include \"device_registers.h\"\r\n\r\n/*!\r\n * @brief Interrupt handler for a FlexCAN instance.\r\n *\r\n * @param   instance    The FlexCAN instance number.\r\n */\r\nvoid FLEXCAN_IRQHandler(uint8_t instance);\r\n\r\n/*!\r\n * @brief Error interrupt handler for a FlexCAN instance.\r\n *\r\n * @param   instance    The FlexCAN instance number.\r\n */\r\nvoid FLEXCAN_Error_IRQHandler(uint8_t instance);\r\n\r\n/*!\r\n * @brief Error interrupt handler for a FlexCAN instance.\r\n *\r\n * @param   instance    The FlexCAN instance number.\r\n */\r\nvoid FLEXCAN_BusOff_IRQHandler(uint8_t instance);\r\n\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\n\r\n/*!\r\n * @brief Wake up handler for a FlexCAN instance.\r\n *\r\n * @param   instance    The FlexCAN instance number.\r\n */\r\nvoid FLEXCAN_WakeUpHandler(uint8_t instance);\r\n\r\n#endif /* FEATURE_CAN_HAS_WAKE_UP_IRQ */\r\n\r\n#if (defined(CPU_S32K116) || (defined(CPU_S32K118)))\r\n\r\n/*******************************************************************************\r\n * Default interrupt handlers signatures\r\n ******************************************************************************/\r\nvoid CAN0_ORed_Err_Wakeup_IRQHandler(void);\r\nvoid CAN0_ORed_0_31_MB_IRQHandler(void);\r\n\r\n#elif (defined (CPU_S32K142) || defined (CPU_S32K144HFT0VLLT) || defined (CPU_S32K144LFT0MLLT) ||\\\r\n    defined (CPU_S32K146) || defined (CPU_S32K148) || defined (CPU_S32MTV) || defined (CPU_S32K116)\\\r\n    || (defined (CPU_S32K118)) || defined (CPU_S32K144W) || defined (CPU_S32K142W))\r\n\r\n/*******************************************************************************\r\n * Default interrupt handlers signatures\r\n ******************************************************************************/\r\nvoid CAN0_ORed_IRQHandler(void);\r\nvoid CAN0_Error_IRQHandler(void);\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\nvoid CAN0_Wake_Up_IRQHandler(void);\r\n#endif\r\nvoid CAN0_ORed_0_15_MB_IRQHandler(void);\r\nvoid CAN0_ORed_16_31_MB_IRQHandler(void);\r\n#if (defined (CPU_S32K144W) || defined (CPU_S32K142W))\r\nvoid CAN0_ORed_32_47_MB_IRQHandler(void);\r\n\r\nvoid CAN0_ORed_48_63_MB_IRQHandler(void);\r\n#endif\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n\r\nvoid CAN1_ORed_IRQHandler(void);\r\nvoid CAN1_Error_IRQHandler(void);\r\nvoid CAN1_ORed_0_15_MB_IRQHandler(void);\r\nvoid CAN1_ORed_16_31_MB_IRQHandler(void);\r\n#if (defined (CPU_S32K144W) || defined (CPU_S32K142W))\r\nvoid CAN1_ORed_32_47_MB_IRQHandler(void);\r\n\r\nvoid CAN1_ORed_48_63_MB_IRQHandler(void);\r\n#endif\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 2U)\r\n\r\nvoid CAN2_ORed_IRQHandler(void);\r\nvoid CAN2_Error_IRQHandler(void);\r\nvoid CAN2_ORed_0_15_MB_IRQHandler(void);\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 2U) */\r\n\r\n#elif defined(CPU_S32V234)\r\n\r\n/*******************************************************************************\r\n * Default interrupt handlers signatures\r\n ******************************************************************************/\r\nvoid CAN0_IRQHandler(void);\r\nvoid CAN0_Buff_IRQHandler(void);\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n\r\nvoid CAN1_IRQHandler(void);\r\nvoid CAN1_Buff_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#elif (defined(CPU_MPC5748G) || defined(CPU_MPC5746C) || defined(CPU_MPC5744B) || \\\r\n       defined(CPU_MPC5745B) || defined(CPU_MPC5746B) || defined(CPU_MPC5744C) || \\\r\n       defined(CPU_MPC5745C) || defined(CPU_MPC5747C) || defined(CPU_MPC5748C) || \\\r\n       defined(CPU_MPC5746G) || defined(CPU_MPC5747G))\r\n\r\n/*******************************************************************************\r\n * Default interrupt handlers signatures\r\n ******************************************************************************/\r\nvoid CAN0_ORed_IRQHandler(void);\r\nvoid CAN0_Error_IRQHandler(void);\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\nvoid CAN0_Wake_Up_IRQHandler(void);\r\n#endif\r\nvoid CAN0_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN0_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN0_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN0_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN0_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN0_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN0_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n\r\nvoid CAN1_ORed_IRQHandler(void);\r\nvoid CAN1_Error_IRQHandler(void);\r\nvoid CAN1_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN1_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN1_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN1_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN1_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN1_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN1_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 2U)\r\n\r\nvoid CAN2_ORed_IRQHandler(void);\r\nvoid CAN2_Error_IRQHandler(void);\r\nvoid CAN2_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN2_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN2_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN2_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN2_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN2_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 2U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 3U)\r\n\r\nvoid CAN3_ORed_IRQHandler(void);\r\nvoid CAN3_Error_IRQHandler(void);\r\nvoid CAN3_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN3_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN3_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN3_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN3_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN3_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN3_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif\r\n\r\n#if (CAN_INSTANCE_COUNT > 4U)\r\n\r\nvoid CAN4_ORed_IRQHandler(void);\r\nvoid CAN4_Error_IRQHandler(void);\r\nvoid CAN4_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN4_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN4_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN4_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN4_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN4_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN4_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 4U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 5U)\r\n\r\nvoid CAN5_ORed_IRQHandler(void);\r\nvoid CAN5_Error_IRQHandler(void);\r\nvoid CAN5_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN5_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN5_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN5_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN5_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN5_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN5_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif\r\n#if (CAN_INSTANCE_COUNT > 6U)\r\n\r\nvoid CAN6_ORed_IRQHandler(void);\r\nvoid CAN6_Error_IRQHandler(void);\r\nvoid CAN6_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN6_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN6_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN6_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN6_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN6_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN6_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 6U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 7U)\r\n\r\nvoid CAN7_ORed_IRQHandler(void);\r\nvoid CAN7_Error_IRQHandler(void);\r\nvoid CAN7_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN7_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN7_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN7_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN7_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN7_ORed_32_63_MB_IRQHandler(void);\r\nvoid CAN7_ORed_64_95_MB_IRQHandler(void);\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 7U) */\r\n\r\n#elif (defined(CPU_MPC5741P) || defined(CPU_MPC5742P) || defined(CPU_MPC5743P) || \\\r\n       defined(CPU_MPC5744P) || defined(CPU_S32R372) || defined(CPU_S32R274))\r\n\r\n/*******************************************************************************\r\n * Default interrupt handlers signatures\r\n ******************************************************************************/\r\nvoid CAN0_ORed_IRQHandler(void);\r\nvoid CAN0_Error_IRQHandler(void);\r\n#if FEATURE_CAN_HAS_WAKE_UP_IRQ\r\nvoid CAN0_Wake_Up_IRQHandler(void);\r\n#endif\r\nvoid CAN0_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN0_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN0_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN0_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN0_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN0_ORed_32_39_MB_IRQHandler(void);\r\nvoid CAN0_ORed_40_47_MB_IRQHandler(void);\r\nvoid CAN0_ORed_48_55_MB_IRQHandler(void);\r\nvoid CAN0_ORed_56_63_MB_IRQHandler(void);\r\n#if (defined(CPU_S32R372) || defined(CPU_S32R274))\r\nvoid CAN0_ORed_64_79_MB_IRQHandler(void);\r\nvoid CAN0_ORed_80_95_MB_IRQHandler(void);\r\n#endif\r\n\r\n#if (CAN_INSTANCE_COUNT > 1U)\r\n\r\n#if( defined(CPU_MPC5741P) || defined(CPU_MPC5742P) || defined(CPU_MPC5743P) || \\\r\n     defined(CPU_MPC5744P) || defined(CPU_S32R274))\r\nvoid CAN1_ORed_IRQHandler(void);\r\nvoid CAN1_Error_IRQHandler(void);\r\nvoid CAN1_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN1_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN1_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN1_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN1_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN1_ORed_32_39_MB_IRQHandler(void);\r\nvoid CAN1_ORed_40_47_MB_IRQHandler(void);\r\nvoid CAN1_ORed_48_55_MB_IRQHandler(void);\r\nvoid CAN1_ORed_56_63_MB_IRQHandler(void);\r\n#else // is defined(CPU_S32R372)\r\nvoid CAN2_ORed_IRQHandler(void);\r\nvoid CAN2_Error_IRQHandler(void);\r\nvoid CAN2_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN2_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN2_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN2_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN2_ORed_32_39_MB_IRQHandler(void);\r\nvoid CAN2_ORed_40_47_MB_IRQHandler(void);\r\nvoid CAN2_ORed_48_55_MB_IRQHandler(void);\r\nvoid CAN2_ORed_56_63_MB_IRQHandler(void);\r\nvoid CAN2_ORed_64_79_MB_IRQHandler(void);\r\nvoid CAN2_ORed_80_95_MB_IRQHandler(void);\r\n#endif //endif cpu defined\r\n#endif /* (CAN_INSTANCE_COUNT > 1U) */\r\n\r\n#if (CAN_INSTANCE_COUNT > 2U)\r\n\r\nvoid CAN2_ORed_IRQHandler(void);\r\nvoid CAN2_Error_IRQHandler(void);\r\nvoid CAN2_ORed_00_03_MB_IRQHandler(void);\r\nvoid CAN2_ORed_04_07_MB_IRQHandler(void);\r\nvoid CAN2_ORed_08_11_MB_IRQHandler(void);\r\nvoid CAN2_ORed_12_15_MB_IRQHandler(void);\r\nvoid CAN2_ORed_16_31_MB_IRQHandler(void);\r\nvoid CAN2_ORed_32_39_MB_IRQHandler(void);\r\nvoid CAN2_ORed_40_47_MB_IRQHandler(void);\r\nvoid CAN2_ORed_48_55_MB_IRQHandler(void);\r\nvoid CAN2_ORed_56_63_MB_IRQHandler(void);\r\n#if (defined(CPU_S32R372) || defined(CPU_S32R274))\r\nvoid CAN2_ORed_64_79_MB_IRQHandler(void);\r\nvoid CAN2_ORed_80_95_MB_IRQHandler(void);\r\n#endif\r\n\r\n#endif /* (CAN_INSTANCE_COUNT > 2U) */\r\n\r\n#else\r\n    #error \"No valid CPU defined!\"\r\n#endif\r\n\r\n#endif /* FLEXCAN_IRQ_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm0_pwm_params.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#include \"ftm0_pwm_params.h\"\r\n\r\n/* Fault configuration structure for FTM0 */\r\nftm_pwm_fault_param_t flexTimer_pwm0_FaultConfig = {\r\n  false,                               /* Output pin state on fault */\r\n  false,                               /* PWM fault interrupt state */\r\n  0U,                                  /* Fault filter value */\r\n  FTM_FAULT_CONTROL_DISABLED,          /* Fault mode */\r\n\r\n  {\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n  }\r\n};\r\n\r\n/* Independent channels configuration structure for flexTimer_pwm0 */\r\nftm_independent_ch_param_t flexTimer_pwm0_IndependentChannelsConfig[2] = {\r\n  {\r\n    0U,                                /* hwChannelId */\r\n    FTM_POLARITY_HIGH,                 /* Edge mode */\r\n    16384U,                            /* Duty cycle percent 0-0x8000 */\r\n    false,                             /* External Trigger */\r\n    FTM_LOW_STATE,                   /* The selection of the channel (n) mode */\r\n    false,                       /* Enabled/disabled the channel (n+1) output */\r\n    FTM_MAIN_DUPLICATED,\r\n                       /* Select channel (n+1) output relative to channel (n) */\r\n    false,                             /* Dead time enabled/disabled */\r\n  },\r\n\r\n  {\r\n    1U,                                /* hwChannelId */\r\n    FTM_POLARITY_LOW,                  /* Edge mode */\r\n    0U,                                /* Duty cycle percent 0-0x8000 */\r\n    false,                             /* External Trigger */\r\n    FTM_LOW_STATE,                   /* The selection of the channel (n) mode */\r\n    false,                       /* Enabled/disabled the channel (n+1) output */\r\n    FTM_MAIN_DUPLICATED,\r\n                       /* Select channel (n+1) output relative to channel (n) */\r\n    false,                             /* Dead time enabled/disabled */\r\n  },\r\n};\r\n\r\n/* PWM configuration for flexTimer_pwm0 */\r\nftm_pwm_param_t flexTimer_pwm0_PwmConfig = {\r\n  2U,                                  /* Number of independent PWM channels */\r\n  0U,                                  /* Number of combined PWM channels */\r\n  FTM_MODE_EDGE_ALIGNED_PWM,           /* PWM mode */\r\n  0U,                                  /* Dead time value */\r\n  FTM_DEADTIME_DIVID_BY_1,             /* Dead time prescaler */\r\n  20000U,                              /* PWM frequency */\r\n  flexTimer_pwm0_IndependentChannelsConfig,\r\n                          /* Independent PWM channels configuration structure */\r\n  NULL,                      /* Combined PWM channels configuration structure */\r\n  &flexTimer_pwm0_FaultConfig          /* PWM fault configuration structure */\r\n};\r\n\r\n/* Global configuration of flexTimer_pwm0 */\r\nftm_user_config_t flexTimer_pwm0_InitConfig = {\r\n  {\r\n    true,                              /* Software trigger state */\r\n    false,                             /* Hardware trigger 1 state */\r\n    false,                             /* Hardware trigger 2 state */\r\n    false,                             /* Hardware trigger 3 state */\r\n    true,                              /* Max loading point state */\r\n    true,                              /* Min loading point state */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for INVCTRL register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for SWOCTRL register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for OUTMASK register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for CNTIN register */\r\n    true,                              /* Automatic clear of the trigger*/\r\n    FTM_UPDATE_NOW,                    /* Synchronization point */\r\n  },\r\n  FTM_MODE_EDGE_ALIGNED_PWM,           /* Mode of operation for FTM */\r\n  FTM_CLOCK_DIVID_BY_1,                /* FTM clock prescaler */\r\n  FTM_CLOCK_SOURCE_SYSTEMCLK,          /* FTM clock source */\r\n  FTM_BDM_MODE_00,                     /* FTM debug mode */\r\n  false,                               /* Interrupt state */\r\n  false                                /* Initialization trigger */\r\n};\r\n\r\nftm_state_t ftmStateStruct0;\r\n"},{"name":"ftm0_pwm_params.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef FTM0_PWM_PARAMS_H\r\n#define FTM0_PWM_PARAMS_H\r\n\r\n/* MODULE flexTimer_pwm0.*/\r\n\r\n/* Include inherited beans */\r\n#include \"ftm_pwm_driver.h\"\r\n\r\n/* Device instance number */\r\n#define FTM_PWM0                       0U\r\n\r\n/*fault configuration structure for FTM0*/\r\nextern ftm_pwm_fault_param_t flexTimer_pwm0_FaultConfig;\r\n\r\n/* Independent channels configuration structure for flexTimer_pwm0 */\r\nextern ftm_independent_ch_param_t flexTimer_pwm0_IndependentChannelsConfig[2];\r\n\r\n/* PWM configuration for flexTimer_pwm0 */\r\nextern ftm_pwm_param_t flexTimer_pwm0_PwmConfig;\r\n\r\n/* Global configuration of flexTimer_pwm0 */\r\nextern ftm_user_config_t flexTimer_pwm0_InitConfig;\r\n\r\n/* Global state structure of flexTimer_pwm0 */\r\nextern ftm_state_t ftmStateStruct0;\r\n\r\n#endif\r\n"},{"name":"ftm3_pwm_params.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#include \"ftm3_pwm_params.h\"\r\n\r\n/* Fault configuration structure for FTM3 */\r\nftm_pwm_fault_param_t flexTimer_pwm3_FaultConfig = {\r\n  false,                               /* Output pin state on fault */\r\n  false,                               /* PWM fault interrupt state */\r\n  0U,                                  /* Fault filter value */\r\n  FTM_FAULT_CONTROL_DISABLED,          /* Fault mode */\r\n\r\n  {\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n\r\n    {\r\n      false,                        /* Fault channel state (Enabled/Disabled) */\r\n      false,                 /* Fault channel filter state (Enabled/Disabled) */\r\n      FTM_POLARITY_HIGH,               /* Channel output state on fault */\r\n    },\r\n  }\r\n};\r\n\r\n/* Independent channels configuration structure for flexTimer_pwm3 */\r\nftm_independent_ch_param_t flexTimer_pwm3_IndependentChannelsConfig[2] = {\r\n  {\r\n    0U,                                /* hwChannelId */\r\n    FTM_POLARITY_HIGH,                 /* Edge mode */\r\n    16384U,                            /* Duty cycle percent 0-0x8000 */\r\n    false,                             /* External Trigger */\r\n    FTM_LOW_STATE,                   /* The selection of the channel (n) mode */\r\n    false,                       /* Enabled/disabled the channel (n+1) output */\r\n    FTM_MAIN_DUPLICATED,\r\n                       /* Select channel (n+1) output relative to channel (n) */\r\n    false,                             /* Dead time enabled/disabled */\r\n  },\r\n\r\n  {\r\n    1U,                                /* hwChannelId */\r\n    FTM_POLARITY_LOW,                  /* Edge mode */\r\n    0U,                                /* Duty cycle percent 0-0x8000 */\r\n    false,                             /* External Trigger */\r\n    FTM_LOW_STATE,                   /* The selection of the channel (n) mode */\r\n    false,                       /* Enabled/disabled the channel (n+1) output */\r\n    FTM_MAIN_DUPLICATED,\r\n                       /* Select channel (n+1) output relative to channel (n) */\r\n    false,                             /* Dead time enabled/disabled */\r\n  },\r\n};\r\n\r\n/* PWM configuration for flexTimer_pwm3 */\r\nftm_pwm_param_t flexTimer_pwm3_PwmConfig = {\r\n  2U,                                  /* Number of independent PWM channels */\r\n  0U,                                  /* Number of combined PWM channels */\r\n  FTM_MODE_EDGE_ALIGNED_PWM,           /* PWM mode */\r\n  0U,                                  /* Dead time value */\r\n  FTM_DEADTIME_DIVID_BY_1,             /* Dead time prescaler */\r\n  1000000U,                            /* PWM frequency */\r\n  flexTimer_pwm3_IndependentChannelsConfig,\r\n                          /* Independent PWM channels configuration structure */\r\n  NULL,                      /* Combined PWM channels configuration structure */\r\n  &flexTimer_pwm3_FaultConfig          /* PWM fault configuration structure */\r\n};\r\n\r\n/* Global configuration of flexTimer_pwm3 */\r\nftm_user_config_t flexTimer_pwm3_InitConfig = {\r\n  {\r\n    true,                              /* Software trigger state */\r\n    false,                             /* Hardware trigger 1 state */\r\n    false,                             /* Hardware trigger 2 state */\r\n    false,                             /* Hardware trigger 3 state */\r\n    true,                              /* Max loading point state */\r\n    true,                              /* Min loading point state */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for INVCTRL register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for SWOCTRL register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for OUTMASK register */\r\n    FTM_SYSTEM_CLOCK,                  /* Update mode for CNTIN register */\r\n    true,                              /* Automatic clear of the trigger*/\r\n    FTM_UPDATE_NOW,                    /* Synchronization point */\r\n  },\r\n  FTM_MODE_EDGE_ALIGNED_PWM,           /* Mode of operation for FTM */\r\n  FTM_CLOCK_DIVID_BY_1,                /* FTM clock prescaler */\r\n  FTM_CLOCK_SOURCE_SYSTEMCLK,          /* FTM clock source */\r\n  FTM_BDM_MODE_00,                     /* FTM debug mode */\r\n  false,                               /* Interrupt state */\r\n  false                                /* Initialization trigger */\r\n};\r\n\r\nftm_state_t ftmStateStruct3;\r\n"},{"name":"ftm3_pwm_params.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef FTM3_PWM_PARAMS_H\r\n#define FTM3_PWM_PARAMS_H\r\n\r\n/* MODULE flexTimer_pwm3.*/\r\n\r\n/* Include inherited beans */\r\n#include \"ftm_pwm_driver.h\"\r\n\r\n/* Device instance number */\r\n#define FTM_PWM3                       3U\r\n\r\n/*fault configuration structure for FTM3*/\r\nextern ftm_pwm_fault_param_t flexTimer_pwm3_FaultConfig;\r\n\r\n/* Independent channels configuration structure for flexTimer_pwm3 */\r\nextern ftm_independent_ch_param_t flexTimer_pwm3_IndependentChannelsConfig[2];\r\n\r\n/* PWM configuration for flexTimer_pwm3 */\r\nextern ftm_pwm_param_t flexTimer_pwm3_PwmConfig;\r\n\r\n/* Global configuration of flexTimer_pwm3 */\r\nextern ftm_user_config_t flexTimer_pwm3_InitConfig;\r\n\r\n/* Global state structure of flexTimer_pwm3 */\r\nextern ftm_state_t ftmStateStruct3;\r\n\r\n#endif\r\n"},{"name":"ftm_chn_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2019, NXP.\r\n * All rights reserved.\r\n */\r\n\r\n#include <stdint.h>\r\n#include \"ftm_fault_irq.h\"\r\n#include \"ftm_common.h\"\r\n#include \"ftm_hw_access.h\"\r\n#include \"ftm_chn_irq.h\"\r\n\r\n#define HW_FTM_0  0\r\n#define HW_FTM_1  1\r\n#define HW_FTM_2  2\r\n#define HW_FTM_3  3\r\n#define HW_FTM_4  4\r\n#define HW_FTM_5  5\r\n#define HW_FTM_6  6\r\n#define HW_FTM_7  7\r\n\r\n\r\n/******************************************************************************\r\n * Variables\r\n *****************************************************************************/\r\n\r\n/*\r\n * @brief Function table to save FTM CHN isr callback function pointers.\r\n *\r\n * Call FTM_CHR_DRV_InstallCallback to install isr callback functions.\r\n */\r\nstatic ftm_chn_isr_callback_t ftmChrIsrCallbackTable[8][8] = { { 0 } };\r\n\r\n/*!\r\n * @addtogroup ftm_irq\r\n * @{\r\n */\r\n\r\n/******************************************************************************\r\n * Code\r\n *****************************************************************************/\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n\r\n#ifdef FTM0\r\nvoid FTM0_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM0, i) && FTM_DRV_HasChnEventOccurred (FTM0, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_0][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM0, i);\r\n        }\r\n}\r\n\r\nvoid FTM0_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM0, i) && FTM_DRV_HasChnEventOccurred (FTM0, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_0][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM0, i);\r\n        }\r\n}\r\n\r\nvoid FTM0_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM0, i) && FTM_DRV_HasChnEventOccurred (FTM0, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_0][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM0, i);\r\n        }\r\n}\r\n\r\nvoid FTM0_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM0, i) && FTM_DRV_HasChnEventOccurred (FTM0, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_0][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM0, i);\r\n        }\r\n}\r\n#endif\r\n\r\n#ifdef FTM1\r\nvoid FTM1_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM1, i) && FTM_DRV_HasChnEventOccurred (FTM1, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_1][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM1, i);\r\n        }\r\n}\r\n\r\nvoid FTM1_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM1, i) && FTM_DRV_HasChnEventOccurred (FTM1, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_1][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM1, i);\r\n        }\r\n}\r\n\r\nvoid FTM1_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM1, i) && FTM_DRV_HasChnEventOccurred (FTM1, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_1][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM1, i);\r\n        }\r\n}\r\n\r\nvoid FTM1_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM1, i) && FTM_DRV_HasChnEventOccurred (FTM1, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_1][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM1, i);\r\n        }\r\n}\r\n#endif\r\n\r\n#ifdef FTM2\r\nvoid FTM2_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM2, i) && FTM_DRV_HasChnEventOccurred (FTM2, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_2][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM2, i);\r\n        }\r\n}\r\n\r\nvoid FTM2_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM2, i) && FTM_DRV_HasChnEventOccurred (FTM2, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_2][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM2, i);\r\n        }\r\n}\r\n\r\nvoid FTM2_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM2, i) && FTM_DRV_HasChnEventOccurred (FTM2, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_2][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM2, i);\r\n        }\r\n}\r\n\r\nvoid FTM2_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM2, i) && FTM_DRV_HasChnEventOccurred (FTM2, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_2][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM2, i);\r\n        }\r\n}\r\n#endif\r\n\r\n#ifdef FTM3\r\nvoid FTM3_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM3, i) && FTM_DRV_HasChnEventOccurred (FTM3, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_3][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM3, i);\r\n        }\r\n}\r\n\r\nvoid FTM3_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM3, i) && FTM_DRV_HasChnEventOccurred (FTM3, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_3][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM3, i);\r\n        }\r\n}\r\n\r\nvoid FTM3_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM3, i) && FTM_DRV_HasChnEventOccurred (FTM3, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_3][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM3, i);\r\n        }\r\n}\r\n\r\nvoid FTM3_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM3, i) && FTM_DRV_HasChnEventOccurred (FTM3, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_3][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM3, i);\r\n        }\r\n}\r\n#endif\r\n\r\n#ifdef FTM4\r\nvoid FTM4_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM4, i) && FTM_DRV_HasChnEventOccurred (FTM4, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_4][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM4, i);\r\n        }\r\n}\r\n\r\nvoid FTM4_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM4, i) && FTM_DRV_HasChnEventOccurred (FTM4, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_4][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM4, i);\r\n        }\r\n}\r\n\r\nvoid FTM4_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM4, i) && FTM_DRV_HasChnEventOccurred (FTM4, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_4][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM4, i);\r\n        }\r\n}\r\n\r\nvoid FTM4_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM4, i) && FTM_DRV_HasChnEventOccurred (FTM4, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_4][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM4, i);\r\n        }\r\n}\r\n#endif\r\n\r\n#ifdef FTM5\r\nvoid FTM5_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM5, i) && FTM_DRV_HasChnEventOccurred (FTM5, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_5][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM5, i);\r\n        }\r\n}\r\n\r\nvoid FTM5_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM5, i) && FTM_DRV_HasChnEventOccurred (FTM5, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_5][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM5, i);\r\n        }\r\n}\r\n\r\nvoid FTM5_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM5, i) && FTM_DRV_HasChnEventOccurred (FTM5, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_5][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM5, i);\r\n        }\r\n}\r\n\r\nvoid FTM5_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM5, i) && FTM_DRV_HasChnEventOccurred (FTM5, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_5][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM5, i);\r\n        }\r\n}\r\n#endif\r\n\r\n\r\n#ifdef FTM6\r\nvoid FTM6_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM6, i) && FTM_DRV_HasChnEventOccurred (FTM6, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_6][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM6, i);\r\n        }\r\n}\r\n\r\nvoid FTM6_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM6, i) && FTM_DRV_HasChnEventOccurred (FTM6, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_6][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM6, i);\r\n        }\r\n}\r\n\r\nvoid FTM6_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM6, i) && FTM_DRV_HasChnEventOccurred (FTM6, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_6][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM6, i);\r\n        }\r\n}\r\n\r\nvoid FTM6_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM6, i) && FTM_DRV_HasChnEventOccurred (FTM6, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_6][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM6, i);\r\n        }\r\n}\r\n#endif\r\n\r\n#ifdef FTM7\r\nvoid FTM7_Ch0_1_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 0; i <= 1; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM7, i) && FTM_DRV_HasChnEventOccurred (FTM7, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_7][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM7, i);\r\n        }\r\n}\r\n\r\nvoid FTM7_Ch2_3_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 2; i <= 3; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM7, i) && FTM_DRV_HasChnEventOccurred (FTM7, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_7][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM7, i);\r\n        }\r\n}\r\n\r\nvoid FTM7_Ch4_5_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 4; i <= 5; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM7, i) && FTM_DRV_HasChnEventOccurred (FTM7, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_7][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM7, i);\r\n        }\r\n}\r\n\r\nvoid FTM7_Ch6_7_IRQHandler(void)\r\n{\r\n    uint8_t i;\r\n    for (i = 6; i <= 7; ++i)\r\n        if (FTM_DRV_IsChnIntEnabled (FTM7, i) && FTM_DRV_HasChnEventOccurred (FTM7, i))\r\n        {\r\n            (*ftmChrIsrCallbackTable[HW_FTM_7][i])();\r\n            FTM_DRV_ClearChnEventFlag(FTM7, i);\r\n        }\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n/*FUNCTION*********************************************************************\r\n*\r\n* Function Name : FTM_CHR_DRV_InstallCallback\r\n* Description   : Install the user-defined callback in FTM.\r\n* When an FTM CHN interrupt request is served, the callback will be executed\r\n* inside the ISR.\r\n*\r\n*END*************************************************************************/\r\nvoid\r\nFTM_CHR_DRV_InstallCallback(uint8_t ftmModule,\r\n                            uint8_t ftmChannel,\r\n                            ftm_chn_isr_callback_t userCallback)\r\n{\r\n    ftmChrIsrCallbackTable[ftmModule][ftmChannel] = userCallback;\r\n}\r\n\r\n/******************************************************************************\r\n * EOF\r\n *****************************************************************************/\r\n"},{"name":"ftm_chn_irq.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2019, NXP.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of Freescale Semiconductor, Inc. nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n#ifndef _FTM_CHN_IRQ_H\r\n#define _FTM_CHN_IRQ_H\r\n\r\n/*! @brief The FTM CHN ISR callback function*/\r\ntypedef void (*ftm_chn_isr_callback_t)(void);\r\n\r\n/*FUNCTION*********************************************************************\r\n*\r\n* Function Name : GPIO_DRV_InstallCallback\r\n* Description   : Install the user-defined callback in GPI.\r\n* When an GPI interrupt request is served, the callback will be executed\r\n* inside the ISR.\r\n*\r\n*END*************************************************************************/\r\nvoid\r\nFTM_CHR_DRV_InstallCallback(uint8_t ftmModule,\r\n                            uint8_t ftmChannel,\r\n                            ftm_chn_isr_callback_t userCallback);\r\n\r\n#ifdef FTM0\r\nvoid FTM0_Ch0_1_IRQHandler(void);\r\nvoid FTM0_Ch2_3_IRQHandler(void);\r\nvoid FTM0_Ch4_5_IRQHandler(void);\r\nvoid FTM0_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM1\r\nvoid FTM1_Ch0_1_IRQHandler(void);\r\nvoid FTM1_Ch2_3_IRQHandler(void);\r\nvoid FTM1_Ch4_5_IRQHandler(void);\r\nvoid FTM1_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM2\r\nvoid FTM2_Ch0_1_IRQHandler(void);\r\nvoid FTM2_Ch2_3_IRQHandler(void);\r\nvoid FTM2_Ch4_5_IRQHandler(void);\r\nvoid FTM2_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM3\r\nvoid FTM3_Ch0_1_IRQHandler(void);\r\nvoid FTM3_Ch2_3_IRQHandler(void);\r\nvoid FTM3_Ch4_5_IRQHandler(void);\r\nvoid FTM3_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM4\r\nvoid FTM4_Ch0_1_IRQHandler(void);\r\nvoid FTM4_Ch2_3_IRQHandler(void);\r\nvoid FTM4_Ch4_5_IRQHandler(void);\r\nvoid FTM4_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM5\r\nvoid FTM5_Ch0_1_IRQHandler(void);\r\nvoid FTM5_Ch2_3_IRQHandler(void);\r\nvoid FTM5_Ch4_5_IRQHandler(void);\r\nvoid FTM5_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM6\r\nvoid FTM6_Ch0_1_IRQHandler(void);\r\nvoid FTM6_Ch2_3_IRQHandler(void);\r\nvoid FTM6_Ch4_5_IRQHandler(void);\r\nvoid FTM6_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#ifdef FTM7\r\nvoid FTM7_Ch0_1_IRQHandler(void);\r\nvoid FTM7_Ch2_3_IRQHandler(void);\r\nvoid FTM7_Ch4_5_IRQHandler(void);\r\nvoid FTM7_Ch6_7_IRQHandler(void);\r\n#endif\r\n\r\n#endif /* _GPIO_IRQ_H  */"},{"name":"ftm_common.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_common.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, Taking address of near auto variable.\r\n * The code is not dynamically linked. An absolute stack address is obtained\r\n * when taking the address of the near auto variable. A source of error in\r\n * writing dynamic code is that the stack segment may be different from the data\r\n * segment.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, external symbol defined without a prior\r\n * declaration.\r\n * The symbols are declared in the driver common file as external; they are needed\r\n * at driver initialization to install the correct interrupt handler, but are not\r\n * a part of the public API.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, could define variable at block scope\r\n * The variables are defined in the source file to make transition to other\r\n * platforms easier.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from\r\n * 'essentially enum<i>' to 'essentially Boolean'. This is required by\r\n * the conversion of a enum type into a bool type.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n */\r\n\r\n#include \"ftm_common.h\"\r\n#include \"ftm_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/*! @brief Table of base addresses for FTM instances. */\r\nFTM_Type * const g_ftmBase[FTM_INSTANCE_COUNT] = FTM_BASE_PTRS;\r\n\r\n/*! @brief Interrupt vectors for the FTM peripheral. */\r\nconst IRQn_Type g_ftmIrqId[FTM_INSTANCE_COUNT][FEATURE_FTM_CHANNEL_COUNT] = FTM_IRQS;\r\nconst IRQn_Type g_ftmFaultIrqId[FTM_INSTANCE_COUNT] = FTM_Fault_IRQS;\r\nconst IRQn_Type g_ftmOverflowIrqId[FTM_INSTANCE_COUNT] = FTM_Overflow_IRQS;\r\nconst IRQn_Type g_ftmReloadIrqId[FTM_INSTANCE_COUNT] = FTM_Reload_IRQS;\r\n\r\n#ifdef ERRATA_E10856\r\nbool faultDetection = false;\r\n#endif\r\n\r\n/*! @brief Pointer to runtime state structure. */\r\nftm_state_t * ftmStatePtr[FTM_INSTANCE_COUNT] = {NULL};\r\n\r\n/*! @brief  Select external clock pin or clock source for peripheral */\r\nstatic const clock_names_t g_ftmExtClockSel[FTM_INSTANCE_COUNT] = {FTM0_CLK,\r\n                                                                   FTM1_CLK,\r\n#if (FTM_INSTANCE_COUNT > 2U)\r\n                                                                   FTM2_CLK,\r\n#endif\r\n#if (FTM_INSTANCE_COUNT > 3U)\r\n                                                                   FTM3_CLK,\r\n#endif\r\n#if (FTM_INSTANCE_COUNT > 4U)\r\n                                                                   FTM4_CLK,\r\n#endif\r\n#if (FTM_INSTANCE_COUNT > 5U)\r\n                                                                   FTM5_CLK,\r\n#endif\r\n#if (FTM_INSTANCE_COUNT > 6U)\r\n                                                                   FTM6_CLK,\r\n#endif\r\n#if (FTM_INSTANCE_COUNT > 7U)\r\n                                                                   FTM7_CLK,\r\n#endif\r\n                                                                   };\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_Init\r\n * Description   : Initializes the FTM driver and get the clock frequency value\r\n * which select one of three possible clock sources for the FTM counter.\r\n *\r\n * Implements    : FTM_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_Init(uint32_t instance,\r\n                      const ftm_user_config_t * info,\r\n                      ftm_state_t * state)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(info != NULL);\r\n    DEV_ASSERT(state != NULL);\r\n    DEV_ASSERT((info->ftmClockSource == FTM_CLOCK_SOURCE_SYSTEMCLK) || \\\r\n               (info->ftmClockSource == FTM_CLOCK_SOURCE_FIXEDCLK) || \\\r\n               (info->ftmClockSource == FTM_CLOCK_SOURCE_EXTERNALCLK));\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    status_t status = STATUS_SUCCESS;\r\n    uint8_t index = 0U;\r\n\r\n    /* Check if this instance is already initialized */\r\n    if (ftmStatePtr[instance] != NULL)\r\n    {\r\n        status = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Configure state structure. */\r\n        state->ftmClockSource = info->ftmClockSource;\r\n        state->ftmMode = FTM_MODE_NOT_INITIALIZED;\r\n        state->ftmPeriod = 0U;\r\n        ftmStatePtr[instance] = state;\r\n\r\n        for (index = 0U; index < FEATURE_FTM_CHANNEL_COUNT; index++)\r\n        {\r\n            state->measurementResults[index] = 0U;\r\n            state->channelsCallbacksParams[index] = NULL;\r\n            state->channelsCallbacks[index] = NULL;\r\n            state->enableNotification[index] = false;\r\n        }\r\n\r\n        /* The reset operation doesn't care about write protection. FTM_DRV_Reset will\r\n         * disable this protection.*/\r\n        FTM_DRV_Reset(ftmBase);\r\n        FTM_DRV_InitModule(ftmBase, info->ftmPrescaler);\r\n        /* Get clock name used to configure the FlexTimer module */\r\n        state->ftmSourceClockFrequency = FTM_DRV_GetFrequency(instance);\r\n        /* Check the functional clock is selected for FTM */\r\n        DEV_ASSERT(state->ftmSourceClockFrequency > 0U);\r\n    }\r\n\r\n    if (STATUS_SUCCESS == status)\r\n    {\r\n        /* Check if the mode operation in PWM mode */\r\n        if ((FTM_MODE_EDGE_ALIGNED_PWM == info->ftmMode) || (FTM_MODE_CEN_ALIGNED_PWM == info->ftmMode) || (FTM_MODE_OUTPUT_COMPARE == info->ftmMode))\r\n        {\r\n            /* Configure sync for between registers and buffers */\r\n            status = FTM_DRV_SetSync(instance, &(info->syncMethod));\r\n        }\r\n\r\n        /* Enable the generation of initialization trigger on chip module */\r\n        FTM_DRV_SetInitTriggerCmd(ftmBase, info->enableInitializationTrigger);\r\n        FTM_DRV_SetBdmMode(ftmBase, info->BDMMode);\r\n\r\n        /* Check if enable interrupt in counter mode */\r\n        if (info->isTofIsrEnabled)\r\n        {\r\n            FTM_DRV_SetTimerOverflowInt(ftmBase, true);\r\n            INT_SYS_EnableIRQ(g_ftmOverflowIrqId[instance]);\r\n        }\r\n        else\r\n        {\r\n            FTM_DRV_SetTimerOverflowInt(ftmBase, false);\r\n            INT_SYS_DisableIRQ(g_ftmOverflowIrqId[instance]);\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_Deinit\r\n * Description   : Shuts down the FTM driver.\r\n * First, FTM_DRV_Init must be called. Then this function will disables the FTM module.\r\n *\r\n * Implements    : FTM_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_Deinit(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    /* Reset all FTM register */\r\n    FTM_DRV_Reset(ftmBase);\r\n    ftmStatePtr[instance] = NULL;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_GetDefaultConfig\r\n * Description   : This function will get the default configuration values\r\n * in the structure which is used as a common use-case.\r\n * Return        : None\r\n * Implements    : FTM_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid FTM_DRV_GetDefaultConfig(ftm_user_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->syncMethod.softwareSync     = true;\r\n    config->syncMethod.hardwareSync0    = false;\r\n    config->syncMethod.hardwareSync1    = false;\r\n    config->syncMethod.hardwareSync2    = false;\r\n    config->syncMethod.maxLoadingPoint  = false;\r\n    config->syncMethod.minLoadingPoint  = false;\r\n    config->syncMethod.inverterSync     = FTM_SYSTEM_CLOCK;\r\n    config->syncMethod.outRegSync       = FTM_SYSTEM_CLOCK;\r\n    config->syncMethod.maskRegSync      = FTM_SYSTEM_CLOCK;\r\n    config->syncMethod.initCounterSync  = FTM_SYSTEM_CLOCK;\r\n    config->syncMethod.autoClearTrigger = true;\r\n    config->syncMethod.syncPoint        = FTM_UPDATE_NOW;\r\n\r\n    config->ftmMode                     = FTM_MODE_EDGE_ALIGNED_PWM;\r\n    config->ftmPrescaler                = FTM_CLOCK_DIVID_BY_1;\r\n    config->ftmClockSource              = FTM_CLOCK_SOURCE_SYSTEMCLK;\r\n    config->BDMMode                     = FTM_BDM_MODE_11;\r\n    config->isTofIsrEnabled             = false;\r\n    config->enableInitializationTrigger = false;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_MaskOutputChannels\r\n * Description   : This function will mask the output of the channels and at match\r\n * events will be ignored by the masked channels.\r\n *\r\n * Implements : FTM_DRV_MaskOutputChannels_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_MaskOutputChannels(uint32_t instance,\r\n                                    uint32_t channelsMask,\r\n                                    bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetOutmaskReg(ftmBase, channelsMask);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetInitialCounterValue\r\n * Description   : This function configure the initial counter value. The counter\r\n * will get this value after an overflow event.\r\n *\r\n * Implements : FTM_DRV_SetInitialCounterValue_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetInitialCounterValue(uint32_t instance,\r\n                                        uint16_t counterValue,\r\n                                        bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetCounterInitVal(ftmBase, counterValue);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetHalfCycleReloadPoint\r\n * Description   : This function configure the value of the counter which will\r\n * generates an reload point.\r\n *\r\n * Implements : FTM_DRV_SetHalfCycleReloadPoint_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetHalfCycleReloadPoint(uint32_t instance,\r\n                                         uint16_t reloadPoint,\r\n                                         bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetHalfCycleValue(ftmBase, reloadPoint);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetSoftOutChnValue\r\n * Description   : This function will force the output value of a channel to a specific value.\r\n * Before using this function it's mandatory to mask the match events using\r\n * FTM_DRV_MaskOutputChannels and to enable software output control using\r\n * FTM_DRV_SetSoftwareOutputChannelControl.\r\n *\r\n * Implements : FTM_DRV_SetSoftOutChnValue_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetSoftOutChnValue(uint32_t instance,\r\n                                    uint8_t channelsValues,\r\n                                    bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    FTM_DRV_SetAllChnSoftwareCtrlVal(ftmBase, channelsValues ^ (uint8_t)ftmBase->POL);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetSoftwareOutputChannelControl\r\n * Description   : This function will configure which output channel can be\r\n * software controlled.\r\n *\r\n * Implements : FTM_DRV_SetSoftwareOutputChannelControl_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetSoftwareOutputChannelControl(uint32_t instance,\r\n                                                 uint8_t channelsMask,\r\n                                                 bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    FTM_DRV_SetAllChnSoftwareCtrlCmd(ftmBase, channelsMask);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetAllChnSoftwareOutputControl\r\n * Description   : This function will control list of channels by software to force\r\n * the output to specified value.\r\n * Despite the odd channels are configured as HIGH/LOW, they will be inverted in the following\r\n * configuration: COMP bit = 1 and CH(n)OCV and CH(n+1)OCV are HIGH. Please check Software\r\n * output control behavior chapter from RM.\r\n *\r\n * Implements : FTM_DRV_SetAllChnSoftwareOutputControl_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetAllChnSoftwareOutputControl(uint32_t instance,\r\n                                                uint8_t channelMask,\r\n                                                uint8_t channelValueMask,\r\n                                                bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint16_t value = 0U;\r\n\r\n    value = (uint16_t)(((uint16_t)channelValueMask ^ (uint16_t)ftmBase->POL) << (uint16_t)8U) | (uint16_t)channelMask;\r\n\r\n    /* Enable and force the software control of channels output */\r\n    FTM_DRV_SoftwareOutputControl(ftmBase, value);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetInvertingControl\r\n * Description   : This function will configure if the second channel of a pair\r\n * will be inverted or not.\r\n *\r\n * Implements : FTM_DRV_SetInvertingControl_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetInvertingControl(uint32_t instance,\r\n                                     uint8_t channelsPairMask,\r\n                                     bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetInvctrlReg(ftmBase, channelsPairMask);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetModuloCounterValue\r\n * Description   : This function configure the maximum counter value.\r\n *\r\n * Implements : FTM_DRV_SetModuloCounterValue_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetModuloCounterValue(uint32_t instance,\r\n                                       uint16_t counterValue,\r\n                                       bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetMod(ftmBase, counterValue);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetOutputlevel\r\n * Description   : This function will set the channel edge or level on the selection\r\n * of the channel mode.\r\n *\r\n * Implements : FTM_DRV_SetOutputlevel_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetOutputlevel(uint32_t instance,\r\n                                uint8_t channel,\r\n                                uint8_t level)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    /* Sets the channel edge or level selection */\r\n    FTM_DRV_SetChnEdgeLevel(ftmBase, channel, level);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetSync\r\n * Description   : This function configure the synchronization for PWM register\r\n * (CnV, MOD, CINT, HCR, OUTMASK).If this function is used whit wrong parameters\r\n * it's possible to generate wrong waveform. Registers synchronization need to\r\n * be configured for PWM and output compare mode.\r\n *\r\n * Implements : FTM_DRV_SetSync_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_SetSync(uint32_t instance,\r\n                         const ftm_pwm_sync_t * param)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(param != NULL);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n    bool hardwareSync = param->hardwareSync0 || param->hardwareSync1 || param->hardwareSync2;\r\n\r\n    /* Software and hardware triggers are not allowed in the same time */\r\n    if ((param->softwareSync && hardwareSync) || (true != (param->softwareSync || hardwareSync)))\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n    else if (param->softwareSync)\r\n    {\r\n        /* Configure sync for OUTMASK register */\r\n        FTM_DRV_SetOutmaskSoftwareSyncModeCmd(ftmBase, true);\r\n        /* Configure sync for INVCTRL register */\r\n        FTM_DRV_SetInvctrlSoftwareSyncModeCmd(ftmBase, true);\r\n        /* Configure sync for SWOCTRL register */\r\n        FTM_DRV_SetSwoctrlSoftwareSyncModeCmd(ftmBase, true);\r\n        /* Configure sync for MOD, HCR, CNTIN, and CnV registers */\r\n        FTM_DRV_SetModCntinCvSoftwareSyncModeCmd(ftmBase, true);\r\n        /* Configure synchronization method (waiting next loading point or now) */\r\n        FTM_DRV_SetCounterSoftwareSyncModeCmd(ftmBase, param->syncPoint);\r\n    }\r\n    else\r\n    {\r\n        /* Configure sync for OUTMASK register */\r\n        FTM_DRV_SetOutmaskHardwareSyncModeCmd(ftmBase, true);\r\n        /* Configure sync for INVCTRL register */\r\n        FTM_DRV_SetInvctrlHardwareSyncModeCmd(ftmBase, true);\r\n        /* Configure sync for SWOCTRL register */\r\n        FTM_DRV_SetSwoctrlHardwareSyncModeCmd(ftmBase, true);\r\n        /* Configure sync for MOD, HCR, CNTIN, and CnV registers */\r\n        FTM_DRV_SetModCntinCvHardwareSyncModeCmd(ftmBase, true);\r\n        /* Configure synchronization method (waiting next loading point or now) */\r\n        FTM_DRV_SetCounterHardwareSyncModeCmd(ftmBase, (bool)param->syncPoint);\r\n    }\r\n\r\n    if (STATUS_SUCCESS == retStatus)\r\n    {\r\n        /* Enhanced PWM sync is used */\r\n        FTM_DRV_SetPwmSyncModeCmd(ftmBase, true);\r\n        /* Configure trigger source for sync */\r\n        FTM_DRV_SetHardwareSyncTriggerSrc(ftmBase, 0U, param->hardwareSync0);\r\n        FTM_DRV_SetHardwareSyncTriggerSrc(ftmBase, 1U, param->hardwareSync1);\r\n        FTM_DRV_SetHardwareSyncTriggerSrc(ftmBase, 2U, param->hardwareSync2);\r\n        /* Configure loading points */\r\n        FTM_DRV_SetMaxLoadingCmd(ftmBase, param->maxLoadingPoint);\r\n        FTM_DRV_SetMinLoadingCmd(ftmBase, param->minLoadingPoint);\r\n        /* Configure sync for OUTMASK register */\r\n        FTM_DRV_SetOutmaskPwmSyncModeCmd(ftmBase, (bool)param->maskRegSync);\r\n        /* Configure sync for INVCTRL register */\r\n        FTM_DRV_SetInvctrlPwmSyncModeCmd(ftmBase, param->inverterSync);\r\n        /* Configure sync for SWOCTRL register */\r\n        FTM_DRV_SetSwoctrlPwmSyncModeCmd(ftmBase, param->outRegSync);\r\n        /* Configure sync for MOD, HCR, CNTIN, and CnV registers */\r\n        FTM_DRV_SetCntinPwmSyncModeCmd(ftmBase, param->initCounterSync);\r\n        /* Configure if FTM clears TRIGj (j=0,1,2) when the hardware trigger j is detected. */\r\n        FTM_DRV_SetHwTriggerSyncModeCmd(ftmBase, param->autoClearTrigger);\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_GenerateHardwareTrigger\r\n * Description   : This function is used to configure a trigger source for FTM instance.\r\n * This allow a hardware trigger input which can be used in PWM synchronization.\r\n * Note that the hardware trigger is implemented only on trigger 1 for each instance.\r\n *\r\n * Implements : FTM_DRV_GenerateHardwareTrigger_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_GenerateHardwareTrigger(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    SIM_Type * simeBase = SIM_BASE_PTRS;\r\n\r\n    FTM_DRV_SyncBit(simeBase, instance, true);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_EnableInterrupts\r\n * Description   : This function will enable the generation a list of interrupts.\r\n * It includes the FTM overflow interrupts, the reload point interrupt, the fault\r\n * interrupt and the channel (n) interrupt.\r\n *\r\n * Implements : FTM_DRV_EnableInterrupts_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_EnableInterrupts(uint32_t instance,\r\n                                  uint32_t interruptMask)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint32_t chnlInts = (interruptMask & 0x000000FFU);\r\n    uint8_t channel = 0U;\r\n\r\n    /* Enable the timer overflow interrupt */\r\n    if ((interruptMask & (uint32_t)FTM_TIME_OVER_FLOW_INT_ENABLE) != 0x0U)\r\n    {\r\n        FTM_DRV_SetTimerOverflowInt(ftmBase, true);\r\n        INT_SYS_EnableIRQ(g_ftmOverflowIrqId[instance]);\r\n    }\r\n\r\n    /* Enable the fault interrupt */\r\n    if ((interruptMask & (uint32_t)FTM_FAULT_INT_ENABLE) != 0x0U)\r\n    {\r\n        FTM_DRV_SetFaultInt(ftmBase, true);\r\n        INT_SYS_EnableIRQ(g_ftmFaultIrqId[instance]);\r\n    }\r\n\r\n    /* Enable the reload interrupt */\r\n    if ((interruptMask & (uint32_t)FTM_RELOAD_INT_ENABLE) != 0x0U)\r\n    {\r\n        FTM_DRV_SetReIntEnabledCmd(ftmBase, true);\r\n        INT_SYS_EnableIRQ(g_ftmReloadIrqId[instance]);\r\n    }\r\n\r\n    /* Enable the channel interrupts */\r\n    while (chnlInts != 0U)\r\n    {\r\n        if ((chnlInts & 0x1U) != 0x0U)\r\n        {\r\n            FTM_DRV_EnableChnInt(ftmBase, channel);\r\n            INT_SYS_EnableIRQ(g_ftmIrqId[instance][channel]);\r\n        }\r\n        channel++;\r\n        chnlInts = chnlInts >> 1U;\r\n    }\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_DisableInterrupts\r\n * Description   : This function is used to disable some interrupts.\r\n *\r\n * Implements : FTM_DRV_DisableInterrupts_Activity\r\n *END**************************************************************************/\r\nvoid FTM_DRV_DisableInterrupts(uint32_t instance,\r\n                               uint32_t interruptMask)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint32_t chnlInts = (interruptMask & 0x000000FFU);\r\n    uint8_t channel = 0U;\r\n\r\n    /* Disable the timer overflow interrupt */\r\n    if ((interruptMask & (uint32_t)FTM_TIME_OVER_FLOW_INT_ENABLE) != 0x0U)\r\n    {\r\n        FTM_DRV_SetTimerOverflowInt(ftmBase, false);\r\n        INT_SYS_DisableIRQ(g_ftmOverflowIrqId[instance]);\r\n    }\r\n\r\n    /* Disable the fault interrupt */\r\n    if ((interruptMask & (uint32_t)FTM_FAULT_INT_ENABLE) != 0x0U)\r\n    {\r\n        FTM_DRV_SetFaultInt(ftmBase, false);\r\n        INT_SYS_DisableIRQ(g_ftmFaultIrqId[instance]);\r\n    }\r\n\r\n    /* Disable the reload interrupt */\r\n    if ((interruptMask & (uint32_t)FTM_RELOAD_INT_ENABLE) != 0x0U)\r\n    {\r\n        FTM_DRV_SetReIntEnabledCmd(ftmBase, false);\r\n        INT_SYS_DisableIRQ(g_ftmReloadIrqId[instance]);\r\n    }\r\n\r\n    /* Disable the channel interrupts */\r\n    while (chnlInts != 0U)\r\n    {\r\n        if ((chnlInts & 0x1U) != 0x0U)\r\n        {\r\n            FTM_DRV_DisableChnInt(ftmBase, channel);\r\n            INT_SYS_DisableIRQ(g_ftmIrqId[instance][channel]);\r\n        }\r\n        channel++;\r\n        chnlInts = chnlInts >> 1U;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_GetEnabledInterrupts\r\n * Description   : This function will get the enabled FTM interrupts.\r\n *\r\n * Implements : FTM_DRV_GetEnabledInterrupts_Activity\r\n *END**************************************************************************/\r\nuint32_t FTM_DRV_GetEnabledInterrupts(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type const * ftmBase = g_ftmBase[instance];\r\n    uint32_t enabledInterrupts = 0U;\r\n    uint8_t channel = FEATURE_FTM_CHANNEL_COUNT;\r\n\r\n\r\n    /* Check if timer overflow interrupt is enabled */\r\n    if (FTM_DRV_IsOverflowIntEnabled(ftmBase) == true)\r\n    {\r\n        enabledInterrupts |= (uint32_t)FTM_TIME_OVER_FLOW_INT_ENABLE;\r\n    }\r\n\r\n    /* Check if fault interrupt is enabled */\r\n    if (FTM_DRV_IsFaultIntEnabled(ftmBase) == true)\r\n    {\r\n        enabledInterrupts |= (uint32_t)FTM_FAULT_INT_ENABLE;\r\n    }\r\n\r\n    /* Check if the reload interrupt is enabled */\r\n    if (FTM_DRV_IsReloadIntEnabled(ftmBase) == true)\r\n    {\r\n        enabledInterrupts |= (uint32_t)FTM_RELOAD_INT_ENABLE;\r\n    }\r\n\r\n    /* Check if the channel interrupts are enabled */\r\n    while (channel > 0U)\r\n    {\r\n        channel--;\r\n        if (FTM_DRV_IsChnIntEnabled(ftmBase, channel) == true)\r\n        {\r\n            enabledInterrupts |= (1UL << (uint32_t)channel);\r\n        }\r\n    }\r\n\r\n    return enabledInterrupts;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_GetStatusFlags\r\n * Description   : This function will get the FTM status flags.\r\n *\r\n * Implements : FTM_DRV_GetStatusFlags_Activity\r\n *END**************************************************************************/\r\nuint32_t FTM_DRV_GetStatusFlags(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type const * ftmBase = g_ftmBase[instance];\r\n    uint8_t channel = 0U;\r\n    uint32_t statusFlags = 0U;\r\n\r\n    /* Check the timer flag */\r\n    if (FTM_DRV_HasTimerOverflowed(ftmBase) == true)\r\n    {\r\n        statusFlags |= (uint32_t)FTM_TIME_OVER_FLOW_FLAG;\r\n    }\r\n\r\n    /* Check fault flag */\r\n    if (FTM_DRV_GetDetectedFaultInput(ftmBase) == true)\r\n    {\r\n        statusFlags |= (uint32_t)FTM_FAULT_FLAG;\r\n    }\r\n\r\n    /* Check reload flag */\r\n    if (FTM_DRV_GetReloadFlag(ftmBase) == true)\r\n    {\r\n        statusFlags |= (uint32_t)FTM_RELOAD_FLAG;\r\n    }\r\n\r\n    /* Check channel trigger flag */\r\n    if (FTM_DRV_IsChnTriggerGenerated(ftmBase) == true)\r\n    {\r\n        statusFlags |= (uint32_t)FTM_CHANNEL_TRIGGER_FLAG;\r\n    }\r\n\r\n    /* Lower 8 bits contain the channel status flags */\r\n    for (channel = 0U; channel < FEATURE_FTM_CHANNEL_COUNT; channel++)\r\n    {\r\n        if (FTM_DRV_HasChnEventOccurred(ftmBase, channel) == true)\r\n        {\r\n            statusFlags |= (1UL << (uint32_t)channel);\r\n        }\r\n    }\r\n\r\n    return statusFlags;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_ClearStatusFlags\r\n * Description   : This function is used to clear the FTM status flags.\r\n *\r\n * Implements : FTM_DRV_ClearStatusFlags_Activity\r\n *END**************************************************************************/\r\nvoid FTM_DRV_ClearStatusFlags(uint32_t instance,\r\n                              uint32_t flagMask)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint32_t chnlMask = (flagMask & 0x000000FFU);\r\n    uint8_t channel = 0U;\r\n\r\n    /* Clear the timer overflow flag by writing a 0 to the bit while it is set */\r\n    if ((flagMask & (uint32_t)FTM_TIME_OVER_FLOW_FLAG) != 0x0U)\r\n    {\r\n        FTM_DRV_ClearTimerOverflow(ftmBase);\r\n    }\r\n\r\n    /* Clear fault flag by writing a 0 to the bit while it is set */\r\n    if ((flagMask & (uint32_t)FTM_FAULT_FLAG) != 0x0U)\r\n    {\r\n        FTM_DRV_ClearFaultsIsr(ftmBase);\r\n    }\r\n\r\n    /* Check reload flag by writing a 0 to the bit while it is set */\r\n    if ((flagMask & (uint32_t)FTM_RELOAD_FLAG) != 0x0U)\r\n    {\r\n        FTM_DRV_ClearReloadFlag(ftmBase);\r\n    }\r\n\r\n    /* Clear channel trigger flag */\r\n    if ((flagMask & (uint32_t)FTM_CHANNEL_TRIGGER_FLAG) != 0x0U)\r\n    {\r\n        FTM_DRV_ClearChnTriggerFlag(ftmBase);\r\n    }\r\n\r\n    /* Clear the channel status flags by writing a 0 to the bit */\r\n    for (channel = 0U; channel < FEATURE_FTM_CHANNEL_COUNT; channel++)\r\n    {\r\n        if ((chnlMask & 0x00000001U) != 0x0U)\r\n        {\r\n            FTM_DRV_ClearChnEventStatus(ftmBase, channel);\r\n        }\r\n        chnlMask = chnlMask >> 1U;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_GetFrequency\r\n * Description   : Retrieves the frequency of the clock source feeding the FTM counter.\r\n * Function will return a 0 if no clock source is selected and the FTM counter is disabled.\r\n * The returned value is clock sources for the FTM counter.\r\n *\r\n * Implements    : FTM_DRV_GetFrequency_Activity\r\n *END**************************************************************************/\r\nuint32_t FTM_DRV_GetFrequency(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type const * ftmBase = g_ftmBase[instance];\r\n    status_t returnCode = STATUS_SUCCESS;\r\n    uint8_t clkPs;\r\n    uint32_t frequency = 0U;\r\n    const ftm_state_t * state = ftmStatePtr[instance];\r\n    DEV_ASSERT(state != NULL);\r\n    clkPs = (uint8_t)(1U << FTM_DRV_GetClockPs(ftmBase));\r\n\r\n    switch (state->ftmClockSource)\r\n    {\r\n        case FTM_CLOCK_SOURCE_EXTERNALCLK:\r\n            returnCode = CLOCK_SYS_GetFreq(g_ftmExtClockSel[instance], &frequency);\r\n            break;\r\n        case FTM_CLOCK_SOURCE_FIXEDCLK:\r\n            /* Get the clock frequency value */\r\n            returnCode = CLOCK_SYS_GetFreq(SIM_RTCCLK_CLK, &frequency);\r\n            break;\r\n        case FTM_CLOCK_SOURCE_SYSTEMCLK:\r\n            /* Get the clock frequency value */\r\n            returnCode = CLOCK_SYS_GetFreq(CORE_CLK, &frequency);\r\n            break;\r\n        default:\r\n            /* Nothing to do */\r\n            break;\r\n    }\r\n\r\n    /* Checks the functional clock of FTM module */\r\n    (void)returnCode;\r\n    DEV_ASSERT(returnCode == STATUS_SUCCESS);\r\n\r\n    return (uint32_t)(frequency / clkPs);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_ConvertFreqToPeriodTicks\r\n * Description   : This function converts the input parameters representing\r\n * frequency in Hz to a period value in ticks needed by the hardware timer.\r\n *\r\n * Implements    : FTM_DRV_ConvertFreqToPeriodTicks_Activity\r\n *END**************************************************************************/\r\nuint16_t FTM_DRV_ConvertFreqToPeriodTicks(uint32_t instance,\r\n                                          uint32_t freqencyHz)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(freqencyHz != 0U);\r\n    uint32_t uFTMhz;\r\n    const ftm_state_t * state = ftmStatePtr[instance];\r\n    uFTMhz = state->ftmSourceClockFrequency;\r\n\r\n    return (uint16_t)(uFTMhz / freqencyHz);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_CounterReset\r\n * Description   : This function will allow the FTM to restart the counter to\r\n * its initial counting value in the register.\r\n * Note that the configuration is set in the FTM_DRV_SetSync() function to make\r\n * sure that the FTM registers are updated by software trigger or hardware trigger.\r\n *\r\n * Implements : FTM_DRV_CounterReset_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_CounterReset(uint32_t instance,\r\n                              bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    /* Updates the counter with its initial value */\r\n    FTM_DRV_SetCounter(ftmBase, 0U);\r\n    /* Set a software trigger or waiting a hardware trigger */\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*******************************************************************************\r\n* EOF\r\n******************************************************************************/\r\n"},{"name":"ftm_common.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_common.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n  *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, global typedef not referenced\r\n * The enumeration structure is used by user to enable, clear a list of interrupts.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macros defined are used to define features for each driver, so this might be reported\r\n * when the analysis is made only on one driver.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro defined.\r\n * This macro is needed to improve the time efficiency.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from\r\n * 'essentially Boolean' type to 'essentially unsigned'.This is required by the\r\n * conversion of a bit-field of a bool type into a bit-field of a register type.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.7, Composite expression with smaller\r\n * essential type than other operand.\r\n * The expression is safe as the baud rate calculation algorithm cannot overflow\r\n * the result.\r\n\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, Could define variable at block scope\r\n * The variable is used in driver c file, so it must remain global.\r\n */\r\n#ifndef FTM_COMMON_H\r\n#define FTM_COMMON_H\r\n#include <stddef.h>\r\n#include \"status.h\"\r\n#include \"device_registers.h\"\r\n#include \"callbacks.h\"\r\n\r\n/*!\r\n * @addtogroup ftm\r\n * @{\r\n */\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n/*! @brief Table of base addresses for FTM instances. */\r\nextern FTM_Type * const g_ftmBase[FTM_INSTANCE_COUNT];\r\n\r\n/*! @brief Interrupt vectors for the FTM peripheral. */\r\nextern const IRQn_Type g_ftmIrqId[FTM_INSTANCE_COUNT][FEATURE_FTM_CHANNEL_COUNT];\r\nextern const IRQn_Type g_ftmFaultIrqId[FTM_INSTANCE_COUNT];\r\nextern const IRQn_Type g_ftmOverflowIrqId[FTM_INSTANCE_COUNT];\r\nextern const IRQn_Type g_ftmReloadIrqId[FTM_INSTANCE_COUNT];\r\n\r\n#ifdef ERRATA_E10856\r\nextern bool faultDetection;\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief FTM_SC - Read and modify and write to Status And Control (RW)\r\n */\r\n#define FTM_RMW_SC(base, mask, value) (((base)->SC) = ((((base)->SC) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_CNT - Read and modify and write to Counter (RW)\r\n */\r\n#define FTM_RMW_CNT(base, mask, value) (((base)->CNT) = ((((base)->CNT) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_MOD - Read and modify and write Modulo (RW)\r\n */\r\n#define FTM_RMW_MOD(base, mask, value) (((base)->MOD) = ((((base)->MOD) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_CNTIN - Read and modify and write Counter Initial Value (RW)\r\n */\r\n#define FTM_RMW_CNTIN(base, mask, value) (((base)->CNTIN) = ((((base)->CNTIN) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_STATUS - Read and modify and write Capture And Compare Status (RW)\r\n */\r\n#define FTM_RMW_STATUS(base, mask, value) (((base)->STATUS) = ((((base)->STATUS) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_MODE -  Read and modify and write Counter Features Mode Selection (RW)\r\n */\r\n#define FTM_RMW_MODE(base, mask, value) (((base)->MODE) = ((((base)->MODE) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_CnSCV -  Read and modify and write Channel (n) Status And Control (RW)\r\n */\r\n#define FTM_RMW_CnSCV_REG(base, channel, mask, value) (((base)->CONTROLS[channel].CnSC) = ((((base)->CONTROLS[channel].CnSC) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_DEADTIME - Read and modify and write Dead-time Insertion Control (RW)\r\n */\r\n#define FTM_RMW_DEADTIME(base, mask, value) (((base)->DEADTIME) = ((((base)->DEADTIME) & ~(mask)) | (value)))\r\n/*!\r\n * @brief FTM_EXTTRIG - Read and modify and write External Trigger Control (RW)\r\n */\r\n#define FTM_RMW_EXTTRIG_REG(base, mask, value) (((base)->EXTTRIG) = ((((base)->EXTTRIG) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_FLTCTRL -  Read and modify and write Fault Control (RW)\r\n */\r\n#define FTM_RMW_FLTCTRL(base, mask, value) (((base)->FLTCTRL) = ((((base)->FLTCTRL) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_FMS -  Read and modify and write Fault Mode Status (RW)\r\n */\r\n#define FTM_RMW_FMS(base, mask, value) (((base)->FMS) = ((((base)->FMS) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_CONF -  Read and modify and write Configuration (RW)\r\n */\r\n#define FTM_RMW_CONF(base, mask, value) (((base)->CONF) = ((((base)->CONF) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief POL -  Read and modify and write Polarity (RW)\r\n */\r\n#define FTM_RMW_POL(base, mask, value) (((base)->POL) = ((((base)->POL) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FILTER -  Read and modify and write Filter (RW)\r\n */\r\n#define FTM_RMW_FILTER(base, mask, value) (((base)->FILTER) = ((((base)->FILTER) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief SYNC -  Read and modify and write Synchronization (RW)\r\n */\r\n#define FTM_RMW_SYNC(base, mask, value) (((base)->SYNC) = ((((base)->SYNC) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief QDCTRL -  Read and modify and write Quadrature Decoder Control And Status (RW)\r\n */\r\n#define FTM_RMW_QDCTRL(base, mask, value) (((base)->QDCTRL) = ((((base)->QDCTRL) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_PAIR0DEADTIME - Read and modify and write Dead-time Insertion Control for the pair 0 (RW)\r\n */\r\n#define FTM_RMW_PAIR0DEADTIME(base, mask, value) (((base)->PAIR0DEADTIME) = ((((base)->PAIR0DEADTIME) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_PAIR1DEADTIME - Read and modify and write Dead-time Insertion Control for the pair 1 (RW)\r\n */\r\n#define FTM_RMW_PAIR1DEADTIME(base, mask, value) (((base)->PAIR1DEADTIME) = ((((base)->PAIR1DEADTIME) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_PAIR2DEADTIME - Read and modify and write Dead-time Insertion Control for the pair 2 (RW)\r\n */\r\n#define FTM_RMW_PAIR2DEADTIME(base, mask, value) (((base)->PAIR2DEADTIME) = ((((base)->PAIR2DEADTIME) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_PAIR3DEADTIME - Read and modify and write Dead-time Insertion Control for the pair 3 (RW)\r\n */\r\n#define FTM_RMW_PAIR3DEADTIME(base, mask, value) (((base)->PAIR3DEADTIME) = ((((base)->PAIR3DEADTIME) & ~(mask)) | (value)))\r\n\r\n#if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n/*!\r\n * @brief FTM_MOD_MIRROR - Read and modify and write mirror of modulo value for the FTM counter (RW)\r\n */\r\n#define FTM_RMW_MOD_MIRROR(base, mask, value) (((base)->MOD_MIRROR) = ((((base)->MOD_MIRROR) & ~(mask)) | (value)))\r\n\r\n/*!\r\n * @brief FTM_CnV_MIRROR -  Read and modify and write mirror of channel (n) match value (RW)\r\n */\r\n#define FTM_RMW_CnV_MIRROR(base, channel, mask, value) (((base)->CV_MIRROR[channel]) = ((((base)->CV_MIRROR[channel]) & ~(mask)) | (value)))\r\n#endif\r\n\r\n/*!< @brief Channel number for CHAN0.*/\r\n#define CHAN0_IDX (0U)\r\n/*!< @brief Channel number for CHAN1.*/\r\n#define CHAN1_IDX (1U)\r\n/*!< @brief Channel number for CHAN2.*/\r\n#define CHAN2_IDX (2U)\r\n/*!< @brief Channel number for CHAN3.*/\r\n#define CHAN3_IDX (3U)\r\n/*!< @brief Channel number for CHAN4.*/\r\n#define CHAN4_IDX (4U)\r\n/*!< @brief Channel number for CHAN5.*/\r\n#define CHAN5_IDX (5U)\r\n/*!< @brief Channel number for CHAN6.*/\r\n#define CHAN6_IDX (6U)\r\n/*!< @brief Channel number for CHAN7.*/\r\n#define CHAN7_IDX (7U)\r\n\r\n/*******************************************************************************\r\n * Enumerations\r\n ******************************************************************************/\r\n/*!\r\n * @brief FlexTimer operation mode\r\n *\r\n * Implements : ftm_config_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_MODE_NOT_INITIALIZED    = 0x00U,    /*!< The driver is not initialized */\r\n    FTM_MODE_INPUT_CAPTURE      = 0x01U,    /*!< Input capture */\r\n    FTM_MODE_OUTPUT_COMPARE     = 0x02U,    /*!< Output compare */\r\n    FTM_MODE_EDGE_ALIGNED_PWM   = 0x03U,    /*!< Edge aligned PWM */\r\n    FTM_MODE_CEN_ALIGNED_PWM    = 0x04U,    /*!< Center aligned PWM */\r\n    FTM_MODE_QUADRATURE_DECODER = 0x05U,    /*!< Quadrature decoder */\r\n    FTM_MODE_UP_TIMER           = 0x06U,    /*!< Timer with up counter */\r\n    FTM_MODE_UP_DOWN_TIMER      = 0x07U     /*!< timer with up-down counter */\r\n} ftm_config_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer clock source selection\r\n *\r\n * Implements : ftm_clock_source_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_CLOCK_SOURCE_NONE           = 0x00U,    /*!< None use clock for FTM  */\r\n    FTM_CLOCK_SOURCE_SYSTEMCLK      = 0x01U,    /*!< System clock            */\r\n    FTM_CLOCK_SOURCE_FIXEDCLK       = 0x02U,    /*!< Fixed clock             */\r\n    FTM_CLOCK_SOURCE_EXTERNALCLK    = 0x03U     /*!< External clock          */\r\n} ftm_clock_source_t;\r\n\r\n/*!\r\n * @brief FlexTimer pre-scaler factor selection for the clock source.\r\n * In quadrature decoder mode set FTM_CLOCK_DIVID_BY_1\r\n *\r\n * Implements : ftm_clock_ps_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_CLOCK_DIVID_BY_1    = 0x00U,    /*!< Divide by 1   */\r\n    FTM_CLOCK_DIVID_BY_2    = 0x01U,    /*!< Divide by 2   */\r\n    FTM_CLOCK_DIVID_BY_4    = 0x02U,    /*!< Divide by 4   */\r\n    FTM_CLOCK_DIVID_BY_8    = 0x03U,    /*!< Divide by 8   */\r\n    FTM_CLOCK_DIVID_BY_16   = 0x04U,    /*!< Divide by 16  */\r\n    FTM_CLOCK_DIVID_BY_32   = 0x05U,    /*!< Divide by 32  */\r\n    FTM_CLOCK_DIVID_BY_64   = 0x06U,    /*!< Divide by 64  */\r\n    FTM_CLOCK_DIVID_BY_128  = 0x07U     /*!< Divide by 128 */\r\n} ftm_clock_ps_t;\r\n\r\n/*!\r\n * @brief List of FTM interrupts\r\n *\r\n * Implements : ftm_interrupt_option_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_CHANNEL0_INT_ENABLE       = 0x00000001U,    /*!< Channel 0 interrupt */\r\n    FTM_CHANNEL1_INT_ENABLE       = 0x00000002U,    /*!< Channel 1 interrupt */\r\n    FTM_CHANNEL2_INT_ENABLE       = 0x00000004U,    /*!< Channel 2 interrupt */\r\n    FTM_CHANNEL3_INT_ENABLE       = 0x00000008U,    /*!< Channel 3 interrupt */\r\n    FTM_CHANNEL4_INT_ENABLE       = 0x00000010U,    /*!< Channel 4 interrupt */\r\n    FTM_CHANNEL5_INT_ENABLE       = 0x00000020U,    /*!< Channel 5 interrupt */\r\n    FTM_CHANNEL6_INT_ENABLE       = 0x00000040U,    /*!< Channel 6 interrupt */\r\n    FTM_CHANNEL7_INT_ENABLE       = 0x00000080U,    /*!< Channel 7 interrupt */\r\n    FTM_FAULT_INT_ENABLE          = 0x00000100U,    /*!< Fault interrupt */\r\n    FTM_TIME_OVER_FLOW_INT_ENABLE = 0x00000200U,    /*!< Time overflow interrupt */\r\n    FTM_RELOAD_INT_ENABLE         = 0x00000400U     /*!< Reload interrupt; Available only on certain SoC's */\r\n} ftm_interrupt_option_t;\r\n\r\n/*!\r\n * @brief List of FTM flags\r\n *\r\n * Implements : ftm_status_flag_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_CHANNEL0_FLAG        = 0x00000001U,    /*!< Channel 0 Flag */\r\n    FTM_CHANNEL1_FLAG        = 0x00000002U,    /*!< Channel 1 Flag */\r\n    FTM_CHANNEL2_FLAG        = 0x00000004U,    /*!< Channel 2 Flag */\r\n    FTM_CHANNEL3_FLAG        = 0x00000008U,    /*!< Channel 3 Flag */\r\n    FTM_CHANNEL4_FLAG        = 0x00000010U,    /*!< Channel 4 Flag */\r\n    FTM_CHANNEL5_FLAG        = 0x00000020U,    /*!< Channel 5 Flag */\r\n    FTM_CHANNEL6_FLAG        = 0x00000040U,    /*!< Channel 6 Flag */\r\n    FTM_CHANNEL7_FLAG        = 0x00000080U,    /*!< Channel 7 Flag */\r\n    FTM_FAULT_FLAG           = 0x00000100U,    /*!< Fault Flag */\r\n    FTM_TIME_OVER_FLOW_FLAG  = 0x00000200U,    /*!< Time overflow Flag */\r\n    FTM_RELOAD_FLAG          = 0x00000400U,    /*!< Reload Flag; Available only on certain SoC's */\r\n    FTM_CHANNEL_TRIGGER_FLAG = 0x00000800U     /*!< Channel trigger Flag */\r\n} ftm_status_flag_t;\r\n\r\n/*!\r\n * @brief FTM sync source\r\n *\r\n * Implements : ftm_reg_update_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_SYSTEM_CLOCK    = 0U,       /*!< Register is updated with its buffer value at all rising\r\n                                     *   edges of system clock */\r\n    FTM_PWM_SYNC        = 1U        /*!< Register is updated with its buffer value at the\r\n                                     *   FTM synchronization */\r\n} ftm_reg_update_t;\r\n\r\n/*!\r\n * @brief FTM update register\r\n *\r\n * Implements : ftm_pwm_sync_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_WAIT_LOADING_POINTS = 0U,   /*!< FTM register is updated at first loading point */\r\n    FTM_UPDATE_NOW          = 1U    /*!< FTM register is updated immediately */\r\n} ftm_pwm_sync_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer pre-scaler factor for the dead-time insertion\r\n *\r\n * Implements : ftm_deadtime_ps_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_DEADTIME_DIVID_BY_1  = 0x01U, /*!< Divide by 1   */\r\n    FTM_DEADTIME_DIVID_BY_4  = 0x02U, /*!< Divide by 4   */\r\n    FTM_DEADTIME_DIVID_BY_16 = 0x03U  /*!< Divide by 16  */\r\n} ftm_deadtime_ps_t;\r\n\r\n/*!\r\n * @brief Options for the FlexTimer behavior in BDM Mode\r\n *\r\n * Implements : ftm_bdm_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_BDM_MODE_00 = 0x00U,    /*!< FTM counter stopped, CH(n)F bit can be set, FTM channels\r\n                                 *   in functional mode, writes to MOD,CNTIN and C(n)V registers bypass\r\n                                 *   the register buffers */\r\n    FTM_BDM_MODE_01 = 0x01U,    /*!< FTM counter stopped, CH(n)F bit is not set, FTM channels\r\n                                 *   outputs are forced to their safe value , writes to MOD,CNTIN and\r\n                                 *   C(n)V registers bypass the register buffers */\r\n    FTM_BDM_MODE_10 = 0x02U,    /*!< FTM counter stopped, CH(n)F bit is not set, FTM channels\r\n                                *    outputs are frozen when chip enters in BDM mode, writes to MOD,\r\n                                *    CNTIN and C(n)V registers bypass the register buffers */\r\n    FTM_BDM_MODE_11 = 0x03U     /*!< FTM counter in functional mode, CH(n)F bit can be set,\r\n                                 *   FTM channels in functional mode, writes to MOD,CNTIN and C(n)V\r\n                                 *   registers is in fully functional mode */\r\n} ftm_bdm_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer state structure of the driver\r\n *\r\n * Implements : ftm_state_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    ftm_clock_source_t ftmClockSource;                             /*!< Clock source used by FTM counter */\r\n    ftm_config_mode_t ftmMode;                                     /*!< Mode of operation for FTM */\r\n    uint16_t ftmPeriod;                                            /*!< This field is used only in PWM mode to store signal period */\r\n    uint32_t ftmSourceClockFrequency;                              /*!< The clock frequency is used for counting */\r\n    uint16_t measurementResults[FEATURE_FTM_CHANNEL_COUNT];        /*!< This field is used only in input capture mode to store edges time stamps */\r\n    void * channelsCallbacksParams[FEATURE_FTM_CHANNEL_COUNT];     /*!< The parameters of callback function for channels events */\r\n    ic_callback_t channelsCallbacks[FEATURE_FTM_CHANNEL_COUNT];    /*!< The callback function for channels events */\r\n    bool enableNotification[FEATURE_FTM_CHANNEL_COUNT];            /*!< To save channels enable the notification on the callback application */\r\n} ftm_state_t;\r\n\r\n/*!\r\n * @brief FlexTimer Registers sync parameters\r\n *        Please don't use software and hardware trigger simultaneously\r\n * Implements : ftm_pwm_sync_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool softwareSync;                          /*!< True - enable software sync,\r\n                                                 *   False - disable software sync */\r\n    bool hardwareSync0;                         /*!< True - enable hardware 0 sync,\r\n                                                 *   False - disable hardware 0 sync */\r\n    bool hardwareSync1;                         /*!< True - enable hardware 1 sync,\r\n                                                 *   False - disable hardware 1 sync */\r\n    bool hardwareSync2;                         /*!< True - enable hardware 2 sync,\r\n                                                 *   False - disable hardware 2 sync */\r\n    bool maxLoadingPoint;                       /*!< True - enable maximum loading point,\r\n                                                 *   False - disable maximum loading point */\r\n    bool minLoadingPoint;                       /*!< True - enable minimum loading point,\r\n                                                 *   False - disable minimum loading point */\r\n    ftm_reg_update_t inverterSync;              /*!< Configures INVCTRL sync */\r\n    ftm_reg_update_t outRegSync;                /*!< Configures SWOCTRL sync */\r\n    ftm_reg_update_t maskRegSync;               /*!< Configures OUTMASK sync */\r\n    ftm_reg_update_t initCounterSync;           /*!< Configures CNTIN sync */\r\n    bool autoClearTrigger;                      /*!< Available only for hardware trigger */\r\n    ftm_pwm_sync_mode_t syncPoint;              /*!< Configure synchronization method\r\n                                                 *   (waiting next loading point or immediate) */\r\n} ftm_pwm_sync_t;\r\n\r\n/*!\r\n * @brief Configuration structure that the user needs to set\r\n *\r\n * Implements : ftm_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    ftm_pwm_sync_t syncMethod;              /*!< Register sync options available in the\r\n                                             *   ftm_sync_method_t enumeration  */\r\n    ftm_config_mode_t ftmMode;              /*!< Mode of operation for FTM */\r\n    ftm_clock_ps_t ftmPrescaler;            /*!< Register pre-scaler options available in the\r\n                                             *   ftm_clock_ps_t enumeration  */\r\n    ftm_clock_source_t ftmClockSource;      /*!< Select clock source for FTM */\r\n    ftm_bdm_mode_t BDMMode;                 /*!< Select FTM behavior in BDM mode */\r\n    bool isTofIsrEnabled;                   /*!< true: enable interrupt,\r\n                                             *   false: write interrupt is disabled */\r\n    bool enableInitializationTrigger;       /*!< true: enable the generation of initialization trigger\r\n                                             *   false: disable the generation of initialization trigger */\r\n} ftm_user_config_t;\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n/*! @brief Pointer to runtime state structure. */\r\nextern ftm_state_t * ftmStatePtr[FTM_INSTANCE_COUNT];\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Sets the filter Pre-scaler divider.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] filterPrescale The FTM peripheral clock pre-scale divider\r\n *\r\n * Implements : FTM_DRV_SetClockFilterPs_Activity\r\n */\r\nstatic inline void FTM_DRV_SetClockFilterPs(FTM_Type * const ftmBase,\r\n                                            uint8_t filterPrescale)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_FLTPS_MASK, FTM_SC_FLTPS(filterPrescale));\r\n}\r\n\r\n/*!\r\n * @brief Reads the FTM filter clock divider.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The FTM filter clock pre-scale divider\r\n *\r\n * Implements : FTM_DRV_GetClockFilterPs_Activity\r\n */\r\nstatic inline uint8_t FTM_DRV_GetClockFilterPs(const FTM_Type * ftmBase)\r\n{\r\n    return (uint8_t)((((ftmBase)->SC) & FTM_SC_FLTPS_MASK) >> FTM_SC_FLTPS_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Returns the FTM peripheral current counter value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The current FTM timer counter value\r\n *\r\n * Implements : FTM_DRV_GetCounter_Activity\r\n */\r\nstatic inline uint16_t FTM_DRV_GetCounter(const FTM_Type * ftmBase)\r\n{\r\n    return (uint16_t)((((ftmBase)->CNT) & FTM_CNT_COUNT_MASK) >> FTM_CNT_COUNT_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Returns the FTM peripheral counter modulo value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return FTM timer modulo value\r\n *\r\n * Implements : FTM_DRV_GetMod_Activity\r\n */\r\nstatic inline uint16_t FTM_DRV_GetMod(const FTM_Type * ftmBase)\r\n{\r\n    return (uint16_t)((((ftmBase)->MOD) & FTM_MOD_MOD_MASK) >> FTM_MOD_MOD_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Returns the FTM peripheral counter initial value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return FTM timer counter initial value\r\n *\r\n * Implements : FTM_DRV_GetCounterInitVal_Activity\r\n */\r\nstatic inline uint16_t FTM_DRV_GetCounterInitVal(const FTM_Type * ftmBase)\r\n{\r\n    return (uint16_t)((((ftmBase)->CNTIN) & FTM_CNTIN_INIT_MASK) >> FTM_CNTIN_INIT_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears the content of Channel (n) Status And Control.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel  The FTM peripheral channel number\r\n *\r\n * Implements : FTM_DRV_ClearChSC_Activity\r\n */\r\nstatic inline void FTM_DRV_ClearChSC(FTM_Type * const ftmBase,\r\n                                     uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    ((ftmBase)->CONTROLS[channel].CnSC) = 0U;\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->CONTROLS[channel].CnSC;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM peripheral timer channel edge level.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n *\r\n * @return The ELSnB:ELSnA mode value, will be 00, 01, 10, 11\r\n *\r\n * Implements : FTM_DRV_GetChnEdgeLevel_Activity\r\n */\r\nstatic inline uint8_t FTM_DRV_GetChnEdgeLevel(const FTM_Type * ftmBase,\r\n                                              uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    uint8_t retValue;\r\n\r\n    retValue = (uint8_t)((((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_ELSA_MASK) >> FTM_CnSC_ELSA_SHIFT);\r\n\r\n    retValue |= (uint8_t)(((((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_ELSB_MASK) >> FTM_CnSC_ELSB_SHIFT) << 1U);\r\n\r\n    return retValue;\r\n}\r\n\r\n/*!\r\n * @brief Configure the feature of FTM counter reset by the selected input capture event.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] enable Enable the FTM counter reset\r\n *                   - true : FTM counter is reset\r\n *                   - false: FTM counter is not reset\r\n *\r\n * Implements : FTM_DRV_SetChnIcrstCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetChnIcrstCmd(FTM_Type * const ftmBase,\r\n                                          uint8_t channel,\r\n                                          bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    /* Write ICRST bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_ICRST_MASK, FTM_CnSC_ICRST(enable));\r\n}\r\n\r\n/*!\r\n * @brief Returns whether the FTM FTM counter is reset.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @return State of the FTM peripheral timer channel ICRST\r\n *         - true : Enabled the FTM counter reset\r\n *         - false: Disabled the FTM counter reset\r\n *\r\n * Implements : FTM_DRV_IsChnIcrst_Activity\r\n */\r\nstatic inline bool FTM_DRV_IsChnIcrst(const FTM_Type * ftmBase,\r\n                                      uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_ICRST_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer channel DMA.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] enable Enable DMA transfers for the channel\r\n *                   - true : Enabled DMA transfers\r\n *                   - false: Disabled DMA transfers\r\n *\r\n * Implements : FTM_DRV_SetChnDmaCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetChnDmaCmd(FTM_Type * const ftmBase,\r\n                                        uint8_t channel,\r\n                                        bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    /* Write DMA bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_DMA_MASK, FTM_CnSC_DMA(enable));\r\n}\r\n\r\n/*!\r\n * @brief Returns whether the FTM peripheral timer channel DMA is enabled.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @return State of the FTM peripheral timer channel DMA\r\n *         - true : Enabled DMA transfers\r\n *         - false: Disabled DMA transfers\r\n *\r\n * Implements : FTM_DRV_IsChnDma_Activity\r\n */\r\nstatic inline bool FTM_DRV_IsChnDma(const FTM_Type * ftmBase,\r\n                                    uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_DMA_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the trigger generation on FTM channel outputs.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] enable Trigger mode control\r\n *                   - false : Enable PWM output without generating a pulse\r\n *                   - true  : Disable a trigger generation on channel output\r\n *\r\n * Implements : FTM_DRV_SetTrigModeControlCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetTrigModeControlCmd(FTM_Type * const ftmBase,\r\n                                                 uint8_t channel,\r\n                                                 bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    /* Write TRIGMODE bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_TRIGMODE_MASK, FTM_CnSC_TRIGMODE((enable)));\r\n}\r\n\r\n/*!\r\n * @brief Returns whether the trigger mode is enabled.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @return State of the channel outputs\r\n *         - true : Enabled a trigger generation on channel output\r\n *         - false: PWM outputs without generating a pulse\r\n *\r\n * Implements : FTM_DRV_GetTriggerControled_Activity\r\n */\r\nstatic inline bool FTM_DRV_GetTriggerControled(const FTM_Type * ftmBase,\r\n                                               uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_TRIGMODE_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Get the state of channel input.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @return State of the channel inputs\r\n *         - true : The channel input is one\r\n *         - false: The channel input is zero\r\n *\r\n * Implements : FTM_DRV_GetChInputState_Activity\r\n */\r\nstatic inline bool FTM_DRV_GetChInputState(const FTM_Type * ftmBase,\r\n                                           uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_CHIS_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Get the value of channel output.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @return Value of the channel outputs\r\n *         - true : The channel output is one\r\n *         - false: The channel output is zero\r\n *\r\n * Implements : FTM_DRV_GetChOutputValue_Activity\r\n */\r\nstatic inline bool FTM_DRV_GetChOutputValue(const FTM_Type * ftmBase,\r\n                                            uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_CHOV_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM peripheral timer channel counter value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n *\r\n * @return Channel counter value\r\n *\r\n * Implements : FTM_DRV_GetChnCountVal_Activity\r\n */\r\nstatic inline uint16_t FTM_DRV_GetChnCountVal(const FTM_Type * ftmBase,\r\n                                              uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (uint16_t)((ftmBase)->CONTROLS[channel].CnV);\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM peripheral timer  channel event status.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n *\r\n * @return Channel event status\r\n *         - true  : A channel event has occurred\r\n *         - false : No channel event has occurred\r\n *\r\n * Implements : FTM_DRV_GetChnEventStatus_Activity\r\n */\r\nstatic inline bool FTM_DRV_GetChnEventStatus(const FTM_Type * ftmBase,\r\n                                             uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->STATUS) & (1UL << channel)) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM peripheral timer status info for all channels.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return Channel event status value\r\n *\r\n * Implements : FTM_DRV_GetEventStatus_Activity\r\n */\r\nstatic inline uint32_t FTM_DRV_GetEventStatus(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase)->STATUS) & (0xFFU);\r\n}\r\n\r\n/*!\r\n * @brief Clears the FTM peripheral timer all channel event status.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n *\r\n * Implements : FTM_DRV_ClearChnEventStatus_Activity\r\n */\r\nstatic inline void FTM_DRV_ClearChnEventStatus(FTM_Type * const ftmBase,\r\n                                               uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    ((ftmBase)->STATUS) &= (~(1UL << channel));\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->STATUS;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel output mask.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] mask Value to set Output Mask\r\n *                 - true : Channel output is masked\r\n *                 - false: Channel output is not masked\r\n *\r\n * Implements : FTM_DRV_SetChnOutputMask_Activity\r\n */\r\nstatic inline void FTM_DRV_SetChnOutputMask(FTM_Type * const ftmBase,\r\n                                            uint8_t channel,\r\n                                            bool mask)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if (mask)\r\n    {\r\n        ((ftmBase)->OUTMASK) |= (1UL << channel);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->OUTMASK) &= ~(1UL << channel);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel output initial state 0 or 1.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] state Initial state for channels output\r\n *                  - true : The initialization value is 1\r\n *                  - false: The initialization value is 0\r\n *\r\n * Implements : FTM_DRV_SetChnOutputInitStateCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetChnOutputInitStateCmd(FTM_Type * const ftmBase,\r\n                                                    uint8_t channel,\r\n                                                    bool state)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if (state)\r\n    {\r\n        ((ftmBase)->OUTINIT) |= (1UL << channel);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->OUTINIT) &= ~(1UL << channel);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Disables the FTM peripheral timer fault interrupt.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * Implements : FTM_DRV_DisableFaultInt_Activity\r\n */\r\nstatic inline void FTM_DRV_DisableFaultInt(FTM_Type * const ftmBase)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_FAULTIE_MASK, FTM_MODE_FAULTIE(0U));\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer capture test mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable Capture Test Mode Enable\r\n *            - true : Capture test mode is enabled\r\n *            - false: Capture test mode is disabled\r\n *\r\n * Implements : FTM_DRV_SetCaptureTestCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetCaptureTestCmd(FTM_Type * const ftmBase,\r\n                                             bool enable)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_CAPTEST_MASK, FTM_MODE_CAPTEST(enable));\r\n}\r\n\r\n/*!\r\n * @brief Get status of the FTMEN bit in the FTM_MODE register.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @return the FTM Enable status\r\n *         - true : TPM compatibility. Free running counter and synchronization compatible with TPM\r\n *         - false: Free running counter and synchronization are different from TPM behavior\r\n *\r\n * Implements : FTM_DRV_IsFtmEnable_Activity\r\n */\r\nstatic inline bool FTM_DRV_IsFtmEnable(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->MODE & FTM_MODE_FTMEN_MASK) >> FTM_MODE_FTMEN_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Determines if the FTM counter is re-initialized when the selected trigger for\r\n * synchronization is detected.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable FTM counter re-initialization selection\r\n *                   - true : To update FTM counter when triggered\r\n *                   - false: To count normally\r\n *\r\n * Implements : FTM_DRV_SetCountReinitSyncCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetCountReinitSyncCmd(FTM_Type * const ftmBase,\r\n                                                 bool enable)\r\n{\r\n    FTM_RMW_SYNC(ftmBase, FTM_SYNC_REINIT_MASK, FTM_SYNC_REINIT(enable));\r\n}\r\n\r\n/*!\r\n * @brief Checks whether the write protection is enabled.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return Write-protection status\r\n *         - true : If enabled\r\n *         - false: If not\r\n *\r\n * Implements : FTM_DRV_IsWriteProtectionEnabled_Activity\r\n */\r\nstatic inline bool FTM_DRV_IsWriteProtectionEnabled(const FTM_Type * ftmBase)\r\n{\r\n    return (ftmBase->FMS & FTM_FMS_WPEN_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Checks whether the logic OR of the fault inputs is enabled.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return the enabled fault inputs status\r\n *         - true : The logic OR of the enabled fault inputs is 1\r\n *         - false: The logic OR of the enabled fault inputs is 0\r\n *\r\n * Implements : FTM_DRV_IsFaultInputEnabled_Activity\r\n */\r\nstatic inline bool FTM_DRV_IsFaultInputEnabled(const FTM_Type * ftmBase)\r\n{\r\n    return (ftmBase->FMS & FTM_FMS_FAULTIN_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Checks whether a fault condition is detected at the fault input.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel\r\n *\r\n * @return the fault condition status\r\n *         - true : A fault condition was detected at the fault input\r\n *         - false: No fault condition was detected at the fault input\r\n *\r\n * Implements : FTM_DRV_IsFaultFlagDetected_Activity\r\n */\r\nstatic inline bool FTM_DRV_IsFaultFlagDetected(const FTM_Type * ftmBase,\r\n                                               uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < CHAN4_IDX);\r\n\r\n    return (ftmBase->FMS & (FTM_FMS_FAULTF0_MASK << channel)) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Clear a fault condition is detected at the fault input.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel\r\n *\r\n * Implements : FTM_DRV_ClearFaultFlagDetected_Activity\r\n */\r\nstatic inline void FTM_DRV_ClearFaultFlagDetected(FTM_Type * const ftmBase,\r\n                                                  uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < CHAN4_IDX);\r\n\r\n    ((ftmBase)->FMS) &= (~(1UL << channel));\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->FMS;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the channel invert for a channel pair.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel invert for a channel pair\r\n *                   - true : To enable channel inverting\r\n *                   - false: To disable channel inversion\r\n *\r\n * Implements : FTM_DRV_SetDualChnInvertCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetDualChnInvertCmd(FTM_Type * const ftmBase,\r\n                                               uint8_t chnlPairNum,\r\n                                               bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->INVCTRL) |=  (1UL << chnlPairNum);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->INVCTRL) &=  ~(1UL << chnlPairNum);\r\n    }\r\n}\r\n\r\n/*FTM software output control*/\r\n/*!\r\n * @brief Enables or disables the channel software output control.\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel Channel to be enabled or disabled\r\n * @param[in] enable State of channel software output control\r\n *                   - true : To enable the channel output will be affected by software output control\r\n *                   - false: To disable the channel output is unaffected\r\n *\r\n * Implements : FTM_DRV_SetChnSoftwareCtrlCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetChnSoftwareCtrlCmd(FTM_Type * const ftmBase,\r\n                                                 uint8_t channel,\r\n                                                 bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->SWOCTRL) |=  (1UL << channel);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->SWOCTRL) &=  ~(1UL << channel);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Sets the channel software output control value.\r\n * Despite the odd channels are configured as HIGH/LOW, they will be inverted in the following\r\n * configuration: COMP bit = 1 and CH(n)OCV and CH(n+1)OCV are HIGH. Please check Software\r\n * output control behavior chapter from RM.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer.\r\n * @param[in] channel Channel to be configured\r\n * @param[in] enable State of software output control value\r\n *                   - true : to force 1 to the channel output\r\n *                   - false: to force 0 to the channel output\r\n *\r\n * Implements : FTM_DRV_SetChnSoftwareCtrlVal_Activity\r\n */\r\nstatic inline void FTM_DRV_SetChnSoftwareCtrlVal(FTM_Type * const ftmBase,\r\n                                                 uint8_t channel,\r\n                                                 bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if ((uint32_t)enable != (((uint32_t)ftmBase->POL >> (uint32_t)channel) & (uint32_t)1U))\r\n    {\r\n        ((ftmBase)->SWOCTRL) |=  (1UL << (channel + FTM_SWOCTRL_CH0OCV_SHIFT));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->SWOCTRL) &=  ~(1UL << (channel + FTM_SWOCTRL_CH0OCV_SHIFT));\r\n    }\r\n}\r\n\r\n/*FTM PWM load control*/\r\n/*!\r\n * @brief Set the global load mechanism.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * Implements : FTM_DRV_SetGlobalLoadCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetGlobalLoadCmd(FTM_Type * const ftmBase)\r\n{\r\n    ((ftmBase)->PWMLOAD) |=  (1UL << FTM_PWMLOAD_GLDOK_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Enable the global load.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of the global load mechanism\r\n *                   - true : Global Load OK enabled\r\n *                   - false: Global Load OK disabled\r\n *\r\n * Implements : FTM_DRV_SetLoadCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetLoadCmd(FTM_Type * const ftmBase,\r\n                                      bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->PWMLOAD) |=  (1UL << FTM_PWMLOAD_GLEN_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->PWMLOAD) &=  ~(1UL << FTM_PWMLOAD_GLEN_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enable the half cycle reload.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of the half cycle match as a reload opportunity\r\n *                   - true : Half cycle reload is enabled\r\n *                   - false: Half cycle reload is disabled\r\n *\r\n * Implements : FTM_DRV_SetHalfCycleCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetHalfCycleCmd(FTM_Type * const ftmBase,\r\n                                           bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->PWMLOAD) |=  (1UL << FTM_PWMLOAD_HCSEL_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->PWMLOAD) &=  ~(1UL << FTM_PWMLOAD_HCSEL_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the loading of MOD, CNTIN and CV with values of their write buffer.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of loading updated values\r\n *                   - true : To enable the loading of value of their buffer\r\n *                   - false: To disable the loading of value of their buffer\r\n *\r\n * Implements : FTM_DRV_SetPwmLoadCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetPwmLoadCmd(FTM_Type * const ftmBase,\r\n                                         bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->PWMLOAD) |=  (1UL << FTM_PWMLOAD_LDOK_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->PWMLOAD) &=  ~(1UL << FTM_PWMLOAD_LDOK_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Includes or excludes the channel in the matching process.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel Channel to be configured\r\n * @param[in] enable State of channel\r\n *                - true : means include the channel in the matching process\r\n *                - false: means do not include channel in the matching process\r\n *\r\n * Implements : FTM_DRV_SetPwmLoadChnSelCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetPwmLoadChnSelCmd(FTM_Type * const ftmBase,\r\n                                               uint8_t channel,\r\n                                               bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->PWMLOAD) |=  (1UL << channel);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->PWMLOAD) &=  ~(1UL << channel);\r\n    }\r\n}\r\n\r\n/*FTM configuration*/\r\n/*!\r\n * @brief Enables or disables the FTM initialization trigger on Reload Point.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable bit controls whether an initialization trigger is generated\r\n *                   - true : Trigger is generated when a reload point is reached\r\n *                   - false: Trigger is generated on counter wrap events\r\n *\r\n * Implements : FTM_DRV_SetInitTrigOnReloadCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetInitTrigOnReloadCmd(FTM_Type * const ftmBase,\r\n                                                  bool enable)\r\n{\r\n    ftmBase->CONF = (ftmBase->CONF & ~FTM_CONF_ITRIGR_MASK) | FTM_CONF_ITRIGR(enable);\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM global time base signal generation to other FTM's.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of global time base signal\r\n *                   - true : To enable the golobal time base generation to other FTM instances\r\n *                   - false: To disable the golobal time base generation to other FTM instances\r\n *\r\n * Implements : FTM_DRV_SetGlobalTimeBaseOutputCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetGlobalTimeBaseOutputCmd(FTM_Type * const ftmBase,\r\n                                                      bool enable)\r\n{\r\n    ftmBase->CONF = (ftmBase->CONF & ~FTM_CONF_GTBEOUT_MASK) | FTM_CONF_GTBEOUT(enable);\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM timer global time base.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of global time base\r\n *                   - true : To enable an external global time base signal\r\n *                   - false: To disable an external global time base signal\r\n *\r\n * Implements : FTM_DRV_SetGlobalTimeBaseCmd_Activity\r\n */\r\nstatic inline void FTM_DRV_SetGlobalTimeBaseCmd(FTM_Type * const ftmBase,\r\n                                                bool enable)\r\n{\r\n    ftmBase->CONF = (ftmBase->CONF & ~FTM_CONF_GTBEEN_MASK) | FTM_CONF_GTBEEN(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets the frequency of reload points\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] val Value of the TOF bit set frequency\r\n *\r\n * Implements : FTM_DRV_SetLoadFreq_Activity\r\n */\r\nstatic inline void FTM_DRV_SetLoadFreq(FTM_Type * const ftmBase,\r\n                                       uint8_t val)\r\n{\r\n    FTM_RMW_CONF(ftmBase, FTM_CONF_LDFQ_MASK, FTM_CONF_LDFQ(val));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM extended dead-time value for the channel pair.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channelPair The FTM peripheral channel pair (n)\r\n * @param[in] value The FTM peripheral extend pre-scale divider using the concatenation with the dead-time value\r\n *\r\n * Implements : FTM_DRV_SetExtPairDeadtimeValue_Activity\r\n */\r\nstatic inline void FTM_DRV_SetExtPairDeadtimeValue(FTM_Type * const ftmBase,\r\n                                                   uint8_t channelPair,\r\n                                                   uint8_t value)\r\n{\r\n    DEV_ASSERT(value < 16U);\r\n    DEV_ASSERT(channelPair < CHAN4_IDX);\r\n\r\n    switch (channelPair)\r\n    {\r\n        case CHAN0_IDX:\r\n            FTM_RMW_PAIR0DEADTIME(ftmBase, FTM_PAIR0DEADTIME_DTVALEX_MASK, FTM_PAIR0DEADTIME_DTVALEX(value));\r\n            break;\r\n        case CHAN1_IDX:\r\n            FTM_RMW_PAIR1DEADTIME(ftmBase, FTM_PAIR1DEADTIME_DTVALEX_MASK, FTM_PAIR1DEADTIME_DTVALEX(value));\r\n            break;\r\n        case CHAN2_IDX:\r\n            FTM_RMW_PAIR2DEADTIME(ftmBase, FTM_PAIR2DEADTIME_DTVALEX_MASK, FTM_PAIR2DEADTIME_DTVALEX(value));\r\n            break;\r\n        case CHAN3_IDX:\r\n            FTM_RMW_PAIR3DEADTIME(ftmBase, FTM_PAIR3DEADTIME_DTVALEX_MASK, FTM_PAIR3DEADTIME_DTVALEX(value));\r\n            break;\r\n        default:\r\n            /* Nothing to do */\r\n            break;\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM dead time divider for the channel pair.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channelPair The FTM peripheral channel pair (n)\r\n * @param[in] divider The FTM peripheral pre-scaler divider\r\n *                    - FTM_DEADTIME_DIVID_BY_1 : Divide by 1\r\n *                    - FTM_DEADTIME_DIVID_BY_4 : Divide by 4\r\n *                    - FTM_DEADTIME_DIVID_BY_16: Divide by 16\r\n *\r\n * Implements : FTM_DRV_SetPairDeadtimePrescale_Activity\r\n */\r\nstatic inline void FTM_DRV_SetPairDeadtimePrescale(FTM_Type * const ftmBase,\r\n                                                   uint8_t channelPair,\r\n                                                   ftm_deadtime_ps_t divider)\r\n{\r\n    DEV_ASSERT(channelPair < CHAN4_IDX);\r\n\r\n    switch (channelPair)\r\n    {\r\n        case CHAN0_IDX:\r\n            FTM_RMW_PAIR0DEADTIME(ftmBase, FTM_PAIR0DEADTIME_DTPS_MASK, FTM_PAIR0DEADTIME_DTPS((uint8_t)divider));\r\n            break;\r\n        case CHAN1_IDX:\r\n            FTM_RMW_PAIR1DEADTIME(ftmBase, FTM_PAIR1DEADTIME_DTPS_MASK, FTM_PAIR1DEADTIME_DTPS((uint8_t)divider));\r\n            break;\r\n        case CHAN2_IDX:\r\n            FTM_RMW_PAIR2DEADTIME(ftmBase, FTM_PAIR2DEADTIME_DTPS_MASK, FTM_PAIR2DEADTIME_DTPS((uint8_t)divider));\r\n            break;\r\n        case CHAN3_IDX:\r\n            FTM_RMW_PAIR3DEADTIME(ftmBase, FTM_PAIR3DEADTIME_DTPS_MASK, FTM_PAIR3DEADTIME_DTPS((uint8_t)divider));\r\n            break;\r\n        default:\r\n            /* Nothing to do */\r\n            break;\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM dead-time value for the channel pair.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channelPair The FTM peripheral channel pair (n)\r\n * @param[in] count The FTM peripheral selects the dead-time value\r\n *                  - 0U : no counts inserted\r\n *                  - 1U : 1 count is inserted\r\n *                  - 2U : 2 count is inserted\r\n *                  - ... up to a possible 63 counts\r\n *\r\n * Implements : FTM_DRV_SetPairDeadtimeCount_Activity\r\n */\r\nstatic inline void FTM_DRV_SetPairDeadtimeCount(FTM_Type * const ftmBase,\r\n                                                uint8_t channelPair,\r\n                                                uint8_t count)\r\n{\r\n    DEV_ASSERT(channelPair < CHAN4_IDX);\r\n    DEV_ASSERT(count < 64U);\r\n\r\n    switch (channelPair)\r\n    {\r\n        case CHAN0_IDX:\r\n            FTM_RMW_PAIR0DEADTIME(ftmBase, FTM_PAIR0DEADTIME_DTVAL_MASK, FTM_PAIR0DEADTIME_DTVAL(count));\r\n            break;\r\n        case CHAN1_IDX:\r\n            FTM_RMW_PAIR1DEADTIME(ftmBase, FTM_PAIR1DEADTIME_DTVAL_MASK, FTM_PAIR1DEADTIME_DTVAL(count));\r\n            break;\r\n        case CHAN2_IDX:\r\n            FTM_RMW_PAIR2DEADTIME(ftmBase, FTM_PAIR2DEADTIME_DTVAL_MASK, FTM_PAIR2DEADTIME_DTVAL(count));\r\n            break;\r\n        case CHAN3_IDX:\r\n            FTM_RMW_PAIR3DEADTIME(ftmBase, FTM_PAIR3DEADTIME_DTVAL_MASK, FTM_PAIR3DEADTIME_DTVAL(count));\r\n            break;\r\n        default:\r\n            /* Nothing to do */\r\n            break;\r\n    }\r\n}\r\n\r\n#if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n/*!\r\n * @brief Sets the mirror of the modulo integer value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value The value to be set to the timer modulo\r\n *\r\n * Implements : FTM_DRV_SetMirrorMod_Activity\r\n */\r\nstatic inline void FTM_DRV_SetMirrorMod(FTM_Type * const ftmBase,\r\n                                        uint16_t value)\r\n{\r\n    FTM_RMW_MOD_MIRROR(ftmBase, FTM_MOD_MIRROR_MOD_MASK, FTM_MOD_MIRROR_MOD(value));\r\n}\r\n\r\n/*!\r\n * @brief Returns the mirror of the FTM peripheral counter modulo value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return the mirror of the FTM timer modulo value\r\n *\r\n * Implements : FTM_DRV_GetMirrorMod_Activity\r\n */\r\nstatic inline uint16_t FTM_DRV_GetMirrorMod(const FTM_Type * ftmBase)\r\n{\r\n    return (uint16_t)((((ftmBase)->MOD_MIRROR) & FTM_MOD_MIRROR_MOD_MASK) >> FTM_MOD_MIRROR_MOD_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Returns The modulo fractional value is used in the PWM period dithering.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return the modulo fractional value\r\n *\r\n * Implements : FTM_DRV_GetModFracVal_Activity\r\n */\r\nstatic inline uint8_t FTM_DRV_GetModFracVal(const FTM_Type * ftmBase)\r\n{\r\n    return (uint8_t)((((ftmBase)->MOD_MIRROR) & FTM_MOD_MIRROR_FRACMOD_MASK) >> FTM_MOD_MIRROR_FRACMOD_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Sets the mirror of the channel (n) match integer value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel (n)\r\n * @param[in] value The value to be set to the mirror of the channel (n) match integer value\r\n *\r\n * Implements : FTM_DRV_SetMirrorChnMatchVal_Activity\r\n */\r\nstatic inline void FTM_DRV_SetMirrorChnMatchVal(FTM_Type * const ftmBase,\r\n                                                uint8_t channel,\r\n                                                uint16_t value)\r\n{\r\n    FTM_RMW_CnV_MIRROR(ftmBase, channel, FTM_CV_MIRROR_VAL_MASK, FTM_CV_MIRROR_VAL(value));\r\n}\r\n\r\n/*!\r\n * @brief Returns the mirror of the channel (n) match integer value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel (n)\r\n *\r\n * @return the mirror of the channel (n) match value\r\n *\r\n * Implements : FTM_DRV_GetMirrorChnMatchVal_Activity\r\n */\r\nstatic inline uint16_t FTM_DRV_GetMirrorChnMatchVal(const FTM_Type * ftmBase,\r\n                                                    uint8_t channel)\r\n{\r\n    return (uint16_t)((((ftmBase)->CV_MIRROR[channel]) & FTM_CV_MIRROR_VAL_MASK) >> FTM_CV_MIRROR_VAL_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Returns the channel (n) match fractional value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel (n)\r\n *\r\n * @return The channel (n) match fractional value is used in the PWM edge dithering\r\n *\r\n * Implements : FTM_DRV_GetChnMatchFracVal_Activity\r\n */\r\nstatic inline uint8_t FTM_DRV_GetChnMatchFracVal(const FTM_Type * ftmBase,\r\n                                                 uint8_t channel)\r\n{\r\n    return (uint8_t)((((ftmBase)->CV_MIRROR[channel]) & FTM_CV_MIRROR_FRACVAL_MASK) >> FTM_CV_MIRROR_FRACVAL_SHIFT);\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Initializes the FTM driver.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] info The FTM user configuration structure, see #ftm_user_config_t.\r\n * @param[out] state The FTM state structure of the driver.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_Init(uint32_t instance,\r\n                      const ftm_user_config_t * info,\r\n                      ftm_state_t * state);\r\n\r\n/*!\r\n * @brief Shuts down the FTM driver.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_Deinit(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function will get the default configuration values\r\n *        in the structure which is used as a common use-case.\r\n * @param[out] config Pointer to the structure in which the\r\n *                    configuration will be saved.\r\n * @return None\r\n */\r\nvoid FTM_DRV_GetDefaultConfig(ftm_user_config_t * const config);\r\n\r\n/*!\r\n * @brief This function will mask the output of the channels and at match events will be ignored\r\n * by the masked channels.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channelsMask The mask which will select which channels will ignore match events.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update PWM parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_MaskOutputChannels(uint32_t instance,\r\n                                    uint32_t channelsMask,\r\n                                    bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function configure the initial counter value. The counter will get this\r\n * value after an overflow event.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] counterValue Initial counter value.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\n\r\nstatus_t FTM_DRV_SetInitialCounterValue(uint32_t instance,\r\n                                        uint16_t counterValue,\r\n                                        bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function configure the value of the counter which will generates an reload point.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] reloadPoint Counter value which generates the reload point.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetHalfCycleReloadPoint(uint32_t instance,\r\n                                         uint16_t reloadPoint,\r\n                                         bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will force the output value of a channel to a specific value.\r\n * Before using this function it's mandatory to mask the match events using\r\n * FTM_DRV_MaskOutputChannels and to enable software output control using\r\n * FTM_DRV_SetSoftwareOutputChannelControl.\r\n * @Note: When the PWM signal is configured with LOW/HIGH polarity on the channel (n).\r\n * It should be set the safe state as LOW level state. However, We will have an issue\r\n * with COMP bit is zero and CH(n)OCV is HIGH and CH(n+1)OCV is LOW.in the independent channel configuration.\r\n * Code configuration:\r\n * {\r\n *      .polarity = FTM_POLARITY_HIGH,\r\n *      .safeState = FTM_POLARITY_LOW,\r\n *      .enableSecondChannelOutput = true,\r\n *      .secondChannelPolarity = FTM_MAIN_DUPLICATED,\r\n * }\r\n *\r\n * Workaround: Configure the safe state as HIGH level state. The expected output will be correctly controlling\r\n * Should change configuration as following:\r\n * {\r\n *      .polarity = FTM_POLARITY_HIGH,\r\n *      .safeState = FTM_HIGH_STATE,\r\n *      .enableSecondChannelOutput = true,\r\n *      .secondChannelPolarity = FTM_MAIN_DUPLICATED,\r\n * }\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channelsValues The values which will be software configured for channels.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update registers.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetSoftOutChnValue(uint32_t instance,\r\n                                    uint8_t channelsValues,\r\n                                    bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will configure which output channel can be software controlled.\r\n * Software output control forces the following values on channels (n) and (n+1) when the\r\n * COMP bit is zero and POL bit is zero.\r\n * CH(n)OC|CH(n+1)OC|CH(n)OCV|CH(n+1)OCV|Channel (n) Output      | Channel (n+1) Output\r\n *    0   |    0    |   X    |    X     | is not modified by SWOC| is not modified by SWOC\r\n *    1   |    1    |   0    |    0     | is forced to zero      | is forced to zero\r\n *    1   |    1    |   0    |    1     | is forced to zero      | is forced to one\r\n *    1   |    1    |   1    |    0     | is forced to one       | is forced to zero\r\n *    1   |    1    |   1    |    1     | is forced to one       | is forced to one\r\n *\r\n * Software output control forces the following values on channels (n) and (n+1) when the\r\n * COMP bit is one and POL bit is zero.\r\n * CH(n)OC|CH(n+1)OC|CH(n)OCV|CH(n+1)OCV|Channel (n) Output      | Channel (n+1) Output\r\n *    0   |    0    |   X    |    X     | is not modified by SWOC| is not modified by SWOC\r\n *    1   |    1    |   0    |    0     | is forced to zero      | is forced to zero\r\n *    1   |    1    |   0    |    1     | is forced to zero      | is forced to one\r\n *    1   |    1    |   1    |    0     | is forced to one       | is forced to zero\r\n *    1   |    1    |   1    |    1     | is forced to one       | is forced to zero\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channelsMask The mask which will configure the channels which can be software controlled.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update registers.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetSoftwareOutputChannelControl(uint32_t instance,\r\n                                                 uint8_t channelsMask,\r\n                                                 bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will control list of channels by software to force\r\n * the output to specified value.\r\n * Despite the odd channels are configured as HIGH/LOW, they will be inverted in the following\r\n * configuration: COMP bit = 1 and CH(n)OCV and CH(n+1)OCV are HIGH. Please check software\r\n * output control behavior chapter from reference manual.\r\n * @Note: When the PWM signal is configured with LOW/HIGH polarity on the channel (n).\r\n * It should be set the safe state as LOW level state. However, We will have an issue\r\n * with COMP bit is zero and CH(n)OCV is HIGH and CH(n+1)OCV is LOW.in the independent channel configuration.\r\n * Code configuration:\r\n * {\r\n *      .polarity = FTM_POLARITY_HIGH,\r\n *      .safeState = FTM_POLARITY_LOW,\r\n *      .enableSecondChannelOutput = true,\r\n *      .secondChannelPolarity = FTM_MAIN_DUPLICATED,\r\n * }\r\n *\r\n * Workaround: Configure the safe state as HIGH level state. The expected output will be correctly controlling\r\n * Should change configuration as following:\r\n * {\r\n *      .polarity = FTM_POLARITY_HIGH,\r\n *      .safeState = FTM_HIGH_STATE,\r\n *      .enableSecondChannelOutput = true,\r\n *      .secondChannelPolarity = FTM_MAIN_DUPLICATED,\r\n * }\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channelMask The mask which will configure the channels which can be software controlled.\r\n * @param [in] channelValueMask The values which will be software configured for channels.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update registers.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetAllChnSoftwareOutputControl(uint32_t instance,\r\n                                                uint8_t channelMask,\r\n                                                uint8_t channelValueMask,\r\n                                                bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will configure if the second channel of a pair will be inverted or not.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channelsPairMask The mask which will configure which channel pair will invert the second channel.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update registers.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetInvertingControl(uint32_t instance,\r\n                                     uint8_t channelsPairMask,\r\n                                     bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function configure the maximum counter value.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] counterValue Maximum counter value\r\n * @param [in] softwareTrigger If true a software trigger is generate to update parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetModuloCounterValue(uint32_t instance,\r\n                                       uint16_t counterValue,\r\n                                       bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will set the channel edge or level on the selection\r\n * of the channel mode.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel The channel number.\r\n * @param [in] level The level or edge selection for channel mode.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_SetOutputlevel(uint32_t instance,\r\n                                uint8_t channel,\r\n                                uint8_t level);\r\n\r\n/*!\r\n * @brief This function configures sync mechanism for some FTM registers (MOD, CNINT, HCR,\r\n *          CnV, OUTMASK, INVCTRL, SWOCTRL).\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] param The sync configuration structure.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_SetSync(uint32_t instance,\r\n                         const ftm_pwm_sync_t * param);\r\n\r\n/*!\r\n * @brief This function is used to configure a trigger source for FTM instance.\r\n * This allow a hardware trigger input which can be used in PWM synchronization.\r\n * Note that the hardware trigger is implemented only on trigger 1 for each instance.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_GenerateHardwareTrigger(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function will enable the generation a list of interrupts.\r\n * It includes the FTM overflow interrupts, the reload point interrupt, the fault\r\n * interrupt and the channel (n) interrupt.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] interruptMask The mask of interrupt. This is a logical OR of members of the\r\n *            enumeration ::ftm_interrupt_option_t\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_EnableInterrupts(uint32_t instance,\r\n                                  uint32_t interruptMask);\r\n\r\n/*!\r\n * @brief This function is used to disable some interrupts.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] interruptMask The mask of interrupt. This is a logical OR of members of the\r\n *            enumeration ::ftm_interrupt_option_t\r\n */\r\nvoid FTM_DRV_DisableInterrupts(uint32_t instance,\r\n                               uint32_t interruptMask);\r\n\r\n/*!\r\n * @brief This function will get the enabled FTM interrupts.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return The enabled interrupts. This is the logical OR of members of the\r\n *         enumeration ::ftm_interrupt_option_t\r\n */\r\nuint32_t FTM_DRV_GetEnabledInterrupts(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function will get the FTM status flags.\r\n * @Note: Regarding the duty cycle is 100% at the channel output, the match interrupt\r\n * has no event due to the C(n)V and C(n+1)V value are not between CNTIN value and MOD value.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return The status flags. This is the logical OR of members of the\r\n *         enumeration ::ftm_status_flag_t\r\n */\r\nuint32_t FTM_DRV_GetStatusFlags(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function is used to clear the FTM status flags.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] flagMask The status flags to clear. This is a logical OR of members of the\r\n *            enumeration ::ftm_status_flag_t\r\n */\r\nvoid FTM_DRV_ClearStatusFlags(uint32_t instance,\r\n                              uint32_t flagMask);\r\n\r\n/*!\r\n * @brief Retrieves the frequency of the clock source feeding the FTM counter.\r\n *\r\n * Function will return a 0 if no clock source is selected and the FTM counter is disabled\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @return The frequency of the clock source running the FTM counter (0 if counter is disabled)\r\n */\r\nuint32_t FTM_DRV_GetFrequency(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function is used to covert the given frequency to period in ticks\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] freqencyHz Frequency value in Hz.\r\n *\r\n * @return The value in ticks of the frequency\r\n */\r\nuint16_t FTM_DRV_ConvertFreqToPeriodTicks(uint32_t instance,\r\n                                          uint32_t freqencyHz);\r\n\r\n/*!\r\n * @brief This function will allow the FTM to restart the counter to\r\n * its initial counting value in the register.\r\n * Note that the configuration is set in the FTM_DRV_SetSync() function to make\r\n * sure that the FTM registers are updated by software trigger or hardware trigger.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] softwareTrigger Selects the software trigger or hardware trigger to update COUNT register.\r\n *            - true: A software trigger is generate to update register\r\n *            - false: A software trigger is not implemented and need to update later or\r\n *            select a hardware trigger and waiting an external trigger for updating register.\r\n */\r\nstatus_t FTM_DRV_CounterReset(uint32_t instance,\r\n                              bool softwareTrigger);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n/*! @}*/ /* End of addtogroup ftm_common */\r\n\r\n#endif /* FTM_COMMON_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_fault_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2018, NXP.\r\n * All rights reserved.\r\n */\r\n\r\n#include <stdint.h>\r\n#include \"ftm_fault_irq.h\"\r\n#include \"ftm_common.h\"\r\n\r\n/******************************************************************************\r\n * Variables\r\n *****************************************************************************/\r\n\r\n/*\r\n * @brief Function table to save GPI isr callback function pointers.\r\n *\r\n * Call GPI_DRV_InstallCallback to install isr callback functions.\r\n */\r\nstatic ftm_fault_isr_callback_t ftmFaultIsrCallbackTable[8][4] = { { 0 } };\r\n\r\n/*!\r\n * @addtogroup fault_irq\r\n * @{\r\n */\r\n\r\n/******************************************************************************\r\n * Code\r\n *****************************************************************************/\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n\r\n#ifdef FTM0\r\nvoid FTM0_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 4; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM0, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[0][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM0, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n#ifdef FTM1\r\nvoid FTM1_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 4; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM1, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[1][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM1, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n\r\n#ifdef FTM2\r\nvoid FTM2_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 4; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM2, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[2][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM2, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n#ifdef FTM3\r\nvoid FTM3_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 4; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM3, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[3][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM3, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n\r\n#ifdef FTM4\r\nvoid FTM4_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 2; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM4, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[4][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM4, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n#ifdef FTM5\r\nvoid FTM5_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 2; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM5, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[5][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM5, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n#ifdef FTM6\r\nvoid FTM6_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 2; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM6, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[6][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM6, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief gpio FTM Fault handler with the same name in startup code\r\n */\r\n#ifdef FTM7\r\nvoid FTM7_Fault_IRQHandler(void)\r\n{\r\n\tuint8_t i;\r\n    for (i = 0; i < 2; ++i)\r\n    {\r\n        if (FTM_DRV_IsFaultFlagDetected(FTM7, i) != 0)\r\n        {\r\n            (*ftmFaultIsrCallbackTable[7][i])();\r\n            FTM_DRV_ClearFaultFlagDetected(FTM7, i);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n/*FUNCTION*********************************************************************\r\n*\r\n* Function Name : FTM_Fault_InstallCallback\r\n* Description   : Install the user-defined callback in PWM Fault.\r\n* When an Fault interrupt request is served, the callback will be executed\r\n* inside the ISR.\r\n*\r\n*END*************************************************************************/\r\nvoid\r\nFTM_FAULT_DRV_InstallCallback(uint8_t ftmModule,\r\n                        uint8_t faultPin,\r\n                        ftm_fault_isr_callback_t userCallback)\r\n{\r\n\r\n    ftmFaultIsrCallbackTable[ftmModule][faultPin] = userCallback;\r\n}\r\n\r\n/******************************************************************************\r\n * EOF\r\n *****************************************************************************/\r\n"},{"name":"ftm_fault_irq.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2018, NXP.\r\n * All rights reserved.\r\n */\r\n\r\n#ifndef _FTM_FAULT_IRQ_H\r\n#define _FTM_FAULT_IRQ_H\r\n\r\n/*! @brief The FTM ISR callback function*/\r\ntypedef void (*ftm_fault_isr_callback_t)(void);\r\n\r\n/*FUNCTION*********************************************************************\r\n*\r\n* Function Name : FTM_DRV_InstallCallback\r\n* Description   : Install the user-defined callback in FTM PWM fault.\r\n* When an FTM PWM fault interrupt request is served, the callback will be executed\r\n* inside the ISR.\r\n*\r\n*END*************************************************************************/\r\nvoid\r\nFTM_FAULT_DRV_InstallCallback(uint8_t ftmModule,\r\n                        uint8_t faultPin,\r\n                        ftm_fault_isr_callback_t userCallback);\r\n\r\n#endif /* _FTM_IRQ_H  */\r\n"},{"name":"ftm_hw_access.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_hal.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n */\r\n\r\n#include \"ftm_hw_access.h\"\r\n\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitModule\r\n * Description   : Initializes the FTM. This function will enable the flexTimer module\r\n * and selects one pre-scale factor for the FTM clock source.\r\n *END**************************************************************************/\r\nvoid FTM_DRV_InitModule(FTM_Type * const ftmBase,\r\n                        ftm_clock_ps_t ftmClockPrescaler)\r\n{\r\n    /* Use FTM mode */\r\n    FTM_DRV_Enable(ftmBase, true);\r\n    FTM_DRV_SetClockPs(ftmBase, ftmClockPrescaler);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_Reset\r\n * Description   : Resets the FTM registers. All the register use in the driver should be\r\n * reset to default value of each register.\r\n *END**************************************************************************/\r\nvoid FTM_DRV_Reset(FTM_Type * const ftmBase)\r\n{\r\n    uint8_t chnIndex;\r\n\r\n    /* WPDIS is set when WPEN bit is read as a 1 and then 1 is written to WPDIS */\r\n    ((ftmBase)->FMS) &= 0U;\r\n    /* This is the reset value for MODE register. WPDIS bit is set to disable write protection */\r\n    ((ftmBase)->MODE) = 0x00000004U;\r\n    ((ftmBase)->SC) &= 0U;\r\n    ((ftmBase)->CNT) = 0U;\r\n    ((ftmBase)->MOD) = 0U;\r\n    ((ftmBase)->CNTIN) = 0U;\r\n    ((ftmBase)->STATUS) &= 0U;\r\n    ((ftmBase)->SYNC) = 0U;\r\n    ((ftmBase)->OUTINIT) = 0U;\r\n    ((ftmBase)->OUTMASK) = 0U;\r\n    ((ftmBase)->COMBINE) = 0U;\r\n    ((ftmBase)->DEADTIME) = 0U;\r\n    ((ftmBase)->EXTTRIG) &= 0U;\r\n    ((ftmBase)->POL) = 0U;\r\n    ((ftmBase)->FILTER) = 0U;\r\n    ((ftmBase)->FLTCTRL) = 0U;\r\n    ((ftmBase)->QDCTRL) = 0U;\r\n    ((ftmBase)->CONF) = 0U;\r\n    ((ftmBase)->FLTPOL) = 0U;\r\n    ((ftmBase)->SYNCONF) = 0U;\r\n    ((ftmBase)->INVCTRL) = 0U;\r\n    ((ftmBase)->SWOCTRL) = 0U;\r\n    ((ftmBase)->PWMLOAD) = 0U;\r\n    ((ftmBase)->HCR) = 0U;\r\n    #if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n        #if (FTM_INSTANCE_COUNT > 2U)\r\n        if ((ftmBase == FTM1) || (ftmBase == FTM2))\r\n        #else\r\n        if (ftmBase == FTM1)\r\n        #endif\r\n        {\r\n            ((ftmBase)->MOD_MIRROR) = 0U;\r\n        }\r\n    #endif\r\n    /* Set to reset value all CnV and CnSC registers */\r\n    for (chnIndex = 0; chnIndex < FEATURE_FTM_CHANNEL_COUNT; chnIndex++)\r\n    {\r\n        ((ftmBase)->CONTROLS[chnIndex].CnSC) &= 0U;\r\n        ((ftmBase)->CONTROLS[chnIndex].CnV) = 0U;\r\n        #if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n            #if (FTM_INSTANCE_COUNT > 2U)\r\n            if ((ftmBase == FTM1) || (ftmBase == FTM2))\r\n            #else\r\n            if (ftmBase == FTM1)\r\n            #endif\r\n            {\r\n                ((ftmBase)->CV_MIRROR[chnIndex]) = 0U;\r\n            }\r\n        #endif\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetChnTriggerCmd\r\n * Description   : Enables or disables the generation of the FTM peripheral timer channel trigger.\r\n * Enables or disables the generation of the FTM peripheral timer channel trigger when the\r\n * FTM counter is equal to its initial value.\r\n *END**************************************************************************/\r\nvoid FTM_DRV_SetChnTriggerCmd(FTM_Type * const ftmBase,\r\n                              uint8_t channel,\r\n                              bool enable)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    uint32_t value = 0U;\r\n\r\n    if (channel < 2U)\r\n    {\r\n        value = (uint32_t)FTM_EXTTRIG_CH0TRIG_MASK << (uint32_t)channel;\r\n    }\r\n    else if (channel < 6U)\r\n    {\r\n        value = (uint32_t)FTM_EXTTRIG_CH2TRIG_MASK << ((uint32_t)(channel) - 2U);\r\n    }\r\n    else\r\n    {\r\n        value = (uint32_t)FTM_EXTTRIG_CH6TRIG_MASK << ((uint32_t)(channel) - 6U);\r\n    }\r\n\r\n    if (true == enable)\r\n    {\r\n        ((ftmBase)->EXTTRIG) |= value;\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->EXTTRIG) &= ~value;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_SetChnInputCaptureFilter\r\n * Description   : Sets the FTM peripheral timer channel input capture filter value.\r\n *END**************************************************************************/\r\nvoid FTM_DRV_SetChnInputCaptureFilter(FTM_Type * const ftmBase,\r\n                                      uint8_t channel,\r\n                                      uint8_t value)\r\n{\r\n    DEV_ASSERT(CHAN4_IDX > channel);\r\n\r\n    switch (channel)\r\n    {\r\n        case CHAN0_IDX:\r\n            FTM_RMW_FILTER(ftmBase, FTM_FILTER_CH0FVAL_MASK, FTM_FILTER_CH0FVAL(value));\r\n            break;\r\n        case CHAN1_IDX:\r\n            FTM_RMW_FILTER(ftmBase, FTM_FILTER_CH1FVAL_MASK, FTM_FILTER_CH1FVAL(value));\r\n            break;\r\n        case CHAN2_IDX:\r\n            FTM_RMW_FILTER(ftmBase, FTM_FILTER_CH2FVAL_MASK, FTM_FILTER_CH2FVAL(value));\r\n            break;\r\n        case CHAN3_IDX:\r\n            FTM_RMW_FILTER(ftmBase, FTM_FILTER_CH3FVAL_MASK, FTM_FILTER_CH3FVAL(value));\r\n            break;\r\n        default:\r\n            /* Nothing to do */\r\n            break;\r\n    }\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macros defined are used to define features for each driver, so this might be reported\r\n * when the analysis is made only on one driver.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro defined.\r\n * This macro is needed in creating a common name for any IP.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from\r\n * 'essentially Boolean' type to 'essentially unsigned'.This is required by the\r\n * conversion of a bit-field of a bool type into a bit-field of a register type.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.7, Composite expression with smaller\r\n * essential type than other operand.\r\n * The expression is safe as the baud rate calculation algorithm cannot overflow\r\n * the result.\r\n */\r\n\r\n#ifndef FTM_HW_ACCESS_H\r\n#define FTM_HW_ACCESS_H\r\n\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n#include \"status.h\"\r\n#include \"device_registers.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"clock_manager.h\"\r\n#include \"ftm_common.h\"\r\n\r\n\r\n/*!\r\n * @defgroup ftm_hw_access FTM HW ACCESS\r\n * @brief FlexTimer Module Hardware Abstraction Level.\r\n * FTM HW ACCESS provides low level APIs for reading and writing to all hardware features\r\n * of the FlexTimer module.\r\n * @{\r\n */\r\n\r\n/*\r\n * S32K14x FTM\r\n *\r\n * FlexTimer Module\r\n *\r\n * Registers defined in this header file:\r\n * - FTM_SC - Status And Control\r\n * - FTM_CNT - Counter\r\n * - FTM_MOD - Modulo\r\n * - FTM_C0SC - Channel (n) Status And Control\r\n * - FTM_C0V - Channel (n) Value\r\n * - FTM_C1SC - Channel (n) Status And Control\r\n * - FTM_C1V - Channel (n) Value\r\n * - FTM_C2SC - Channel (n) Status And Control\r\n * - FTM_C2V - Channel (n) Value\r\n * - FTM_C3SC - Channel (n) Status And Control\r\n * - FTM_C3V - Channel (n) Value\r\n * - FTM_C4SC - Channel (n) Status And Control\r\n * - FTM_C4V - Channel (n) Value\r\n * - FTM_C5SC - Channel (n) Status And Control\r\n * - FTM_C5V - Channel (n) Value\r\n * - FTM_C6SC - Channel (n) Status And Control\r\n * - FTM_C6V - Channel (n) Value\r\n * - FTM_C7SC - Channel (n) Status And Control\r\n * - FTM_C7V - Channel (n) Value\r\n * - FTM_CNTIN - Counter Initial Value\r\n * - FTM_STATUS - Capture And Compare Status\r\n * - FTM_MODE - Features Mode Selection\r\n * - FTM_SYNC - Synchronization\r\n * - FTM_OUTINIT - Initial State For Channels Output\r\n * - FTM_OUTMASK - Output Mask\r\n * - FTM_COMBINE - Function For Linked Channels\r\n * - FTM_DEADTIME - Dead-time Insertion Control\r\n * - FTM_EXTTRIG - FTM External Trigger\r\n * - FTM_POL - Channels Polarity\r\n * - FTM_FMS - Fault Mode Status\r\n * - FTM_FILTER - Input Capture Filter Control\r\n * - FTM_FLTCTRL - Fault Control\r\n * - FTM_QDCTRL - Quadrature Decoder Control And Status\r\n * - FTM_CONF - Configuration\r\n * - FTM_FLTPOL - FTM Fault Input Polarity\r\n * - FTM_SYNCONF - Synchronization Configuration\r\n * - FTM_INVCTRL - FTM Inverting Control\r\n * - FTM_SWOCTRL - FTM Software Output Control\r\n * - FTM_PWMLOAD - FTM PWM Load\r\n * - FTM_HCR - Half Cycle Register\r\n */\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Sets the value for the half cycle reload register.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value The 16 bit counter value\r\n */\r\nstatic inline void FTM_DRV_SetHalfCycleValue(FTM_Type * const ftmBase,\r\n                                             uint16_t value)\r\n{\r\n    ((ftmBase)->HCR) = value;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM clock source.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] clock The FTM peripheral clock selection\r\n *            - 00: No clock\r\n *            - 01: system clock\r\n *            - 10: fixed clock\r\n *            - 11: External clock\r\n */\r\nstatic inline void FTM_DRV_SetClockSource(FTM_Type * const ftmBase,\r\n                                          ftm_clock_source_t clock)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_CLKS_MASK, FTM_SC_CLKS(clock));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM clock divider.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] ps The FTM peripheral clock pre-scale divider\r\n */\r\nstatic inline void FTM_DRV_SetClockPs(FTM_Type * const ftmBase,\r\n                                      ftm_clock_ps_t ps)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_PS_MASK, FTM_SC_PS(ps));\r\n}\r\n\r\n/*!\r\n * @brief Reads the FTM clock divider.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The FTM clock pre-scale divider\r\n */\r\nstatic inline uint8_t FTM_DRV_GetClockPs(const FTM_Type * ftmBase)\r\n{\r\n    return (uint8_t)((((ftmBase)->SC) & FTM_SC_PS_MASK) >> FTM_SC_PS_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief  Enables the FTM peripheral timer overflow interrupt.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] state - true : Overflow interrupt enabled\r\n *                  - false: Overflow interrupt disabled\r\n */\r\nstatic inline void FTM_DRV_SetTimerOverflowInt(FTM_Type * const ftmBase,\r\n                                               bool state)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_TOIE_MASK, FTM_SC_TOIE(state));\r\n}\r\n\r\n/*!\r\n * @brief Enable PWM channel Outputs.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM channel\r\n\r\n */\r\nstatic inline void FTM_DRV_EnablePwmChannelOutputs(FTM_Type * const ftmBase,\r\n                                                   uint8_t channel)\r\n{\r\n    FTM_RMW_SC(ftmBase, (1UL << (channel + FTM_FEATURE_OUTPUT_CHANNEL_OFFSET)), (1UL << (channel + FTM_FEATURE_OUTPUT_CHANNEL_OFFSET)));\r\n}\r\n\r\n/*!\r\n * @brief Disable PWM channel Outputs.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM channel\r\n */\r\nstatic inline void FTM_DRV_DisablePwmChannelOutputs(FTM_Type * const ftmBase,\r\n                                                    uint8_t channel)\r\n{\r\n    uint32_t regValue = ((ftmBase)->SC);\r\n    regValue = regValue & (~(1UL << (channel + FTM_FEATURE_OUTPUT_CHANNEL_OFFSET)));\r\n    ((ftmBase)->SC) = (regValue);\r\n}\r\n\r\n/*!\r\n * @brief Clears the timer overflow interrupt flag.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline void FTM_DRV_ClearTimerOverflow(FTM_Type * const ftmBase)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_TOF_MASK, FTM_SC_TOF(0U));\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->SC;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Reads the bit that controls enabling the FTM timer overflow interrupt.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return State of Timer Overflow Interrupt\r\n *         - true : Overflow interrupt is enabled\r\n *         - false: Overflow interrupt is disabled\r\n */\r\nstatic inline bool FTM_DRV_IsOverflowIntEnabled(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->SC & FTM_SC_TOIE_MASK) >> FTM_SC_TOIE_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Returns the FTM peripheral timer overflow interrupt flag.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return State of Timer Overflow Flag\r\n *         - true : FTM counter has overflowed\r\n *         - false: FTM counter has not overflowed\r\n */\r\nstatic inline bool FTM_DRV_HasTimerOverflowed(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->SC & FTM_SC_TOF_MASK) >> FTM_SC_TOF_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM count direction bit.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode The Center-Aligned PWM selection\r\n *                 - 1U: Up counting mode\r\n *                 - 0U: Up down counting mode\r\n */\r\nstatic inline void FTM_DRV_SetCpwms(FTM_Type * const ftmBase,\r\n                                    bool mode)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(mode));\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM count direction bit.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The Center-Aligned PWM selection\r\n *         - 1U: Up counting mode\r\n *         - 0U: Up down counting mode\r\n */\r\nstatic inline bool FTM_DRV_GetCpwms(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->SC & FTM_SC_CPWMS_MASK) >> FTM_SC_CPWMS_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Set the FTM reload interrupt enable.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable - true : Reload interrupt is  enabled\r\n *                   - false: Reload interrupt is disabled\r\n */\r\nstatic inline void FTM_DRV_SetReIntEnabledCmd(FTM_Type * const ftmBase,\r\n                                              bool enable)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_RIE_MASK, FTM_SC_RIE(enable));\r\n}\r\n\r\n/*!\r\n * @brief Get the state whether the FTM counter reached a reload point.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return State of reload point\r\n *         - true : FTM counter reached a reload point\r\n *         - false: FTM counter did not reach a reload point\r\n */\r\nstatic inline bool FTM_DRV_GetReloadFlag(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->SC & FTM_SC_RF_MASK) >> FTM_SC_RF_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Clears the reload flag bit.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline void FTM_DRV_ClearReloadFlag(FTM_Type * const ftmBase)\r\n{\r\n    FTM_RMW_SC(ftmBase, FTM_SC_RF_MASK, FTM_SC_RF(0U));\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->SC;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Return true/false whether the reload interrupt was enabled or not\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline bool FTM_DRV_IsReloadIntEnabled(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->SC & FTM_SC_RIE_MASK) >> FTM_SC_RIE_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Reads the FTM clock source.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The FTM clock source selection\r\n *          - 00: No clock\r\n *          - 01: system clock\r\n *          - 10: fixed clock\r\n *          - 11: External clock\r\n */\r\nstatic inline uint8_t FTM_DRV_GetClockSource(const FTM_Type * ftmBase)\r\n{\r\n    return (uint8_t)((((ftmBase)->SC) & FTM_SC_CLKS_MASK) >> FTM_SC_CLKS_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral current counter value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value The FTM timer counter value to be set\r\n */\r\nstatic inline void FTM_DRV_SetCounter(FTM_Type * const ftmBase,\r\n                                      uint16_t value)\r\n{\r\n    FTM_RMW_CNT(ftmBase, FTM_CNT_COUNT_MASK, FTM_CNT_COUNT(value));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer modulo value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value The value to be set to the timer modulo\r\n */\r\nstatic inline void FTM_DRV_SetMod(FTM_Type * const ftmBase,\r\n                                  uint16_t value)\r\n{\r\n    FTM_RMW_MOD(ftmBase, FTM_MOD_MOD_MASK, FTM_MOD_MOD(value));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer counter initial value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value initial value to be set\r\n */\r\nstatic inline void FTM_DRV_SetCounterInitVal(FTM_Type * const ftmBase,\r\n                                             uint16_t value)\r\n{\r\n    FTM_RMW_CNTIN(ftmBase, FTM_CNTIN_INIT_MASK, FTM_CNTIN_INIT(value));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] selection The mode to be set valid value MSnB:MSnA :00, 01, 10, 11\r\n */\r\nstatic inline void FTM_DRV_SetChnMSnBAMode(FTM_Type * const ftmBase,\r\n                                           uint8_t channel,\r\n                                           uint8_t selection)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    /* write MSA bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_MSA_MASK, FTM_CnSC_MSA((uint32_t)selection & 0x01U));\r\n\r\n    /* write MSB bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_MSB_MASK, FTM_CnSC_MSB(((uint32_t)selection & 0x02U) >> 1U));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel edge level.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] level ELSnB:ELSnA :00, 01, 10, 11\r\n */\r\nstatic inline void FTM_DRV_SetChnEdgeLevel(FTM_Type * const ftmBase,\r\n                                           uint8_t channel,\r\n                                           uint8_t level)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    /* write ELSA bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_ELSA_MASK, FTM_CnSC_ELSA((uint32_t)level & 0x01U));\r\n\r\n    /* write ELSB bit */\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_ELSB_MASK, FTM_CnSC_ELSB(((uint32_t)level & 0x02U) >> 1U));\r\n}\r\n\r\n/*!\r\n * @brief Enables the FTM peripheral timer channel(n) interrupt.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n */\r\nstatic inline void FTM_DRV_EnableChnInt(FTM_Type * const ftmBase,\r\n                                        uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_CHIE_MASK, FTM_CnSC_CHIE(1U));\r\n}\r\n\r\n/*!\r\n * @brief Disables the FTM peripheral timer channel(n) interrupt.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n */\r\nstatic inline void FTM_DRV_DisableChnInt(FTM_Type * const ftmBase,\r\n                                         uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_CHIE_MASK, FTM_CnSC_CHIE(0U));\r\n}\r\n\r\n/*!\r\n * @brief Clear the channel flag by writing a 0 to the CHF bit.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n */\r\nstatic inline void FTM_DRV_ClearChnEventFlag(FTM_Type * const ftmBase,\r\n                                             uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_CHF_MASK, FTM_CnSC_CHF(0U));\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->CONTROLS[channel].CnSC;\r\n#endif\r\n}\r\n\r\n/*FTM channel control*/\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel counter value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] value Counter value to be set\r\n */\r\nstatic inline void FTM_DRV_SetChnCountVal(FTM_Type * const ftmBase,\r\n                                          uint8_t channel,\r\n                                          uint16_t value)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    ((ftmBase)->CONTROLS[channel].CnV) = value;\r\n}\r\n\r\n/*!\r\n * @brief Get FTM channel(n) interrupt enabled or not.\r\n * @param[in] ftmBase FTM module base address\r\n * @param[in] channel The FTM peripheral channel number\r\n */\r\nstatic inline bool FTM_DRV_IsChnIntEnabled(const FTM_Type * ftmBase,\r\n                                           uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_CHIE_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Returns whether any event for the FTM peripheral timer channel has occurred.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n *\r\n * @return State of channel flag\r\n *         - true : Event occurred\r\n *         - false: No event occurred.\r\n */\r\nstatic inline bool FTM_DRV_HasChnEventOccurred(const FTM_Type * ftmBase,\r\n                                               uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    return (((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_CHF_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM peripheral timer channel mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n *\r\n * @return The MSnB:MSnA mode value, will be 00, 01, 10, 11\r\n *\r\n */\r\nstatic inline uint8_t FTM_DRV_GetChnMode(const FTM_Type * ftmBase,\r\n                                         uint8_t channel)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    uint8_t retValue;\r\n\r\n    retValue = (uint8_t)((((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_MSA_MASK) >> FTM_CnSC_MSA_SHIFT);\r\n\r\n    retValue |= (uint8_t)(((((ftmBase)->CONTROLS[channel].CnSC) & FTM_CnSC_MSB_MASK) >> FTM_CnSC_MSB_SHIFT) << 1U);\r\n\r\n    return retValue;\r\n}\r\n\r\n/*!\r\n * @brief Writes the provided value to the OUTMASK register.\r\n *\r\n * This function will mask/unmask multiple channels.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] regVal Value to be written to the register\r\n */\r\nstatic inline void FTM_DRV_SetOutmaskReg(FTM_Type * const ftmBase,\r\n                                         uint32_t regVal)\r\n{\r\n    ((ftmBase)->OUTMASK) = regVal;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel output polarity.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] polarity The polarity to be set\r\n *            - true : The channel polarity is active low\r\n *            - false  : The channel polarity is active high\r\n */\r\nstatic inline void FTM_DRV_SetChnOutputPolarityCmd(FTM_Type * const ftmBase,\r\n                                                   uint8_t channel,\r\n                                                   bool polarity)\r\n{\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if (true != polarity)\r\n    {\r\n        ((ftmBase)->POL) &= ~(1UL << channel);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->POL) |= (1UL << channel);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel fault input polarity.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] fltChannel The FTM peripheral channel number\r\n * @param[in] polarity The polarity to be set\r\n *                - false : The fault input polarity is active high\r\n *                - true: The fault input polarity is active low\r\n */\r\nstatic inline void FTM_DRV_SetChnFaultInputPolarityCmd(FTM_Type * const ftmBase,\r\n                                                       uint8_t fltChannel,\r\n                                                       bool polarity)\r\n{\r\n    DEV_ASSERT(fltChannel < FTM_FEATURE_FAULT_CHANNELS);\r\n\r\n    if (true == polarity)\r\n    {\r\n        ((ftmBase)->FLTPOL) &= ~(1UL << fltChannel);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->FLTPOL) |= (1UL << fltChannel);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables/disables the FTM peripheral timer fault interrupt.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] state Timer fault interrupt state\r\n *            - true : Fault control interrupt is enable\r\n *            - false: Fault control interrupt is disabled\r\n */\r\nstatic inline void FTM_DRV_SetFaultInt(FTM_Type * const ftmBase,\r\n                                       bool state)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_FAULTIE_MASK, FTM_MODE_FAULTIE(state));\r\n}\r\n\r\n/*!\r\n * @brief Return true/false whether the Fault interrupt was enabled or not\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline bool FTM_DRV_IsFaultIntEnabled(const FTM_Type * ftmBase)\r\n{\r\n    return ((ftmBase->MODE & FTM_MODE_FAULTIE_MASK) >> FTM_MODE_FAULTIE_SHIFT) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Clears all fault interrupt flags that are active.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline void FTM_DRV_ClearFaultsIsr(FTM_Type * const ftmBase)\r\n{\r\n    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF0_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF0(0U) | FTM_FMS_FAULTF(0U));\r\n    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF1_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF1(0U) | FTM_FMS_FAULTF(0U));\r\n    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF2_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF2(0U) | FTM_FMS_FAULTF(0U));\r\n    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF3_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF3(0U) | FTM_FMS_FAULTF(0U));\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    ftmBase->FMS;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Defines the FTM fault control mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode Fault control mode value\r\n * - FTM_FAULT_CONTROL_DISABLED: Fault control disabled\r\n * - FTM_FAULT_CONTROL_MAN_EVEN: Fault control enabled for even channel (0, 2, 4, 6) and manual fault clearing.\r\n * - FTM_FAULT_CONTROL_MAN_ALL : Fault control enabled for all channels and manual fault clearing is enabled.\r\n * - FTM_FAULT_CONTROL_AUTO_ALL: Fault control enabled for all channels and automatic fault clearing is enabled.\r\n */\r\nstatic inline void FTM_DRV_SetFaultControlMode(FTM_Type * const ftmBase,\r\n                                               uint32_t mode)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_FAULTM_MASK, FTM_MODE_FAULTM(mode));\r\n}\r\n\r\n/*!\r\n * @brief Initializes the channels output.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable Initialize the channels output\r\n *                   - true : The channels output is initialized according to the state of OUTINIT reg\r\n *                   - false: No effect\r\n */\r\nstatic inline void FTM_DRV_SetInitChnOutputCmd(FTM_Type * const ftmBase,\r\n                                               bool enable)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_INIT_MASK, FTM_MODE_INIT(enable));\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM detected fault input.\r\n *\r\n * This function reads the status for all fault inputs\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The fault byte\r\n *         - 0 : No fault condition was detected.\r\n *         - 1 : A fault condition was detected.\r\n */\r\nstatic inline bool FTM_DRV_GetDetectedFaultInput(const FTM_Type * ftmBase)\r\n{\r\n    return (ftmBase->FMS & FTM_FMS_FAULTF_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM write protection.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable The FTM write protection selection\r\n *                   - true : Write-protection is enabled\r\n *                   - false: Write-protection is disabled\r\n */\r\nstatic inline void FTM_DRV_SetWriteProtectionCmd(FTM_Type * const ftmBase,\r\n                                                 bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ftmBase->FMS = (ftmBase->FMS & ~FTM_FMS_WPEN_MASK) | FTM_FMS_WPEN(1U);\r\n    }\r\n    else\r\n    {\r\n        ftmBase->MODE = (ftmBase->MODE & ~FTM_MODE_WPDIS_MASK) | FTM_MODE_WPDIS(1U);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables the FTM peripheral timer group.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable FTM mode selection\r\n *                   - true : All registers including FTM-specific registers are available\r\n *                   - false: Only the TPM-compatible registers are available\r\n */\r\nstatic inline void FTM_DRV_Enable(FTM_Type * const ftmBase,\r\n                                  bool enable)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_FTMEN_MASK, FTM_MODE_FTMEN(enable));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer sync mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable PWM synchronization mode\r\n *                   - false: No restriction both software and hardware triggers can be used\r\n *                   - true : Software trigger can only be used for MOD and CnV synchronization,\r\n *                            hardware trigger only for OUTMASK and FTM counter synchronization.\r\n */\r\nstatic inline void FTM_DRV_SetPwmSyncMode(FTM_Type * const ftmBase,\r\n                                          bool enable)\r\n{\r\n    FTM_RMW_MODE(ftmBase, FTM_MODE_PWMSYNC_MASK, FTM_MODE_PWMSYNC(enable));\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer software trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer.\r\n * @param[in] enable Software trigger selection\r\n *                   - true : Software trigger is selected\r\n *                   - false: Software trigger is not selected\r\n */\r\nstatic inline void FTM_DRV_SetSoftwareTriggerCmd(FTM_Type * const ftmBase,\r\n                                                 bool enable)\r\n{\r\n    FTM_RMW_SYNC(ftmBase, FTM_SYNC_SWSYNC_MASK, FTM_SYNC_SWSYNC(enable));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM hardware synchronization trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] trigger_num Number of trigger\r\n *                        - 0U: trigger 0\r\n *                        - 1U: trigger 1\r\n *                        - 2U: trigger 2\r\n * @param[in] enable State of trigger\r\n *                   - true : Enable hardware trigger from field trigger_num for PWM synchronization\r\n *                   - false: Disable hardware trigger from field trigger_num for PWM synchronization\r\n */\r\nstatic inline void FTM_DRV_SetHardwareSyncTriggerSrc(FTM_Type * const ftmBase,\r\n                                                     uint8_t trigger_num,\r\n                                                     bool enable)\r\n{\r\n    DEV_ASSERT(trigger_num < 3U);\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->SYNC) |= ((uint32_t)(FTM_SYNC_TRIG0_MASK) << trigger_num);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->SYNC) &= ~((uint32_t)(FTM_SYNC_TRIG0_MASK) << trigger_num);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Determines when the OUTMASK register is updated with the value of its buffer.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable Output Mask synchronization selection\r\n *                   - true : OUTMASK register is updated only by PWM synchronization\r\n *                   - false: OUTMASK register is updated in all rising edges of the system clock\r\n */\r\nstatic inline void FTM_DRV_SetOutmaskPwmSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                    bool enable)\r\n{\r\n    FTM_RMW_SYNC(ftmBase, FTM_SYNC_SYNCHOM_MASK, FTM_SYNC_SYNCHOM(enable));\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer maximum loading points.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable Maximum loading point selection\r\n *                   - true : To enable maximum loading point\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetMaxLoadingCmd(FTM_Type * const ftmBase,\r\n                                            bool enable)\r\n{\r\n    FTM_RMW_SYNC(ftmBase, FTM_SYNC_CNTMAX_MASK, FTM_SYNC_CNTMAX(enable));\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer minimum loading points.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable Minimum loading point selection\r\n *                   - true : To enable minimum loading point\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetMinLoadingCmd(FTM_Type * const ftmBase,\r\n                                            bool enable)\r\n{\r\n    FTM_RMW_SYNC(ftmBase, FTM_SYNC_CNTMIN_MASK, FTM_SYNC_CNTMIN(enable));\r\n}\r\n\r\n/*!\r\n * @brief Enables the FTM peripheral timer channel modified combine mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel pair outputs modified combine\r\n *                   - true : To enable modified combine\r\n *                   - false: To disable modified combine\r\n */\r\nstatic inline void FTM_DRV_SetDualChnMofCombineCmd(FTM_Type * const ftmBase,\r\n                                                   uint8_t chnlPairNum,\r\n                                                   bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= ((uint32_t)FTM_COMBINE_MCOMBINE0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~((uint32_t)FTM_COMBINE_MCOMBINE0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables the FTM peripheral timer channel pair fault control.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel pair fault control\r\n *                   - true : To enable fault control\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetDualChnFaultCmd(FTM_Type * const ftmBase,\r\n                                              uint8_t chnlPairNum,\r\n                                              bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= ((uint32_t)FTM_COMBINE_FAULTEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~((uint32_t)FTM_COMBINE_FAULTEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer channel pair counter PWM sync.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel pair counter PWM sync\r\n *                   - true : To enable PWM synchronization\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetDualChnPwmSyncCmd(FTM_Type * const ftmBase,\r\n                                                uint8_t chnlPairNum,\r\n                                                bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= ((uint32_t)FTM_COMBINE_SYNCEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~((uint32_t)FTM_COMBINE_SYNCEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables or disabled the FTM peripheral timer channel pair deadtime insertion.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel pair deadtime insertion\r\n *                   - true : To enable deadtime insertion\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetDualChnDeadtimeCmd(FTM_Type * const ftmBase,\r\n                                                 uint8_t chnlPairNum,\r\n                                                 bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= ((uint32_t)FTM_COMBINE_DTEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~((uint32_t)FTM_COMBINE_DTEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer channel dual edge capture.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel dual edge capture\r\n *                   - true : To enable dual edge capture mode\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetDualChnDecapCmd(FTM_Type * const ftmBase,\r\n                                              uint8_t chnlPairNum,\r\n                                              bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= ((uint32_t)FTM_COMBINE_DECAP0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~((uint32_t)FTM_COMBINE_DECAP0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables the FTM peripheral timer dual edge capture mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of dual edge capture mode\r\n *                   - true : To enable dual edge capture\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetDualEdgeCaptureCmd(FTM_Type * const ftmBase,\r\n                                                 uint8_t chnlPairNum,\r\n                                                 bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= ((uint32_t)FTM_COMBINE_DECAPEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~((uint32_t)FTM_COMBINE_DECAPEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables the FTM peripheral timer dual edge capture mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n *\r\n * @return Dual edge capture mode status\r\n *         - true : To enable dual edge capture\r\n *         - false: To disable\r\n */\r\nstatic inline bool FTM_DRV_GetDualEdgeCaptureBit(const FTM_Type * ftmBase,\r\n                                                 uint8_t chnlPairNum)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    return (((ftmBase)->COMBINE) & ((uint32_t)FTM_COMBINE_DECAPEN0_MASK << (chnlPairNum * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH))) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer channel pair output complement mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] polarity State of channel pair output complement mode\r\n *            - true : The channel (n+1) output is the complement of the channel (n) output\r\n *            - false: The channel (n+1) output is the same as the channel (n) output\r\n */\r\nstatic inline void FTM_DRV_SetDualChnCompCmd(FTM_Type * const ftmBase,\r\n                                             uint8_t chnlPairNum,\r\n                                             bool polarity)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (polarity == true)\r\n    {\r\n        ((ftmBase)->COMBINE) |= (FTM_COMBINE_COMP0_MASK << ((uint32_t)(chnlPairNum) * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~(FTM_COMBINE_COMP0_MASK << ((uint32_t)(chnlPairNum) * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the FTM peripheral timer channel pair output combine mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n * @param[in] enable State of channel pair output combine mode\r\n *                   - true : Channels pair are combined\r\n *                   - false: Channels pair are independent\r\n */\r\nstatic inline void FTM_DRV_SetDualChnCombineCmd(FTM_Type * const ftmBase,\r\n                                                uint8_t chnlPairNum,\r\n                                                bool enable)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->COMBINE) |= (FTM_COMBINE_COMBINE0_MASK << ((uint32_t)(chnlPairNum) * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->COMBINE) &= ~(FTM_COMBINE_COMBINE0_MASK << ((uint32_t)(chnlPairNum) * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Verify if an channels pair is used in combine mode or not.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n *\r\n * @return Channel pair output combine mode status\r\n *         - true : Channels pair are combined\r\n *         - false: Channels pair are independent\r\n */\r\nstatic inline bool FTM_DRV_GetDualChnCombineCmd(const FTM_Type * ftmBase,\r\n                                                uint8_t chnlPairNum)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    return (((ftmBase)->COMBINE) & (FTM_COMBINE_COMBINE0_MASK << ((uint32_t)(chnlPairNum) * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH))) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Verify if an channels pair is used in the modified combine mode or not.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] chnlPairNum The FTM peripheral channel pair number\r\n *\r\n * @return Channel pair output combine mode status\r\n *         - true : Channels pair are combined\r\n *         - false: Channels pair are independent\r\n */\r\nstatic inline bool FTM_DRV_GetDualChnMofCombineCmd(const FTM_Type * ftmBase,\r\n                                                   uint8_t chnlPairNum)\r\n{\r\n    DEV_ASSERT(chnlPairNum < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    return (((ftmBase)->COMBINE) & (FTM_COMBINE_MCOMBINE0_MASK << ((uint32_t)(chnlPairNum) * FTM_FEATURE_COMBINE_CHAN_CTRL_WIDTH))) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM extended dead-time value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value The FTM peripheral extend pre-scale divider\r\n */\r\nstatic inline void FTM_DRV_SetExtDeadtimeValue(FTM_Type * const ftmBase,\r\n                                               uint8_t value)\r\n{\r\n    DEV_ASSERT(value < 16U);\r\n\r\n    FTM_RMW_DEADTIME(ftmBase, FTM_DEADTIME_DTVALEX_MASK, FTM_DEADTIME_DTVALEX(value));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM dead time divider.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] divider The FTM peripheral pre-scaler divider\r\n *                    - FTM_DEADTIME_DIVID_BY_1 : Divide by 1\r\n *                    - FTM_DEADTIME_DIVID_BY_4 : Divide by 4\r\n *                    - FTM_DEADTIME_DIVID_BY_16: Divide by 16\r\n */\r\nstatic inline void FTM_DRV_SetDeadtimePrescale(FTM_Type * const ftmBase,\r\n                                               ftm_deadtime_ps_t divider)\r\n{\r\n    FTM_RMW_DEADTIME(ftmBase, FTM_DEADTIME_DTPS_MASK, FTM_DEADTIME_DTPS((uint8_t)divider));\r\n}\r\n\r\n/*!\r\n * @brief Sets the FTM deadtime value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] count The FTM peripheral pre-scaler divider\r\n *                  - 0U : no counts inserted\r\n *                  - 1U : 1 count is inserted\r\n *                  - 2U : 2 count is inserted\r\n *                  - ... up to a possible 63 counts\r\n */\r\nstatic inline void FTM_DRV_SetDeadtimeCount(FTM_Type * const ftmBase,\r\n                                            uint8_t count)\r\n{\r\n    DEV_ASSERT(count < 64U);\r\n\r\n    FTM_RMW_DEADTIME(ftmBase, FTM_DEADTIME_DTVAL_MASK, FTM_DEADTIME_DTVAL(count));\r\n}\r\n\r\n/*FTM external trigger */\r\n/*!\r\n * @brief Enables or disables the generation of the trigger when the FTM counter is equal\r\n * to the CNTIN register.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of initialization trigger\r\n *                   - true : To enable\r\n *                   - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetInitTriggerCmd(FTM_Type * const ftmBase,\r\n                                             bool enable)\r\n{\r\n    ftmBase->EXTTRIG = (ftmBase->EXTTRIG & ~FTM_EXTTRIG_INITTRIGEN_MASK) | FTM_EXTTRIG_INITTRIGEN(enable);\r\n}\r\n\r\n/*!\r\n * @brief Checks whether any channel trigger event has occurred.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @return Channel trigger status\r\n *         - true : If there is a channel trigger event\r\n *         - false: If not.\r\n */\r\nstatic inline bool FTM_DRV_IsChnTriggerGenerated(const FTM_Type * ftmBase)\r\n{\r\n    return (ftmBase->EXTTRIG & FTM_EXTTRIG_TRIGF_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Clear the channel trigger flag.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline void FTM_DRV_ClearChnTriggerFlag(FTM_Type * const ftmBase)\r\n{\r\n    FTM_RMW_EXTTRIG_REG(ftmBase, FTM_EXTTRIG_TRIGF_MASK, FTM_EXTTRIG_TRIGF(0UL));\r\n}\r\n\r\n/* Quadrature decoder control */\r\n/*!\r\n * @brief Enables the channel quadrature decoder.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of channel quadrature decoder\r\n *                  - true : To enable\r\n *                  - false: To disable\r\n */\r\nstatic inline void FTM_DRV_SetQuadDecoderCmd(FTM_Type * const ftmBase,\r\n                                             bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->QDCTRL) |= (1UL << FTM_QDCTRL_QUADEN_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->QDCTRL) &= ~(1UL << FTM_QDCTRL_QUADEN_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the phase A input filter.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of phase A input filter\r\n *                   - true : Enables the phase input filter\r\n *                   - false: Disables the filter\r\n */\r\nstatic inline void FTM_DRV_SetQuadPhaseAFilterCmd(FTM_Type * const ftmBase,\r\n                                                  bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->QDCTRL) |= (1UL << FTM_QDCTRL_PHAFLTREN_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->QDCTRL) &= ~(1UL << FTM_QDCTRL_PHAFLTREN_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Selects polarity for the quadrature decode phase A input.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode Phase A input polarity selection\r\n *                - 0U: Normal polarity\r\n *                - 1U: Inverted polarity\r\n */\r\nstatic inline void FTM_DRV_SetQuadPhaseAPolarity(FTM_Type * const ftmBase,\r\n                                                 uint8_t mode)\r\n{\r\n    FTM_RMW_QDCTRL(ftmBase, FTM_QDCTRL_PHAPOL_MASK, FTM_QDCTRL_PHAPOL(mode));\r\n}\r\n\r\n/*!\r\n * @brief Selects polarity for the quadrature decode phase B input.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode Phase B input polarity selection\r\n *                - 0U: Normal polarity\r\n *                - 1U: Inverted polarity\r\n */\r\nstatic inline void FTM_DRV_SetQuadPhaseBPolarity(FTM_Type * const ftmBase,\r\n                                                 uint8_t mode)\r\n{\r\n    FTM_RMW_QDCTRL(ftmBase, FTM_QDCTRL_PHBPOL_MASK, FTM_QDCTRL_PHBPOL(mode));\r\n}\r\n\r\n/*!\r\n * @brief Sets the encoding mode used in quadrature decoding mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] quadMode Quadrature decoder mode selection\r\n *                     - 0U: Phase A and Phase B encoding mode\r\n *                     - 1U: Count and direction encoding mode\r\n */\r\nstatic inline void FTM_DRV_SetQuadMode(FTM_Type * const ftmBase,\r\n                                       uint8_t quadMode)\r\n{\r\n    FTM_RMW_QDCTRL(ftmBase, FTM_QDCTRL_QUADMODE_MASK, FTM_QDCTRL_QUADMODE(quadMode));\r\n}\r\n\r\n/*!\r\n * @brief Gets the FTM counter direction in quadrature mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The counting direction\r\n *         - 1U: if counting direction is increasing\r\n *         - 0U: if counting direction is decreasing\r\n */\r\nstatic inline bool FTM_DRV_GetQuadDir(const FTM_Type * ftmBase)\r\n{\r\n    return (ftmBase->QDCTRL & FTM_QDCTRL_QUADIR_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Timer overflow direction in quadrature mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n *\r\n * @return The timer overflow direction\r\n *         - 1U: if TOF bit was set on the top of counting\r\n *         - 0U: if TOF bit was set on the bottom of counting\r\n */\r\nstatic inline bool FTM_DRV_GetQuadTimerOverflowDir(const FTM_Type * ftmBase)\r\n{\r\n    return (ftmBase->QDCTRL & FTM_QDCTRL_TOFDIR_MASK) != 0U;\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the phase B input filter.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of phase B input filter\r\n *                   - true : Enables the phase input filter\r\n *                   - false: Disables the filter\r\n */\r\nstatic inline void FTM_DRV_SetQuadPhaseBFilterCmd(FTM_Type * const ftmBase,\r\n                                                  bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->QDCTRL) |= (1UL << FTM_QDCTRL_PHBFLTREN_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->QDCTRL) &= ~(1UL << FTM_QDCTRL_PHBFLTREN_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Sets the fault input filter value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value Fault input filter value\r\n */\r\nstatic inline void FTM_DRV_SetFaultInputFilterVal(FTM_Type * const ftmBase,\r\n                                                  uint32_t value)\r\n{\r\n    FTM_RMW_FLTCTRL(ftmBase, FTM_FLTCTRL_FFVAL_MASK, FTM_FLTCTRL_FFVAL(value));\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the fault input filter.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] inputNum Fault input to be configured, valid value 0, 1, 2, 3\r\n * @param[in] enable State of fault input filter\r\n *                   - true : To enable fault input filter\r\n *                   - false: To disable fault input filter\r\n */\r\nstatic inline void FTM_DRV_SetFaultInputFilterCmd(FTM_Type * const ftmBase,\r\n                                                  uint8_t inputNum,\r\n                                                  bool enable)\r\n{\r\n    DEV_ASSERT(inputNum < CHAN4_IDX);\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->FLTCTRL) |=  (1UL << (inputNum + FTM_FLTCTRL_FFLTR0EN_SHIFT));\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->FLTCTRL) &=  ~(1UL << (inputNum + FTM_FLTCTRL_FFLTR0EN_SHIFT));\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Clears the entire content value of the Fault control register.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nstatic inline void FTM_DRV_ClearFaultControl(FTM_Type * const ftmBase)\r\n{\r\n    ((ftmBase)->FLTCTRL) =  0U;\r\n}\r\n\r\n/*!\r\n * @brief Enables or disables the fault input.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] inputNum fault input to be configured, valid value 0, 1, 2, 3\r\n * @param[in] enable State of fault input\r\n *                   - true : To enable fault input\r\n *                   - false: To disable fault input\r\n */\r\nstatic inline void FTM_DRV_SetFaultInputCmd(FTM_Type * const ftmBase,\r\n                                            uint8_t inputNum,\r\n                                            bool enable)\r\n{\r\n    DEV_ASSERT(inputNum < CHAN4_IDX);\r\n\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->FLTCTRL) |=  (1UL << inputNum);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->FLTCTRL) &=  ~(1UL << inputNum);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Configures the behavior of the PWM outputs when a fault is detected\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of fault output\r\n *                   - true : Output pins are set tri-state,\r\n *                   - false: Pins are set to a safe state determined by POL bits\r\n */\r\nstatic inline void FTM_DRV_SetPwmFaultBehavior(FTM_Type * const ftmBase,\r\n                                               bool enable)\r\n{\r\n    if (enable)\r\n    {\r\n        ((ftmBase)->FLTCTRL) |=  (1UL << FTM_FLTCTRL_FSTATE_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        ((ftmBase)->FLTCTRL) &=  ~(1UL << FTM_FLTCTRL_FSTATE_SHIFT);\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Writes the provided value to the Inverting control register.\r\n *\r\n * This function is enable/disable inverting control on multiple channel pairs.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] regVal Value to be written to the register\r\n */\r\nstatic inline void FTM_DRV_SetInvctrlReg(FTM_Type * const ftmBase,\r\n                                         uint32_t regVal)\r\n{\r\n    ((ftmBase)->INVCTRL) = regVal;\r\n}\r\n\r\n/*FTM software output control*/\r\n/*!\r\n * @brief Enables or disables the channel software output control.The\r\n * main difference between this function and FTM_HAL_SetChnSoftwareCtrlCmd\r\n * is that this can configure all the channels in the same time.\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channelsMask Channels to be enabled or disabled\r\n */\r\nstatic inline void FTM_DRV_SetAllChnSoftwareCtrlCmd(FTM_Type * const ftmBase,\r\n                                                    uint8_t channelsMask)\r\n{\r\n    uint32_t mask = FTM_SWOCTRL_CH0OC_MASK | FTM_SWOCTRL_CH1OC_MASK | FTM_SWOCTRL_CH2OC_MASK |\r\n                    FTM_SWOCTRL_CH3OC_MASK | FTM_SWOCTRL_CH4OC_MASK | FTM_SWOCTRL_CH5OC_MASK |\r\n                    FTM_SWOCTRL_CH6OC_MASK | FTM_SWOCTRL_CH7OC_MASK;\r\n    ((ftmBase)->SWOCTRL) = (((ftmBase)->SWOCTRL) & (~(mask))) | channelsMask;\r\n}\r\n\r\n/*!\r\n * @brief Sets the channel software output control value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer.\r\n * @param[in] channelsValues The values which will overwrite the output channels\r\n */\r\nstatic inline void FTM_DRV_SetAllChnSoftwareCtrlVal(FTM_Type * const ftmBase,\r\n                                                    uint8_t channelsValues)\r\n{\r\n    uint32_t mask = FTM_SWOCTRL_CH0OCV_MASK | FTM_SWOCTRL_CH1OCV_MASK | FTM_SWOCTRL_CH2OCV_MASK |\r\n                        FTM_SWOCTRL_CH3OCV_MASK | FTM_SWOCTRL_CH4OCV_MASK | FTM_SWOCTRL_CH5OCV_MASK |\r\n                        FTM_SWOCTRL_CH6OCV_MASK | FTM_SWOCTRL_CH7OCV_MASK;\r\n   ((ftmBase)->SWOCTRL) = (((ftmBase)->SWOCTRL) & (~(mask))) | ((uint32_t)channelsValues << FTM_SWOCTRL_CH0OCV_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Enable and Force the software control of channels output at once.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer.\r\n * @param[in] value The values which enables and force the software control of channels output\r\n */\r\nstatic inline void FTM_DRV_SoftwareOutputControl(FTM_Type * const ftmBase,\r\n                                                 uint16_t value)\r\n{\r\n   ((ftmBase)->SWOCTRL) = value;\r\n}\r\n\r\n/*!\r\n * @brief Sets the BDM mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] val The FTM behavior in BDM mode\r\n *                - FTM_BDM_MODE_00: FTM counter stopped, CH(n)F bit can be set, FTM channels\r\n *                                   in functional mode, writes to MOD,CNTIN and C(n)V registers bypass\r\n *                                   the register buffers\r\n *                - FTM_BDM_MODE_01: FTM counter stopped, CH(n)F bit is not set, FTM channels\r\n *                                   outputs are forced to their safe value , writes to MOD,CNTIN and\r\n *                                   C(n)V registers bypass the register buffers\r\n *                - FTM_BDM_MODE_10: FTM counter stopped, CH(n)F bit is not set, FTM channels\r\n *                                   outputs are frozen when chip enters in BDM mode, writes to MOD,\r\n *                                   CNTIN and C(n)V registers bypass the register buffers\r\n *                - FTM_BDM_MODE_11: FTM counter in functional mode, CH(n)F bit can be set,\r\n *                                   FTM channels in functional mode, writes to MOD,CNTIN and C(n)V\r\n *                                   registers is in fully functional mode\r\n */\r\nstatic inline void FTM_DRV_SetBdmMode(FTM_Type * const ftmBase,\r\n                                      ftm_bdm_mode_t val)\r\n{\r\n    FTM_RMW_CONF(ftmBase, FTM_CONF_BDMMODE_MASK, FTM_CONF_BDMMODE(val));\r\n}\r\n\r\n/*FTM Synchronization configuration*/\r\n/*!\r\n * @brief Sets the sync mode for the FTM SWOCTRL register when using a hardware trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of software output control synchronization\r\n *                   - true : The hardware trigger activates SWOCTRL register sync\r\n *                   - false: The hardware trigger does not activate SWOCTRL register sync\r\n */\r\nstatic inline void FTM_DRV_SetSwoctrlHardwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWSOC_MASK) | FTM_SYNCONF_HWSOC(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM INVCTRL register when using a hardware trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of inverting control synchronization\r\n *                   - true : The hardware trigger activates INVCTRL register sync\r\n *                   - false: The hardware trigger does not activate INVCTRL register sync\r\n */\r\nstatic inline void FTM_DRV_SetInvctrlHardwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWINVC_MASK) | FTM_SYNCONF_HWINVC(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM OUTMASK register when using a hardware trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of output mask synchronization\r\n *                   - true : The hardware trigger activates OUTMASK register sync\r\n *                   - false: The hardware trigger does not activate OUTMASK register sync\r\n */\r\nstatic inline void FTM_DRV_SetOutmaskHardwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWOM_MASK) | FTM_SYNCONF_HWOM(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM MOD, CNTIN and CV registers when using a hardware trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of registers synchronization\r\n *                   - true : The hardware trigger activates  MOD, HCR, CNTIN, and CV registers sync\r\n *                   - false: The hardware trigger does not activate MOD, HCR, CNTIN, and CV registers sync\r\n */\r\nstatic inline void FTM_DRV_SetModCntinCvHardwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                            bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWWRBUF_MASK) | FTM_SYNCONF_HWWRBUF(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM counter register when using a hardware trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of FTM counter synchronization\r\n *                   - true : The hardware trigger activates FTM counter sync\r\n *                   - false: The hardware trigger does not activate FTM counter sync\r\n */\r\nstatic inline void FTM_DRV_SetCounterHardwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWRSTCNT_MASK) | FTM_SYNCONF_HWRSTCNT(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM SWOCTRL register when using a software trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of software output control synchronization\r\n *                   - true : The software trigger activates SWOCTRL register sync\r\n *                   - false: The software trigger does not activate SWOCTRL register sync\r\n */\r\nstatic inline void FTM_DRV_SetSwoctrlSoftwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWSOC_MASK) | FTM_SYNCONF_SWSOC(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM INVCTRL register when using a software trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of State of inverting control synchronization\r\n *                   - true : The software trigger activates INVCTRL register sync\r\n *                   - false: The software trigger does not activate INVCTRL register sync\r\n */\r\nstatic inline void FTM_DRV_SetInvctrlSoftwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWINVC_MASK) | FTM_SYNCONF_SWINVC(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM OUTMASK register when using a software trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of output mask synchronization\r\n *                   - true : The software trigger activates OUTMASK register sync\r\n *                   - false: The software trigger does not activate OUTMASK register sync\r\n */\r\nstatic inline void FTM_DRV_SetOutmaskSoftwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWOM_MASK) | FTM_SYNCONF_SWOM(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM MOD, CNTIN and CV registers when using a software trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of registers synchronization\r\n *                   - true : The software trigger activates FTM MOD, CNTIN and CV registers sync\r\n *                   - false: The software trigger does not activate FTM MOD, CNTIN and CV registers sync\r\n */\r\nstatic inline void FTM_DRV_SetModCntinCvSoftwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                            bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWWRBUF_MASK) | FTM_SYNCONF_SWWRBUF(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets hardware trigger mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] enable State of hardware trigger mode\r\n *                   - true : FTM does not clear the TRIGx bit when the hardware trigger j is detected\r\n *                   - false: FTM clears the TRIGx bit when the hardware trigger j is detected\r\n */\r\nstatic inline void FTM_DRV_SetHwTriggerSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                   bool enable)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWTRIGMODE_MASK) | FTM_SYNCONF_HWTRIGMODE(enable);\r\n}\r\n\r\n/*!\r\n * @brief Sets sync mode for FTM counter register when using a software trigger.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] update_mode State of FTM counter synchronization\r\n *                   - true : The software trigger activates FTM counter sync\r\n *                   - false: The software trigger does not activate FTM counter sync\r\n */\r\nstatic inline void FTM_DRV_SetCounterSoftwareSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                         ftm_pwm_sync_mode_t update_mode)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWRSTCNT_MASK) | FTM_SYNCONF_SWRSTCNT(update_mode);\r\n}\r\n\r\n/*!\r\n * @brief Sets the PWM synchronization mode to enhanced or legacy.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode State of synchronization mode\r\n *                   - true : Enhanced PWM synchronization is selected\r\n *                   - false: Legacy PWM synchronization is selected\r\n */\r\nstatic inline void FTM_DRV_SetPwmSyncModeCmd(FTM_Type * const ftmBase,\r\n                                             bool mode)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SYNCMODE_MASK) | FTM_SYNCONF_SYNCMODE(mode);\r\n}\r\n\r\n/*!\r\n * @brief Sets the SWOCTRL register PWM synchronization mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode State of register synchronization\r\n *                   - true : SWOCTRL register is updated by PWM sync\r\n *                   - false: SWOCTRL register is updated at all rising edges of system clock\r\n */\r\nstatic inline void FTM_DRV_SetSwoctrlPwmSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                    ftm_reg_update_t mode)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWOC_MASK) | FTM_SYNCONF_SWOC(mode);\r\n}\r\n\r\n/*!\r\n * @brief Sets the INVCTRL register PWM synchronization mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode State of register synchronization\r\n *                   - true : INVCTRL register is updated by PWM sync\r\n *                   - false: INVCTRL register is updated at all rising edges of system clock\r\n */\r\nstatic inline void FTM_DRV_SetInvctrlPwmSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                    ftm_reg_update_t mode)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_INVC_MASK) | FTM_SYNCONF_INVC(mode);\r\n}\r\n\r\n/*!\r\n * @brief Sets the CNTIN register PWM synchronization mode.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] mode State of register synchronization\r\n *                   - true : CNTIN register is updated by PWM sync\r\n *                   - false: CNTIN register is updated at all rising edges of system clock\r\n */\r\nstatic inline void FTM_DRV_SetCntinPwmSyncModeCmd(FTM_Type * const ftmBase,\r\n                                                  ftm_reg_update_t mode)\r\n{\r\n    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_CNTINC_MASK) | FTM_SYNCONF_CNTINC(mode);\r\n}\r\n\r\n#if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n/*!\r\n * @brief Sets the modulo fractional value in the PWM dithering.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] value The value to be set to the fractional value for the modulo\r\n */\r\nstatic inline void FTM_DRV_SetModFracVal(FTM_Type * const ftmBase,\r\n                                         uint8_t value)\r\n{\r\n    FTM_RMW_MOD_MIRROR(ftmBase, FTM_MOD_MIRROR_FRACMOD_MASK, FTM_MOD_MIRROR_FRACMOD(value));\r\n}\r\n\r\n/*!\r\n * @brief Sets the channel (n) match fractional value.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel (n)\r\n * @param[in] value The value to be set to the channel (n) match fractional value\r\n */\r\nstatic inline void FTM_DRV_SetChnMatchFracVal(FTM_Type * const ftmBase,\r\n                                              uint8_t channel,\r\n                                              uint8_t value)\r\n{\r\n    FTM_RMW_CnV_MIRROR(ftmBase, channel, FTM_CV_MIRROR_FRACVAL_MASK, FTM_CV_MIRROR_FRACVAL(value));\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Sets the sync bit as a hardware trigger source for FTM instance.\r\n *\r\n * @param[in] simBase The SIM base address pointer.\r\n * @param[in] instance The instance number of the FTM module.\r\n * @param[in] enable Enable/Disable the sync bit.\r\n */\r\nstatic inline void FTM_DRV_SyncBit(SIM_Type * const simBase,\r\n                                   uint32_t instance,\r\n                                   bool enable)\r\n{\r\n    uint32_t instTemp = instance;\r\n\r\n    if (instTemp > 3U)\r\n    {\r\n        instTemp = instance + 7U;\r\n    }\r\n\r\n    if (true == enable)\r\n    {\r\n        simBase->FTMOPT1 |= (1U << instTemp);\r\n    }\r\n    else\r\n    {\r\n        simBase->FTMOPT1 &= ~(1U << instTemp);\r\n    }\r\n}\r\n\r\n/* DRV functionality */\r\n/*!\r\n * @brief Resets the FTM registers. All the register use in the driver should be\r\n * reset to default value of each register.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n */\r\nvoid FTM_DRV_Reset(FTM_Type * const ftmBase);\r\n\r\n/*!\r\n * @brief Initializes the FTM. This function will enable the flexTimer module\r\n * and selects one pre-scale factor for the FTM clock source.\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] ftmClockPrescaler The FTM peripheral clock pre-scale divider\r\n */\r\nvoid FTM_DRV_InitModule(FTM_Type * const ftmBase,\r\n                        ftm_clock_ps_t ftmClockPrescaler);\r\n\r\n/*!\r\n * @brief Enables or disables the generation of the FTM peripheral timer channel trigger when the\r\n * FTM counter is equal to its initial value\r\n *\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number\r\n * @param[in] enable Enables the generation of the channel trigger\r\n *                   - true : The generation of the channel trigger is enabled\r\n *                   - false: The generation of the channel trigger is disabled\r\n */\r\nvoid FTM_DRV_SetChnTriggerCmd(FTM_Type * const ftmBase,\r\n                              uint8_t channel,\r\n                              bool enable);\r\n\r\n/*!\r\n * @brief Sets the FTM peripheral timer channel input capture filter value.\r\n * @param[in] ftmBase The FTM base address pointer\r\n * @param[in] channel The FTM peripheral channel number, only 0,1,2,3, channel 4, 5,6, 7 don't have\r\n * @param[in] value Filter value to be set\r\n */\r\nvoid FTM_DRV_SetChnInputCaptureFilter(FTM_Type * const ftmBase,\r\n                                      uint8_t channel,\r\n                                      uint8_t value);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n\r\n#endif /* FTM_HW_ACCESS_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_ic_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_ic_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, external symbol defined without a prior\r\n * declaration.\r\n * The symbols are declared in the driver common file as external; they are needed\r\n * at driver initialization to install the correct interrupt handler, but are not\r\n * a part of the public API.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n */\r\n\r\n#include \"ftm_ic_driver.h\"\r\n#include \"ftm_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\nstatic void FTM_DRV_InputCaptureHandler(uint32_t instance,\r\n                                        uint8_t channelPair);\r\n\r\nstatic void FTM_DRV_IrqHandler(uint32_t instance,\r\n                               uint8_t channelPair);\r\n\r\nstatic status_t FTM_DRV_InitMeasurement(uint32_t instance,\r\n                                        uint8_t channel,\r\n                                        bool continuousModeEn,\r\n                                        ftm_signal_measurement_mode_t measurementType);\r\n\r\n#if (FEATURE_FTM_HAS_NUM_IRQS_CHANS == 1U)\r\nvoid FTM0_Ch0_7_IRQHandler(void);\r\nvoid FTM1_Ch0_7_IRQHandler(void);\r\n#endif\r\n\r\n#if (FEATURE_FTM_HAS_NUM_IRQS_CHANS == 4U)\r\nvoid FTM0_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM0_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM0_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM0_Ch6_Ch7_IRQHandler(void);\r\n\r\nvoid FTM1_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM1_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM1_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM1_Ch6_Ch7_IRQHandler(void);\r\n\r\n#if (FTM_INSTANCE_COUNT > 2U)\r\nvoid FTM2_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM2_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM2_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM2_Ch6_Ch7_IRQHandler(void);\r\n\r\nvoid FTM3_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM3_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM3_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM3_Ch6_Ch7_IRQHandler(void);\r\n#endif\r\n\r\n#if (FTM_INSTANCE_COUNT > 4U)\r\nvoid FTM4_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM4_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM4_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM4_Ch6_Ch7_IRQHandler(void);\r\n\r\nvoid FTM5_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM5_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM5_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM5_Ch6_Ch7_IRQHandler(void);\r\n#endif\r\n\r\n#if (FTM_INSTANCE_COUNT > 6U)\r\nvoid FTM6_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM6_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM6_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM6_Ch6_Ch7_IRQHandler(void);\r\n\r\nvoid FTM7_Ch0_Ch1_IRQHandler(void);\r\n\r\nvoid FTM7_Ch2_Ch3_IRQHandler(void);\r\n\r\nvoid FTM7_Ch4_Ch5_IRQHandler(void);\r\n\r\nvoid FTM7_Ch6_Ch7_IRQHandler(void);\r\n#endif\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitMeasurement\r\n * Description   : This function is used to initialize the measurement mode in the\r\n * input capture mode. It is called in the FTM_DRV_InitInputCapture function.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t FTM_DRV_InitMeasurement(uint32_t instance,\r\n                                        uint8_t channel,\r\n                                        bool continuousModeEn,\r\n                                        ftm_signal_measurement_mode_t measurementType)\r\n{\r\n    DEV_ASSERT((channel % 2U) == 0U);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t chnlPairNum = (uint8_t)(channel >> 1U);\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    /* Enable the dual edge mode */\r\n    FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, chnlPairNum, true);\r\n    /* Enable dual edge input capture */\r\n    FTM_DRV_SetDualChnDecapCmd(ftmBase, chnlPairNum, true);\r\n\r\n    /* If continuous mode is set */\r\n    if (true == continuousModeEn)\r\n    {\r\n        /* Set MSnA and MSnB bit */\r\n        FTM_DRV_SetChnMSnBAMode(ftmBase, channel, 3U);\r\n    }\r\n    else\r\n    {\r\n        /* Clear MSnA and Set MSnB bit */\r\n        FTM_DRV_SetChnMSnBAMode(ftmBase, channel, 2U);\r\n    }\r\n\r\n    /* Check If want to measure a pulse width or period of the signal */\r\n    if ((FTM_PERIOD_ON_MEASUREMENT == measurementType) || (FTM_RISING_EDGE_PERIOD_MEASUREMENT== measurementType))\r\n    {\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, channel, 1U);\r\n        if (FTM_PERIOD_ON_MEASUREMENT == measurementType)\r\n        {\r\n            /* Measure time between rising and falling edge - positive duty */\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, (uint8_t)(channel + 1U), 2U);\r\n        }\r\n        else\r\n        {\r\n            /* If channel (n) is configured to capture falling edges (ELS(n)B:ELS(n)A = 0:1)\r\n             * then channel (n+1) also captures falling edges (ELS(n+1)B:ELS(n+1)A = 0:1) */\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, (uint8_t)(channel + 1U), 1U);\r\n        }\r\n    }\r\n    else if ((FTM_PERIOD_OFF_MEASUREMENT == measurementType) || (FTM_FALLING_EDGE_PERIOD_MEASUREMENT == measurementType))\r\n    {\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, channel, 2U);\r\n        if (FTM_PERIOD_OFF_MEASUREMENT == measurementType)\r\n        {\r\n            /* Measure time between falling and rising edge - negative duty */\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, (uint8_t)(channel + 1U), 1U);\r\n        }\r\n        else\r\n        {\r\n            /* If channel (n) is configured to capture rising edges (ELS(n)B:ELS(n)A = 1:0) than\r\n             * channel (n+1) is setup to capture also raising edges (ELS(n+1)B:ELS(n+1)A = 1:0) */\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, (uint8_t)(channel + 1U), 2U);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    /* Enable the interrupt request for the channel which will indicate that the measurement is done. */\r\n    FTM_DRV_EnableChnInt(ftmBase, (uint8_t)(channel + 1U));\r\n    INT_SYS_EnableIRQ(g_ftmIrqId[instance][channel]);\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitInputCapture\r\n * Description   : Configures Channel Input Capture for either getting time-stamps on edge detection\r\n * or on signal measurement . When the edge specified in the captureMode\r\n * argument occurs on the channel the FTM counter is captured into the CnV register.\r\n * The user will have to read the CnV register separately to get this value. The filter\r\n * function is disabled if the filterVal argument passed in is 0. The filter function\r\n * is available only on channels 0,1,2,3.\r\n *\r\n * Implements    : FTM_DRV_InitInputCapture_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_InitInputCapture(uint32_t instance,\r\n                                  const ftm_input_param_t * param)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(param != NULL);\r\n    DEV_ASSERT(param->nMaxCountValue > 0U);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t chnlPairNum = 0U;\r\n    uint8_t index = 0U;\r\n    uint8_t hwChannel = 0U;\r\n    bool contModeEn;\r\n    ftm_signal_measurement_mode_t measurementType;\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    if ((NULL != state) && (FTM_MODE_NOT_INITIALIZED == state->ftmMode))\r\n    {\r\n        FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n        FTM_DRV_SetCounterInitVal(ftmBase, 0U);\r\n        FTM_DRV_SetMod(ftmBase, param->nMaxCountValue);\r\n        FTM_DRV_SetCpwms(ftmBase, false);\r\n        /* Disable the combine mode */\r\n        FTM_DRV_SetDualChnMofCombineCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualChnCombineCmd(ftmBase, chnlPairNum, false);\r\n\r\n        for (index = 0U; index < param->nNumChannels; index++)\r\n        {\r\n            hwChannel = param->inputChConfig[index].hwChannelId;\r\n            chnlPairNum =  (uint8_t)(hwChannel >> 1U);\r\n            /* Save in state structure user define handlers */\r\n            state->channelsCallbacksParams[hwChannel] =  param->inputChConfig[index].channelsCallbacksParams;\r\n            state->channelsCallbacks[hwChannel] = param->inputChConfig[index].channelsCallbacks;\r\n            state->enableNotification[hwChannel] = true;\r\n\r\n            /* Enable filtering for input channels */\r\n            if (hwChannel < CHAN4_IDX)\r\n            {\r\n                if (true == param->inputChConfig[index].filterEn)\r\n                {\r\n                    FTM_DRV_SetChnInputCaptureFilter(ftmBase, hwChannel, (uint8_t)param->inputChConfig[index].filterValue);\r\n                }\r\n                else\r\n                {\r\n                    FTM_DRV_SetChnInputCaptureFilter(ftmBase, hwChannel, 0U);\r\n                }\r\n            }\r\n\r\n            if (FTM_EDGE_DETECT == param->inputChConfig[index].inputMode)\r\n            {\r\n                /* Disable the dual edge mode */\r\n                FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, chnlPairNum, false);\r\n                /* Set input capture mode */\r\n                FTM_DRV_SetChnMSnBAMode(ftmBase, hwChannel, 0U);\r\n                /* Set the event which will generate the interrupt */\r\n                FTM_DRV_SetChnEdgeLevel(ftmBase, hwChannel, (uint8_t)param->inputChConfig[index].edgeAlignement);\r\n                /* Enable interrupt request for the current channel */\r\n                FTM_DRV_EnableChnInt(ftmBase, hwChannel);\r\n                INT_SYS_EnableIRQ(g_ftmIrqId[instance][hwChannel]);\r\n            }\r\n            else if (FTM_SIGNAL_MEASUREMENT == param->inputChConfig[index].inputMode)\r\n            {\r\n                measurementType = param->inputChConfig[index].measurementType;\r\n                contModeEn = param->inputChConfig[index].continuousModeEn;\r\n                /* Configure the measurement type */\r\n                retStatus = FTM_DRV_InitMeasurement(instance, hwChannel, contModeEn, measurementType);\r\n            }\r\n            else\r\n            {\r\n                /* Do nothing */\r\n            }\r\n\r\n            if (STATUS_SUCCESS != retStatus)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (STATUS_SUCCESS == retStatus)\r\n        {\r\n            state->ftmMode = FTM_MODE_INPUT_CAPTURE;\r\n            /* Set clock source to start the counter */\r\n            FTM_DRV_SetClockSource(ftmBase, state->ftmClockSource);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_DeinitInputCapture\r\n * Description   : Disables Channel Input Capture\r\n *\r\n * Implements    : FTM_DRV_DeinitInputCapture_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_DeinitInputCapture(uint32_t instance,\r\n                                    const ftm_input_param_t * param)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(param != NULL);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t chnlPairNum = 0U;\r\n    uint8_t index = 0U;\r\n    uint8_t hwChannel = 0U;\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    DEV_ASSERT(state != NULL);\r\n\r\n    /* FTM counter is disabled */\r\n    FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n    FTM_DRV_SetCounterInitVal(ftmBase, 0U);\r\n    FTM_DRV_SetMod(ftmBase, 0xFFFFU);\r\n    FTM_DRV_SetCpwms(ftmBase, false);\r\n    for (index = 0U; index < param->nNumChannels; index++)\r\n    {\r\n        hwChannel = param->inputChConfig[index].hwChannelId;\r\n        chnlPairNum =  (uint8_t)(hwChannel >> 1U);\r\n        /* Disable filtering for input channels */\r\n        if (hwChannel < CHAN4_IDX)\r\n        {\r\n            FTM_DRV_SetChnInputCaptureFilter(ftmBase, hwChannel, 0U);\r\n        }\r\n\r\n        FTM_DRV_SetDualChnCombineCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, hwChannel, (uint8_t)0U);\r\n        FTM_DRV_DisableChnInt(ftmBase, hwChannel);\r\n    }\r\n\r\n    /* Clear Callbacks function from the state structure */\r\n    for (index = 0U; index < FEATURE_FTM_CHANNEL_COUNT; index++)\r\n    {\r\n        state->channelsCallbacksParams[index] =  NULL;\r\n        state->channelsCallbacks[index] = NULL;\r\n    }\r\n\r\n    state->ftmMode = FTM_MODE_NOT_INITIALIZED;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_GetInputCaptureMeasurement\r\n * Description   : This function is used to calculate the measurement and/or time stamps values\r\n * which are read from the C(n, n+1)V registers and stored to the static buffers.\r\n *\r\n * Implements    : FTM_DRV_GetInputCaptureMeasurement_Activity\r\n *END**************************************************************************/\r\nuint16_t FTM_DRV_GetInputCaptureMeasurement(uint32_t instance,\r\n                                            uint8_t channel)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    const ftm_state_t * state = ftmStatePtr[instance];\r\n    uint16_t value = 0U;\r\n\r\n    if (state != NULL)\r\n    {\r\n        value = state->measurementResults[channel];\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_StartNewSignalMeasurement\r\n * Description   : This function starts new Signal Measurements on a dual input compare channel\r\n * that is configured as single-shot measurement.\r\n *\r\n * Implements    : FTM_DRV_StartNewSignalMeasurement_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_StartNewSignalMeasurement(uint32_t instance,\r\n                                           uint8_t channel)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    /* Clear CH(n)F and CH(n+1)F  flags and Set DECAP bit */\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t chnlPairNum = (uint8_t)(channel >> 1U);\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    /* Get channel mode */\r\n    if (FTM_FEATURE_INPUT_CAPTURE_SINGLE_SHOT == FTM_DRV_GetChnMode(ftmBase, channel))\r\n    {\r\n        if (FTM_DRV_GetDualEdgeCaptureBit(ftmBase, chnlPairNum))\r\n        {\r\n            /* Clear event flags for channel n and n + 1 */\r\n            FTM_DRV_ClearChnEventFlag(ftmBase, (uint8_t)(channel + 1U));\r\n            FTM_DRV_ClearChnEventFlag(ftmBase, channel);\r\n            /* Set DECAP bit to start measurement */\r\n            FTM_DRV_SetDualChnDecapCmd(ftmBase, chnlPairNum, true);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_IC_DRV_SetChannelMode\r\n * Description   : This function is used to change the channel mode at run time or\r\n * when stopping channel. The channel mode is selected in the ftm_ic_op_mode_t\r\n * enumeration type.\r\n *\r\n * Implements    : FTM_IC_DRV_SetChannelMode_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_IC_DRV_SetChannelMode(uint32_t instance,\r\n                                   uint8_t channel,\r\n                                   ftm_ic_op_mode_t inputMode,\r\n                                   bool enableContinuousCapture)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t level = 1U;\r\n    uint8_t nextChnlevel = 1U;\r\n    uint8_t channelPair =  (uint8_t)(channel >> 1U);\r\n\r\n    if (inputMode == FTM_DISABLE_OPERATION)\r\n    {\r\n        /* Set the edge level to disable operation on the channel input */\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, channel, 0x0U);\r\n    }\r\n    else if ((inputMode == FTM_TIMESTAMP_RISING_EDGE) ||\r\n             (inputMode == FTM_TIMESTAMP_FALLING_EDGE) ||\r\n             (inputMode == FTM_TIMESTAMP_BOTH_EDGES))\r\n    {\r\n        /* Disable the dual edge mode */\r\n        FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, channelPair, false);\r\n        /* Set input capture mode */\r\n        FTM_DRV_SetChnMSnBAMode(ftmBase, channel, 0U);\r\n        /* Set the event which will generate the interrupt */\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, channel, (uint8_t)inputMode);\r\n        /* Enable interrupt request for the current channel */\r\n        FTM_DRV_EnableChnInt(ftmBase, channel);\r\n    }\r\n    else\r\n    {\r\n        /* Check the channel is even number */\r\n        DEV_ASSERT((channel % 2U) == 0U);\r\n        /* Enable the dual edge mode */\r\n        FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, channelPair, true);\r\n        /* Enable dual edge input capture */\r\n        FTM_DRV_SetDualChnDecapCmd(ftmBase, channelPair, true);\r\n        /* If continuous mode is set*/\r\n        if (true == enableContinuousCapture)\r\n        {\r\n            /* Set MSnA and MSnB bit*/\r\n            FTM_DRV_SetChnMSnBAMode(ftmBase, channel, 3U);\r\n        }\r\n        else\r\n        {\r\n            /* Clear MSnA and Set MSnB bit*/\r\n            FTM_DRV_SetChnMSnBAMode(ftmBase, channel, 2U);\r\n        }\r\n\r\n        /* Check If want to measure a pulse width or period of the signal */\r\n        if ((FTM_MEASURE_PULSE_HIGH == inputMode) || (FTM_MEASURE_RISING_EDGE_PERIOD == inputMode))\r\n        {\r\n            if (FTM_MEASURE_PULSE_HIGH == inputMode)\r\n            {\r\n                /* Measure time between rising and falling edge - positive duty */\r\n                nextChnlevel = 2U;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            level = 2U;\r\n            if (FTM_MEASURE_FALLING_EDGE_PERIOD == inputMode)\r\n            {\r\n                /* If channel (n) is configured to capture rising edges (ELS(n)B:ELS(n)A = 1:0) than\r\n                 * channel (n+1) is setup to capture also raising edges (ELS(n+1)B:ELS(n+1)A = 1:0) */\r\n                nextChnlevel = 2U;\r\n            }\r\n        }\r\n\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, channel, level);\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, (uint8_t)(channel + 1U), nextChnlevel);\r\n\r\n        /* Disable interrupt request for the current channel */\r\n        FTM_DRV_DisableChnInt(ftmBase, channel);\r\n        FTM_DRV_EnableChnInt(ftmBase, (uint8_t)(channel + 1U));\r\n    }\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n#if (FEATURE_FTM_HAS_NUM_IRQS_CHANS == 1U)\r\n/* Implementation of FTM0_Ch0_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM0_Ch0_7_IRQHandler(void)\r\n{\r\n    uint32_t statusFlag = FTM_DRV_GetStatusFlags(0U);\r\n    uint32_t enabledInt = FTM_DRV_GetEnabledInterrupts(0U);\r\n    uint32_t index = 0U;\r\n    uint32_t shift = 0U;\r\n    bool isIntOnChn = false;\r\n    bool isIntOnNextChn = false;\r\n\r\n    for (index = 0U; index < (uint32_t)(FEATURE_FTM_CHANNEL_COUNT / 2U); index++)\r\n    {\r\n        shift = index << 1U;\r\n        isIntOnChn = (((statusFlag & enabledInt) & (0x1UL << shift)) != 0U) ? true : false;\r\n        shift++;\r\n        isIntOnNextChn = (((statusFlag & enabledInt) & (0x1UL << shift)) != 0U) ? true : false;\r\n\r\n        if ((isIntOnChn == true) || (isIntOnNextChn == true))\r\n        {\r\n            FTM_DRV_IrqHandler(0U, (uint8_t)index);\r\n        }\r\n    }\r\n}\r\n\r\n/* Implementation of FTM1_Ch0_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM1_Ch0_7_IRQHandler(void)\r\n{\r\n    uint32_t statusFlag = FTM_DRV_GetStatusFlags(1U);\r\n    uint32_t enabledInt = FTM_DRV_GetEnabledInterrupts(1U);\r\n    uint32_t index = 0U;\r\n    uint32_t shift = 0U;\r\n    bool isIntOnChn = false;\r\n    bool isIntOnNextChn = false;\r\n\r\n    for (index = 0U; index < (uint32_t)(FEATURE_FTM_CHANNEL_COUNT / 2U); index++)\r\n    {\r\n        shift = index << 1U;\r\n        isIntOnChn = (((statusFlag & enabledInt) & (0x1UL << shift)) != 0U) ? true : false;\r\n        shift++;\r\n        isIntOnNextChn = (((statusFlag & enabledInt) & (0x1UL << shift)) != 0U) ? true : false;\r\n\r\n        if ((isIntOnChn == true) || (isIntOnNextChn == true))\r\n        {\r\n            FTM_DRV_IrqHandler(1U, (uint8_t)index);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n#if (FEATURE_FTM_HAS_NUM_IRQS_CHANS == 4U)\r\n/* Implementation of FTM0_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM0_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(0U, 0U);\r\n}\r\n\r\n/* Implementation of FTM0_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM0_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(0U, 1U);\r\n}\r\n\r\n/* Implementation of FTM0_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM0_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(0U, 2U);\r\n}\r\n\r\n/* Implementation of FTM0_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM0_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(0U, 3U);\r\n}\r\n\r\n/* Implementation of FTM1_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM1_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(1U, 0U);\r\n}\r\n\r\n/* Implementation of FTM1_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM1_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(1U, 1U);\r\n}\r\n\r\n/* Implementation of FTM1_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM1_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(1U, 2U);\r\n}\r\n\r\n/* Implementation of FTM1_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM1_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(1U, 3U);\r\n}\r\n\r\n#if (FTM_INSTANCE_COUNT > 2U)\r\n/* Implementation of FTM2_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM2_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(2U, 0U);\r\n}\r\n\r\n/* Implementation of FTM2_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM2_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(2U, 1U);\r\n}\r\n\r\n/* Implementation of FTM2_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM2_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(2U, 2U);\r\n}\r\n\r\n/* Implementation of FTM2_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM2_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(2U, 3U);\r\n}\r\n\r\n/* Implementation of FTM3_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM3_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(3U, 0U);\r\n}\r\n\r\n/* Implementation of FTM3_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM3_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(3U, 1U);\r\n}\r\n\r\n/* Implementation of FTM3_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM3_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(3U, 2U);\r\n}\r\n\r\n/* Implementation of FTM3_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM3_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(3U, 3U);\r\n}\r\n#endif\r\n\r\n#if (FTM_INSTANCE_COUNT > 4U)\r\n/* Implementation of FTM4_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM4_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(4U, 0U);\r\n}\r\n\r\n/* Implementation of FTM4_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM4_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(4U, 1U);\r\n}\r\n\r\n/* Implementation of FTM4_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM4_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(4U, 2U);\r\n}\r\n\r\n/* Implementation of FTM4_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM4_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(4U, 3U);\r\n}\r\n\r\n/* Implementation of FTM5_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM5_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(5U, 0U);\r\n}\r\n\r\n/* Implementation of FTM5_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM5_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(5U, 1U);\r\n}\r\n\r\n/* Implementation of FTM5_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM5_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(5U, 2U);\r\n}\r\n\r\n/* Implementation of FTM5_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM5_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(5U, 3U);\r\n}\r\n#endif\r\n\r\n#if (FTM_INSTANCE_COUNT > 6U)\r\n/* Implementation of FTM6_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM6_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(6U, 0U);\r\n}\r\n\r\n/* Implementation of FTM6_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM6_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(6U, 1U);\r\n}\r\n\r\n/* Implementation of FTM6_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM6_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(6U, 2U);\r\n}\r\n\r\n/* Implementation of FTM6_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM6_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(6U, 3U);\r\n}\r\n\r\n/* Implementation of FTM7_Ch0_Ch1_IRQHandler master handler named in startup code. */\r\nvoid FTM7_Ch0_Ch1_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(7U, 0U);\r\n}\r\n\r\n/* Implementation of FTM7_Ch2_Ch3_IRQHandler master handler named in startup code. */\r\nvoid FTM7_Ch2_Ch3_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(7U, 1U);\r\n}\r\n\r\n/* Implementation of FTM7_Ch4_Ch5_IRQHandler master handler named in startup code. */\r\nvoid FTM7_Ch4_Ch5_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(7U, 2U);\r\n}\r\n\r\n/* Implementation of FTM7_Ch6_Ch7_IRQHandler master handler named in startup code. */\r\nvoid FTM7_Ch6_Ch7_IRQHandler(void)\r\n{\r\n    FTM_DRV_IrqHandler(7U, 3U);\r\n}\r\n#endif\r\n#endif\r\n\r\nstatic void FTM_DRV_IrqHandler(uint32_t instance,\r\n                               uint8_t channelPair)\r\n{\r\n    const ftm_state_t * state = ftmStatePtr[instance];\r\n    switch (state->ftmMode)\r\n    {\r\n        case FTM_MODE_INPUT_CAPTURE:\r\n            FTM_DRV_InputCaptureHandler(instance, channelPair);\r\n            break;\r\n        default:\r\n            /* Nothing to do */\r\n            break;\r\n    }\r\n}\r\n\r\nstatic void FTM_DRV_InputCaptureHandler(uint32_t instance,\r\n                                        uint8_t channelPair)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channelPair < (FEATURE_FTM_CHANNEL_COUNT >> 1U));\r\n\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t channel = (uint8_t)(channelPair << 1U);\r\n\r\n    /* Verify the mode for current pair of channels */\r\n    if (FTM_DRV_GetDualEdgeCaptureBit(ftmBase, channelPair))\r\n    {\r\n        /* Dual edge input capture case */\r\n        uint16_t first_event_time = FTM_DRV_GetChnCountVal(ftmBase, channel);\r\n        uint16_t second_event_time = FTM_DRV_GetChnCountVal(ftmBase, (uint8_t)(channel + 1U));\r\n        if (second_event_time < first_event_time)\r\n        {\r\n            /* Measurement when overflow occurred */\r\n            state->measurementResults[channel] = (uint16_t)(second_event_time + (FTM_DRV_GetMod(ftmBase) - first_event_time));\r\n        }\r\n        else\r\n        {\r\n            /* Measurement when overflow doesn't occurred */\r\n            state->measurementResults[channel] = (uint16_t)(second_event_time - first_event_time);\r\n        }\r\n\r\n        /* Clear flags for channels n and n+1 */\r\n        FTM_DRV_ClearChnEventFlag(ftmBase, channel);\r\n        FTM_DRV_ClearChnEventFlag(ftmBase, (uint8_t)(channel + 1U));\r\n    }\r\n    else\r\n    {\r\n        /* To get the channel interrupt source the both channels flag must be checked */\r\n        if (false == FTM_DRV_HasChnEventOccurred(ftmBase, channel))\r\n        {\r\n            channel++;\r\n        }\r\n\r\n        /* Get the time stamp of the event */\r\n        state->measurementResults[channel] = FTM_DRV_GetChnCountVal(ftmBase, channel);\r\n        /* Clear the flag for C(n+1) channel */\r\n        FTM_DRV_ClearChnEventFlag(ftmBase, channel);\r\n    }\r\n\r\n    /* If the callback is defined to use it */\r\n    if (((state->channelsCallbacks[channel]) != NULL) && (state->enableNotification[channel] == true))\r\n    {\r\n        state->channelsCallbacks[channel](IC_EVENT_MEASUREMENT_COMPLETE, state->channelsCallbacksParams[channel]);\r\n    }\r\n}\r\n\r\n/*******************************************************************************\r\n* EOF\r\n******************************************************************************/\r\n"},{"name":"ftm_ic_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_ic_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n */\r\n\r\n#ifndef FTM_IC_DRIVER_H\r\n#define FTM_IC_DRIVER_H\r\n\r\n#include \"ftm_common.h\"\r\n\r\n/*!\r\n * @addtogroup ftm_ic_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief Selects mode operation in the input capture\r\n *\r\n * Implements : ftm_input_op_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_EDGE_DETECT         = 0U,    /*!< FTM edge detect */\r\n    FTM_SIGNAL_MEASUREMENT  = 1U,    /*!< FTM signal measurement */\r\n    FTM_NO_OPERATION        = 2U     /*!< FTM no operation */\r\n} ftm_input_op_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer input capture measurement type for dual edge input capture\r\n *\r\n * Implements : ftm_signal_measurement_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_NO_MEASUREMENT                  = 0x00U,    /*!< No measurement */\r\n    FTM_RISING_EDGE_PERIOD_MEASUREMENT  = 0x01U,    /*!< Period measurement between two consecutive rising edges */\r\n    FTM_FALLING_EDGE_PERIOD_MEASUREMENT = 0x02U,    /*!< Period measurement between two consecutive falling edges */\r\n    FTM_PERIOD_ON_MEASUREMENT           = 0x03U,    /*!< The time measurement taken for the pulse to remain ON or HIGH state */\r\n    FTM_PERIOD_OFF_MEASUREMENT          = 0x04U     /*!< The time measurement taken for the pulse to remain OFF or LOW state */\r\n} ftm_signal_measurement_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer input capture edge mode as rising edge or falling edge\r\n *\r\n * Implements : ftm_edge_alignment_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_NO_PIN_CONTROL          = 0x00U,       /*!< No trigger */\r\n    FTM_RISING_EDGE             = 0x01U,       /*!< Rising edge trigger */\r\n    FTM_FALLING_EDGE            = 0x02U,       /*!< Falling edge trigger */\r\n    FTM_BOTH_EDGES              = 0x03U        /*!< Rising and falling edge trigger */\r\n} ftm_edge_alignment_mode_t;\r\n\r\n/*!\r\n * @brief The measurement type for input capture mode\r\n * Implements : ftm_ic_op_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_DISABLE_OPERATION           = 0x00U, /*!< Have no operation */\r\n    FTM_TIMESTAMP_RISING_EDGE       = 0x01U, /*!< Rising edge trigger */\r\n    FTM_TIMESTAMP_FALLING_EDGE      = 0x02U, /*!< Falling edge trigger */\r\n    FTM_TIMESTAMP_BOTH_EDGES        = 0x03U, /*!< Rising and falling edge trigger */\r\n    FTM_MEASURE_RISING_EDGE_PERIOD  = 0x04U, /*!< Period measurement between two consecutive rising edges */\r\n    FTM_MEASURE_FALLING_EDGE_PERIOD = 0x05U, /*!< Period measurement between two consecutive falling edges */\r\n    FTM_MEASURE_PULSE_HIGH          = 0x06U, /*!< The time measurement taken for the pulse to remain ON or HIGH state */\r\n    FTM_MEASURE_PULSE_LOW           = 0x07U  /*!< The time measurement taken for the pulse to remain OFF or LOW state */\r\n} ftm_ic_op_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver Input capture parameters for each channel\r\n *\r\n * Implements : ftm_input_ch_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t hwChannelId;                                /*!< Physical hardware channel ID*/\r\n    ftm_input_op_mode_t inputMode;                      /*!< FlexTimer module mode of operation  */\r\n    ftm_edge_alignment_mode_t edgeAlignement;           /*!< Edge alignment Mode for signal measurement*/\r\n    ftm_signal_measurement_mode_t measurementType;      /*!< Measurement Mode for signal measurement*/\r\n    uint16_t filterValue;                               /*!< Filter Value */\r\n    bool filterEn;                                      /*!< Input capture filter state */\r\n    bool continuousModeEn;                              /*!< Continuous measurement state */\r\n    void * channelsCallbacksParams;                     /*!< The parameters of callback functions for channels events */\r\n    ic_callback_t channelsCallbacks;                    /*!< The callback function for channels events */\r\n} ftm_input_ch_param_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver input capture parameters\r\n *\r\n * Implements : ftm_input_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t nNumChannels;                    /*!< Number of input capture channel used */\r\n    uint16_t nMaxCountValue;                 /*!< Maximum counter value. Minimum value is 0 for this mode */\r\n    ftm_input_ch_param_t * inputChConfig;    /*!< Input capture channels configuration */\r\n} ftm_input_param_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief This function configures the channel in the Input Capture mode for either getting\r\n * time-stamps on edge detection or on signal measurement. When the edge specified in the captureMode\r\n * argument occurs on the channel and then the FTM counter is captured into the CnV register.\r\n * The user have to read the CnV register separately to get this value. The filter\r\n * function is disabled if the filterVal argument passed as 0. The filter feature.\r\n * is available only on channels 0,1,2,3.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] param Configuration of the input capture channel.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_InitInputCapture(uint32_t instance,\r\n                                  const ftm_input_param_t * param);\r\n\r\n/*!\r\n * @brief  Disables input capture mode and clears FTM timer configuration\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] param Configuration of the output compare channel.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_DeinitInputCapture(uint32_t instance,\r\n                                    const ftm_input_param_t * param);\r\n\r\n/*!\r\n * @brief  This function is used to calculate the measurement and/or time stamps values\r\n * which are read from the C(n, n+1)V registers and stored to the static buffers.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel  For getting the time stamp of the last edge (in normal input capture) this\r\n *                    parameter represents the channel number.\r\n *                    For getting the last measured value (in dual edge input capture) this parameter\r\n *                    is the lowest channel number of the pair (EX: 0, 2, 4, 6).\r\n * @return value   The measured value\r\n */\r\nuint16_t FTM_DRV_GetInputCaptureMeasurement(uint32_t instance,\r\n                                            uint8_t channel);\r\n\r\n/*!\r\n * @brief  Starts new single-shot signal measurement of the given channel.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel Configuration of the output compare channel.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_StartNewSignalMeasurement(uint32_t instance,\r\n                                           uint8_t channel);\r\n/*!\r\n * @brief Set mode operation for channel in the input capture mode\r\n *\r\n * This function will change the channel mode at run time or\r\n * when stopping channel. The channel mode is selected in the ftm_ic_op_mode_t\r\n * enumeration type.\r\n *\r\n * @param[in] instance The input capture instance number.\r\n * @param[in] channel The channel number.\r\n * @param[in] inputMode The channel operation mode.\r\n * @param[in] enableContinuousCapture Enable/disable the continuous capture mode.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_IC_DRV_SetChannelMode(uint32_t instance,\r\n                                   uint8_t channel,\r\n                                   ftm_ic_op_mode_t inputMode,\r\n                                   bool enableContinuousCapture);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n/*! @}*/ /* End of addtogroup ftm_ic_driver */\r\n\r\n#endif /* FTM_IC_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_mc_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_mc_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, external symbol defined without a prior\r\n * declaration.\r\n * The symbols are declared in the driver common file as external; they are needed\r\n * at driver initialization to install the correct interrupt handler, but are not\r\n * a part of the public API.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n */\r\n\r\n#include \"ftm_mc_driver.h\"\r\n#include \"ftm_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitCounter\r\n * Description   : Initializes the FTM counter. This function provides access to the\r\n * FTM counter settings. The counter can be run in Up counting or Up-down counting modes.\r\n * To run the counter in Free running mode, choose Up counting option and provide\r\n * 0x0 for the countStartVal and 0xFFFF for countFinalVal. Please call this\r\n * function only when FTM is used as timer/counter. User must call the FTM_DRV_Deinit\r\n * and the FTM_DRV_Init to Re-Initialize the FTM before calling FTM_DRV_InitCounter\r\n * for the second time and afterwards.\r\n *\r\n * Implements    : FTM_DRV_InitCounter_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_InitCounter(uint32_t instance,\r\n                             const ftm_timer_param_t * timer)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(timer != NULL);\r\n    DEV_ASSERT((FTM_MODE_UP_TIMER == timer->mode) || (FTM_MODE_UP_DOWN_TIMER == timer->mode));\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n    uint8_t channel = 0U;\r\n\r\n    if ((NULL != state) && (FTM_MODE_NOT_INITIALIZED == state->ftmMode))\r\n    {\r\n        /* Disable counter clock */\r\n        FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n        /* Clear the overflow flag */\r\n        FTM_DRV_ClearTimerOverflow(ftmBase);\r\n        /* Set counter initial and maximum values */\r\n        FTM_DRV_SetCounterInitVal(ftmBase, timer->initialValue);\r\n        FTM_DRV_SetMod(ftmBase, timer->finalValue);\r\n        /* Disable the quadrature decoder mode */\r\n        FTM_DRV_SetQuadDecoderCmd(ftmBase, false);\r\n        /* Use FTM as counter, disable all the channels */\r\n        for (channel = 0U; channel < FEATURE_FTM_CHANNEL_COUNT; channel++)\r\n        {\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channel, 0U);\r\n        }\r\n\r\n        /* Check the FTM counter modes */\r\n        if (FTM_MODE_UP_TIMER == timer->mode)\r\n        {\r\n            FTM_DRV_SetCpwms(ftmBase, false);\r\n        }\r\n        else if (FTM_MODE_UP_DOWN_TIMER == timer->mode)\r\n        {\r\n            FTM_DRV_SetCpwms(ftmBase, true);\r\n        }\r\n        else\r\n        {\r\n            /* Do nothing */\r\n        }\r\n\r\n        state->ftmMode = timer->mode;\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_CounterStart\r\n * Description   : Starts the FTM counter.\r\n *\r\n * Implements    : FTM_DRV_CounterStart_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_CounterStart(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    const ftm_state_t * state = ftmStatePtr[instance];\r\n    /* Check the clock source is available for FTM counter */\r\n    DEV_ASSERT(state->ftmSourceClockFrequency > 0U);\r\n    /* Enable counter clock */\r\n    FTM_DRV_SetClockSource(ftmBase, state->ftmClockSource);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_CounterStop\r\n * Description   : Stops the FTM counter.\r\n *\r\n * Implements    : FTM_DRV_CounterStop_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_CounterStop(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    /* Stop the FTM counter */\r\n    FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_CounterRead\r\n * Description   : Reads back the current value of the FTM counter.\r\n *\r\n * Implements    : FTM_DRV_CounterRead_Activity\r\n *END**************************************************************************/\r\nuint32_t FTM_DRV_CounterRead(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type const * ftmBase = g_ftmBase[instance];\r\n\r\n    return FTM_DRV_GetCounter(ftmBase);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_MC_DRV_GetDefaultConfig\r\n * Description   : This function will get the default configuration values\r\n * in the structure which is used as a common use-case.\r\n * Return        : None\r\n * Implements    : FTM_MC_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid FTM_MC_DRV_GetDefaultConfig(ftm_timer_param_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->mode         = FTM_MODE_UP_TIMER;\r\n    config->initialValue = 0U;\r\n    config->finalValue   = 65535U;\r\n}\r\n\r\n/*******************************************************************************\r\n* EOF\r\n******************************************************************************/\r\n"},{"name":"ftm_mc_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_mc_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n */\r\n\r\n#ifndef FTM_MC_DRIVER_H\r\n#define FTM_MC_DRIVER_H\r\n\r\n#include \"ftm_common.h\"\r\n\r\n/*!\r\n * @addtogroup ftm_mc_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief The configuration structure in timer mode\r\n *\r\n * Implements : ftm_timer_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    ftm_config_mode_t mode;                 /*!< FTM mode */\r\n    uint16_t initialValue;                  /*!< Initial counter value */\r\n    uint16_t finalValue;                    /*!< Final counter value */\r\n} ftm_timer_param_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Initialize the FTM counter.\r\n *\r\n * Starts the FTM counter. This function provides access to the\r\n * FTM counter settings. The counter can be run in Up counting and Up-down counting modes.\r\n * To run the counter in Free running mode, choose Up counting option and provide\r\n * 0x0 value for the initialValue and 0xFFFF for finalValue. Please call this\r\n * function only when FTM is used as timer/counter. User must call the FTM_DRV_Deinit\r\n * and the FTM_DRV_Init to Re-Initialize the FTM before calling FTM_DRV_InitCounter\r\n * for the second time and afterwards.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @param[in] timer Timer configuration structure.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Initialized successfully.\r\n */\r\nstatus_t FTM_DRV_InitCounter(uint32_t instance,\r\n                             const ftm_timer_param_t * timer);\r\n\r\n/*!\r\n * @brief Starts the FTM counter.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_CounterStart(uint32_t instance);\r\n\r\n/*!\r\n * @brief Stops the FTM counter.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_CounterStop(uint32_t instance);\r\n\r\n/*!\r\n * @brief Reads back the current value of the FTM counter.\r\n *\r\n * @param[in] instance The FTM peripheral instance number.\r\n * @return The current counter value\r\n */\r\nuint32_t FTM_DRV_CounterRead(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function will get the default configuration values\r\n *        in the structure which is used as a common use-case.\r\n * @param[out] config Pointer to the structure in which the\r\n *             configuration will be saved.\r\n * @return None\r\n */\r\nvoid FTM_MC_DRV_GetDefaultConfig(ftm_timer_param_t * const config);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n/*! @}*/ /* End of addtogroup ftm_mc_driver */\r\n\r\n#endif /* FTM_MC_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_oc_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_oc_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n */\r\n\r\n#include \"ftm_oc_driver.h\"\r\n#include \"ftm_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitOutputCompare\r\n * Description   : Configures the FTM to generate timed pulses\r\n * When the FTM counter matches the value of compareVal argument (this is\r\n * written into CnV register), the channel output is changed based on what is specified\r\n * in the compareMode argument.\r\n *\r\n * Implements    : FTM_DRV_InitOutputCompare_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_InitOutputCompare(uint32_t instance,\r\n                                   const ftm_output_cmp_param_t * param)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(param != NULL);\r\n    DEV_ASSERT(param->maxCountValue > 0U);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t index = 0U;\r\n    uint8_t hwChannel = 0U;\r\n    uint8_t chnlPairNum = 0U;\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    if ((NULL != state) && (FTM_MODE_NOT_INITIALIZED == state->ftmMode))\r\n    {\r\n        FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n        FTM_DRV_SetCpwms(ftmBase, false);\r\n        /* Clear the overflow flag */\r\n        FTM_DRV_ClearTimerOverflow(ftmBase);\r\n        FTM_DRV_SetCounterInitVal(ftmBase, 0U);\r\n        FTM_DRV_SetMod(ftmBase, param->maxCountValue);\r\n        FTM_DRV_SetCounter(ftmBase, 0U);\r\n        FTM_DRV_SetQuadDecoderCmd(ftmBase, false);\r\n        /* Use FTM as counter, disable all the channels */\r\n        for (index = 0U; index < param->nNumOutputChannels; index++)\r\n        {\r\n            DEV_ASSERT(param->maxCountValue >= param->outputChannelConfig[index].comparedValue);\r\n            hwChannel = param->outputChannelConfig[index].hwChannelId;\r\n            chnlPairNum =  (uint8_t)(hwChannel >> 1U);\r\n            FTM_DRV_SetDualChnMofCombineCmd(ftmBase, chnlPairNum, false);\r\n            FTM_DRV_SetDualChnCombineCmd(ftmBase, chnlPairNum, false);\r\n            FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, chnlPairNum, false);\r\n            /* Set Channel Output mode */\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, hwChannel, (uint8_t)(param->outputChannelConfig[index].chMode));\r\n            /* Enter counter mode for all configured channels */\r\n            FTM_DRV_SetChnMSnBAMode(ftmBase, hwChannel, 1U);\r\n            /* Write initial count value for all channels */\r\n            FTM_DRV_SetChnCountVal(ftmBase, hwChannel, param->outputChannelConfig[index].comparedValue);\r\n            /* Enable channel output */\r\n            FTM_DRV_EnablePwmChannelOutputs(ftmBase, hwChannel);\r\n            /* Enable the generation a trigger on chip module */\r\n            FTM_DRV_SetChnTriggerCmd(ftmBase, hwChannel, param->outputChannelConfig[index].enableExternalTrigger);\r\n        }\r\n\r\n        /* Set software trigger */\r\n        FTM_DRV_SetSoftwareTriggerCmd(ftmBase, true);\r\n        state->ftmMode = param->mode;\r\n        /* Set clock source to start the counter */\r\n        FTM_DRV_SetClockSource(ftmBase, state->ftmClockSource);\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_DeinitOutputCompare\r\n * Description   : Disables compare match output control and clears FTM timer configuration\r\n *\r\n * Implements    : FTM_DRV_DeinitOutputCompare_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_DeinitOutputCompare(uint32_t instance,\r\n                                     const ftm_output_cmp_param_t * param)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(param != NULL);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t index = 0U;\r\n    uint8_t hwChannel = 0U;\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    DEV_ASSERT(state != NULL);\r\n\r\n    /* Stop the FTM counter */\r\n    FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n    /* Clear the overflow flag */\r\n    FTM_DRV_ClearTimerOverflow(ftmBase);\r\n    FTM_DRV_SetCounterInitVal(ftmBase, 0U);\r\n    for (index = 0U; index < param->nNumOutputChannels; index++)\r\n    {\r\n        hwChannel = param->outputChannelConfig[index].hwChannelId;\r\n        /* Disable Channel Output mode */\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, hwChannel, (uint8_t)0U);\r\n        /* Write initial count value for all channels to 0xFFFF */\r\n        FTM_DRV_SetChnCountVal(ftmBase, hwChannel, 0U);\r\n        /* Disable channel output */\r\n        FTM_DRV_DisablePwmChannelOutputs(ftmBase, hwChannel);\r\n    }\r\n\r\n    /* Clear out the registers */\r\n    FTM_DRV_SetMod(ftmBase, 0U);\r\n    FTM_DRV_SetCounter(ftmBase, 0U);\r\n    state->ftmMode = FTM_MODE_NOT_INITIALIZED;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_UpdateOutputCompareChannel\r\n * Description   : Sets the next compare match value on the given channel starting\r\n *                 from the current counter value.\r\n *\r\n * Implements    : FTM_DRV_UpdateOutputCompareChannel_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_UpdateOutputCompareChannel(uint32_t instance,\r\n                                            uint8_t channel,\r\n                                            uint16_t nextComparematchValue,\r\n                                            ftm_output_compare_update_t update,\r\n                                            bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    uint16_t counterValue = FTM_DRV_GetCounter(g_ftmBase[instance]);\r\n    uint16_t compareValue = 0U;\r\n    uint16_t maxCounterValue = FTM_DRV_GetMod(g_ftmBase[instance]);\r\n    DEV_ASSERT(nextComparematchValue <= maxCounterValue);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    if (update == FTM_RELATIVE_VALUE)\r\n    {\r\n        /* Configure channel compare register */\r\n        if (nextComparematchValue > (maxCounterValue - counterValue))\r\n        {\r\n            compareValue = (uint16_t)(nextComparematchValue - (maxCounterValue - counterValue));\r\n        }\r\n        else\r\n        {\r\n            compareValue = (uint16_t)(counterValue + nextComparematchValue);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        compareValue = nextComparematchValue;\r\n    }\r\n\r\n    /* Set CnV value and use software trigger for sync */\r\n    FTM_DRV_SetChnCountVal(g_ftmBase[instance], channel, compareValue);\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*******************************************************************************\r\n* EOF\r\n******************************************************************************/\r\n"},{"name":"ftm_oc_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_oc_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n */\r\n\r\n#ifndef FTM_OC_DRIVER_H\r\n#define FTM_OC_DRIVER_H\r\n\r\n#include \"ftm_common.h\"\r\n\r\n/*!\r\n * @addtogroup ftm_oc_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief FlexTimer Mode configuration for output compare mode\r\n *\r\n * Implements : ftm_output_compare_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_DISABLE_OUTPUT  = 0x00U,    /*!< No action on output pin */\r\n    FTM_TOGGLE_ON_MATCH = 0x01U,    /*!< Toggle on match */\r\n    FTM_CLEAR_ON_MATCH  = 0x02U,    /*!< Clear on match */\r\n    FTM_SET_ON_MATCH    = 0x03U     /*!< Set on match */\r\n} ftm_output_compare_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer input capture type of the next output compare value\r\n *\r\n * Implements : ftm_output_compare_update_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_RELATIVE_VALUE = 0x00U,     /*!< Next compared value is relative to current value */\r\n    FTM_ABSOLUTE_VALUE = 0x01U      /*!< Next compared value is absolute */\r\n} ftm_output_compare_update_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver PWM parameters each channel in the output compare mode\r\n *\r\n * Implements : ftm_output_cmp_ch_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t hwChannelId;                        /*!< Physical hardware channel ID*/\r\n    ftm_output_compare_mode_t chMode;           /*!< Channel output mode*/\r\n    uint16_t comparedValue;                     /*!< The compared value */\r\n    bool enableExternalTrigger;                 /*!< true: enable the generation of a trigger is used for on-chip modules\r\n                                                 *   false: disable the generation of a trigger */\r\n} ftm_output_cmp_ch_param_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver PWM parameters which is configured for the list of channels\r\n *\r\n * Implements : ftm_output_cmp_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t nNumOutputChannels;                             /*!< Number of output compare channels */\r\n    ftm_config_mode_t mode;                                 /*!< FlexTimer PWM operation mode */\r\n    uint16_t maxCountValue;                                 /*!< Maximum count value in ticks */\r\n    ftm_output_cmp_ch_param_t * outputChannelConfig;        /*!< Output compare channels configuration */\r\n} ftm_output_cmp_param_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Configures the FTM to generate timed pulses (Output compare mode).\r\n *\r\n * When the FTM counter matches the value of CnV, the channel output is changed based on what is\r\n * specified in the mode argument. The signal period can be modified using\r\n * param->maxCountValue. After this function when the max counter value and CnV are equal.\r\n * FTM_DRV_UpdateOutputCompareChannel function can be used to change CnV value.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] param configuration of the output compare channels\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_InitOutputCompare(uint32_t instance,\r\n                                   const ftm_output_cmp_param_t * param);\r\n\r\n/*!\r\n * @brief  Disables compare match output control and clears FTM timer configuration\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] param Configuration of the output compare channel\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_DeinitOutputCompare(uint32_t instance,\r\n                                     const ftm_output_cmp_param_t * param);\r\n\r\n/*!\r\n * @brief Sets the next compare match value based on the current counter value\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel Configuration of the output compare channel\r\n * @param [in] nextComparematchValue Timer value in ticks until the next compare match event should appear\r\n * @param [in] update\r\n *        - FTM_RELATIVE_VALUE : nextComparemantchValue will be added to current counter value\r\n *        - FTM_ABSOLUTE_VALUE : nextComparemantchValue will be written in counter register as it is\r\n * @param [in] softwareTrigger This parameter will be true if software trigger sync is enabled and\r\n * the user want to generate a software trigger (the value from buffer will be moved to register immediate or\r\n * at next loading point depending on the sync configuration). Otherwise this parameter must be false\r\n * and the next compared value will be stored in buffer until a trigger signal will be received.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_UpdateOutputCompareChannel(uint32_t instance,\r\n                                            uint8_t channel,\r\n                                            uint16_t nextComparematchValue,\r\n                                            ftm_output_compare_update_t update,\r\n                                            bool softwareTrigger);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n/*! @}*/ /* End of addtogroup ftm_oc_driver */\r\n\r\n#endif /* FTM_OC_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_pwm_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_pwm_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from\r\n * 'essentially enum<i>' to 'essentially Boolean'\r\n * This is required by the conversion of a enum into a bit field value.\r\n */\r\n\r\n#include \"ftm_pwm_driver.h\"\r\n#include \"ftm_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitPwmIndependentChannel\r\n * Description   : Configures the PWM signal for the independent channel.\r\n *\r\n *END**************************************************************************/\r\nstatic void FTM_DRV_InitPwmIndependentChannel(uint32_t instance,\r\n                                              const ftm_pwm_param_t * param)\r\n{\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t index = 0U;\r\n    uint8_t channelId = 0U;\r\n    uint8_t chnlPairNum = 0U;\r\n\r\n    /* Configure independent PWM channels */\r\n    for (index = 0U; index < param->nNumIndependentPwmChannels; index++)\r\n    {\r\n        channelId = param->pwmIndependentChannelConfig[index].hwChannelId;\r\n        chnlPairNum =  (uint8_t)(channelId >> 1U);\r\n        /* Configure POL bits for fail safe state */\r\n        FTM_DRV_SetChnOutputPolarityCmd(ftmBase, channelId, (bool)param->pwmIndependentChannelConfig[index].safeState);\r\n\r\n        /* Configure polarity of the PWM signal taking into consideration POL and ELSA/ELSB */\r\n        if ((uint32_t)(param->pwmIndependentChannelConfig[index].safeState) == (uint32_t)(param->pwmIndependentChannelConfig[index].polarity))\r\n        {\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channelId, (uint8_t)1U);\r\n        }\r\n        else\r\n        {\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channelId, (uint8_t)2U);\r\n        }\r\n\r\n        if (param->pwmIndependentChannelConfig[index].enableSecondChannelOutput)\r\n        {\r\n            /* Configure dead time, and enable complementary channel. */\r\n            FTM_DRV_SetDualChnDeadtimeCmd(ftmBase, chnlPairNum, param->pwmIndependentChannelConfig[index].deadTime);\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channelId + 1U, (uint8_t)2U);\r\n            FTM_DRV_SetDualChnCompCmd(ftmBase, chnlPairNum, true);\r\n            if (param->pwmIndependentChannelConfig[index].secondChannelPolarity == FTM_MAIN_INVERTED)\r\n            {\r\n                FTM_DRV_SetChnOutputPolarityCmd(ftmBase, channelId + 1U, (bool)param->pwmIndependentChannelConfig[index].safeState);\r\n            }\r\n            else\r\n            {\r\n                FTM_DRV_SetChnOutputPolarityCmd(ftmBase, channelId + 1U, !((bool)param->pwmIndependentChannelConfig[index].safeState));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            FTM_DRV_SetDualChnCompCmd(ftmBase, chnlPairNum, false);\r\n        }\r\n\r\n        /* Disable combined mode. */\r\n        FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualChnCombineCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualChnMofCombineCmd(ftmBase, chnlPairNum, false);\r\n        /* Set MSB and MSA bits*/\r\n        FTM_DRV_SetChnMSnBAMode(ftmBase, channelId, 3U);\r\n        /* Configure fault mode */\r\n        FTM_DRV_SetDualChnFaultCmd(ftmBase, chnlPairNum, ((param->faultConfig)->faultMode != FTM_FAULT_CONTROL_DISABLED) ? true : false);\r\n        /* Enable sync control for channels*/\r\n        FTM_DRV_SetDualChnPwmSyncCmd(ftmBase, chnlPairNum, true);\r\n        /* Enable the generation a trigger on chip module */\r\n        FTM_DRV_SetChnTriggerCmd(ftmBase, channelId, param->pwmIndependentChannelConfig[index].enableExternalTrigger);\r\n\r\n        /* Write FTMn_PWMLOAD register to enable synchronized loading points for the given channel */\r\n        FTM_DRV_EnablePwmChannelOutputs(ftmBase, channelId);\r\n        if (param->pwmIndependentChannelConfig[index].enableSecondChannelOutput)\r\n        {\r\n            FTM_DRV_EnablePwmChannelOutputs(ftmBase, channelId + 1U);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitPwmCombinedChannel\r\n * Description   : Configures the PWM signal for the combined channel.\r\n *\r\n *END**************************************************************************/\r\nstatic void FTM_DRV_InitPwmCombinedChannel(uint32_t instance,\r\n                                           const ftm_pwm_param_t * param)\r\n{\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t index = 0U;\r\n    uint8_t channelId = 0U;\r\n    uint8_t chnlPairNum = 0U;\r\n\r\n    /* Configure combined PWM channels */\r\n    for (index = 0U; index < param->nNumCombinedPwmChannels; index++)\r\n    {\r\n        channelId = param->pwmCombinedChannelConfig[index].hwChannelId;\r\n        chnlPairNum = (uint8_t)(channelId >> 1U);\r\n        /* Check if the channel id is even number */\r\n        DEV_ASSERT((channelId % 2U) == 0U);\r\n\r\n        /* Configure POL bits for fail safe state */\r\n        FTM_DRV_SetChnOutputPolarityCmd(ftmBase, channelId, (bool)param->pwmCombinedChannelConfig[index].mainChannelSafeState);\r\n\r\n        /* Configure polarity of the PWM signal taking into consideration POL and ELSA/ELSB */\r\n        if ((uint32_t)(param->pwmCombinedChannelConfig[index].mainChannelSafeState) == (uint32_t)(param->pwmCombinedChannelConfig[index].mainChannelPolarity))\r\n        {\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channelId, (uint8_t)1U);\r\n        }\r\n        else\r\n        {\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channelId, (uint8_t)2U);\r\n        }\r\n\r\n        FTM_DRV_SetDualEdgeCaptureCmd(ftmBase, chnlPairNum, false);\r\n        /* Set MSB and MSA bits */\r\n        FTM_DRV_SetChnMSnBAMode(ftmBase, channelId, 3U);\r\n\r\n        /* Enable channel (n) output */\r\n        FTM_DRV_EnablePwmChannelOutputs(ftmBase, channelId);\r\n        /* Configure channel n+1 if it necessary. */\r\n        if (param->pwmCombinedChannelConfig[index].enableSecondChannelOutput)\r\n        {\r\n            channelId = channelId + 1U;\r\n            /* Configure POL bits for fail safe state */\r\n            FTM_DRV_SetChnOutputPolarityCmd(ftmBase, channelId, (bool)param->pwmCombinedChannelConfig[index].secondChannelSafeState);\r\n            FTM_DRV_SetChnEdgeLevel(ftmBase, channelId, (uint8_t)2U);\r\n            /* Configure polarity of the second channel relative to main channel polarity. */\r\n            if (param->pwmCombinedChannelConfig[index].secondChannelSafeState == param->pwmCombinedChannelConfig[index].mainChannelSafeState)\r\n            {\r\n                if(param->pwmCombinedChannelConfig[index].secondChannelPolarity == FTM_MAIN_DUPLICATED)\r\n                {\r\n                    /* If dead time is enabled and COMPx = 0 the channel n+1 is automatically disabled. */\r\n                    DEV_ASSERT(!(param->pwmCombinedChannelConfig[index].deadTime));\r\n                    FTM_DRV_SetDualChnCompCmd(ftmBase, chnlPairNum, false);\r\n                }\r\n                else\r\n                {\r\n                    FTM_DRV_SetDualChnCompCmd(ftmBase, chnlPairNum, true);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if(param->pwmCombinedChannelConfig[index].secondChannelPolarity == FTM_MAIN_DUPLICATED)\r\n                {\r\n                    FTM_DRV_SetDualChnCompCmd(ftmBase, chnlPairNum, true);\r\n                }\r\n                else\r\n                {\r\n                    /* If dead time is enabled and COMPx = 0 the channel n+1 is automatically disabled. */\r\n                    DEV_ASSERT(!(param->pwmCombinedChannelConfig[index].deadTime));\r\n                    FTM_DRV_SetDualChnCompCmd(ftmBase, chnlPairNum, false);\r\n                }\r\n            }\r\n            /* Enable channel (n+1) output */\r\n            FTM_DRV_EnablePwmChannelOutputs(ftmBase, (uint8_t)(channelId));\r\n        }\r\n\r\n        /* Set fault control for the channel */\r\n        FTM_DRV_SetDualChnFaultCmd(ftmBase, chnlPairNum, ((param->faultConfig)->faultMode != FTM_FAULT_CONTROL_DISABLED) ? true : false);\r\n        /* Enable sync control for channels */\r\n        FTM_DRV_SetDualChnPwmSyncCmd(ftmBase, chnlPairNum, true);\r\n        /* Enable the combine mode */\r\n        FTM_DRV_SetDualChnCombineCmd(ftmBase, chnlPairNum, true);\r\n        /* Configure the modified combine mode */\r\n        FTM_DRV_SetDualChnMofCombineCmd(ftmBase, chnlPairNum, param->pwmCombinedChannelConfig[index].enableModifiedCombine);\r\n        /* Configure dead time */\r\n        FTM_DRV_SetDualChnDeadtimeCmd(ftmBase, chnlPairNum, param->pwmCombinedChannelConfig[index].deadTime);\r\n        /* Enable the generation a trigger on the channel (n) */\r\n        channelId = (uint8_t)(chnlPairNum << 1U);\r\n        FTM_DRV_SetChnTriggerCmd(ftmBase, channelId, param->pwmCombinedChannelConfig[index].enableExternalTrigger);\r\n        /* Enable the generation a trigger on the channel (n+1) */\r\n        channelId = channelId + 1U;\r\n        FTM_DRV_SetChnTriggerCmd(ftmBase, channelId, param->pwmCombinedChannelConfig[index].enableExternalTriggerOnNextChn);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitPwmDutyCycleChannel\r\n * Description   : This function will update the duty cycle for the PWM signal\r\n * at the initialization.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t FTM_DRV_InitPwmDutyCycleChannel(uint32_t instance,\r\n                                                const ftm_pwm_param_t * param)\r\n{\r\n    uint8_t index = 0U;\r\n    uint8_t hwChannel = 0U;\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    for (index = 0U; index < param->nNumIndependentPwmChannels; index++)\r\n    {\r\n        hwChannel = param->pwmIndependentChannelConfig[index].hwChannelId;\r\n        /* Write CnV registers and setup duty cycle and phase values */\r\n        retVal = FTM_DRV_UpdatePwmChannel(instance,\r\n                                          hwChannel,\r\n                                          FTM_PWM_UPDATE_IN_DUTY_CYCLE,\r\n                                          param->pwmIndependentChannelConfig[index].uDutyCyclePercent,\r\n                                          0U,\r\n                                          false);\r\n    }\r\n\r\n    for (index = 0U; index < param->nNumCombinedPwmChannels; index++)\r\n    {\r\n        hwChannel = param->pwmCombinedChannelConfig[index].hwChannelId;\r\n        /* Write CnV registers and setup duty cycle and phase values */\r\n        retVal = FTM_DRV_UpdatePwmChannel(instance,\r\n                                          hwChannel,\r\n                                          FTM_PWM_UPDATE_IN_DUTY_CYCLE,\r\n                                          param->pwmCombinedChannelConfig[index].firstEdge,\r\n                                          param->pwmCombinedChannelConfig[index].secondEdge,\r\n                                          false);\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_InitPwm\r\n * Description   : Configures duty cycle and frequency and starts outputting\r\n * PWM on specified channels.\r\n *\r\n * Implements    : FTM_DRV_InitPwm_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_InitPwm(uint32_t instance,\r\n                         const ftm_pwm_param_t * param)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(param != NULL);\r\n    status_t retVal = STATUS_SUCCESS;\r\n    uint8_t fltChannel = 0U;\r\n    uint8_t faultChnNum = 0U;\r\n    uint32_t tempInst = instance;\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    if ((NULL != state) && (FTM_MODE_NOT_INITIALIZED == state->ftmMode))\r\n    {\r\n        /* Disable counter clock */\r\n        FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n        /* Clear the overflow flag */\r\n        FTM_DRV_ClearTimerOverflow(ftmBase);\r\n        /* Disable write protection */\r\n        FTM_DRV_SetWriteProtectionCmd(ftmBase, false);\r\n        /* Configure FTM mode */\r\n        state->ftmMode = param->mode;\r\n        /* Configure independent PWM channels */\r\n        FTM_DRV_InitPwmIndependentChannel(instance, param);\r\n        /* Configure combined PWM channels */\r\n        FTM_DRV_InitPwmCombinedChannel(instance, param);\r\n        /* Set enable outputs to be set to Initial/default value */\r\n        FTM_DRV_SetInitChnOutputCmd(ftmBase, true);\r\n        /* Enable faults (if faults were configured) */\r\n        if ((param->faultConfig)->faultMode != FTM_FAULT_CONTROL_DISABLED)\r\n        {\r\n            /* Configure PWM Output behavior */\r\n            FTM_DRV_SetPwmFaultBehavior(ftmBase, ((param->faultConfig)->pwmOutputStateOnFault) ? true : false);\r\n            /* Configure fault filter value */\r\n            FTM_DRV_SetFaultInputFilterVal(ftmBase, ((param->faultConfig)->faultFilterValue));\r\n            /* Check the FTM instances */\r\n            if (tempInst <= 3U)\r\n            {\r\n                faultChnNum = (uint8_t)FTM_FEATURE_FAULT_CHANNELS;\r\n            }\r\n            else\r\n            {\r\n                faultChnNum = (uint8_t)(FTM_FEATURE_FAULT_CHANNELS >> 1U);\r\n            }\r\n\r\n            for (fltChannel = 0U; fltChannel < faultChnNum; fltChannel++)\r\n            {\r\n                if (true == (param->faultConfig)->ftmFaultChannelParam[fltChannel].faultChannelEnabled)\r\n                {\r\n                    /* Enable fault channel */\r\n                    FTM_DRV_SetFaultInputCmd(ftmBase, fltChannel, true);\r\n                    /* Configure fault filter */\r\n                    FTM_DRV_SetFaultInputFilterCmd(ftmBase,\r\n                                                   fltChannel,\r\n                                                   ((param->faultConfig)->ftmFaultChannelParam[fltChannel].faultFilterEnabled) ? true : false);\r\n                    /* Configure fault outputs */\r\n                    FTM_DRV_SetChnFaultInputPolarityCmd(ftmBase,\r\n                                                        fltChannel,\r\n                                                        (((param->faultConfig)->ftmFaultChannelParam[fltChannel].ftmFaultPinPolarity  == FTM_POLARITY_HIGH)? true : false));\r\n                }\r\n            }\r\n\r\n            /* Set fault interrupt */\r\n            if (true == ((param->faultConfig)->pwmFaultInterrupt))\r\n            {\r\n                FTM_DRV_SetFaultInt(ftmBase, true);\r\n            }\r\n\r\n            /* Enable fault control */\r\n            FTM_DRV_SetFaultControlMode(ftmBase, (uint32_t)(param->faultConfig)->faultMode);\r\n        }\r\n\r\n        /* Configure PWM mode: edge or center aligned */\r\n        FTM_DRV_SetCpwms(ftmBase, (param->mode == FTM_MODE_CEN_ALIGNED_PWM) ? true : false);\r\n        /* Calculate frequency of the give FTM hardware module - all channels will run at the same frequency */\r\n        state->ftmPeriod = FTM_DRV_ConvertFreqToPeriodTicks(instance, param->uFrequencyHZ);\r\n        /* Based on reference manual, in PWM mode CNTIN is to be set 0*/\r\n        FTM_DRV_SetCounterInitVal(ftmBase, 0U);\r\n        /* Write MOD register with the value of the period */\r\n        /* For center aligned mode MOD register should be divided by 2 */\r\n        /* For edge aligned mode period is determined by: MOD-CNTIN+1 */\r\n        if (param->mode == FTM_MODE_CEN_ALIGNED_PWM)\r\n        {\r\n            FTM_DRV_SetMod(ftmBase, (uint16_t)(state->ftmPeriod >> 1U));\r\n        }\r\n        else\r\n        {\r\n            FTM_DRV_SetMod(ftmBase, (uint16_t)(state->ftmPeriod - 1U));\r\n        }\r\n\r\n        /* Update the duty cycle */\r\n        retVal = FTM_DRV_InitPwmDutyCycleChannel(instance, param);\r\n\r\n        if (STATUS_SUCCESS == retVal)\r\n        {\r\n            /* Configure dead time for combine mode */\r\n            FTM_DRV_SetDeadtimeCount(ftmBase, param->deadTimeValue);\r\n            FTM_DRV_SetDeadtimePrescale(ftmBase, param->deadTimePrescaler);\r\n            FTM_DRV_Enable(ftmBase, true);\r\n            FTM_DRV_SetPwmSyncMode(ftmBase, true);\r\n            /* Set clock source to start counter */\r\n            FTM_DRV_SetClockSource(ftmBase, state->ftmClockSource);\r\n        }\r\n        else\r\n        {\r\n            /* Restore FTM mode if initialization fails */\r\n            state->ftmMode = FTM_MODE_NOT_INITIALIZED;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_DeinitPwm\r\n * Description   : Stops all PWM channels.\r\n *\r\n * Implements    : FTM_DRV_DeinitPwm_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_DeinitPwm(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    uint8_t channel;\r\n    uint8_t chnlPairNum;\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    DEV_ASSERT(state != NULL);\r\n\r\n    /* Stop the FTM counter */\r\n    FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n    for (channel = 0U; channel < FEATURE_FTM_CHANNEL_COUNT; channel++)\r\n    {\r\n        chnlPairNum = (uint8_t)(channel >> 1U);\r\n        /* Disable PWM mode in hardware */\r\n        FTM_DRV_SetChnCountVal(ftmBase, channel, 0U);\r\n        FTM_DRV_SetChnEdgeLevel(ftmBase, channel, 0U);\r\n        FTM_DRV_SetChnMSnBAMode(ftmBase, channel, 0U);\r\n        FTM_DRV_SetCpwms(ftmBase, false);\r\n        /* Configure polarity bit */\r\n        FTM_DRV_SetChnOutputPolarityCmd(ftmBase, channel, false);\r\n        FTM_DRV_DisablePwmChannelOutputs(ftmBase, channel);\r\n        /* Clear the PWM synchronization */\r\n        FTM_DRV_SetDualChnPwmSyncCmd(ftmBase, chnlPairNum, false);\r\n        /* Clear combination for each pair of channels */\r\n        FTM_DRV_SetDualChnMofCombineCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualChnCombineCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualChnDeadtimeCmd(ftmBase, chnlPairNum, false);\r\n        FTM_DRV_SetDualChnFaultCmd(ftmBase, chnlPairNum, false);\r\n    }\r\n\r\n    /* Clear the dead-time pre-scaler and value */\r\n    FTM_DRV_SetExtDeadtimeValue(ftmBase, 0U);\r\n    FTM_DRV_SetDeadtimePrescale(ftmBase, FTM_DEADTIME_DIVID_BY_1);\r\n    FTM_DRV_SetDeadtimeCount(ftmBase, 0U);\r\n    /* Clear fault control register */\r\n    FTM_DRV_ClearFaultControl(ftmBase);\r\n    /* Disable fault interrupt */\r\n    FTM_DRV_SetFaultInt(ftmBase, false);\r\n    /* Disable fault control */\r\n    FTM_DRV_SetFaultControlMode(ftmBase, (uint32_t)FTM_FAULT_CONTROL_DISABLED);\r\n    /* Clear the module value of the registers */\r\n    FTM_DRV_SetMod(ftmBase, 0U);\r\n    FTM_DRV_SetCounter(ftmBase, 0U);\r\n    state->ftmMode = FTM_MODE_NOT_INITIALIZED;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_UpdatePwmChannel\r\n * Description   : This function will update the duty cycle of PWM output.\r\n * - If the type of update in the duty cycle, this function will convert the input parameters representing\r\n * frequency in Hz to a period value in ticks needed by the hardware timer. Period is calculated depending\r\n * on the operating mode of the FTM module and is stored in internal state structure.\r\n * firstEdge and secondEdge can have value between 0 - FTM_MAX_DUTY_CYCLE(0 = 0% duty\r\n * and FTM_MAX_DUTY_CYCLE = 100% duty). secondEdge value is used only whenFTM module is used in PWM combine mode.\r\n * - If the type of update in ticks, this function will get value in ticks to the hardware timer.\r\n * firstEdge and secondEdge variables can have value between 0 and ftmPeriod is stored in the state structure.\r\n * - in the modified combine mode, the firstEdge parameter is fixed value and only can modify the secondEdge variables\r\n * which is the initial value in the channel (n+1) match edge when the FTM counter has been ran.\r\n *\r\n * Implements    : FTM_DRV_UpdatePwmChannel_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_UpdatePwmChannel(uint32_t instance,\r\n                                  uint8_t channel,\r\n                                  ftm_pwm_update_option_t typeOfUpdate,\r\n                                  uint16_t firstEdge,\r\n                                  uint16_t secondEdge,\r\n                                  bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    uint16_t hwFirstEdge = 0U;\r\n    uint16_t hwSecondEdge = 0U;\r\n    uint16_t ftmPeriod = 0U;\r\n    uint8_t chnlPairNum = (uint8_t)(channel >> 1U);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    /* Get the newest period in the MOD register */\r\n    ftmPeriod = FTM_DRV_GetMod(ftmBase);\r\n    /* Check the mode operation in FTM module */\r\n    if (state->ftmMode == FTM_MODE_CEN_ALIGNED_PWM)\r\n    {\r\n        ftmPeriod = (uint16_t)(ftmPeriod << 1U);\r\n    }\r\n    else if (state->ftmMode == FTM_MODE_EDGE_ALIGNED_PWM)\r\n    {\r\n        ftmPeriod = (uint16_t)(ftmPeriod + 1U);\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    /* Check the type of update for PWM */\r\n    if (FTM_PWM_UPDATE_IN_DUTY_CYCLE == typeOfUpdate)\r\n    {\r\n        if ((firstEdge <= FTM_MAX_DUTY_CYCLE) && (secondEdge <= FTM_MAX_DUTY_CYCLE))\r\n        {\r\n            /* Calculate DutyCycle based of the previously calculated frequency*/\r\n            /* For greater resolution the DutyCycle values are in the range [0. FTM_MAX_DUTY_CYCLE]\r\n             *  where 0 = 0% or PWM always at Low and FTM_MAX_DUTY_CYCLE = 100% or PWM always HIGH;\r\n             *  a value of 0x4000 is equivalent of 50% DutyCycle. */\r\n            hwFirstEdge = (uint16_t)((ftmPeriod * firstEdge) >> FTM_DUTY_TO_TICKS_SHIFT);\r\n            hwSecondEdge = (uint16_t)((ftmPeriod * secondEdge) >> FTM_DUTY_TO_TICKS_SHIFT);\r\n            /* adjust DutyCycle if 100% value is to be achieved. */\r\n            if (FTM_MAX_DUTY_CYCLE == firstEdge)\r\n            {\r\n                /* If expected duty is 100% then increase by 1 the value that is to be written\r\n                 *  to Hardware so it will exceed value of period */\r\n                hwFirstEdge = (uint16_t)(hwFirstEdge + 1U);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            retStatus = STATUS_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if ((firstEdge <= ftmPeriod) && (secondEdge <= ftmPeriod))\r\n        {\r\n            hwFirstEdge = firstEdge;\r\n            hwSecondEdge = secondEdge;\r\n        }\r\n        else\r\n        {\r\n            retStatus = STATUS_ERROR;\r\n        }\r\n    }\r\n\r\n    if (STATUS_SUCCESS == retStatus)\r\n    {\r\n        if (true == FTM_DRV_GetDualChnCombineCmd(ftmBase, chnlPairNum))\r\n        {\r\n            if (true == FTM_DRV_GetDualChnMofCombineCmd(ftmBase, chnlPairNum))\r\n            {\r\n                /* Check the clock source for FTM counter is disabled or not */\r\n                if (FTM_DRV_GetClockSource(ftmBase) == 0U)\r\n                {\r\n                    FTM_DRV_SetChnCountVal(ftmBase, (uint8_t)(chnlPairNum * 2U), hwFirstEdge);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                FTM_DRV_SetChnCountVal(ftmBase, (uint8_t)(chnlPairNum * 2U), hwFirstEdge);\r\n            }\r\n\r\n            /* Modify the initial value in the channel (n+1) match edge */\r\n            FTM_DRV_SetChnCountVal(ftmBase, (uint8_t)((chnlPairNum * 2U) + 1U), hwSecondEdge);\r\n        }\r\n        else\r\n        {\r\n            /* Channel value is divided by 2 for up down counter mode to keep same duty */\r\n            if (true == FTM_DRV_GetCpwms(ftmBase))\r\n            {\r\n                FTM_DRV_SetChnCountVal(ftmBase, channel, (uint16_t)(hwFirstEdge >> 1U));\r\n            }\r\n            else\r\n            {\r\n                FTM_DRV_SetChnCountVal(ftmBase, channel, hwFirstEdge);\r\n            }\r\n        }\r\n\r\n        /* Software trigger is generated to change CnV registers */\r\n        /* Before this please configure sync mechanism to use software trigger */\r\n        FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n        /* Store the PWM period in the state structure */\r\n        state->ftmPeriod = ftmPeriod;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_UpdatePwmPeriod\r\n * Description   : This function will update the new period in the frequency or\r\n * in the counter value into mode register which modify the period of PWM signal\r\n * on the channel output.\r\n * - If the type of update in the duty cycle which is reused in FTM_DRV_UpdatePwmChannel\r\n * function to convert the newValue parameters representing frequency in Hz to\r\n * a period value to update the MOD register. The newValue parameter must be value\r\n * between 1U and maximum is the frequency of the FTM counter.\r\n * - If the type of update in ticks, this function will get value in counting to\r\n * the MOD register. The newValue parameter must be value between 1U and 0xFFFFU\r\n *\r\n * Implements : FTM_DRV_UpdatePwmPeriod_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_UpdatePwmPeriod(uint32_t instance,\r\n                                 ftm_pwm_update_option_t typeOfUpdate,\r\n                                 uint32_t newValue,\r\n                                 bool softwareTrigger)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(newValue != 0U);\r\n    uint32_t ftmPeriod = 0U;\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    /* Check the type of update for period in PWM mode */\r\n    if (FTM_PWM_UPDATE_IN_TICKS == typeOfUpdate)\r\n    {\r\n        ftmPeriod = newValue;\r\n    }\r\n    else\r\n    {\r\n        if (newValue <= state->ftmSourceClockFrequency)\r\n        {\r\n            ftmPeriod = (uint32_t)FTM_DRV_ConvertFreqToPeriodTicks(instance, newValue);\r\n        }\r\n        else\r\n        {\r\n            retStatus = STATUS_ERROR;\r\n        }\r\n    }\r\n\r\n    if (STATUS_SUCCESS == retStatus)\r\n    {\r\n        /* Check the ftmPeriod is invalid */\r\n        DEV_ASSERT(ftmPeriod <= 0xFFFFU);\r\n        /* Check the signal operation in which PWM mode */\r\n        DEV_ASSERT((FTM_MODE_CEN_ALIGNED_PWM == state->ftmMode) || (FTM_MODE_EDGE_ALIGNED_PWM == state->ftmMode));\r\n        if (FTM_MODE_CEN_ALIGNED_PWM == state->ftmMode)\r\n        {\r\n            ftmPeriod = (ftmPeriod >> 1U);\r\n        }\r\n        else\r\n        {\r\n            DEV_ASSERT(ftmPeriod > 0U);\r\n            ftmPeriod = (ftmPeriod - 1U);\r\n        }\r\n        /* Set the new modulo value into MOD register */\r\n        FTM_DRV_SetMod(ftmBase, (uint16_t)(ftmPeriod));\r\n        /* Software trigger is generated to change MOD registers */\r\n        FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n        /* Store the PWM period in the state structure */\r\n        state->ftmPeriod = (uint16_t)ftmPeriod;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_FastUpdatePwmChannels\r\n * Description   : This function will update the duty cycle of PWM output for multiple channels.\r\n *\r\n * The main differences between this function and FTM_DRV_UpdatePwmChannel is the execution speed. This\r\n * feature makes this function ideal for applications like motor controlling.\r\n * The downside is the low flexibility of the parameters (this function accept only updates in ticks).\r\n *\r\n * Implements : FTM_DRV_FastUpdatePwmChannels_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_FastUpdatePwmChannels(uint32_t instance,\r\n                                       uint8_t numberOfChannels,\r\n                                       const uint8_t * channels,\r\n                                       const uint16_t * duty,\r\n                                       bool softwareTrigger)\r\n{\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(numberOfChannels <= FEATURE_FTM_CHANNEL_COUNT);\r\n    uint8_t i;\r\n\r\n    for (i = 0U; i < numberOfChannels; i++)\r\n    {\r\n        ((ftmBase)->CONTROLS[channels[i]].CnV) = duty[i];\r\n    }\r\n\r\n    if (softwareTrigger)\r\n    {\r\n       ftmBase->SYNC |= FTM_SYNC_SWSYNC_MASK;\r\n    }\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_ControlChannelOutput\r\n * Description   : This function is used to control the final logic of the\r\n * channel output.\r\n *\r\n * Implements : FTM_DRV_ControlChannelOutput_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_ControlChannelOutput(uint32_t instance,\r\n                                      uint8_t channel,\r\n                                      bool enableChannelOutput)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    if (enableChannelOutput == true)\r\n    {\r\n        /* Enable the channel output */\r\n        FTM_DRV_EnablePwmChannelOutputs(ftmBase, channel);\r\n    }\r\n    else\r\n    {\r\n        /* Disable the channel output */\r\n        FTM_DRV_DisablePwmChannelOutputs(ftmBase, channel);\r\n    }\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n#if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_UpdatePwmPeriodDither\r\n * Description   : This function will use in the PWM period dithering. This value\r\n * is added to an internal accumulator at the end of each PWM period. The value is\r\n * updated with its write buffer value according to the register synchronization.\r\n *\r\n * Implements : FTM_DRV_UpdatePwmPeriodDither_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_UpdatePwmPeriodDither(uint32_t instance,\r\n                                       uint8_t newModFracVal,\r\n                                       bool softwareTrigger)\r\n{\r\n    DEV_ASSERT((instance == 1U) || (instance == 2U));\r\n    DEV_ASSERT(newModFracVal <= 32U);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetModFracVal(ftmBase, newModFracVal);\r\n    /* Software trigger is generated to change MOD_MIRROR registers */\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_UpdatePwmEdgeChannelDither\r\n * Description   : This function will use in the PWM edge dithering. This value\r\n * is added to the channel (n) internal accumulator at the end of each PWM period.\r\n * The FRACVAL is updated with its write buffer value according to the register\r\n * synchronization. The PWM edge dithering is not available when the channel in the\r\n * input capture modes, and the channel in output compare mode.\r\n *\r\n * Implements    : FTM_DRV_UpdatePwmEdgeChannelDither_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_UpdatePwmEdgeChannelDither(uint32_t instance,\r\n                                            uint8_t channel,\r\n                                            uint8_t newMatchFracVal,\r\n                                            bool softwareTrigger)\r\n{\r\n    DEV_ASSERT((instance == 1U) || (instance == 2U));\r\n    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);\r\n    DEV_ASSERT(newMatchFracVal <= 32U);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    FTM_DRV_SetChnMatchFracVal(ftmBase, channel, newMatchFracVal);\r\n    /* Software trigger is generated to change CnV_MIRROR registers */\r\n    FTM_DRV_SetSoftwareTriggerCmd(ftmBase, softwareTrigger);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n#endif\r\n\r\n#ifdef ERRATA_E10856\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_PWM_DRV_IrqHandler\r\n * Description   : This function is used to workaround an errata which the safe state\r\n * is not removed from channel outputs after fault condition ends if SWOCTRL is being\r\n * used to control the pin. The FTM_MODE[FAULTM] should be configured for manual fault\r\n * clearing (0b10)\r\n * This function must be used in the TOF interrupt handler when a fault is detected to\r\n * ensure that the outputs return to the value configured by FTM_SWOCTR\r\n *\r\n * Implements    : FTM_PWM_DRV_IrqHandler_Activity\r\n *END**************************************************************************/\r\nvoid FTM_PWM_DRV_IrqHandler(uint32_t instance,\r\n                            uint32_t chnOutCtrlVal)\r\n{\r\n    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);\r\n    DEV_ASSERT(chnOutCtrlVal <= 0xFFu);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n\r\n    /* 1. Check the value of FTM_FMS[FAULTF] */\r\n    if (FTM_DRV_GetDetectedFaultInput(ftmBase) == true)\r\n    {\r\n        faultDetection = true;\r\n        /* 2. Write the FTM_OUTMASK register to set the bit */\r\n        FTM_DRV_SetOutmaskReg(ftmBase, chnOutCtrlVal);\r\n        /* 3. Clear fault conditions by reading the FTM_FMS register and then writing FTM_FMS with all zeroes */\r\n        FTM_DRV_ClearFaultsIsr(ftmBase);\r\n        /* 4. Clear the FTM_SC[TOF] bit by reading the FTM_SC register, then writing a 0 to FTM_SC[TOF] */\r\n        FTM_DRV_ClearTimerOverflow(ftmBase);\r\n        /* 5. Exit the interrupt handler to skip following steps */\r\n    }\r\n    else if (faultDetection == true)\r\n    {\r\n        /* 6. Clear the FTM_SWOCTRL by writing all zeroes to it */\r\n        FTM_DRV_SetAllChnSoftwareCtrlCmd(ftmBase, 0x00U);\r\n        FTM_DRV_SetAllChnSoftwareCtrlVal(ftmBase, 0x00U);\r\n        /* 7. Write FTM_SWOCTRL with the desired value again */\r\n        uint8_t u8chnOutCtrlVal = (uint8_t)(chnOutCtrlVal & 0xFFu);\r\n        FTM_DRV_SetAllChnSoftwareCtrlCmd(ftmBase, u8chnOutCtrlVal);\r\n        FTM_DRV_SetAllChnSoftwareCtrlVal(ftmBase, u8chnOutCtrlVal);\r\n        /* 8. Clear the FTM_OUTMASK bits that were set in step 2 */\r\n        FTM_DRV_SetOutmaskReg(ftmBase, 0x00U);\r\n        /* 9. Clear the fault variable that was set in step 1 when the fault condition was originally detected */\r\n        faultDetection = false;\r\n        /* 10. Clear the FTM_SC[TOF] bit by reading the FTM_SC register, then writing a 0 to FTM_SC[TOF] */\r\n        FTM_DRV_ClearTimerOverflow(ftmBase);\r\n    }\r\n    else\r\n    {\r\n        /* Nothing to do */\r\n    }\r\n}\r\n#endif\r\n\r\n/*******************************************************************************\r\n* EOF\r\n******************************************************************************/\r\n"},{"name":"ftm_pwm_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_pwm_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macro is used in ftm_pwm driver, but in pwm_pal the functions which use it is not called.\r\n *\r\n */\r\n\r\n#ifndef FTM_PWM_DRIVER_H\r\n#define FTM_PWM_DRIVER_H\r\n\r\n#include \"ftm_common.h\"\r\n\r\n/*!\r\n * @addtogroup ftm_pwm_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*! @brief Maximum value for PWM duty cycle */\r\n#define FTM_MAX_DUTY_CYCLE      (0x8000U)\r\n/*! @brief Shift value which converts duty to ticks */\r\n#define FTM_DUTY_TO_TICKS_SHIFT (15U)\r\n\r\n/*!\r\n * @brief FlexTimer Configure type of PWM update in the duty cycle or in ticks\r\n *\r\n * Implements : ftm_pwm_update_option_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_PWM_UPDATE_IN_DUTY_CYCLE = 0x00U,     /*!< The type of PWM update in the duty cycle/pulse or also use in frequency update */\r\n    FTM_PWM_UPDATE_IN_TICKS      = 0x01U      /*!< The type of PWM update in ticks */\r\n} ftm_pwm_update_option_t;\r\n\r\n/*!\r\n * @brief The polarity of the channel output is configured in PWM signal\r\n *\r\n * Implements : ftm_polarity_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_POLARITY_LOW  = 0x00U,  /*!< The channel polarity is active LOW which is defined again */\r\n    FTM_POLARITY_HIGH = 0x01U   /*!< The channel polarity is active HIGH which is defined again */\r\n} ftm_polarity_t;\r\n\r\n/*!\r\n * @brief FlexTimer PWM channel (n+1) polarity for combine mode\r\n *\r\n * Implements : ftm_second_channel_polarity_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_MAIN_INVERTED   = 0x01U,  /*!< The channel (n+1) output is the inverse of the\r\n                                   *   channel (n) output  */\r\n    FTM_MAIN_DUPLICATED = 0x00U   /*!< The channel (n+1) output is the same as the\r\n                                   *   channel (n) output */\r\n} ftm_second_channel_polarity_t;\r\n\r\n/*!\r\n * @brief FlexTimer fault control\r\n *\r\n * Implements : ftm_fault_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_FAULT_CONTROL_DISABLED  = 0x00U,    /*!< Fault control is disabled for all channels */\r\n    FTM_FAULT_CONTROL_MAN_EVEN  = 0x01U,    /*!< Fault control is enabled for even channels\r\n                                             *   only (channels 0, 2, 4, and 6), and the selected\r\n                                             *   mode is the manual fault clearing */\r\n    FTM_FAULT_CONTROL_MAN_ALL   = 0x02U,    /*!< Fault control is enabled for all channels,\r\n                                             *   and the selected mode is the manual fault clearing */\r\n    FTM_FAULT_CONTROL_AUTO_ALL  = 0x03U     /*!< Fault control is enabled for all channels, and\r\n                                             *   the selected mode is the automatic fault clearing */\r\n} ftm_fault_mode_t;\r\n\r\n/*!\r\n * @brief Select level of the channel (n) output at the beginning\r\n *\r\n * Implements : ftm_safe_state_polarity_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_LOW_STATE = 0x00U,    /*!< When fault is detected PWM channel is low. */\r\n    FTM_HIGH_STATE  = 0x01U   /*!< When fault is detected PWM channel is high. */\r\n} ftm_safe_state_polarity_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver PWM Fault channel parameters\r\n *\r\n * Implements : ftm_pwm_ch_fault_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool faultChannelEnabled;                   /*!< Fault channel state */\r\n    bool faultFilterEnabled;                    /*!< Fault channel filter state */\r\n    ftm_polarity_t ftmFaultPinPolarity;         /*!< Channel output state on fault */\r\n} ftm_pwm_ch_fault_param_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver PWM Fault parameter\r\n *\r\n * Implements : ftm_pwm_fault_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool pwmOutputStateOnFault;             /*!< Output pin state on fault (safe state or tri-state) */\r\n    bool pwmFaultInterrupt;                 /*!< PWM fault interrupt state */\r\n    uint8_t faultFilterValue;               /*!< Fault filter value */\r\n    ftm_fault_mode_t faultMode;             /*!< Fault mode */\r\n    ftm_pwm_ch_fault_param_t ftmFaultChannelParam[FTM_FEATURE_FAULT_CHANNELS]; /*!< Fault channels configuration */\r\n} ftm_pwm_fault_param_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver independent PWM parameter\r\n *\r\n * Implements : ftm_independent_ch_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t hwChannelId;                                 /*!< Physical hardware channel ID */\r\n    ftm_polarity_t polarity;                             /*!< Polarity of the PWM signal generated on MCU pin.*/\r\n    uint16_t uDutyCyclePercent;                          /*!< PWM pulse width, value should be between\r\n                                                          *   0 (0%) to FTM_MAX_DUTY_CYCLE (100%) */\r\n    bool enableExternalTrigger;                          /*!< true: enable the generation of a trigger is used for on-chip modules\r\n                                                          *   false: disable the generation of a trigger */\r\n    ftm_safe_state_polarity_t safeState;                 /*!< Logical state of the PWM channel n when an fault is detected\r\n                                                          *   and to set up the polarity of PWM signal on the channel (n+1) */\r\n    bool enableSecondChannelOutput;                      /*!< Enable complementary mode on next channel */\r\n    ftm_second_channel_polarity_t secondChannelPolarity; /*!< Polarity of the channel n+1 relative to channel n in the complementary mode*/\r\n    bool deadTime;                                       /*!< Enable/disable dead time for channel */\r\n} ftm_independent_ch_param_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver combined PWM parameter\r\n *\r\n * Implements : ftm_combined_ch_param_t_Class\r\n\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t hwChannelId;                                 /*!< Physical hardware channel ID for channel (n) */\r\n    uint16_t firstEdge;                                  /*!< First edge time. This time is relative to signal period. The value for this parameter is\r\n                                                          *   between 0 and FTM_MAX_DUTY_CYCLE(0 = 0% from period and FTM_MAX_DUTY_CYCLE = 100% from period) */\r\n    uint16_t secondEdge;                                 /*!< Second edge time. This time is relative to signal period. The value for this parameter is\r\n                                                          *   between 0 and FTM_MAX_DUTY_CYCLE(0 = 0% from period and FTM_MAX_DUTY_CYCLE = 100% from period) */\r\n    bool deadTime;                                       /*!< Enable/disable dead time for channel */\r\n    bool enableModifiedCombine;                          /*!< Enable/disable the modified combine mode for channels (n) and (n+1) */\r\n    ftm_polarity_t mainChannelPolarity;                  /*!< Polarity of the PWM signal generated on MCU pin for channel n.*/\r\n    bool enableSecondChannelOutput;                      /*!< Select if channel (n+1)  output is enabled/disabled for the complementary mode */\r\n    ftm_second_channel_polarity_t secondChannelPolarity; /*!< Select channel (n+1) polarity relative to channel (n) in the complementary mode */\r\n    bool enableExternalTrigger;                          /*!< The generation of the channel (n) trigger\r\n                                                          *   true: enable the generation of a trigger on the channel (n)\r\n                                                          *   false: disable the generation of a trigger on the channel (n) */\r\n    bool enableExternalTriggerOnNextChn;                 /*!< The generation of the channel (n+1) trigger\r\n                                                          *   true: enable the generation of a trigger on the channel (n+1)\r\n                                                          *   false: disable the generation of a trigger on the channel (n+1) */\r\n    ftm_safe_state_polarity_t mainChannelSafeState;      /*!< The selection of the channel (n) state when fault is detected */\r\n    ftm_safe_state_polarity_t secondChannelSafeState;    /*!< The selection of the channel (n+1) state when fault is detected\r\n                                                          *   and set up the polarity of PWM signal on the channel (n+1) */\r\n} ftm_combined_ch_param_t;\r\n\r\n/*!\r\n * @brief FlexTimer driver PWM parameters\r\n *\r\n * Implements : ftm_pwm_param_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t nNumIndependentPwmChannels;                                     /*!< Number of independent PWM channels */\r\n    uint8_t nNumCombinedPwmChannels;                                        /*!< Number of combined PWM channels */\r\n    ftm_config_mode_t mode;                                                 /*!< FTM mode */\r\n    uint8_t deadTimeValue;                                                  /*!< Dead time value in [ticks] */\r\n    ftm_deadtime_ps_t deadTimePrescaler;                                    /*!< Dead time pre-scaler value[ticks] */\r\n    uint32_t uFrequencyHZ;                                                  /*!< PWM period in Hz */\r\n    ftm_independent_ch_param_t * pwmIndependentChannelConfig;               /*!< Configuration for independent PWM channels */\r\n    ftm_combined_ch_param_t * pwmCombinedChannelConfig;                     /*!< Configuration for combined PWM channels */\r\n    ftm_pwm_fault_param_t * faultConfig;                                    /*!< Configuration for PWM fault */\r\n} ftm_pwm_param_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Stops all PWM channels .\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @return counter the current counter value\r\n */\r\nstatus_t FTM_DRV_DeinitPwm(uint32_t instance);\r\n\r\n/*!\r\n * @brief Configures the duty cycle and frequency and starts the output of the PWM on\r\n * all channels configured in the param structure.\r\n * The independent channel configuration need to clarify the polarity and safe state as following:\r\n * - In the first channel, the POL bit is the value of safeState variable. In the second channel,\r\n * the POL bit is the same value of safeSate with the inverted channel and the POL bit is inverted\r\n * safeState with the duplicated channel.\r\n * - If the polarity and sate state are the value, it will be Low-true pulses. It means the ELSB:ELSA = 0:1.\r\n * Otherwise, it will be High-true pulses. It means the ELSB:ELSA = 1:0.\r\n * Regarding the combined channel configuration:\r\n * - In both channels, the POL bit is the same value with the safeState variable\r\n * - If the polarity and sate state are the value, it will be Low-true pulses. It means the ELSB:ELSA = 0:1.\r\n * Otherwise, it will be High-true pulses. It means the ELSB:ELSA = 1:0.\r\n * - COMP bit will be true when the polarity and safeState are the same value, the second channel is inverted\r\n *.the first channel or when the polarity and safeState are difference value, the second channel is duplicated the first channel.\r\n * - COMP bit will be false when the polarity and safeState are the same value, the second channel is duplicated\r\n *.the first channel or when the polarity and safeState are difference value, the second channel is inverted the first channel.\r\n *\r\n * @Note: These configuration will impact to the FTM_DRV_SetSoftwareOutputChannelControl and FTM_DRV_SetAllChnSoftwareOutputControl function.\r\n * Because the software output control behavior depends on the polarity and COMP bit.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] param FTM driver PWM parameter to configure PWM options.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_InitPwm(uint32_t instance,\r\n                         const ftm_pwm_param_t * param);\r\n\r\n/*!\r\n * @brief This function updates the waveform output in PWM mode (duty cycle and phase).\r\n *\r\n * @Note: Regarding the type of updating PWM in the duty cycle, if the expected duty\r\n * is 100% then the value that is to be written to hardware will be exceed value of period.\r\n * It means that the FTM counter will not match the value of the CnV register in this case.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel The channel number. In combined mode, the code finds the channel.\r\n * @param [in] typeOfUpdate The type of PWM update in the duty cycle/pulse or in ticks.\r\n * @param [in] firstEdge  Duty cycle or first edge time for PWM mode. Can take value between\r\n *                       0 - FTM_MAX_DUTY_CYCLE(0 = 0% from period  and FTM_MAX_DUTY_CYCLE = 100% from period)\r\n *                       Or value in ticks for the first of the PWM mode in which can have value between 0\r\n *                       and ftmPeriod is stored in the state structure.\r\n * @param [in] secondEdge Second edge time - only for combined mode. Can take value\r\n *                       between 0 - FTM_MAX_DUTY_CYCLE(0 = 0% from period  and FTM_MAX_DUTY_CYCLE = 100% from period).\r\n *                       Or value in ticks for the second of the PWM mode in which can have value between 0\r\n *                       and ftmPeriod is stored in the state structure.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update PWM parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_UpdatePwmChannel(uint32_t instance,\r\n                                  uint8_t channel,\r\n                                  ftm_pwm_update_option_t typeOfUpdate,\r\n                                  uint16_t firstEdge,\r\n                                  uint16_t secondEdge,\r\n                                  bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will update the duty cycle of PWM output for multiple channels.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] numberOfChannels The number of channels which should be updated.\r\n * @param [in] channels The list of channels which should be updated.\r\n * @param [in] duty The list of duty cycles for selected channels.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update PWM parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_FastUpdatePwmChannels(uint32_t instance,\r\n                                       uint8_t numberOfChannels,\r\n                                       const uint8_t * channels,\r\n                                       const uint16_t * duty,\r\n                                       bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will update the new period in the frequency or\r\n * in the counter value into mode register which modify the period of PWM signal\r\n * on the channel output\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] typeOfUpdate The type of PWM update is a period in Hz or in ticks.\r\n *                          - For FTM_PWM_UPDATE_IN_DUTY_CYCLE which reuse in FTM_DRV_UpdatePwmChannel function will update in Hz.\r\n *                          - For FTM_PWM_UPDATE_IN_TICKS will update in ticks.\r\n * @param [in] newValue The frequency or the counter value which will select with modified value for PWM signal.\r\n *                      If the type of update in the duty cycle, the newValue parameter must be value\r\n *                      between 1U and maximum is the frequency of the FTM counter.\r\n *                      If the type of update in ticks, the newValue parameter must be value between 1U and 0xFFFFU.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update PWM parameters.\r\n * @return operation status\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_UpdatePwmPeriod(uint32_t instance,\r\n                                 ftm_pwm_update_option_t typeOfUpdate,\r\n                                 uint32_t newValue,\r\n                                 bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function is used to control the final logic of the channel output.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel The channel which is used in PWM mode.\r\n * @param [in] enableChannelOutput Enable/disable the channel output.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n */\r\nstatus_t FTM_DRV_ControlChannelOutput(uint32_t instance,\r\n                                      uint8_t channel,\r\n                                      bool enableChannelOutput);\r\n\r\n#if FEATURE_FTM_HAS_SUPPORTED_DITHERING\r\n/*!\r\n * @brief This function will use in the PWM period dithering. This value\r\n * is added to an internal accumulator at the end of each PWM period. The value is\r\n * updated with its write buffer value according to the register synchronization.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] newModFracVal The modulo fractional value.\r\n * @param [in] softwareTrigger If true a software trigger is generate to update parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_UpdatePwmPeriodDither(uint32_t instance,\r\n                                       uint8_t newModFracVal,\r\n                                       bool softwareTrigger);\r\n\r\n/*!\r\n * @brief This function will use in the PWM edge dithering. This value\r\n * is added to the channel (n) internal accumulator at the end of each PWM period.\r\n * The FRACVAL is updated with its write buffer value according to the register\r\n * synchronization. The PWM edge dithering is not available when the channel in the\r\n * input capture modes, and the channel in output compare modes.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] channel The channel number.\r\n * @param [in] newMatchFracVal The channel (n) match fractional value .\r\n * @param [in] softwareTrigger If true a software trigger is generate to update parameters.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_UpdatePwmEdgeChannelDither(uint32_t instance,\r\n                                            uint8_t channel,\r\n                                            uint8_t newMatchFracVal,\r\n                                            bool softwareTrigger);\r\n#endif\r\n\r\n#ifdef ERRATA_E10856\r\n/*!\r\n * @brief This function is used to workaround an errata which the safe state\r\n * is not removed from channel outputs after fault condition ends if SWOCTRL is being\r\n * used to control the pin. The FTM_MODE[FAULTM] should be configured for manual fault\r\n * clearing (0b10).\r\n * This function must be used in the TOF interrupt handler when a fault is detected to\r\n * ensure that the outputs return to the value configured by FTM_SWOCTR register.\r\n *\r\n * @param [in] instance The FTM peripheral instance number.\r\n * @param [in] chnOutCtrlVal The value of some channel outputs are affected by software output control.\r\n */\r\nvoid FTM_PWM_DRV_IrqHandler(uint32_t instance,\r\n                            uint32_t chnOutCtrlVal);\r\n\r\n#endif /* ERRATA_E10856 */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n/*! @}*/ /* End of addtogroup ftm_pwm_driver */\r\n\r\n#endif /* FTM_PWM_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"ftm_qd_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_qd_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, external symbol defined without a prior\r\n * declaration.\r\n * The symbols are declared in the driver common file as external; they are needed\r\n * at driver initialization to install the correct interrupt handler, but are not\r\n * a part of the public API.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n */\r\n\r\n#include \"ftm_qd_driver.h\"\r\n#include \"ftm_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_QuadDecodeStart\r\n * Description   : Configures the parameters needed and activates quadrature\r\n * decode mode.\r\n *\r\n * Implements    : FTM_DRV_QuadDecodeStart_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_QuadDecodeStart(uint32_t instance,\r\n                                 const ftm_quad_decode_config_t * config)\r\n{\r\n    DEV_ASSERT((instance == 1U) || (instance == 2U));\r\n    DEV_ASSERT(config != NULL);\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    status_t retStatus = STATUS_SUCCESS;\r\n\r\n    if ((NULL != state) && (FTM_MODE_NOT_INITIALIZED == state->ftmMode))\r\n    {\r\n        /* Disable Quadrature Decoder */\r\n        FTM_DRV_SetQuadDecoderCmd(ftmBase, false);\r\n        FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);\r\n        /* Configure Quadrature Decoder */\r\n        /* Set decoder mode Speed and direction or Phase A and Phase B encoding */\r\n        FTM_DRV_SetQuadMode(ftmBase, (uint8_t)config->mode);\r\n        /* Set filter state for Phase A (enable/disable) */\r\n        FTM_DRV_SetQuadPhaseAFilterCmd(ftmBase, config->phaseAConfig.phaseInputFilter);\r\n        /* Set Phase A filter value if phase filter is enabled */\r\n        if (config->phaseAConfig.phaseInputFilter)\r\n        {\r\n            FTM_DRV_SetChnInputCaptureFilter(ftmBase, CHAN0_IDX, config->phaseAConfig.phaseFilterVal);\r\n        }\r\n\r\n        /* Set filter state for Phase B (enable/disable) */\r\n        FTM_DRV_SetQuadPhaseBFilterCmd(ftmBase, config->phaseBConfig.phaseInputFilter);\r\n        /* Set Phase B filter value if phase filter is enabled */\r\n        if (config->phaseBConfig.phaseInputFilter)\r\n        {\r\n            FTM_DRV_SetChnInputCaptureFilter(ftmBase, CHAN1_IDX, config->phaseBConfig.phaseFilterVal);\r\n        }\r\n\r\n        /* Set polarity for Phase A and Phase B */\r\n        FTM_DRV_SetQuadPhaseAPolarity(ftmBase, (uint8_t)config->phaseAConfig.phasePolarity);\r\n        FTM_DRV_SetQuadPhaseBPolarity(ftmBase, (uint8_t)config->phaseBConfig.phasePolarity);\r\n        /* Configure counter (initial value and maximum value) */\r\n        FTM_DRV_SetCounterInitVal(ftmBase, config->initialVal);\r\n        FTM_DRV_SetMod(ftmBase, config->maxVal);\r\n        FTM_DRV_SetCounter(ftmBase, config->initialVal);\r\n        /* Enable Quadrature Decoder */\r\n        FTM_DRV_SetQuadDecoderCmd(ftmBase, true);\r\n        state->ftmMode = FTM_MODE_QUADRATURE_DECODER;\r\n    }\r\n    else\r\n    {\r\n        retStatus = STATUS_ERROR;\r\n    }\r\n\r\n    return retStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_QuadDecodeStop\r\n * Description   : De-activates quadrature decoder mode.\r\n *\r\n * Implements    : FTM_DRV_QuadDecodeStop_Activity\r\n *END**************************************************************************/\r\nstatus_t FTM_DRV_QuadDecodeStop(uint32_t instance)\r\n{\r\n    DEV_ASSERT((instance == 1U) || (instance == 2U));\r\n    FTM_Type * ftmBase = g_ftmBase[instance];\r\n    ftm_state_t * state = ftmStatePtr[instance];\r\n    DEV_ASSERT(state != NULL);\r\n\r\n    /* Disable Quadrature decoder */\r\n    FTM_DRV_SetQuadDecoderCmd(ftmBase, false);\r\n    state->ftmMode = FTM_MODE_NOT_INITIALIZED;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_DRV_QuadGetState\r\n * Description   : Return the current quadrature decoder state\r\n * (counter value, overflow flag and overflow direction)\r\n *\r\n * Implements    : FTM_DRV_QuadGetState_Activity\r\n *END**************************************************************************/\r\nftm_quad_decoder_state_t FTM_DRV_QuadGetState(uint32_t instance)\r\n{\r\n    DEV_ASSERT((instance == 1U) || (instance == 2U));\r\n    FTM_Type const * ftmBase = g_ftmBase[instance];\r\n    ftm_quad_decoder_state_t state;\r\n\r\n    state.counterDirection = FTM_DRV_GetQuadDir(ftmBase);\r\n    state.overflowDirection = FTM_DRV_GetQuadTimerOverflowDir(ftmBase);\r\n    state.overflowFlag = FTM_DRV_HasTimerOverflowed(ftmBase);\r\n    state.counter = FTM_DRV_GetCounter(ftmBase);\r\n\r\n    return state;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : FTM_QD_DRV_GetDefaultConfig\r\n * Description   : This function will get the default configuration values\r\n * in the structure which is used as a common use-case.\r\n * Return        : None\r\n * Implements    : FTM_QD_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid FTM_QD_DRV_GetDefaultConfig(ftm_quad_decode_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->mode                           = FTM_QUAD_COUNT_AND_DIR;\r\n    config->initialVal                     = 0U;\r\n    config->maxVal                         = 65535U;\r\n    config->phaseAConfig.phaseInputFilter = false;\r\n    config->phaseAConfig.phaseFilterVal   = 0U;\r\n    config->phaseAConfig.phasePolarity    = FTM_QUAD_PHASE_NORMAL;\r\n    config->phaseBConfig.phaseInputFilter = false;\r\n    config->phaseBConfig.phaseFilterVal   = 0U;\r\n    config->phaseBConfig.phasePolarity    = FTM_QUAD_PHASE_NORMAL;\r\n}\r\n\r\n/*******************************************************************************\r\n* EOF\r\n******************************************************************************/\r\n"},{"name":"ftm_qd_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file ftm_qd_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n */\r\n\r\n#ifndef FTM_QD_DRIVER_H\r\n#define FTM_QD_DRIVER_H\r\n\r\n#include \"ftm_common.h\"\r\n\r\n/*!\r\n * @addtogroup ftm_qd_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*!\r\n * @brief FlexTimer quadrature decode modes, phase encode or count and direction mode\r\n *\r\n * Implements : ftm_quad_decode_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_QUAD_PHASE_ENCODE   = 0x00U,    /*!< Phase encoding mode                 */\r\n    FTM_QUAD_COUNT_AND_DIR  = 0x01U     /*!< Counter and direction encoding mode */\r\n} ftm_quad_decode_mode_t;\r\n\r\n/*!\r\n * @brief FlexTimer quadrature phase polarities, normal or inverted polarity\r\n *\r\n * Implements : ftm_quad_phase_polarity_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    FTM_QUAD_PHASE_NORMAL = 0x00U,  /*!< Phase input signal is not inverted before identifying\r\n                                     *   the rising and falling edges of this signal */\r\n    FTM_QUAD_PHASE_INVERT = 0x01U   /*!< Phase input signal is inverted before identifying\r\n                                     *   the rising and falling edges of this signal */\r\n} ftm_quad_phase_polarity_t;\r\n\r\n/*!\r\n * @brief FlexTimer quadrature decoder channel parameters\r\n *\r\n * Implements : ftm_phase_params_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool phaseInputFilter;                          /*!< false: disable phase filter,\r\n                                                     *   true: enable phase filter */\r\n    uint8_t phaseFilterVal;                         /*!< Filter value (if input filter is enabled)*/\r\n    ftm_quad_phase_polarity_t phasePolarity;        /*!< Phase polarity */\r\n} ftm_phase_params_t;\r\n\r\n/*!\r\n * @brief FTM quadrature configure structure\r\n *\r\n * Implements : ftm_quad_decode_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    ftm_quad_decode_mode_t mode;        /*!< FTM_QUAD_PHASE_ENCODE or FTM_QUAD_COUNT_AND_DIR */\r\n    uint16_t initialVal;                /*!< Initial counter value*/\r\n    uint16_t maxVal;                    /*!< Maximum counter value*/\r\n    ftm_phase_params_t phaseAConfig;    /*!< Configuration for the input phase a */\r\n    ftm_phase_params_t phaseBConfig;    /*!< Configuration for the input phase b */\r\n} ftm_quad_decode_config_t;\r\n\r\n/*!\r\n * @brief FTM quadrature state(counter value and flags)\r\n *\r\n * Implements : ftm_quad_decoder_state_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint16_t counter;           /*!< Counter value */\r\n    bool overflowFlag;          /*!< True if overflow occurred,\r\n                                 *   False if overflow doesn't occurred */\r\n    bool overflowDirection;     /*!< False if overflow occurred at minimum value,\r\n                                 *   True if overflow occurred at maximum value */\r\n    bool counterDirection;      /*!< False FTM counter is decreasing,\r\n                                 *   True FTM counter is increasing */\r\n} ftm_quad_decoder_state_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Configures the quadrature mode and starts measurement\r\n *\r\n * @param [in] instance Instance number of the FTM module.\r\n * @param [in] config   Configuration structure(quadrature decode mode, polarity for both phases,\r\n *                      initial and maximum value for the counter, filter configuration).\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_QuadDecodeStart(uint32_t instance,\r\n                                 const ftm_quad_decode_config_t * config);\r\n\r\n/*!\r\n * @brief De-activates the quadrature decode mode.\r\n *\r\n * @param [in] instance Instance number of the FTM module.\r\n * @return success\r\n *        - STATUS_SUCCESS : Completed successfully.\r\n *        - STATUS_ERROR : Error occurred.\r\n */\r\nstatus_t FTM_DRV_QuadDecodeStop(uint32_t instance);\r\n\r\n/*!\r\n * @brief Return the current quadrature decoder state (counter value, overflow flag and\r\n * overflow direction)\r\n *\r\n * @param [in] instance Instance number of the FTM module.\r\n * @return The current state of quadrature decoder\r\n */\r\nftm_quad_decoder_state_t FTM_DRV_QuadGetState(uint32_t instance);\r\n\r\n/*!\r\n * @brief This function will get the default configuration values\r\n *        in the structure which is used as a common use-case.\r\n * @param[out] config Pointer to the structure in which the\r\n *                    configuration will be saved.\r\n * @return None\r\n */\r\nvoid FTM_QD_DRV_GetDefaultConfig(ftm_quad_decode_config_t * const config);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n/*! @}*/ /* End of addtogroup ftm_qd_driver */\r\n\r\n#endif /* FTM_QD_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"interrupt_manager.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.1, Conversions shall not be performed\r\n * between a pointer to a function and any other type.\r\n * This is required in order to read/write from vector table memory.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The address of hardware modules is provided as integer so\r\n * it needs to be cast to pointer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The address of hardware modules is provided as integer so\r\n * a conversion between a pointer and an integer has to be performed.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, An object should be defined at block scope\r\n * if its identifier only appears in a single function.\r\n * __VECTOR_RAM variable is not an object with static storage duration, it needs to be\r\n * declared as extern.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 15.5, Return statement before end of function.\r\n * The return statement before end of function is used for simpler code structure\r\n * and better readability.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.11, When an array with external linkage\r\n * is declared, its size should be explicitly specified.\r\n * The number of configurations/callbacks can be zero.\r\n * On the other side C language forbids declaring array of size zero.\r\n */\r\n\r\n /*! @file interrupt_manager.c */\r\n\r\n#include \"interrupt_manager.h\"\r\n#include \"startup.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief Counter to manage the nested callings of global disable/enable interrupt.\r\n */\r\nstatic int32_t g_interruptDisableCount = 0;\r\n\r\n/*!\r\n * @brief Declaration of vector table.\r\n * FEATURE_INTERRUPT_IRQ_MAX is the highest interrupt request number.\r\n * 16 is the maximum number of exceptions\r\n */\r\n#if defined(__ARMCC_VERSION)\r\n    extern uint32_t __VECTOR_RAM;\r\n    extern uint32_t __VECTOR_TABLE;\r\n    extern uint32_t __DATA_ROM;\r\n    extern uint32_t __RAM_START;\r\n#else\r\n    extern uint32_t __VECTOR_RAM[((uint32_t)(FEATURE_INTERRUPT_IRQ_MAX)) + 16U + 1U];\r\n    extern uint32_t __VECTOR_TABLE[((uint32_t)(FEATURE_INTERRUPT_IRQ_MAX)) + 16U + 1U];\r\n    extern uint32_t __DATA_ROM[];\r\n    extern uint32_t __DATA_END[];\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_InstallHandler\r\n * Description   : Install an interrupt handler routine for a given IRQ number\r\n * This function will let application register/replace the interrupt\r\n * handler for specified IRQ number. IRQ number is different than Vector\r\n * number. IRQ 0 will start from Vector 16 address. Refer to reference\r\n * manual for details. Also refer to startup_<CPU>.s file for each chip\r\n * family to find out the default interrupt handler for each device. This\r\n * function will convert the IRQ number to vector number by adding 16 to\r\n * it.\r\n *\r\n * Note          : This method is applicable only if interrupt vector is\r\n *                 copied in RAM, __flash_vector_table__ symbol is used to\r\n *                 control this from linker options.\r\n * Implements INT_SYS_InstallHandler_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_InstallHandler(IRQn_Type irqNumber,\r\n                            const isr_t newHandler,\r\n                            isr_t* const oldHandler)\r\n{\r\n\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(FEATURE_INTERRUPT_IRQ_MIN <= irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n\r\n    const uint32_t * aVectorRam = (uint32_t *)__VECTOR_RAM;\r\n    const uint32_t * aVectorTable = (uint32_t *)__VECTOR_TABLE;\r\n\r\n    /* Check whether there is vector table in RAM */\r\n#if defined(__ARMCC_VERSION)\r\n    if ((aVectorRam != aVectorTable) || (__DATA_ROM > __RAM_START))\r\n#elif (defined(__ICCARM__))\r\n    if ((aVectorRam != aVectorTable) || (INTERRUPTS_SECTION_START != 0))\r\n#else\r\n    const uint32_t * aDataRom = (uint32_t *)__DATA_ROM;\r\n    const uint32_t * aDataRam = (uint32_t *)__DATA_END;\r\n    if ((aVectorRam != aVectorTable) || (aDataRom == aDataRam))\r\n#endif\r\n    {\r\n        uint32_t * pVectorRam = (uint32_t *)__VECTOR_RAM;\r\n\r\n        /* Save the former handler pointer */\r\n        if (oldHandler != (isr_t *) 0)\r\n        {\r\n            *oldHandler = (isr_t)pVectorRam[((int32_t)irqNumber) + 16];\r\n        }\r\n\r\n#if FEATURE_MSCM_HAS_INTERRUPT_ROUTER\r\n\r\n    #if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n\r\n        DEV_ASSERT((int32_t)irqNumber < (int32_t)MSCM_IRSPRC_COUNT);\r\n        /* Check routing is not read-only in case it needs to be written */\r\n        uint16_t cpu_enable = (uint16_t)(1UL << (MSCM->CPXNUM));\r\n        if ((MSCM->IRSPRC[irqNumber] & cpu_enable) == 0U)\r\n        {\r\n            DEV_ASSERT((MSCM->IRSPRC[irqNumber] & (uint16_t)(MSCM_IRSPRC_RO_MASK)) == (uint16_t)MSCM_IRSPRC_RO(0));\r\n        }\r\n\r\n    #endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n\r\n#endif /* FEATURE_MSCM_HAS_INTERRUPT_ROUTER */\r\n\r\n        /* Set handler into vector table */\r\n        pVectorRam[((int32_t)irqNumber) + 16] = (uint32_t)newHandler;\r\n    }\r\n    else\r\n    {\r\n        #if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n            const uint32_t * pVectorRam = (uint32_t *)__VECTOR_RAM;\r\n            /* Check if the existing handler is the same as the one already present in the vector */\r\n            DEV_ASSERT(pVectorRam[((int32_t)irqNumber) + 16] == (uint32_t)newHandler);\r\n\r\n        #endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_EnableIRQ\r\n * Description   : Enables an interrupt for a given IRQ number.\r\n * It calls the system NVIC API to access the interrupt control\r\n * register and MSCM (if available) API for interrupt routing.\r\n * The input IRQ number does not include the core interrupt, only\r\n * the peripheral interrupt, from 0 to a maximum supported IRQ.\r\n * Implements INT_SYS_EnableIRQ_Activity\r\n *END**************************************************************************/\r\nvoid INT_SYS_EnableIRQ(IRQn_Type irqNumber)\r\n{\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(0 <= (int32_t)irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n    /* Enable interrupt */\r\n    S32_NVIC->ISER[(uint32_t)(irqNumber) >> 5U] = (uint32_t)(1UL << ((uint32_t)(irqNumber) & (uint32_t)0x1FU));\r\n\r\n#if FEATURE_MSCM_HAS_INTERRUPT_ROUTER\r\n\r\n    /* Enable routing to current CPU */\r\n    uint16_t cpu_enable = (uint16_t)(1UL << (MSCM->CPXNUM));\r\n    MSCM->IRSPRC[irqNumber] |= cpu_enable;\r\n\r\n#endif /* FEATURE_MSCM_HAS_INTERRUPT_ROUTER */\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_DisableIRQ\r\n * Description   : Disable individual interrupt for a specified IRQ\r\n * It  calls the system NVIC API to access the interrupt control register\r\n * and MSCM (if available) API for interrupt routing.\r\n * Implements INT_SYS_DisableIRQ_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_DisableIRQ(IRQn_Type irqNumber)\r\n{\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(0 <= (int32_t)irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n    /* Disable interrupt */\r\n    S32_NVIC->ICER[((uint32_t)(irqNumber) >> 5U)] = (uint32_t)(1UL << ((uint32_t)(irqNumber) & (uint32_t)0x1FU));\r\n\r\n#if FEATURE_MSCM_HAS_INTERRUPT_ROUTER\r\n\r\n    /* Disable routing to current CPU */\r\n    uint16_t cpu_enable = (uint16_t)(1UL << (MSCM->CPXNUM));\r\n    MSCM->IRSPRC[irqNumber] &= (uint16_t)~(cpu_enable);\r\n\r\n#endif /* FEATURE_MSCM_HAS_INTERRUPT_ROUTER */\r\n\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_EnableIRQGlobal\r\n * Description   : Enable system interrupt\r\n * This function will enable the global interrupt by calling the core API\r\n * Implements INT_SYS_EnableIRQGlobal_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_EnableIRQGlobal(void)\r\n{\r\n    /* Check and update */\r\n    if (g_interruptDisableCount > 0)\r\n    {\r\n        g_interruptDisableCount--;\r\n\r\n        if (g_interruptDisableCount <= 0)\r\n        {\r\n            /* Enable the global interrupt*/\r\n            ENABLE_INTERRUPTS();\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_DisableIRQGlobal\r\n * Description   : Disable system interrupt\r\n * This function will disable the global interrupt by calling the core API\r\n * Implements INT_SYS_DisableIRQGlobal_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_DisableIRQGlobal(void)\r\n{\r\n    /* Disable the global interrupt */\r\n    DISABLE_INTERRUPTS();\r\n\r\n    /* Update counter*/\r\n    g_interruptDisableCount++;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_SetPriority\r\n * Description   : Set the priority of an interrupt\r\n * This function will set the priority of an interrupt.\r\n * Note: The priority cannot be set for every core interrupt.\r\n * Implements INT_SYS_SetPriority_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_SetPriority(IRQn_Type irqNumber, uint8_t priority)\r\n{\r\n\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n\r\n    /* Check IRQ number and priority - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(FEATURE_INTERRUPT_IRQ_MIN <= irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n    DEV_ASSERT(priority < (uint8_t)(1U << FEATURE_NVIC_PRIO_BITS));\r\n\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n\r\n    uint8_t shift = (uint8_t) (8U - FEATURE_NVIC_PRIO_BITS);\r\n\r\n    if ((int32_t)irqNumber < 0)\r\n    {\r\n        uint32_t intVectorId = ((uint32_t)(irqNumber) & 0xFU);\r\n        uint32_t regId = intVectorId / 4U;\r\n\r\n        /* Compute pointer to SHPR register - avoid MISRA violation. */\r\n    #if defined (S32K11x_SERIES)\r\n        DEV_ASSERT((int32_t)regId != 1);\r\n\r\n        volatile uint32_t * shpr_reg_ptr = ((regId == 2U) ? (volatile uint32_t *)&S32_SCB->SHPR2 : (volatile uint32_t *)&S32_SCB->SHPR3);\r\n        uint8_t priByteShift = (uint8_t)(((uint8_t)(intVectorId) & 0x3U) << 3U);\r\n\r\n        /* Clear the old value from the register */\r\n        *shpr_reg_ptr &= ~(0xFFUL << priByteShift);\r\n\r\n        /* Set Priority for Cortex-M0P System Interrupts */\r\n        *shpr_reg_ptr |= ((uint32_t)(((((uint32_t)priority) << shift)) & 0xFFUL)) << priByteShift;\r\n    #else\r\n        volatile uint8_t * shpr_reg_ptr = ((regId == 1U) ? (volatile uint8_t *)&S32_SCB->SHPR1 : ((regId == 2U) ? (volatile uint8_t *)&S32_SCB->SHPR2 : (volatile uint8_t *)&S32_SCB->SHPR3));\r\n\r\n        /* Set Priority for Cortex-M4 System Interrupts */\r\n        shpr_reg_ptr[intVectorId % 4U] = (uint8_t)(((((uint32_t)priority) << shift)) & 0xffUL);\r\n    #endif /* defined (S32K11x_SERIES) */\r\n    }\r\n    else\r\n    {\r\n        /* Set Priority for device specific Interrupts */\r\n    #if defined (S32K11x_SERIES)\r\n        uint32_t iprVectorId = (uint32_t)(irqNumber) >> 2U;\r\n        uint8_t priByteShift = (uint8_t)((((uint8_t)irqNumber) & 0x3U) << 3U);\r\n\r\n        /* Clear the old value from the register */\r\n        S32_NVIC->IPR[iprVectorId] &= ~(0xFFUL << priByteShift);\r\n\r\n        S32_NVIC->IPR[iprVectorId] |= ((uint32_t)(((((uint32_t)priority) << shift)) & 0xFFUL)) << priByteShift;\r\n    #else\r\n        S32_NVIC->IP[(uint32_t)(irqNumber)] = (uint8_t)(((((uint32_t)priority) << shift)) & 0xFFUL);\r\n    #endif /* defined (S32K11x_SERIES) */\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_GetPriority\r\n * Description   : Get the priority of an interrupt\r\n * This function will get the priority of an interrupt.\r\n * Note: The priority cannot be obtained for every core interrupt.\r\n * Implements INT_SYS_GetPriority_Activity\r\n *\r\n *END**************************************************************************/\r\nuint8_t INT_SYS_GetPriority(IRQn_Type irqNumber)\r\n{\r\n\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(FEATURE_INTERRUPT_IRQ_MIN <= irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n\r\n    uint8_t priority = 0U;\r\n    uint8_t shift = (uint8_t) (8U - FEATURE_NVIC_PRIO_BITS);\r\n\r\n    if ((int32_t)irqNumber < 0)\r\n    {\r\n        uint32_t intVectorId = ((uint32_t)(irqNumber) & 0xFU);\r\n        uint32_t regId = intVectorId / 4U;\r\n\r\n        /* Compute pointer to SHPR register - avoid MISRA violation. */\r\n    #if defined (S32K11x_SERIES)\r\n        DEV_ASSERT((int32_t)regId != 1);\r\n\r\n        volatile const uint32_t * shpr_reg_ptr = ((regId == 2U) ? (volatile uint32_t *)&S32_SCB->SHPR2 : (volatile uint32_t *)&S32_SCB->SHPR3);\r\n        uint8_t priByteShift = (uint8_t)(((uint8_t)(intVectorId) & 0x3U) << 3U);\r\n\r\n        priority = ((uint8_t)(*shpr_reg_ptr >> priByteShift)) >> shift;\r\n    #else\r\n        volatile const uint8_t * shpr_reg_ptr = ((regId == 1U) ? (volatile uint8_t *)&S32_SCB->SHPR1 : ((regId == 2U) ? (volatile uint8_t *)&S32_SCB->SHPR2 : (volatile uint8_t *)&S32_SCB->SHPR3));\r\n\r\n        /* Get Priority from Cortex-M  System Interrupts */\r\n        priority = (uint8_t)(shpr_reg_ptr[intVectorId % 4U] >> (shift));\r\n    #endif /* defined (S32K11x_SERIES) */\r\n    }\r\n    else\r\n    {\r\n        /* Get Priority for device specific Interrupts  */\r\n    #if defined (S32K11x_SERIES)\r\n        uint32_t iprVectorId = (uint32_t)(irqNumber) >> 2U;\r\n        uint8_t priByteShift = (uint8_t)((((uint8_t)(irqNumber)) & 0x3U) << 3U);\r\n        priority = ((uint8_t)(S32_NVIC->IPR[iprVectorId] >> priByteShift)) >> shift;\r\n    #else\r\n        priority = (uint8_t)(S32_NVIC->IP[(uint32_t)(irqNumber)] >> shift);\r\n    #endif /* defined (S32K11x_SERIES) */\r\n    }\r\n\r\n    return priority;\r\n}\r\n\r\n#if FEATURE_INTERRUPT_HAS_PENDING_STATE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_ClearPending\r\n * Description   : Clear Pending Interrupt\r\n * This function clears the pending bit of a peripheral interrupt\r\n * or a directed interrupt to this CPU (if available).\r\n * Implements INT_SYS_ClearPending_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_ClearPending(IRQn_Type irqNumber)\r\n{\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(0 <= (int32_t)irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n#if FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER\r\n\r\n    if ((FEATURE_DIRECTED_CPU_INT_MIN <= irqNumber) && (irqNumber <= FEATURE_DIRECTED_CPU_INT_MAX))\r\n    {\r\n        /* Clear Directed CPU Pending Interrupt */\r\n        switch (MSCM->CPXNUM)\r\n        {\r\n            case 0:\r\n                MSCM->IRCP0IR |= (1UL << ((uint32_t)irqNumber - (uint32_t)FEATURE_DIRECTED_CPU_INT_MIN));\r\n                break;\r\n            default:\r\n                MSCM->IRCP1IR |= (1UL << ((uint32_t)irqNumber - (uint32_t)FEATURE_DIRECTED_CPU_INT_MIN));\r\n                break;\r\n        }\r\n        return;\r\n    }\r\n\r\n#endif /* FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER */\r\n\r\n    /* Clear Pending Interrupt */\r\n    S32_NVIC->ICPR[(uint32_t)(irqNumber) >> 5U] = (uint32_t)(1UL << ((uint32_t)(irqNumber) & (uint32_t)0x1FU));\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_SetPending\r\n * Description   : Set Pending Interrupt\r\n * This function configures the pending bit of a peripheral interrupt.\r\n * Implements INT_SYS_SetPending_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_SetPending(IRQn_Type irqNumber)\r\n{\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(0 <= (int32_t)irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n    /* Set Pending Interrupt */\r\n    S32_NVIC->ISPR[(uint32_t)(irqNumber) >> 5U] = (uint32_t)(1UL << ((uint32_t)(irqNumber) & (uint32_t)0x1FU));\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_GetPending\r\n * Description   : Get Pending Interrupt\r\n * This function gets the pending bit of a peripheral interrupt or a directed\r\n * interrupt to this CPU (if available).\r\n * Implements INT_SYS_GetPending_Activity\r\n *\r\n *END**************************************************************************/\r\nuint32_t INT_SYS_GetPending(IRQn_Type irqNumber)\r\n{\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(0 <= (int32_t)irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n#if FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER\r\n\r\n    /* Get Directed CPU Pending Interrupt */\r\n    if ((FEATURE_DIRECTED_CPU_INT_MIN <= irqNumber) && (irqNumber <= FEATURE_DIRECTED_CPU_INT_MAX))\r\n    {\r\n        return (((((MSCM->CPXNUM != 0UL) ? MSCM->IRCP1IR : MSCM->IRCP0IR) &\r\n                  (1UL << ((uint32_t)irqNumber - (uint32_t)FEATURE_DIRECTED_CPU_INT_MIN))) != 0UL) ? 1UL : 0UL);\r\n    }\r\n\r\n#endif /* FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER */\r\n\r\n    /* Get Pending Interrupt */\r\n    return ((uint32_t)(((S32_NVIC->ISPR[(((uint32_t)irqNumber) >> 5UL)] & (1UL << (((uint32_t)irqNumber) & 0x1FUL))) != 0UL) ? 1UL : 0UL));\r\n}\r\n#endif /* FEATURE_INTERRUPT_HAS_PENDING_STATE */\r\n\r\n#if FEATURE_INTERRUPT_HAS_ACTIVE_STATE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_GetActive\r\n * Description   : Get active state of a peripheral interrupt\r\n * This function gets the active state of a peripheral interrupt.\r\n * Implements INT_SYS_GetActive_Activity\r\n *\r\n *END**************************************************************************/\r\nuint32_t INT_SYS_GetActive(IRQn_Type irqNumber)\r\n{\r\n#if (defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT))\r\n    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */\r\n    int32_t dev_irqNumber = (int32_t)irqNumber;\r\n    DEV_ASSERT(0 <= (int32_t)irqNumber);\r\n    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);\r\n#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */\r\n    /* Get Active Interrupt */\r\n    return ((uint32_t)(((S32_NVIC->IABR[(((uint32_t)irqNumber) >> 5UL)] & (1UL << (((uint32_t)irqNumber) & 0x1FUL))) != 0UL) ? 1UL : 0UL));\r\n}\r\n#endif /* FEATURE_INTERRUPT_HAS_ACTIVE_STATE */\r\n\r\n#if FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER\r\n\r\n/*!\r\n * @brief Generate Directed CPU Interrupt\r\n *\r\n * The function generates a directed interrupt to (one or more) CPUs defined by target.\r\n * Implements INT_SYS_GenerateDirectedCpuInterrupt_Activity\r\n *\r\n * @param irqNumber  IRQ number\r\n * @param cpu_target Target CPUs for the directed interrupt\r\n */\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : INT_SYS_GenerateDirectedCpuInterrupt\r\n * Description   : Get active state of a peripheral interrupt\r\n * This function gets the active state of a peripheral interrupt.\r\n * Implements INT_SYS_GenerateDirectedCpuInterrupt_Activity\r\n *\r\n *END**************************************************************************/\r\nvoid INT_SYS_GenerateDirectedCpuInterrupt(IRQn_Type irqNumber, interrupt_manager_cpu_targets_t cpu_target)\r\n{\r\n\r\n    /* Check IRQ number */\r\n    DEV_ASSERT(FEATURE_DIRECTED_CPU_INT_MIN <= irqNumber);\r\n    DEV_ASSERT(irqNumber <= FEATURE_DIRECTED_CPU_INT_MAX);\r\n\r\n    uint32_t reg_val = MSCM_IRCPGIR_INTID((uint32_t)irqNumber - (uint32_t)FEATURE_DIRECTED_CPU_INT_MIN);\r\n\r\n    switch (cpu_target)\r\n    {\r\n        case INTERRUPT_MANAGER_TARGET_SELF:\r\n            reg_val |= MSCM_IRCPGIR_TLF(2);\r\n            break;\r\n        case INTERRUPT_MANAGER_TARGET_OTHERS:\r\n            reg_val |= MSCM_IRCPGIR_TLF(1);\r\n            break;\r\n        case INTERRUPT_MANAGER_TARGET_NONE:\r\n        case INTERRUPT_MANAGER_TARGET_CP0:\r\n        case INTERRUPT_MANAGER_TARGET_CP1:\r\n        case INTERRUPT_MANAGER_TARGET_CP0_CP1:\r\n            reg_val |= (MSCM_IRCPGIR_TLF(0) | MSCM_IRCPGIR_CPUTL(cpu_target));\r\n            break;\r\n        default:\r\n            /* Not treated case ? */\r\n            break;\r\n    }\r\n\r\n    /* Generate Directed CPU Interrupt */\r\n    MSCM->IRCPGIR = reg_val;\r\n}\r\n\r\n#endif /* FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"interrupt_manager.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\inc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n#if !defined(INTERRUPT_MANAGER_H)\r\n#define INTERRUPT_MANAGER_H\r\n\r\n#include \"device_registers.h\"\r\n\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The address of hardware modules is provided as integer so\r\n * it needs to be cast to pointer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The address of hardware modules is provided as integer so\r\n * a conversion between a pointer and an integer has to be performed.\r\n */\r\n\r\n /*! @file interrupt_manager.h */\r\n\r\n/*! @addtogroup interrupt_manager*/\r\n/*! @{*/\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n#if FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER\r\n\r\n/*! @brief The target for directed CPU interrupts */\r\ntypedef enum\r\n{\r\n    INTERRUPT_MANAGER_TARGET_SELF       = -2,\r\n    INTERRUPT_MANAGER_TARGET_OTHERS     = -1,\r\n    INTERRUPT_MANAGER_TARGET_NONE       =  0,\r\n    INTERRUPT_MANAGER_TARGET_CP0        =  1,\r\n    INTERRUPT_MANAGER_TARGET_CP1        =  2,\r\n    INTERRUPT_MANAGER_TARGET_CP0_CP1    =  3\r\n} interrupt_manager_cpu_targets_t;\r\n\r\n#endif /* FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER */\r\n\r\n#if FEATURE_INTERRUPT_MULTICORE_SUPPORT\r\n\r\n/*! @brief Interrupt enabled on core\r\n *  Implements : interrupt_core_enable_t_Class\r\n */\r\ntypedef enum\r\n{\r\n\tINTERRUPT_CORE_DISABLED     = 0U,\r\n    INTERRUPT_CORE_ENABLED      = 1U\r\n} interrupt_core_enable_t;\r\n\r\n#endif /* FEATURE_INTERRUPT_MULTICORE_SUPPORT */\r\n\r\n/*! @brief Interrupt handler type */\r\ntypedef void (* isr_t)(void);\r\n\r\n/*******************************************************************************\r\n * Default interrupt handler - implemented in startup.s\r\n ******************************************************************************/\r\n/*! @brief Default ISR. */\r\nvoid DefaultISR(void);\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n/*! @name Interrupt manager APIs*/\r\n/*@{*/\r\n\r\n/*!\r\n * @brief Installs an interrupt handler routine for a given IRQ number. \r\n *\r\n * This function lets the application register/replace the interrupt\r\n * handler for a specified IRQ number. See a chip-specific reference\r\n * manual for details and the  startup_<SoC>.s file for each chip\r\n * family to find out the default interrupt handler for each device.\r\n *\r\n * @note This method is applicable only if interrupt vector is copied in RAM.\r\n *\r\n * @param irqNumber   IRQ number\r\n * @param newHandler  New interrupt handler routine address pointer\r\n * @param oldHandler  Pointer to a location to store current interrupt handler\r\n */\r\nvoid INT_SYS_InstallHandler(IRQn_Type irqNumber,\r\n                            const isr_t newHandler,\r\n                            isr_t* const oldHandler);\r\n\r\n/*!\r\n * @brief Enables an interrupt for a given IRQ number. \r\n *\r\n * This function  enables the individual interrupt for a specified IRQ number.\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_EnableIRQ(IRQn_Type irqNumber);\r\n\r\n/*!\r\n * @brief Disables an interrupt for a given IRQ number. \r\n *\r\n * This function disables the individual interrupt for a specified IRQ number.\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_DisableIRQ(IRQn_Type irqNumber);\r\n\r\n/*!\r\n * @brief Enables system interrupt.\r\n *\r\n * This function enables the global interrupt by calling the core API.\r\n *\r\n */\r\nvoid INT_SYS_EnableIRQGlobal(void);\r\n\r\n/*!\r\n * @brief Disable system interrupt. \r\n *\r\n * This function disables the global interrupt by calling the core API.\r\n *\r\n */\r\nvoid INT_SYS_DisableIRQGlobal(void);\r\n\r\n/*! @brief  Set Interrupt Priority\r\n *\r\n *   The function sets the priority of an interrupt.\r\n *\r\n *   @param  irqNumber  Interrupt number.\r\n *   @param  priority  Priority to set.\r\n */\r\nvoid INT_SYS_SetPriority(IRQn_Type irqNumber, uint8_t priority);\r\n\r\n/*! @brief  Get Interrupt Priority\r\n *\r\n *   The function gets the priority of an interrupt.\r\n *\r\n *   @param  irqNumber  Interrupt number.\r\n *   @return priority   Priority of the interrupt.\r\n */\r\nuint8_t INT_SYS_GetPriority(IRQn_Type irqNumber);\r\n\r\n#if FEATURE_INTERRUPT_HAS_PENDING_STATE\r\n/*!\r\n * @brief Clear Pending Interrupt\r\n *\r\n * The function clears the pending bit of a peripheral interrupt\r\n * or a directed interrupt to this CPU (if available).\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_ClearPending(IRQn_Type irqNumber);\r\n\r\n/*!\r\n * @brief Set Pending Interrupt\r\n *\r\n * The function configures the pending bit of a peripheral interrupt.\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_SetPending(IRQn_Type irqNumber);\r\n\r\n/*!\r\n * @brief Get Pending Interrupt\r\n *\r\n * The function gets the pending bit of a peripheral interrupt\r\n * or a directed interrupt to this CPU (if available).\r\n *\r\n * @param irqNumber IRQ number\r\n * @return pending  Pending status 0/1\r\n */\r\nuint32_t INT_SYS_GetPending(IRQn_Type irqNumber);\r\n\r\n#endif /* FEATURE_INTERRUPT_HAS_PENDING_STATE */\r\n\r\n#if FEATURE_INTERRUPT_HAS_ACTIVE_STATE\r\n/*!\r\n * @brief Get Active Interrupt\r\n *\r\n * The function gets the active state of a peripheral interrupt.\r\n *\r\n * @param irqNumber IRQ number\r\n * @return active   Active status 0/1\r\n */\r\nuint32_t INT_SYS_GetActive(IRQn_Type irqNumber);\r\n\r\n#endif /* FEATURE_INTERRUPT_HAS_ACTIVE_STATE */\r\n\r\n#if FEATURE_INTERRUPT_HAS_SOFTWARE_IRQ\r\n\r\n/*!\r\n * @brief Set software interrupt request\r\n *\r\n * The function sets a software settable interrupt request.\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_SetSoftwareIRQRequest(IRQn_Type irqNumber);\r\n\r\n/*!\r\n * @brief Clear software interrupt request\r\n *\r\n * The function clears a software settable interrupt request.\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_ClearSoftwareIRQRequest(IRQn_Type irqNumber);\r\n\r\n#endif /* FEATURE_INTERRUPT_HAS_SOFTWARE_IRQ */\r\n\r\n\r\n#if FEATURE_INTERRUPT_MULTICORE_SUPPORT\r\n\r\n/*!\r\n * @brief Enables an interrupt for a given IRQ number, on the given cores.\r\n *\r\n * This function enables the individual interrupt for a specified IRQ number,\r\n * and on the specified cores.\r\n *\r\n * @param irqNumber IRQ number\r\n * @param coresIds array with the cores ids for which to enable the interrupt\r\n * @param coresCnt the number of cores in the coresIds array\r\n */\r\nvoid INT_SYS_EnableIRQ_MC(IRQn_Type irqNumber, const uint8_t *coresIds, uint8_t coresCnt);\r\n\r\n/*!\r\n * @brief Gets the cores on which an interrupt for the specified IRQ\r\n * number is enabled.\r\n *\r\n * This function will populate an array with all the supported cores,\r\n * for which the value will be INTERRUPT_CORE_ENABLED if interrupt is enabled\r\n * on that core, and INTERRUPT_CORE_DISABLED if interrupt is not enabled on\r\n * that core. The array has to be previously allocated using the\r\n * NUMBER_OF_CORES define value.\r\n *\r\n * @param irqNumber IRQ number\r\n * @param cores array with array index as core number; it has to be previously\r\n * allocated using the NUMBER_OF_CORES define value. it will be populated with the\r\n * following value:\r\n *  - INTERRUPT_CORE_DISABLED interrupt disabled for that core\r\n * \t- INTERRUPT_CORE_ENABLED enabled for that core\r\n */\r\nvoid INT_SYS_GetCoresForIRQ(IRQn_Type irqNumber, interrupt_core_enable_t *cores);\r\n\r\n/*!\r\n * @brief Disables an interrupt for a given IRQ number, on the given cores.\r\n *\r\n * This function disables the individual interrupt for a specified IRQ number,\r\n * and on the specified cores.\r\n *\r\n * @param irqNumber IRQ number\r\n * @param coresIds array with the cores ids for which to enable the interrupt\r\n * @param coresCnt the number of cores in the coresIds array\r\n */\r\nvoid INT_SYS_DisableIRQ_MC(IRQn_Type irqNumber, const uint8_t *coresIds, uint8_t coresCnt);\r\n\r\n/*!\r\n * @brief Disables an interrupt for a given IRQ number, on all cores.\r\n *\r\n * This function disables the individual interrupt for a specified IRQ number,\r\n * on all cores. It also clears priority for that IRQ number\r\n *\r\n * @param irqNumber IRQ number\r\n */\r\nvoid INT_SYS_DisableIRQ_MC_All(IRQn_Type irqNumber);\r\n\r\n#endif /* FEATURE_INTERRUPT_MULTICORE_SUPPORT */\r\n\r\n\r\n#if FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER\r\n\r\n/*!\r\n * @brief Generate Directed CPU Interrupt\r\n *\r\n * The function generates a directed interrupt to (one or more) CPUs defined by target.\r\n *\r\n * @param irqNumber  IRQ number\r\n * @param cpu_target Target CPUs for the directed interrupt\r\n */\r\nvoid INT_SYS_GenerateDirectedCpuInterrupt(IRQn_Type irqNumber, interrupt_manager_cpu_targets_t cpu_target);\r\n\r\n#endif /* FEATURE_MSCM_HAS_CPU_INTERRUPT_ROUTER */\r\n\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n/*! @}*/\r\n\r\n#endif /* INTERRUPT_MANAGER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lin_common.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lin_common.c\r\n */\r\n\r\n/*******************************************************************************\r\n * Includes\r\n ******************************************************************************/\r\n#include \"lin_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : BIT\r\n * Description   : Return bit B in byte A\r\n * This is not a public API as it is called by other API functions.\r\n *\r\n *END**************************************************************************/\r\nstatic inline uint8_t BIT(uint8_t A,\r\n                          uint8_t B)\r\n{\r\n    return (uint8_t)((A >> B) & 0x01U);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_ProcessParity\r\n * Description   : Makes or checks parity bits. If action is checking parity, the function\r\n * returns ID value if parity bits are correct or 0xFF if parity bits are incorrect. If action\r\n * is making parity bits, then from input value of ID, the function returns PID.\r\n * This is not a public API as it is called by other API functions.\r\n *\r\n * Implements    : LIN_DRV_ProcessParity_Activity\r\n *END**************************************************************************/\r\nuint8_t LIN_DRV_ProcessParity(uint8_t PID,\r\n                              uint8_t typeAction)\r\n{\r\n    uint8_t parity;\r\n    uint8_t retVal;\r\n\r\n    parity = (uint8_t)(((0xFFU & (BIT(PID, 0U) ^ BIT(PID, 1U) ^ BIT(PID, 2U) ^ BIT(PID, 4U))) << 6U) |\r\n                       ((0xFFU ^ (BIT(PID, 1U) ^ BIT(PID, 3U) ^ BIT(PID, 4U) ^ BIT(PID, 5U))) << 7U));\r\n\r\n    /* Check if action is checking parity bits */\r\n    if (CHECK_PARITY == typeAction)\r\n    {\r\n        /* If parity bits are incorrect */\r\n        if ((PID & 0xC0U) != parity)\r\n        {\r\n            /* Return 0xFF if parity bits are incorrect */\r\n            retVal = 0xFFU;\r\n        }\r\n        /* If parity bits are correct */\r\n        else\r\n        {\r\n            /* Return ID if parity bits are correct */\r\n            retVal = (uint8_t)(PID & 0x3FU);\r\n        }\r\n    }\r\n    /* If action is making parity bits */\r\n    else\r\n    {\r\n        /* Return PID in case of making parity bits */\r\n        retVal = (uint8_t)(PID | parity);\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_MakeChecksumByte\r\n * Description   : Makes the checksum byte for a frame. For PID of identifiers,\r\n * if PID is 0x3C (ID 0x3C) or 0x7D (ID 0x3D) or 0xFE (ID 0x3E) or 0xBF (ID 0x3F)\r\n * apply classic checksum and apply enhanced checksum for other PID.\r\n * In case user want to calculate classic checksum please set PID to zero.\r\n *\r\n * Implements    : LIN_DRV_MakeChecksumByte_Activity\r\n *END**************************************************************************/\r\nuint8_t LIN_DRV_MakeChecksumByte(const uint8_t * buffer,\r\n                                 uint8_t sizeBuffer,\r\n                                 uint8_t PID)\r\n{\r\n    uint8_t length;\r\n    uint16_t checksum = 0U;\r\n\r\n    /* For PID is 0x3C (ID 0x3C) or 0x7D (ID 0x3D) or 0xFE (ID 0x3E) or 0xBF (ID 0x3F)\r\n     * apply classic checksum and apply enhanced checksum for other PID */\r\n    if ((0x3CU != PID) && (0x7DU != PID) && (0xFEU != PID) && (0xBFU != PID))\r\n    {\r\n        /* For PID other than 0x3C, 0x7D, 0xFE and 0xBF: Add PID in checksum calculation */\r\n        checksum = PID;\r\n    }\r\n    else\r\n    {\r\n        /* For 0x3C, 0x7D, 0xFE and 0xBF: Do not add PID in checksum calculation */\r\n        checksum = 0U;\r\n    }\r\n\r\n    for (length = sizeBuffer; 0U < length; length--)\r\n    {\r\n        checksum += *buffer;\r\n        buffer++;\r\n        /* Deal with the carry */\r\n        if (checksum > 0xFFU)\r\n        {\r\n            checksum -= 0xFFU;\r\n        }\r\n    }\r\n\r\n    /* Return reversed checksum */\r\n    return (uint8_t)(~checksum);\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lin_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lin_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The function is defined for use by application code.\r\n */\r\n\r\n/*******************************************************************************\r\n * Includes\r\n ******************************************************************************/\r\n#include \"lin_driver.h\"\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    #include \"lin_lpuart_driver.h\"\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_Init\r\n * Description   : This function initializes a LIN Hardware Interface for operation.\r\n * This function will initialize the run-time state structure to keep track of\r\n * the on-going transfers, ungate the clock to LIN Hardware Interface, initialize the\r\n * module to user defined settings and default settings, configure the IRQ state\r\n * structure and enable the module-level interrupt to the core, and enable the\r\n * LIN Hardware Interface transmitter and receiver.\r\n * The following is an example of how to set up the lin_state_t and the\r\n * lin_user_config_t parameters and how to call the LIN_DRV_Init function\r\n * by passing in these parameters:\r\n *    lin_user_config_t linUserConfig\r\n *    linUserConfig.baudRate = 9600\r\n *    linUserConfig.nodeFunction = SLAVE\r\n *    linUserConfig.autobaudEnable = true\r\n *    linUserConfig.timerGetTimeIntervalCallback = (lin_timer_get_time_interval_t) l_ifc_timerGetTimeIntervalCallbackHandler\r\n *    lin_state_t linState\r\n *    LIN_DRV_Init(instance, (lin_user_config_t *) &linUserConfig, (lin_state_t *) &linState)\r\n *\r\n * Implements    : LIN_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_Init(uint32_t instance,\r\n                      lin_user_config_t * linUserConfig,\r\n                      lin_state_t * linCurrentState)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_Init(instance, linUserConfig, linCurrentState);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_Deinit\r\n * Description   : This function shuts down the LIN Hardware Interface by disabling interrupts and\r\n *                 transmitter/receiver.\r\n *\r\n * Implements    : LIN_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nvoid LIN_DRV_Deinit(uint32_t instance)\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART_DRV_Deinit(instance);\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_GetDefaultConfig\r\n * Description   : This function initializes a configuration structure received\r\n * from the application with default values.\r\n *\r\n * Implements    : LIN_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid LIN_DRV_GetDefaultConfig(bool isMaster,\r\n                              lin_user_config_t * linUserConfig)\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART_DRV_GetDefaultConfig(isMaster, linUserConfig);\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_InstallCallback\r\n * Description   : This function installs the callback function that is used for LIN_DRV_IRQHandler.\r\n * Pass in Null pointer as callback will uninstall.\r\n *\r\n * Implements    : LIN_DRV_InstallCallback_Activity\r\n *END**************************************************************************/\r\nlin_callback_t LIN_DRV_InstallCallback(uint32_t instance,\r\n                                       lin_callback_t function)\r\n{\r\n    lin_callback_t retVal = NULL;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_InstallCallback(instance, function);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_SendFrameDataBlocking\r\n * Description   : This function sends data out through the LIN Hardware Interface using\r\n * blocking method. This function will calculate the checksum byte and send it with the\r\n * frame data. Blocking means that the function does not return until the transmission is\r\n * complete. This function checks if txSize is in range from 1 to 8.\r\n * If not, it will return STATUS_ERROR. This function also checks if the isBusBusy\r\n * is false, if not it will return STATUS_BUSY. The function does not return\r\n * until the transmission is complete. If the transmission is successful, it\r\n * will return STATUS_SUCCESS. If not, it will return STATUS_TIMEOUT.\r\n *\r\n * Implements    : LIN_DRV_SendFrameDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_SendFrameDataBlocking(uint32_t instance,\r\n                                       const uint8_t * txBuff,\r\n                                       uint8_t txSize,\r\n                                       uint32_t timeoutMSec)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_SendFrameDataBlocking(instance, txBuff, txSize, timeoutMSec);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_SendFrameData\r\n * Description   : This function sends data out through the LIN Hardware Interface using\r\n * non-blocking method. This function will calculate the checksum byte and send it with the\r\n * frame data. The function will return immediately after calling this function. If txSize\r\n * is equal to 0 or greater than 8 then the function will return STATUS_ERROR. If isBusBusy is\r\n * currently true then the function will return STATUS_BUSY.\r\n *\r\n * Implements    : LIN_DRV_SendFrameData_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_SendFrameData(uint32_t instance,\r\n                               const uint8_t * txBuff,\r\n                               uint8_t txSize)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_SendFrameData(instance, txBuff, txSize);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_GetTransmitStatus\r\n * Description   : This function returns whether the previous transmission has\r\n * finished. When performing non-blocking transmit, the user can call this\r\n * function to ascertain the state of the current transmission:\r\n * in progress (or busy that STATUS_BUSY) or timeout (STATUS_TIMEOUT) or complete (success that is STATUS_SUCCESS).\r\n * In addition, if the transmission is still in progress, the user can obtain the number\r\n * of bytes that still needed to transmit.\r\n *\r\n * Implements    : LIN_DRV_GetTransmitStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_GetTransmitStatus(uint32_t instance,\r\n                                   uint8_t * bytesRemaining)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_GetTransmitStatus(instance, bytesRemaining);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_ReceiveFrameDataBlocking\r\n * Description   : This function receives data from LIN Hardware Interface module using blocking\r\n * method. This function receives data from LPUART module using blocking\r\n * method, the function does not return until the receive is complete. The interrupt\r\n * handler LIN_LPUART_DRV_IRQHandler will check the checksum byte. If the checksum\r\n * is correct, it will receive the frame data. If the checksum is incorrect, this\r\n * function will return STATUS_TIMEOUT and data in rxBuff might be wrong. This function\r\n * also check if rxSize is in range from 1 to 8. If not, it will return STATUS_ERROR.\r\n * This function also checks if the isBusBusy is false, if not it will return\r\n * STATUS_BUSY.\r\n *\r\n * Implements    : LIN_DRV_ReceiveFrameDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_ReceiveFrameDataBlocking(uint32_t instance,\r\n                                          uint8_t * rxBuff,\r\n                                          uint8_t rxSize,\r\n                                          uint32_t timeoutMSec)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_RecvFrmDataBlocking(instance, rxBuff, rxSize, timeoutMSec);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_ReceiveFrameData\r\n * Description   : This function receives data from LIN Hardware Interface using\r\n * non-blocking method. This function will check the checksum byte. If the checksum is\r\n * correct, it will receive it with the frame data.\r\n * Non-blocking  means that the function returns immediately.\r\n * The application has to get the receive status to know when the reception is complete.\r\n * The interrupt handler LIN_LPUART_DRV_IRQHandler will check the checksum byte. If the\r\n * checksum is correct, it will receive the frame data. If the checksum is incorrect, this\r\n * function will return STATUS_TIMEOUT and data in rxBuff might be wrong. This function also\r\n * check if rxSize is in range from 1 to 8. If not, it will return STATUS_ERROR. This function\r\n * also checks if the isBusBusy is false, if not it will return STATUS_BUSY.\r\n *\r\n * Implements    : LIN_DRV_ReceiveFrameData_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_ReceiveFrameData(uint32_t instance,\r\n                                  uint8_t * rxBuff,\r\n                                  uint8_t rxSize)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_RecvFrmData(instance, rxBuff, rxSize);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_AbortTransferData\r\n * Description   : Aborts an on-going non-blocking transmission/reception.\r\n * While performing a non-blocking transferring data, users can call this\r\n * function to terminate immediately the transferring.\r\n *\r\n * Implements    : LIN_DRV_AbortTransferData_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_AbortTransferData(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_AbortTransferData(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_GetReceiveStatus\r\n * Description   : This function returns whether the data reception is complete.\r\n * When performing non-blocking transmit, the user can call this function to\r\n * ascertain the state of the current receive progress:\r\n * in progress (STATUS_BUSY) or timeout (STATUS_TIMEOUT) or complete (STATUS_SUCCESS).\r\n * In addition, if the reception is still in progress, the user can obtain the\r\n * number of bytes that still needed to receive.\r\n *\r\n * Implements    : LIN_DRV_GetReceiveStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_GetReceiveStatus(uint32_t instance,\r\n                                  uint8_t * bytesRemaining)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_GetReceiveStatus(instance, bytesRemaining);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_GoToSleepMode\r\n * Description   : This function puts current LIN node to sleep mode.\r\n * This function changes current node state to LIN_NODE_STATE_SLEEP_MODE.\r\n *\r\n * Implements    : LIN_DRV_GoToSleepMode_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_GoToSleepMode(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_GoToSleepMode(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_GotoIdleState\r\n * Description   : This function puts current node to Idle state.\r\n *\r\n * Implements    : LIN_DRV_GoToIdleState_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_GotoIdleState(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_GotoIdleState(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_SendWakeupSignal\r\n * Description   : This function sends a wakeup signal through the LPUART interface.\r\n *\r\n * Implements    : LIN_DRV_SendWakeupSignal_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_SendWakeupSignal(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_SendWakeupSignal(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_GetCurrentNodeState\r\n * Description   : This function gets the current LIN node state.\r\n *\r\n * Implements    : LIN_DRV_GetCurrentNodeState_Activity\r\n *END**************************************************************************/\r\nlin_node_state_t LIN_DRV_GetCurrentNodeState(uint32_t instance)\r\n{\r\n    lin_node_state_t retVal = LIN_NODE_STATE_UNINIT;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_GetCurrentNodeState(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_TimeoutService\r\n * Description   : This is callback function for Timer Interrupt Handler.\r\n * Users shall initialize a timer (for example FTM) in Output compare mode\r\n * with period of 500 micro seconds. In timer IRQ handler, call this function.\r\n *\r\n * Implements    : LIN_DRV_TimeoutService_Activity\r\n *END**************************************************************************/\r\nvoid LIN_DRV_TimeoutService(uint32_t instance)\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART_DRV_TimeoutService(instance);\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_SetTimeoutCounter\r\n * Description   : This function sets value for timeout counter that is used in\r\n * LIN_DRV_TimeoutService\r\n *\r\n * Implements    : LIN_DRV_SetTimeoutCounter_Activity\r\n *END**************************************************************************/\r\nvoid LIN_DRV_SetTimeoutCounter(uint32_t instance,\r\n                               uint32_t timeoutValue)\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART_DRV_SetTimeoutCounter(instance, timeoutValue);\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_MasterSendHeader\r\n * Description   : This function sends frame header out through the LIN Hardware Interface\r\n * using a non-blocking method. Non-blocking  means that the function returns\r\n * immediately. This function sends LIN Break field, sync field then the ID with\r\n * correct parity. This function checks if the interface is Master, if not, it will\r\n * return STATUS_ERROR.This function checks if id is in range from 0 to 0x3F, if not\r\n * it will return STATUS_ERROR.\r\n *\r\n * Implements    : LIN_DRV_MasterSendHeader_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_MasterSendHeader(uint32_t instance,\r\n                                  uint8_t id)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_MasterSendHeader(instance, id);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_EnableIRQ\r\n * Description   : This function enables LIN hardware interrupts.\r\n *\r\n * Implements    : LIN_DRV_EnableIRQ_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_EnableIRQ(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_EnableIRQ(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_DisableIRQ\r\n * Description   : This function disables LIN hardware interrupts.\r\n *\r\n * Implements    : LIN_DRV_DisableIRQ_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_DRV_DisableIRQ(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_DisableIRQ(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_DRV_IRQHandler\r\n * Description   : Interrupt handler for LIN Hardware Interface.\r\n * This is not a public API as it is called by IRQ whenever an interrupt\r\n * occurs.\r\n *\r\n * Implements    : LIN_DRV_IRQHandler_Activity\r\n *END**************************************************************************/\r\nvoid LIN_DRV_IRQHandler(uint32_t instance)\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART_DRV_IRQHandler(instance);\r\n#endif\r\n}\r\n\r\n /*FUNCTION**********************************************************************\r\n  *\r\n  * Function Name : LIN_DRV_AutoBaudCapture\r\n  * Description   : This function capture bits time to detect break char, calculate\r\n  * baudrate from sync bits and enable transceiver if autobaud successful.\r\n  * This function should only be used in Slave.\r\n  * The timer should be in mode input capture of both rising and falling edges.\r\n  * The timer input capture pin should be externally connected to RXD pin.\r\n  *\r\n  * Implements    : LIN_DRV_AutoBaudCapture_Activity\r\n  *END**************************************************************************/\r\nstatus_t LIN_DRV_AutoBaudCapture(uint32_t instance)\r\n{\r\n    status_t retVal = STATUS_UNSUPPORTED;\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    retVal = LIN_LPUART_DRV_AutoBaudCapture(instance);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lin_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n** * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lin_driver.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, A project should not contain unused macro declarations\r\n * This exception is being added for MASTER and SLAVE defines that are not used by LIN Stack\r\n * code.\r\n */\r\n\r\n#ifndef LIN_DRIVER_H\r\n#define LIN_DRIVER_H\r\n\r\n/*******************************************************************************\r\n * Includes\r\n ******************************************************************************/\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n#include \"status.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"osif.h\"\r\n\r\n/*!\r\n * @addtogroup lin_driver\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n#define SLAVE  0U\r\n#define MASTER 1U\r\n#define MAKE_PARITY 0U\r\n#define CHECK_PARITY 1U\r\n\r\n/* Table to save ISR pointers for LPUART instances */\r\nextern isr_t g_linLpuartIsrs[LPUART_INSTANCE_COUNT];\r\n\r\n#ifdef LPUART_ERR_IRQS\r\n/* Table to save ERR ISR pointers for LPUART instances */\r\nextern isr_t g_linLpuartErrIsrs[LPUART_INSTANCE_COUNT];\r\n#endif\r\n\r\n/*!\r\n * @brief Callback function to get time interval in nanoseconds\r\n * Implements : lin_timer_get_time_interval_t_Class\r\n */\r\ntypedef uint32_t (* lin_timer_get_time_interval_t) (uint32_t *nanoSeconds);\r\n\r\n/*!\r\n * @brief LIN hardware configuration structure\r\n * Implements : lin_user_config_t_Class\r\n */\r\ntypedef struct {\r\n    uint32_t baudRate;                        /*!< baudrate of LIN Hardware Interface to configure */\r\n    bool nodeFunction;                        /*!< Node function as Master or Slave */\r\n    bool autobaudEnable;                      /*!< Enable Autobaud feature */\r\n    lin_timer_get_time_interval_t timerGetTimeIntervalCallback;    /*!< Callback function to get time interval in nanoseconds */\r\n    uint8_t *classicPID;                      /*!< List of PIDs use classic checksum */\r\n    uint8_t numOfClassicPID;                  /*!< Number of PIDs use classic checksum */\r\n} lin_user_config_t;\r\n\r\n/*!\r\n * @brief Defines types for an enumerating event related to an Identifier.\r\n * Implements : lin_event_id_t_Class\r\n */\r\ntypedef enum {\r\n    LIN_NO_EVENT             = 0x00U,    /*!< No event yet */\r\n    LIN_WAKEUP_SIGNAL        = 0x01U,    /*!< Received a wakeup signal */\r\n    LIN_BAUDRATE_ADJUSTED    = 0x02U,    /*!< Indicate that baudrate was adjusted to Master's baudrate */\r\n    LIN_RECV_BREAK_FIELD_OK  = 0x03U,    /*!< Indicate that correct Break Field was received */\r\n    LIN_SYNC_OK              = 0x04U,    /*!< Sync byte is correct */\r\n    LIN_SYNC_ERROR           = 0x05U,    /*!< Sync byte is incorrect */\r\n    LIN_PID_OK               = 0x06U,    /*!< PID correct */\r\n    LIN_PID_ERROR            = 0x07U,    /*!< PID incorrect */\r\n    LIN_FRAME_ERROR          = 0x08U,    /*!< Framing Error */\r\n    LIN_READBACK_ERROR       = 0x09U,    /*!< Readback data is incorrect */\r\n    LIN_CHECKSUM_ERROR       = 0x0AU,    /*!< Checksum byte is incorrect */\r\n    LIN_TX_COMPLETED         = 0x0BU,    /*!< Sending data completed */\r\n    LIN_RX_COMPLETED         = 0x0CU,    /*!< Receiving data completed */\r\n    LIN_RX_OVERRUN           = 0x0DU     /*!< RX overrun flag */\r\n} lin_event_id_t;\r\n\r\n/*!\r\n * @brief Define type for an enumerating LIN Node state.\r\n * Implements : lin_node_state_t_Class\r\n */\r\ntypedef enum {\r\n    LIN_NODE_STATE_UNINIT                 = 0x00U,    /*!< Uninitialized state */\r\n    LIN_NODE_STATE_SLEEP_MODE             = 0x01U,    /*!< Sleep mode state */\r\n    LIN_NODE_STATE_IDLE                   = 0x02U,    /*!< Idle state */\r\n    LIN_NODE_STATE_SEND_BREAK_FIELD       = 0x03U,    /*!< Send break field state */\r\n    LIN_NODE_STATE_RECV_SYNC              = 0x04U,    /*!< Receive the synchronization byte state */\r\n    LIN_NODE_STATE_SEND_PID               = 0x05U,    /*!< Send PID state */\r\n    LIN_NODE_STATE_RECV_PID               = 0x06U,    /*!< Receive PID state */\r\n    LIN_NODE_STATE_RECV_DATA              = 0x07U,    /*!< Receive data state */\r\n    LIN_NODE_STATE_RECV_DATA_COMPLETED    = 0x08U,    /*!< Receive data completed state */\r\n    LIN_NODE_STATE_SEND_DATA              = 0x09U,    /*!< Send data state */\r\n    LIN_NODE_STATE_SEND_DATA_COMPLETED    = 0x0AU     /*!< Send data completed state */\r\n} lin_node_state_t;\r\n\r\n/*!\r\n * @brief LIN Driver callback function type\r\n * Implements : lin_callback_t_Class\r\n */\r\ntypedef void (* lin_callback_t)(uint32_t instance, void * linState);\r\n\r\n/*!\r\n * @brief Runtime state of the LIN driver.\r\n *\r\n * Note that the caller provides memory for the driver state structures during\r\n * initialization because the driver does not statically allocate memory.\r\n * Implements : lin_state_t_Class\r\n */\r\ntypedef struct {\r\n    const uint8_t * txBuff;                     /*!< The buffer of data being sent. */\r\n    uint8_t * rxBuff;                           /*!< The buffer of received data. */\r\n    uint8_t cntByte;                            /*!< To count number of bytes already transmitted or received. */\r\n    volatile uint8_t txSize;                    /*!< The remaining number of bytes to be transmitted. */\r\n    volatile uint8_t rxSize;                    /*!< The remaining number of bytes to be received. */\r\n    uint8_t checkSum;                           /*!< Checksum byte. */\r\n    volatile bool isTxBusy;                     /*!< True if the LIN interface is transmitting frame data. */\r\n    volatile bool isRxBusy;                     /*!< True if the LIN interface is receiving frame data. */\r\n    volatile bool isBusBusy;                    /*!< True if there are data, frame headers being transferred on bus */\r\n    volatile bool isTxBlocking;                 /*!< True if transmit is blocking transaction. */\r\n    volatile bool isRxBlocking;                 /*!< True if receive is blocking transaction. */\r\n    lin_callback_t Callback;                    /*!< Callback function to invoke after receiving a byte or transmitting a byte. */\r\n    uint8_t currentId;                          /*!< Current ID */\r\n    uint8_t currentPid;                         /*!< Current PID */\r\n    volatile lin_event_id_t currentEventId;     /*!< Current ID Event */\r\n    volatile lin_node_state_t currentNodeState; /*!< Current Node state */\r\n    volatile uint32_t timeoutCounter;           /*!< Value of the timeout counter */\r\n    volatile bool timeoutCounterFlag;           /*!< Timeout counter flag */\r\n    volatile bool baudrateEvalEnable;           /*!< Baudrate Evaluation Process Enable */\r\n    volatile uint8_t fallingEdgeInterruptCount; /*!< Falling Edge count of a sync byte */\r\n    uint32_t linSourceClockFreq;                /*!< Frequency of the source clock for LIN */\r\n    semaphore_t txCompleted;                    /*!< Used to wait for LIN interface ISR to complete transmission.*/\r\n    semaphore_t rxCompleted;                    /*!< Used to wait for LIN interface ISR to complete reception*/\r\n} lin_state_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name LIN DRIVER\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Initializes an instance LIN Hardware Interface for LIN Network.\r\n *\r\n * The caller provides memory for the driver state structures during initialization.\r\n * The user must select the LIN Hardware Interface clock source in the application to initialize the LIN Hardware Interface.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param linUserConfig user configuration structure of type #lin_user_config_t\r\n * @param linCurrentState pointer to the LIN Hardware Interface driver state structure\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : Operation was successful.\r\n *         - STATUS_ERROR   : Operation failed due to semaphores initialize error.\r\n */\r\nstatus_t LIN_DRV_Init(uint32_t instance,\r\n                      lin_user_config_t * linUserConfig,\r\n                      lin_state_t * linCurrentState);\r\n\r\n/*!\r\n * @brief Shuts down the LIN Hardware Interface by disabling interrupts and transmitter/receiver.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return void\r\n */\r\nvoid LIN_DRV_Deinit(uint32_t instance);\r\n\r\n/*!\r\n * @brief Initializes the LIN user configuration structure with default values.\r\n *\r\n * This function initializes a configuration structure received from the application\r\n * with default values.\r\n * Note: Users shall assign measurement callback function pointer that is timerGetTimeIntervalCallback\r\n * for linUserConfig. Users can see detail in doxygen.\r\n *\r\n * @param[in] isMaster Node function:\r\n                - true if node is MASTER\r\n                - false if node is SLAVE\r\n * @param[out] linUserConfig the default configuration\r\n * @return void\r\n */\r\nvoid LIN_DRV_GetDefaultConfig(bool isMaster,\r\n                              lin_user_config_t * linUserConfig);\r\n\r\n/*!\r\n * @brief Installs callback function that is used for LIN_DRV_IRQHandler.\r\n *\r\n * @note After a callback is installed, it bypasses part of the LIN Hardware Interface IRQHandler logic.\r\n * Therefore, the callback needs to handle the indexes of txBuff and txSize.\r\n *\r\n * @param instance LIN Hardware Interface instance number.\r\n * @param function the LIN receive callback function.\r\n * @return Former LIN callback function pointer.\r\n */\r\nlin_callback_t LIN_DRV_InstallCallback(uint32_t instance,\r\n                                       lin_callback_t function);\r\n\r\n/*!\r\n * @brief Sends Frame data out through the LIN Hardware Interface using blocking method.\r\n *  This function will calculate the checksum byte and send it with the frame data.\r\n *  Blocking means that the function does not return until the transmission is complete.\r\n *  This function checks if txSize is in range from 1 to 8.\r\n *  If not, it will return STATUS_ERROR. This function also returns STATUS_ERROR\r\n *  if node's current state is in SLEEP mode. This function checks if the isBusBusy\r\n *  is false, if not it will return LIN_BUS_BUSY. The function does not return\r\n *  until the transmission is complete. If the transmission is successful, it\r\n *  will return STATUS_SUCCESS. If not, it will return STATUS_TIMEOUT.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param txBuff source buffer containing 8-bit data chars to send\r\n * @param txSize the number of bytes to send\r\n * @param timeoutMSec timeout value in milliseconds\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_TIMEOUT : The transmission isn't successful.\r\n */\r\nstatus_t LIN_DRV_SendFrameDataBlocking(uint32_t instance,\r\n                                       const uint8_t * txBuff,\r\n                                       uint8_t txSize,\r\n                                       uint32_t timeoutMSec);\r\n\r\n/*!\r\n * @brief Sends frame data out through the LIN Hardware Interface using non-blocking method.\r\n *  This enables an a-sync method for transmitting data.\r\n *  Non-blocking  means that the function returns immediately.\r\n *  The application has to get the transmit status to know when the transmit is complete.\r\n *  This function will calculate the checksum byte and send it with the frame data. The\r\n *  function will return immediately after calling this function. If txSize is equal to 0\r\n *  or greater than 8 or node's current state is in SLEEP mode then the function will\r\n *  return STATUS_ERROR. If isBusBusy is currently true then the function will\r\n *  return LIN_BUS_BUSY.\r\n * @note If users use LIN_DRV_TimeoutService in a timer interrupt handler, then before using this function,\r\n * users have to set timeout counter to an appropriate value by using LIN_DRV_SetTimeoutCounter(instance, timeoutValue).\r\n * The timeout value should be big enough to complete the transmission. Timeout in real time is (timeoutValue) * (time\r\n * period that LIN_DRV_TimeoutService is called). For example, if LIN_DRV_TimeoutService is called in an timer\r\n * interrupt with period of 500 micro seconds, then timeout in real time is\r\n * timeoutValue * 500 micro seconds.\r\n * @param instance LIN Hardware Interface instance number\r\n * @param txBuff  source buffer containing 8-bit data chars to send\r\n * @param txSize  the number of bytes to send\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_BUSY    : Operation failed due to isBusBusy is currently true.\r\n *         - STATUS_ERROR   : Operation failed due to txSize is equal to 0 or greater than 8\r\n *                            or node's current state is in SLEEP mode\r\n */\r\nstatus_t LIN_DRV_SendFrameData(uint32_t instance,\r\n                               const uint8_t * txBuff,\r\n                               uint8_t txSize);\r\n\r\n/*!\r\n * @brief Get status of an on-going non-blocking transmission\r\n *  While sending frame data using non-blocking method, users can\r\n *  use this function to get status of that transmission.\r\n *  The bytesRemaining shows number of bytes that still needed to transmit.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param bytesRemaining Number of bytes still needed to transmit\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_BUSY    : The transmission is sending\r\n *         - STATUS_TIMEOUT : Operation failed due to timeout has occurred.\r\n */\r\nstatus_t LIN_DRV_GetTransmitStatus(uint32_t instance,\r\n                                   uint8_t * bytesRemaining);\r\n\r\n/*!\r\n * @brief Receives frame data through the LIN Hardware Interface using blocking method.\r\n *  This function receives data from LPUART module using blocking\r\n *  method, the function does not return until the receive is complete. The interrupt\r\n *  handler LIN_LPUART_DRV_IRQHandler will check the checksum byte. If the checksum\r\n *  is correct, it will receive the frame data. If the checksum is incorrect, this\r\n *  function will return STATUS_TIMEOUT and data in rxBuff might be wrong. This function\r\n *  also check if rxSize is in range from 1 to 8. If not, it will return STATUS_ERROR.\r\n *  This function also returns STATUS_ERROR if node's current state is in SLEEP mode.\r\n *  This function checks if the isBusBusy is false, if not it will return\r\n *  LIN_BUS_BUSY.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param rxBuff  buffer containing 8-bit received data\r\n * @param rxSize the number of bytes to receive\r\n * @param timeoutMSec timeout value in milliseconds\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The receives frame data is successful.\r\n *         - STATUS_TIMEOUT : The checksum is incorrect.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n *         - STATUS_ERROR   : Operation failed due is equal to 0 or greater than 8 or\r\n *                            node's current state is in SLEEP mode\r\n */\r\nstatus_t LIN_DRV_ReceiveFrameDataBlocking(uint32_t instance,\r\n                                          uint8_t * rxBuff,\r\n                                          uint8_t rxSize,\r\n                                          uint32_t timeoutMSec);\r\n\r\n/*!\r\n * @brief Receives frame data through the LIN Hardware Interface using non-blocking method.\r\n *  This function will check the checksum byte. If the checksum is correct, it\r\n *  will receive it with the frame data.\r\n *  Non-blocking  means that the function returns immediately.\r\n *  The application has to get the receive status to know when the reception is complete.\r\n *  The interrupt handler LIN_LPUART_DRV_IRQHandler will check the checksum byte. If the\r\n *  checksum is correct, it will receive the frame data. If the checksum is incorrect, this\r\n *  function will return STATUS_TIMEOUT and data in rxBuff might be wrong. This function also\r\n *  check if rxSize is in range from 1 to 8. If not, it will return STATUS_ERROR. This function\r\n *  also returns STATUS_ERROR if node's current state is in SLEEP mode. This function checks\r\n *  if the isBusBusy is false, if not it will return LIN_BUS_BUSY.\r\n * @note If users use LIN_DRV_TimeoutService in a timer interrupt handler, then before using this function,\r\n * users have to set timeout counter to an appropriate value by using LIN_DRV_SetTimeoutCounter(instance, timeoutValue).\r\n * The timeout value should be big enough to complete the reception. Timeout in real time is (timeoutValue) * (time period\r\n * that LIN_DRV_TimeoutService is called). For example, if LIN_DRV_TimeoutService is called in an timer\r\n * interrupt with period of 500 micro seconds, then timeout in real time is\r\n * timeoutValue * 500 micro seconds.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param rxBuff  buffer containing 8-bit received data\r\n * @param rxSize the number of bytes to receive\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The receives frame data is successful.\r\n *         - STATUS_TIMEOUT : The checksum is incorrect.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n *         - STATUS_ERROR   : Operation failed due is equal to 0 or greater than 8 or\r\n *                            node's current state is in SLEEP mode\r\n */\r\nstatus_t LIN_DRV_ReceiveFrameData(uint32_t instance,\r\n                                  uint8_t * rxBuff,\r\n                                  uint8_t rxSize);\r\n\r\n/*!\r\n * @brief Aborts an on-going non-blocking transmission/reception.\r\n *  While performing a non-blocking transferring data, users can call this function\r\n *  to terminate immediately the transferring.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return function always return STATUS_SUCCESS\r\n */\r\nstatus_t LIN_DRV_AbortTransferData(uint32_t instance);\r\n\r\n/*!\r\n * @brief Get status of an on-going non-blocking reception.\r\n *  This function returns whether the data reception is complete.\r\n *  When performing non-blocking transmit, the user can call this function to\r\n *  ascertain the state of the current receive progress:\r\n *  in progress (STATUS_BUSY) or timeout (STATUS_TIMEOUT) or complete (STATUS_SUCCESS).\r\n *  In addition, if the reception is still in progress, the user can obtain the\r\n *  number of bytes that still needed to receive.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param bytesRemaining Number of bytes still needed to receive\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The reception is complete.\r\n *         - STATUS_TIMEOUT : The reception isn't complete.\r\n *         - STATUS_BUSY    : The reception is on going\r\n */\r\nstatus_t LIN_DRV_GetReceiveStatus(uint32_t instance,\r\n                                  uint8_t * bytesRemaining);\r\n\r\n/*!\r\n * @brief Puts current LIN node to sleep mode\r\n * This function changes current node state to LIN_NODE_STATE_SLEEP_MODE\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return function always return STATUS_SUCCESS\r\n */\r\nstatus_t LIN_DRV_GoToSleepMode(uint32_t instance);\r\n\r\n/*!\r\n * @brief Puts current LIN node to Idle state\r\n * This function changes current node state to LIN_NODE_STATE_IDLE\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return function always return STATUS_SUCCESS\r\n */\r\nstatus_t LIN_DRV_GotoIdleState(uint32_t instance);\r\n\r\n/*!\r\n * @brief Sends a wakeup signal through the LIN Hardware Interface\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : Bus busy flag is false.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n */\r\nstatus_t LIN_DRV_SendWakeupSignal(uint32_t instance);\r\n\r\n/*!\r\n * @brief Get the current LIN node state\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return current LIN node state\r\n */\r\nlin_node_state_t LIN_DRV_GetCurrentNodeState (uint32_t instance);\r\n\r\n/*!\r\n * @brief Callback function for Timer Interrupt Handler\r\n * Users may use (optional, not required) LIN_DRV_TimeoutService to check if timeout has occurred during non-blocking frame data\r\n * transmission and reception. User may initialize a timer (for example FTM) in Output Compare Mode\r\n * with period of 500 micro seconds (recommended). In timer IRQ handler, call this function.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return void\r\n */\r\nvoid LIN_DRV_TimeoutService(uint32_t instance);\r\n\r\n/*!\r\n * @brief Set Value for Timeout Counter that is used in LIN_DRV_TimeoutService\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param timeoutValue  Timeout Value to be set\r\n * @return void\r\n */\r\nvoid LIN_DRV_SetTimeoutCounter(uint32_t instance,\r\n                               uint32_t timeoutValue);\r\n\r\n/*!\r\n * @brief Sends frame header out through the LIN Hardware Interface using a non-blocking method.\r\n * This function sends LIN Break field, sync field then the ID with\r\n * correct parity. This function checks if the interface is Master, if not, it will\r\n * return STATUS_ERROR.This function checks if id is in range from 0 to 0x3F, if not\r\n * it will return STATUS_ERROR.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @param id  Frame Identifier\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n *         - STATUS_ERROR   : The interface isn't Master or id isn't in range from 0 to 0x3F\r\n *                            or node's current state is in SLEEP mode.\r\n */\r\nstatus_t LIN_DRV_MasterSendHeader(uint32_t instance,\r\n                                  uint8_t id);\r\n\r\n/*!\r\n * @brief Enables LIN hardware interrupts.\r\n *\r\n * @param instance LIN Hardware Interface instance number.\r\n * @return function always return STATUS_SUCCESS.\r\n */\r\nstatus_t LIN_DRV_EnableIRQ(uint32_t instance);\r\n\r\n/*!\r\n * @brief Disables LIN hardware interrupts.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return function always return STATUS_SUCCESS.\r\n */\r\nstatus_t LIN_DRV_DisableIRQ(uint32_t instance);\r\n\r\n/*!\r\n * @brief Interrupt handler for LIN Hardware Interface.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return void\r\n */\r\nvoid LIN_DRV_IRQHandler(uint32_t instance);\r\n\r\n\r\n/*!\r\n * @brief Makes or checks parity bits. If action is checking parity, the function\r\n * returns ID value if parity bits are correct or 0xFF if parity bits are incorrect. If action\r\n * is making parity bits, then from input value of ID, the function returns PID.\r\n * This is not a public API as it is called by other API functions.\r\n *\r\n * @param PID PID byte in case of checking parity bits or ID byte in case of making parity bits.\r\n * @param typeAction: 1 for Checking parity bits, 0 for making parity bits\r\n * @return Value has 8 bit:\r\n *         - 0xFF : Parity bits are incorrect,\r\n *         - ID   : Checking parity bits are correct.\r\n *         - PID  : typeAction is making parity bits.\r\n */\r\nuint8_t LIN_DRV_ProcessParity(uint8_t PID,\r\n                              uint8_t typeAction);\r\n\r\n/*!\r\n * @brief Makes the checksum byte for a frame. For PID of identifiers,\r\n * if PID is 0x3C (ID 0x3C) or 0x7D (ID 0x3D) or 0xFE (ID 0x3E) or 0xBF (ID 0x3F)\r\n * apply classic checksum and apply enhanced checksum for other PID.\r\n * In case user want to calculate classic checksum please set PID to zero.\r\n *\r\n * @param buffer Pointer to Tx buffer\r\n * @param sizeBuffer Number of bytes that are contained in the buffer.\r\n * @param PID Protected Identifier byte.\r\n * @return the checksum byte.\r\n */\r\nuint8_t LIN_DRV_MakeChecksumByte(const uint8_t *buffer,\r\n                                 uint8_t sizeBuffer,\r\n                                 uint8_t PID);\r\n\r\n/*!\r\n * @brief Captures time interval to capture baudrate automatically\r\n * when enable autobaud feature.\r\n * This function should only be used in Slave.\r\n * The timer should be in input capture mode of both rising and falling edges.\r\n * The timer input capture pin should be externally connected to RXD pin.\r\n *\r\n * @param instance LIN Hardware Interface instance number\r\n * @return operation status\r\n *        - STATUS_SUCCESS: Operation was successful.\r\n *        - STATUS_BUSY:    Operation is running.\r\n *        - STATUS_ERROR:   Operation failed due to break char incorrect,\r\n *                          wakeup signal incorrect\r\n *                          or calculate baudrate failed.\r\n */\r\nstatus_t LIN_DRV_AutoBaudCapture(uint32_t instance);\r\n\r\n/* @} */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n#endif /* LIN_DRIVER_H */\r\n/******************************************************************************/\r\n/* EOF */\r\n/******************************************************************************/\r\n"},{"name":"lin_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lin_irq.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, A compatible declaration shall be\r\n * visible when an object or function with external linkage is defined.\r\n * Folder structure has only C source file for interrupt routine.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, An object should be defined at block\r\n * scope if its identifier only appears in a single function.\r\n * An object with static storage duration declared at block scope cannot be\r\n * accessed directly from outside the block.\r\n */\r\n\r\n/*******************************************************************************\r\n * Includes\r\n ******************************************************************************/\r\n#include \"lin_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\nstatic void LIN_LPUART0_RxTx_IRQHandler(void)\r\n{\r\n    LIN_DRV_IRQHandler(0U);\r\n}\r\n\r\n#ifdef LPUART_ERR_IRQS\r\nstatic void LIN_LPUART0_ERR_IRQHandler(void)\r\n{\r\n    LIN_DRV_IRQHandler(0U);\r\n}\r\n#endif\r\n#endif /* if (LPUART_INSTANCE_COUNT > 0U) */\r\n\r\n#if (LPUART_INSTANCE_COUNT > 1U)\r\nstatic void LIN_LPUART1_RxTx_IRQHandler(void)\r\n{\r\n    LIN_DRV_IRQHandler(1U);\r\n}\r\n\r\n#ifdef LPUART_ERR_IRQS\r\nstatic void LIN_LPUART1_ERR_IRQHandler(void)\r\n{\r\n    LIN_DRV_IRQHandler(1U);\r\n}\r\n#endif\r\n#endif /* if (LPUART_INSTANCE_COUNT > 1U) */\r\n\r\n#if (LPUART_INSTANCE_COUNT > 2U)\r\nstatic void LIN_LPUART2_RxTx_IRQHandler(void)\r\n{\r\n    LIN_DRV_IRQHandler(2U);\r\n}\r\n\r\n#ifdef LPUART_ERR_IRQS\r\nstatic void LIN_LPUART2_ERR_IRQHandler(void)\r\n{\r\n    LIN_DRV_IRQHandler(2U);\r\n}\r\n#endif\r\n#endif /* if (LPUART_INSTANCE_COUNT > 2U) */\r\n\r\nisr_t g_linLpuartIsrs[LPUART_INSTANCE_COUNT] =\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART0_RxTx_IRQHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 1U)\r\n    LIN_LPUART1_RxTx_IRQHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 2U)\r\n    LIN_LPUART2_RxTx_IRQHandler,\r\n#endif\r\n};\r\n\r\n#ifdef LPUART_ERR_IRQS\r\nisr_t g_linLpuartErrIsrs[LPUART_INSTANCE_COUNT] =\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LIN_LPUART0_ERR_IRQHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 1U)\r\n    LIN_LPUART1_ERR_IRQHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 2U)\r\n    LIN_LPUART2_ERR_IRQHandler,\r\n#endif\r\n};\r\n#endif\r\n/******************************************************************************/\r\n/* EOF */\r\n/******************************************************************************/\r\n"},{"name":"lin_lpuart_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lin_lpuart_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, Taking address of near auto variable.\r\n * The code is not dynamically linked. An absolute stack address is obtained\r\n * when taking the address of the near auto variable. A source of error in\r\n * writing dynamic code is that the stack segment may be different from the data\r\n * segment.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, Could define variables 'g_linLpuartIsrs',\r\n * 'g_linLpuartErrIsrs' at block scope.\r\n * These variables are used all over lin_lpuart driver so they must remain global.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to initialize a pointer with an unsigned int define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from pointer to unsigned int.\r\n * The cast is required to initialize a pointer with an unsigned int define,\r\n * representing an address.\r\n */\r\n\r\n/*******************************************************************************\r\n * Includes\r\n ******************************************************************************/\r\n#include \"lin_lpuart_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/* Table of base addresses for LPUART instances. */\r\nLPUART_Type * const g_linLpuartBase[LPUART_INSTANCE_COUNT] = LPUART_BASE_PTRS;\r\n\r\n/* Table to save LPUART IRQ enumeration numbers defined in the CMSIS header file */\r\nconst IRQn_Type g_linLpuartRxTxIrqId[LPUART_INSTANCE_COUNT] = LPUART_RX_TX_IRQS;\r\n\r\n#ifdef LPUART_ERR_IRQS\r\n/* Table to save LPUART_ERR IRQ enumeration numbers defined in the device header file */\r\nconst IRQn_Type g_linLpuartErrIrqId[LPUART_INSTANCE_COUNT] = LPUART_ERR_IRQS;\r\n#endif\r\n\r\n/* Table to save LPUART state structure pointers */\r\nlin_state_t * g_linStatePtr[LPUART_INSTANCE_COUNT] = {NULL};\r\n\r\n/* Table to save LIN user config structure pointers */\r\nlin_user_config_t * g_linUserconfigPtr[LPUART_INSTANCE_COUNT] = {NULL};\r\n\r\n/*******************************************************************************\r\n * Static variables\r\n ******************************************************************************/\r\nstatic uint32_t s_previousTwoBitTimeLength[LPUART_INSTANCE_COUNT] = {0U};\r\nstatic uint8_t s_wakeupSignal[LPUART_INSTANCE_COUNT] = {0U};\r\nstatic uint8_t s_countMeasure[LPUART_INSTANCE_COUNT] = {0U};\r\nstatic uint32_t s_timeMeasure[LPUART_INSTANCE_COUNT] = {0U};\r\nstatic const clock_names_t s_linLpuartClkName[LPUART_INSTANCE_COUNT] = LPUART_CLOCK_NAMES;\r\n\r\n/*******************************************************************************\r\n * Static function prototypes\r\n ******************************************************************************/\r\n\r\nstatic status_t LIN_LPUART_DRV_WaitComplete(uint32_t instance,\r\n                                            uint32_t timeoutMSec);\r\n\r\nstatic void LIN_LPUART_DRV_ProcessBreakDetect(uint32_t instance);\r\n\r\nstatic void LIN_LPUART_DRV_CheckWakeupSignal(uint32_t instance);\r\n\r\nstatic void LIN_LPUART_DRV_ProcessFrame(uint32_t instance,\r\n                                        uint8_t tmpByte);\r\n\r\nstatic void LIN_LPUART_DRV_ProcessFrameHeader(uint32_t instance,\r\n                                              uint8_t tmpByte);\r\n\r\nstatic void LIN_LPUART_DRV_ProcessReceiveFrameData(uint32_t instance,\r\n                                                   uint8_t tmpByte);\r\n\r\nstatic void LIN_LPUART_DRV_ProcessSendFrameData(uint32_t instance,\r\n                                                uint8_t tmpByte);\r\n\r\nstatic void LIN_LPUART_DRV_AutobaudTimerValEval(uint32_t instance,\r\n                                                uint32_t twoBitTimeLength);\r\n\r\nstatic void LIN_LPUART_DRV_EvalTwoBitTimeLength(uint32_t instance,\r\n                                                uint32_t twoBitTimeLength);\r\n\r\nstatic uint8_t LIN_LPUART_DRV_MakeChecksumByte(uint32_t instance,\r\n                                               const uint8_t * buffer,\r\n                                               uint8_t sizeBuffer,\r\n                                               uint8_t PID);\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_Init\r\n * Description   : This function initializes a LPUART instance for operation.\r\n * This function will initialize the run-time state structure to keep track of\r\n * the on-going transfers, initialize the module to user defined settings and\r\n * default settings, set break field length to be 13 bit times minimum, enable\r\n * the break detect interrupt, Rx complete interrupt, frame error detect interrupt,\r\n * and enable the LPUART module transmitter and receiver.\r\n *\r\n * Implements    : LIN_LPUART_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_Init(uint32_t instance,\r\n                             lin_user_config_t * linUserConfig,\r\n                             lin_state_t * linCurrentState)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(linUserConfig && linCurrentState);\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    uint32_t linSourceClockFreq = 0U;\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the LPUART clock as configured in the clock manager */\r\n    (void)CLOCK_SYS_GetFreq(s_linLpuartClkName[instance], &linSourceClockFreq);\r\n\r\n    /* Check if current instance is clock gated off. */\r\n    DEV_ASSERT(linSourceClockFreq > 0U);\r\n\r\n    /* Check if current instance is already initialized. */\r\n    DEV_ASSERT(g_linStatePtr[instance] == NULL);\r\n\r\n    /* Save runtime structure pointer. */\r\n    g_linStatePtr[instance] = linCurrentState;\r\n\r\n    /* Save LIN user config structure pointer. */\r\n    g_linUserconfigPtr[instance] = linUserConfig;\r\n\r\n    /* Clear linSourceClockFreq value */\r\n    linCurrentState->linSourceClockFreq = linSourceClockFreq;\r\n\r\n    /* Init LPUART */\r\n    LPUART_Init(base);\r\n\r\n    /* Create txCompleted and rxCompleted semaphores as counting, with init value is 0 */\r\n    if (OSIF_SemaCreate(&linCurrentState->txCompleted, 0) != STATUS_SUCCESS)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else if (OSIF_SemaCreate(&linCurrentState->rxCompleted, 0) != STATUS_SUCCESS)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* if autobaud is enabled */\r\n        if ((linUserConfig->autobaudEnable) && (linUserConfig->nodeFunction == (bool)SLAVE))\r\n        {\r\n            /* Setting Slave's baudrate to 19200 will help Slave node */\r\n            /* always detect LIN Break from Master */\r\n            linUserConfig->baudRate = 19200U;\r\n            linCurrentState->fallingEdgeInterruptCount = 0U;\r\n            linCurrentState->baudrateEvalEnable = true;\r\n            s_previousTwoBitTimeLength[instance] = 0U;\r\n            s_countMeasure[instance] = 0U;\r\n            s_timeMeasure[instance] = 0U;\r\n        }\r\n\r\n        /* Set baud rate to User's value */\r\n        (void)LPUART_DRV_SetBaudRate(instance, linUserConfig->baudRate);\r\n\r\n        /* Set 8 bit counts per char */\r\n        LPUART_SetBitCountPerChar(base, LPUART_8_BITS_PER_CHAR, false);\r\n\r\n        /* Set no parity mode */\r\n        LPUART_SetParityMode(base, LPUART_PARITY_DISABLED);\r\n\r\n        /* One stop bit */\r\n        LPUART_SetStopBitCount(base, LPUART_ONE_STOP_BIT);\r\n\r\n        /* Check if the current node is MASTER */\r\n        if (linUserConfig->nodeFunction == (bool)MASTER)\r\n        {\r\n            /* Set Break char length as 13 bits minimum */\r\n            LPUART_SetBreakCharTransmitLength(base, LPUART_BREAK_CHAR_13_BIT_MINIMUM);\r\n        }\r\n\r\n        /* Set Break char detect length as 13 bits minimum */\r\n        LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_13_BIT_MINIMUM);\r\n\r\n        /* Enable RX complete interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, true);\r\n\r\n        /* Enable frame error interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_FRAME_ERR_FLAG, true);\r\n\r\n        /* Enable LIN break detect interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, true);\r\n\r\n        /* Install LIN_RxTx ISR for LPUART instance */\r\n        INT_SYS_InstallHandler(g_linLpuartRxTxIrqId[instance], g_linLpuartIsrs[instance], (isr_t *)0);\r\n        /* Enable LPUART interrupts. */\r\n        INT_SYS_EnableIRQ(g_linLpuartRxTxIrqId[instance]);\r\n#ifdef LPUART_ERR_IRQS\r\n        /* Install LIN_ERR ISR for LPUART instance */\r\n        INT_SYS_InstallHandler(g_linLpuartErrIrqId[instance], g_linLpuartErrIsrs[instance], (isr_t *)0);\r\n        /* Enable LPUART error interrupts */\r\n        INT_SYS_EnableIRQ(g_linLpuartErrIrqId[instance]);\r\n#endif\r\n        /* Change node's current state to IDLE */\r\n        linCurrentState->currentNodeState = LIN_NODE_STATE_IDLE;\r\n\r\n        /* Clear flags in current LIN state structure */\r\n        linCurrentState->isTxBusy = false;\r\n        linCurrentState->isRxBusy = false;\r\n        linCurrentState->isBusBusy = false;\r\n        linCurrentState->isRxBlocking = false;\r\n        linCurrentState->isTxBlocking = false;\r\n        linCurrentState->timeoutCounterFlag = false;\r\n        linCurrentState->timeoutCounter = 0U;\r\n\r\n        /* Assign wakeup signal to satisfy LIN Specifications specifies that\r\n         * wakeup signal shall be in range from 250us to 5 ms.\r\n         */\r\n        if (linUserConfig->baudRate > 10000U)\r\n        {\r\n            /* Wakeup signal will be range from 400us to 800us depend on baudrate */\r\n            s_wakeupSignal[instance] = 0x80U;\r\n        }\r\n        else\r\n        {\r\n            /* Wakeup signal will be range from 400us to 4ms depend on baudrate */\r\n            s_wakeupSignal[instance] = 0xF8U;\r\n        }\r\n\r\n        if (!((linUserConfig->autobaudEnable) && (linUserConfig->nodeFunction == (bool)SLAVE)))\r\n        {\r\n            /* Enable the LPUART transmitter and receiver */\r\n            LPUART_SetTransmitterCmd(base, true);\r\n            LPUART_SetReceiverCmd(base, true);\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_Deinit\r\n * Description   : This function shuts down the LPUART by disabling interrupts and\r\n *                 transmitter/receiver.\r\n *\r\n * Implements    : LIN_LPUART_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nvoid LIN_LPUART_DRV_Deinit(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check if current instance is already de-initialized or is gated.*/\r\n    DEV_ASSERT(linCurrentState != NULL);\r\n    DEV_ASSERT(linCurrentState->linSourceClockFreq > 0U);\r\n\r\n    /* Wait until the data is completely shifted out of shift register */\r\n    while (!LPUART_GetStatusFlag(base, LPUART_TX_COMPLETE))\r\n    {\r\n        /* Do nothing */\r\n    }\r\n\r\n    /* Disable the LPUART transmitter and receiver */\r\n    LPUART_SetTransmitterCmd(base, false);\r\n    LPUART_SetReceiverCmd(base, false);\r\n\r\n    /* Destroy TX and RX semaphores. */\r\n    (void)OSIF_SemaDestroy(&linCurrentState->txCompleted);\r\n    (void)OSIF_SemaDestroy(&linCurrentState->rxCompleted);\r\n\r\n    /* Disable LPUART interrupts. */\r\n    INT_SYS_DisableIRQ(g_linLpuartRxTxIrqId[instance]);\r\n#ifdef LPUART_ERR_IRQS\r\n    INT_SYS_DisableIRQ(g_linLpuartErrIrqId[instance]);\r\n#endif\r\n\r\n    /* Change node's current state to UNINIT */\r\n    linCurrentState->currentNodeState = LIN_NODE_STATE_UNINIT;\r\n\r\n    /* Clear our saved pointer to the LIN state structure */\r\n    g_linStatePtr[instance] = NULL;\r\n\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_GetDefaultConfig\r\n * Description   : Initializes a configuration structure received\r\n * from the application with default values.\r\n *\r\n * Implements    : LIN_LPUART_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid LIN_LPUART_DRV_GetDefaultConfig(bool isMaster,\r\n                                     lin_user_config_t * linUserConfig)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(linUserConfig != NULL);\r\n\r\n    linUserConfig->baudRate = 19200U;\r\n    linUserConfig->autobaudEnable = false;\r\n    linUserConfig->timerGetTimeIntervalCallback = NULL;\r\n    if (isMaster == true)\r\n    {\r\n        linUserConfig->nodeFunction = (bool)MASTER;\r\n    }\r\n    else\r\n    {\r\n        linUserConfig->nodeFunction = (bool)SLAVE;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_InstallCallback\r\n * Description   : This function installs the callback function that is used for LIN_LPUART_DRV_IRQHandler.\r\n * Pass in Null pointer as callback will uninstall.\r\n *\r\n * Implements    : LIN_LPUART_DRV_InstallCallback_Activity\r\n *END**************************************************************************/\r\nlin_callback_t LIN_LPUART_DRV_InstallCallback(uint32_t instance,\r\n                                              lin_callback_t function)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Get the current callback function. */\r\n    lin_callback_t currentCallback = linCurrentState->Callback;\r\n\r\n    /* Install new callback function. */\r\n    linCurrentState->Callback = function;\r\n\r\n    return currentCallback;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_MakeChecksumByte\r\n * Description   : This function calculate checksum for a frame. This function\r\n * will return classic or enhanced checksum base on data in\r\n * g_linUserconfigPtr[instance] and input parameter.\r\n *\r\n * Implements    : LIN_LPUART_DRV_SendFrameDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatic uint8_t LIN_LPUART_DRV_MakeChecksumByte(uint32_t instance,\r\n                                               const uint8_t * buffer,\r\n                                               uint8_t sizeBuffer,\r\n                                               uint8_t PID)\r\n{\r\n    /* Get list of PIDs use classic checksum. */\r\n    const uint8_t *classicPID = g_linUserconfigPtr[instance]->classicPID;\r\n    const uint8_t numOfClassicPID = g_linUserconfigPtr[instance]->numOfClassicPID;\r\n    uint8_t checkSum = PID;\r\n    uint8_t retVal = 0U;\r\n\r\n    if(numOfClassicPID == 255U)\r\n    {\r\n        /*all frame use enhanced checksum */\r\n        checkSum = 0U;\r\n    }\r\n    else\r\n    {\r\n        if(classicPID != NULL)\r\n        {\r\n            for (retVal = 0U; retVal < numOfClassicPID; retVal++)\r\n            {\r\n                if(checkSum == classicPID[retVal])\r\n                {\r\n                    checkSum = 0U;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    retVal = LIN_DRV_MakeChecksumByte(buffer, sizeBuffer, checkSum);\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_SendFrameDataBlocking\r\n * Description   : This function sends data out through the LPUART module using\r\n * blocking method. This function checks if txSize is in range from 1 to 8.\r\n * If not, it will return STATUS_ERROR. This function also returns STATUS_ERROR\r\n * if node's current state is in SLEEP mode. This function checks if the\r\n * isBusBusy is false, if not it will return STATUS_BUSY. The function does not\r\n * return until the transmission is complete. If the transmission is successful,\r\n * it will return STATUS_SUCCESS. If not, it will return STATUS_TIMEOUT.\r\n *\r\n * Implements    : LIN_LPUART_DRV_SendFrameDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_SendFrameDataBlocking(uint32_t instance,\r\n                                              const uint8_t * txBuff,\r\n                                              uint8_t txSize,\r\n                                              uint32_t timeoutMSec)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(txBuff != NULL);\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Check whether current mode is sleep mode */\r\n    bool checkSleepMode = (LIN_NODE_STATE_SLEEP_MODE == linCurrentState->currentNodeState);\r\n\r\n    /* Check if txSize > 8 or equal to 0 or node's current state\r\n     * is in SLEEP mode then return STATUS_ERROR */\r\n    if ((8U < txSize) || (0U == txSize) || checkSleepMode)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Check if the LIN Bus is busy */\r\n        if (linCurrentState->isBusBusy)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            /* Make the checksum byte. */\r\n            linCurrentState->checkSum = LIN_LPUART_DRV_MakeChecksumByte(instance, txBuff, txSize, linCurrentState->currentPid);\r\n\r\n            /* Update the LIN state structure. */\r\n            linCurrentState->txBuff = txBuff;\r\n            /* Add a place for checksum byte */\r\n            linCurrentState->txSize = (uint8_t)(txSize + 1U);\r\n            linCurrentState->cntByte = 0U;\r\n            linCurrentState->currentEventId = LIN_NO_EVENT;\r\n            linCurrentState->isBusBusy = true;\r\n            linCurrentState->isTxBusy = true;\r\n            linCurrentState->isTxBlocking = true;\r\n\r\n            /* Set Break char detect length as 10 bits minimum */\r\n            LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n\r\n            /* Set node's current state to SEND_DATA */\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_SEND_DATA;\r\n\r\n            /* Start sending data */\r\n            LPUART_Putchar(base, *linCurrentState->txBuff);\r\n\r\n            /* Wait until the transmission is complete. */\r\n            retVal = LIN_LPUART_DRV_WaitComplete(instance, timeoutMSec);\r\n\r\n            /* Clear Tx Blocking flag */\r\n            linCurrentState->isTxBlocking = false;\r\n\r\n            /* Clear Tx Busy flag. */\r\n            linCurrentState->isTxBusy = false;\r\n\r\n            /* Change node's current state to IDLE */\r\n            (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_SendFrameData\r\n * Description   : This function sends data out through the LPUART module using\r\n * non-blocking method. This function will calculate the checksum byte and send\r\n * it with the frame data. The function will return immediately after calling\r\n * this function. If txSize is equal to 0 or greater than 8  or node's current\r\n * state is in SLEEP mode then the function will return STATUS_ERROR. If\r\n * isBusBusy is currently true then the function will return STATUS_BUSY.\r\n *\r\n * Implements    : LIN_LPUART_DRV_SendFrameData_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_SendFrameData(uint32_t instance,\r\n                                      const uint8_t * txBuff,\r\n                                      uint8_t txSize)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(txBuff != NULL);\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check whether current mode is sleep mode */\r\n    bool checkSleepMode = (LIN_NODE_STATE_SLEEP_MODE == linCurrentState->currentNodeState);\r\n\r\n    /* Check if txSize > 8 or equal to 0 or node's current state\r\n     * is in SLEEP mode then return STATUS_ERROR */\r\n    if ((8U < txSize) || (0U == txSize) || checkSleepMode)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Check if the LIN Bus is busy */\r\n        if (linCurrentState->isBusBusy)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            /* Make the checksum byte. */\r\n            linCurrentState->checkSum = LIN_LPUART_DRV_MakeChecksumByte(instance, txBuff, txSize, linCurrentState->currentPid);\r\n\r\n            /* Update the LIN state structure. */\r\n            linCurrentState->txBuff = txBuff;\r\n            /* Add a place for checksum byte */\r\n            linCurrentState->txSize = (uint8_t)(txSize + 1U);\r\n            linCurrentState->cntByte = 0U;\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_SEND_DATA;\r\n            linCurrentState->currentEventId = LIN_NO_EVENT;\r\n            linCurrentState->isBusBusy = true;\r\n            linCurrentState->isTxBusy = true;\r\n\r\n            /* Set Break char detect length as 10 bits minimum */\r\n            LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n\r\n            /* Start sending data */\r\n            LPUART_Putchar(base, *linCurrentState->txBuff);\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_GetTransmitStatus\r\n * Description   : This function returns whether the previous LPUART transmit has\r\n * finished. When performing non-blocking transmit, the user can call this\r\n * function to ascertain the state of the current transmission:\r\n * in progress (or busy that is STATUS_BUSY) or timeout (if timeout has occurred that is\r\n * STATUS_TIMEOUT) or complete (success that is STATUS_SUCCESS).\r\n * In addition, if the transmission is still in progress, the user can obtain the number\r\n * of bytes that still needed to transmit.\r\n *\r\n * Implements    : LIN_LPUART_DRV_GetTransmitStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_GetTransmitStatus(uint32_t instance,\r\n                                          uint8_t * bytesRemaining)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Get the number of bytes that is still needed to transmit */\r\n    *bytesRemaining = (uint8_t)(linCurrentState->txSize - linCurrentState->cntByte);\r\n\r\n    /* Return status of the on-going transmission */\r\n    if ((linCurrentState->currentEventId == LIN_NO_EVENT) && (*bytesRemaining != 0U))\r\n    {\r\n        if (linCurrentState->timeoutCounterFlag == false)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            retVal = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_RecvFrmDataBlocking\r\n * Description   : This function receives data from LPUART module using blocking\r\n * method, the function does not return until the receive is complete. The interrupt\r\n * handler LIN_LPUART_DRV_IRQHandler will check the checksum byte. If the checksum\r\n * is correct, it will receive the frame data. If the checksum is incorrect, this\r\n * function will return STATUS_TIMEOUT and data in rxBuff might be wrong. This function\r\n * also check if rxSize is in range from 1 to 8. If not, it will return STATUS_ERROR.\r\n * This function also returns STATUS_ERROR if node's current state is in SLEEP mode.\r\n * This function checks if the isBusBusy is false, if not it will return\r\n * STATUS_BUSY.\r\n *\r\n * Implements    : LIN_LPUART_DRV_RecvFrmDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_RecvFrmDataBlocking(uint32_t instance,\r\n                                            uint8_t * rxBuff,\r\n                                            uint8_t rxSize,\r\n                                            uint32_t timeoutMSec)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(rxBuff != NULL);\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Check whether current mode is sleep mode */\r\n    bool checkSleepMode = (LIN_NODE_STATE_SLEEP_MODE == linCurrentState->currentNodeState);\r\n\r\n    /* Check if rxSize > 8 or equal to 0 or node's current state\r\n     * is in SLEEP mode then return STATUS_ERROR */\r\n    if ((8U < rxSize) || (0U == rxSize) || checkSleepMode)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Check if the LIN Rx is busy */\r\n        if (linCurrentState->isRxBusy)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            /* Update the LIN state structure. */\r\n            linCurrentState->rxBuff = rxBuff;\r\n            /* Add a place for checksum byte */\r\n            linCurrentState->rxSize = (uint8_t)(rxSize + 1U);\r\n            linCurrentState->cntByte = 0U;\r\n\r\n            /* Setup receiving data blocking */\r\n            linCurrentState->currentEventId = LIN_NO_EVENT;\r\n            linCurrentState->isRxBlocking = true;\r\n\r\n            /* Wait until the reception is complete. */\r\n            retVal = LIN_LPUART_DRV_WaitComplete(instance, timeoutMSec);\r\n\r\n            /* In case of receiving a go to sleep request, after callback, node is in SLEEP MODE */\r\n            /* In this case, node is in SLEEP MODE state */\r\n            if (linCurrentState->currentNodeState != LIN_NODE_STATE_SLEEP_MODE)\r\n            {\r\n                /* Update node's current state to IDLE. */\r\n                linCurrentState->currentNodeState = LIN_NODE_STATE_IDLE;\r\n            }\r\n\r\n            /* Clear Rx Blocking flag. */\r\n            linCurrentState->isRxBlocking = false;\r\n\r\n            /* Update Bus Busy flag. */\r\n            linCurrentState->isBusBusy = false;\r\n            linCurrentState->isRxBusy = false;\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_RecvFrmData\r\n * Description   : This function receives data from LPUART module using\r\n * non-blocking method. This function returns immediately after initiating the\r\n * receive function. The application has to get the receive status to see when\r\n * the receive is complete. In other words, after calling non-blocking get\r\n * function, the application must get the receive status to check if receive\r\n * is completed or not. The interrupt handler LIN_LPUART_DRV_IRQHandler will check\r\n * the checksum byte. If the checksum is correct, it will receive the frame data.\r\n * If the checksum is incorrect, this function will return STATUS_TIMEOUT and data in\r\n * rxBuff might be wrong. This function also check if rxSize is in range from 1 to 8.\r\n * If not, it will return STATUS_ERROR. This function also returns STATUS_ERROR if\r\n * node's current state is in SLEEP mode. This function checks if the\r\n * isBusBusy is false, if not it will return STATUS_BUSY.\r\n *\r\n * Implements    : LIN_LPUART_DRV_RecvFrmData_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_RecvFrmData(uint32_t instance,\r\n                                    uint8_t * rxBuff,\r\n                                    uint8_t rxSize)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(rxBuff != NULL);\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check whether current mode is sleep mode */\r\n    bool checkSleepMode = (LIN_NODE_STATE_SLEEP_MODE == linCurrentState->currentNodeState);\r\n\r\n    /* Check if rxSize > 8 or equal to 0 or node's current state\r\n     * is in SLEEP mode then return STATUS_ERROR */\r\n    if ((8U < rxSize) || (0U == rxSize) || checkSleepMode)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Check if the LIN Bus is busy */\r\n        if (linCurrentState->isBusBusy)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            /* Update the LIN state structure. */\r\n            linCurrentState->rxBuff = rxBuff;\r\n            /* Add a place for checksum byte */\r\n            linCurrentState->rxSize = (uint8_t)(rxSize + 1U);\r\n            linCurrentState->cntByte = 0U;\r\n\r\n            /* Start receiving data */\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_DATA;\r\n            linCurrentState->currentEventId = LIN_NO_EVENT;\r\n            linCurrentState->isBusBusy = true;\r\n            linCurrentState->isRxBusy = true;\r\n            linCurrentState->isRxBlocking = false;\r\n\r\n            /* Set Break char detect length as 10 bits minimum */\r\n            LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_AbortTransferData\r\n * Description   : Aborts an on-going non-blocking transmission/reception.\r\n * While performing a non-blocking transferring data, users can call this\r\n * function to terminate immediately the transferring.\r\n *\r\n * Implements    : LIN_LPUART_DRV_AbortTransferData_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_AbortTransferData(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Change node's current state to IDLE */\r\n    (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n\r\n    /* Clear LIN Tx and Rx Busy flag */\r\n    linCurrentState->isTxBusy = false;\r\n    linCurrentState->isRxBusy = false;\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_GetReceiveStatus\r\n * Description   : This function returns whether the previous LPUART reception is\r\n * complete. When performing a non-blocking receive, the user can call this\r\n * function to ascertain the state of the current receive progress: in progress\r\n * or complete. In addition, if the reception is still in progress, the user can\r\n * obtain the number of words that is still needed to receive.\r\n *\r\n * Implements    : LIN_LPUART_DRV_GetReceiveStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_GetReceiveStatus(uint32_t instance,\r\n                                         uint8_t * bytesRemaining)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Get the number of bytes that is still needed to receive */\r\n    *bytesRemaining = (uint8_t)(linCurrentState->rxSize - linCurrentState->cntByte);\r\n\r\n    /* Return status of the on-going reception */\r\n    if ((linCurrentState->currentEventId == LIN_NO_EVENT) && (*bytesRemaining != 0U))\r\n    {\r\n        if (linCurrentState->timeoutCounterFlag == false)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            retVal = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_GoToSleepMode\r\n * Description   : This function puts current LIN node to sleep mode.\r\n * This function changes current node state to LIN_NODE_STATE_SLEEP_MODE.\r\n *\r\n * Implements    : LIN_LPUART_DRV_GoToSleepMode_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_GoToSleepMode(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Update node's current state to SLEEP_MODE. */\r\n    linCurrentState->currentNodeState = LIN_NODE_STATE_SLEEP_MODE;\r\n\r\n    /* Clear txBusy, rxBusy, busBusy flags */\r\n    linCurrentState->isTxBusy  = false;\r\n    linCurrentState->isRxBusy  = false;\r\n    linCurrentState->isBusBusy = false;\r\n\r\n    /* Clear LPUART_RX Pin Active Edge Interrupt Flag. */\r\n    (void)LPUART_ClearStatusFlag(base, LPUART_RX_ACTIVE_EDGE_DETECT);\r\n\r\n    /* Set Receive data not inverted */\r\n    LPUART_SetRxDataPolarity(base, false);\r\n\r\n    /* Disable RX complete interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, false);\r\n\r\n    /* Enable RX Input Active Edge interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_ACTIVE_EDGE, true);\r\n\r\n    /* Disable frame error interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_FRAME_ERR_FLAG, false);\r\n\r\n    /* Disable LIN break detect interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, false);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_SendWakeupSignal\r\n * Description   : This function sends a wakeup signal through the LPUART interface.\r\n *\r\n * Implements    : LIN_LPUART_DRV_SendWakeupSignal_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_SendWakeupSignal(uint32_t instance)\r\n{\r\n    /* DEV_ASSERT parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Check if bus is not busy */\r\n    if (linCurrentState->isBusBusy == false)\r\n    {\r\n        /* Send a wakeup signal */\r\n        LPUART_Putchar(base, s_wakeupSignal[instance]);\r\n    }\r\n    else\r\n    {\r\n        retVal = STATUS_BUSY;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_GetCurrentNodeState\r\n * Description   : This function gets the current LIN node state.\r\n *\r\n * Implements    : LIN_LPUART_DRV_GetCurrentNodeState_Activity\r\n *END**************************************************************************/\r\nlin_node_state_t LIN_LPUART_DRV_GetCurrentNodeState(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    lin_node_state_t retVal = LIN_NODE_STATE_UNINIT;\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    if (linCurrentState != NULL)\r\n    {\r\n        retVal = linCurrentState->currentNodeState;\r\n    }\r\n\r\n    /* Return LIN node's current state */\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_TimeoutService\r\n * Description   : This is callback function for Timer Interrupt Handler.\r\n * Users shall initialize a timer (for example FTM) in Output compare mode\r\n * with period of about 500 micro seconds. In timer IRQ handler, call this function.\r\n *\r\n * Implements    : LIN_LPUART_DRV_TimeoutService_Activity\r\n *END**************************************************************************/\r\nvoid LIN_LPUART_DRV_TimeoutService(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Get LIN node's current state */\r\n    lin_node_state_t state = linCurrentState->currentNodeState;\r\n\r\n    switch (state)\r\n    {\r\n        /* If the node is SENDING DATA */\r\n        case LIN_NODE_STATE_SEND_DATA:\r\n            /* Check if timeout Counter is 0 */\r\n            if (linCurrentState->timeoutCounter == 0U)\r\n            {\r\n                /* Set timeout Counter flag */\r\n                linCurrentState->timeoutCounterFlag = true;\r\n\r\n                if (linCurrentState->isTxBlocking == false)\r\n                {\r\n                    /* Callback to handle timeout Counter flag */\r\n                    if (linCurrentState->Callback != NULL)\r\n                    {\r\n                        linCurrentState->Callback(instance, linCurrentState);\r\n                    }\r\n\r\n                    /* Clear Tx busy flag */\r\n                    linCurrentState->isTxBusy = false;\r\n\r\n                    /* Change the node's current state to IDLE */\r\n                    (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                }\r\n            }\r\n            else /* If timeout Counter is not 0, then decrease timeout Counter by one */\r\n            {\r\n                linCurrentState->timeoutCounter--;\r\n            }\r\n\r\n            break;\r\n        /* If the node is RECEIVING DATA */\r\n        case LIN_NODE_STATE_RECV_DATA:\r\n            /* Check if timeout Counter is 0 */\r\n            if (linCurrentState->timeoutCounter == 0U)\r\n            {\r\n                /* Set timeout Counter flag */\r\n                linCurrentState->timeoutCounterFlag = true;\r\n\r\n                /* Check if the reception is non-blocking */\r\n                if (linCurrentState->isRxBlocking == false)\r\n                {\r\n                    /* Callback to handle timeout Counter flag */\r\n                    if (linCurrentState->Callback != NULL)\r\n                    {\r\n                        linCurrentState->Callback(instance, linCurrentState);\r\n                    }\r\n\r\n                    /* Clear Rx busy flag */\r\n                    linCurrentState->isRxBusy = false;\r\n\r\n                    /* Change the node's current state to IDLE */\r\n                    (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                }\r\n            }\r\n            /* If timeout Counter is not 0, then decrease timeout Counter by one */\r\n            else\r\n            {\r\n                linCurrentState->timeoutCounter--;\r\n            }\r\n\r\n            break;\r\n        default:\r\n            /* The node state is not SENDING nor RECEIVING data */\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_SetTimeoutCounter\r\n * Description   : This function sets value for timeout counter that is used in\r\n * LIN_LPUART_DRV_TimeoutService\r\n *\r\n * Implements    : LIN_LPUART_DRV_SetTimeoutCounter_Activity\r\n *END**************************************************************************/\r\nvoid LIN_LPUART_DRV_SetTimeoutCounter(uint32_t instance,\r\n                                      uint32_t timeoutValue)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Clear Timeout Counter Flag */\r\n    linCurrentState->timeoutCounterFlag = false;\r\n\r\n    /* Set new value for Timeout Counter */\r\n    linCurrentState->timeoutCounter = timeoutValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_MasterSendHeader\r\n * Description   : This function sends frame header out through the LPUART module\r\n * using a non-blocking method. Non-blocking  means that the function returns\r\n * immediately. This function sends LIN Break field, sync field then the ID with\r\n * correct parity. This function checks if the interface is Master, if not, it will\r\n * return STATUS_ERROR.This function checks if id is in range from 0 to 0x3F, if not\r\n * it will return STATUS_ERROR. This function also check node's current state is in\r\n * SLEEP mode then the function will return STATUS_ERROR. And check if isBusBusy is\r\n * currently true then the function will return STATUS_BUSY.\r\n *\r\n * Implements    : LIN_LPUART_DRV_MasterSendHeader_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_MasterSendHeader(uint32_t instance,\r\n                                         uint8_t id)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get the current LIN user config structure of this LPUART instance. */\r\n    const lin_user_config_t * linUserConfig = g_linUserconfigPtr[instance];\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check whether current mode is sleep mode */\r\n    bool checkSleepMode = (LIN_NODE_STATE_SLEEP_MODE == linCurrentState->currentNodeState);\r\n\r\n    /* Check if the current node is slave or id is invalid or node's current\r\n     * state is in SLEEP state */\r\n    if ((linUserConfig->nodeFunction == (bool)SLAVE) || (0x3FU < id) || checkSleepMode)\r\n    {\r\n        retVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Check if the LIN bus is busy */\r\n        if (linCurrentState->isBusBusy)\r\n        {\r\n            retVal = STATUS_BUSY;\r\n        }\r\n        else\r\n        {\r\n            linCurrentState->currentId = id;\r\n\r\n            /* Make parity for the current ID */\r\n            linCurrentState->currentPid = LIN_DRV_ProcessParity(id, MAKE_PARITY);\r\n\r\n            /* Set LIN current state to sending Break field */\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_SEND_BREAK_FIELD;\r\n            linCurrentState->currentEventId = LIN_NO_EVENT;\r\n            linCurrentState->isBusBusy = true;\r\n\r\n            /* Set Break char detect length as 13 bits minimum */\r\n            LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_13_BIT_MINIMUM);\r\n            LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, true);\r\n\r\n            /* Send break char by using queue mode */\r\n            LPUART_QueueBreakField(base);\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_EnableIRQ\r\n * Description   : This function enables LPUART hardware interrupts.\r\n *\r\n * Implements    : LIN_LPUART_DRV_EnableIRQ_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_EnableIRQ(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    if (linCurrentState->currentNodeState == LIN_NODE_STATE_SLEEP_MODE)\r\n    {\r\n        /* Enable RX Input Active Edge interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_RX_ACTIVE_EDGE, true);\r\n    }\r\n    else\r\n    {\r\n        /* Enable RX complete interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, true);\r\n\r\n        /* Enable frame error interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_FRAME_ERR_FLAG, true);\r\n\r\n        /* Enable LIN break detect interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, true);\r\n    }\r\n\r\n    /* Enable LPUART interrupts. */\r\n    INT_SYS_EnableIRQ(g_linLpuartRxTxIrqId[instance]);\r\n#ifdef LPUART_ERR_IRQS\r\n    INT_SYS_EnableIRQ(g_linLpuartErrIrqId[instance]);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_DisableIRQ\r\n * Description   : This function disables LPUART hardware interrupts.\r\n *\r\n * Implements    : LIN_LPUART_DRV_DisableIRQ_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_DisableIRQ(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    if (linCurrentState->currentNodeState == LIN_NODE_STATE_SLEEP_MODE)\r\n    {\r\n        /* Disable RX Input Active Edge interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_RX_ACTIVE_EDGE, false);\r\n    }\r\n    else\r\n    {\r\n        /* Disable RX complete interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, false);\r\n\r\n        /* Disable frame error interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_FRAME_ERR_FLAG, false);\r\n\r\n        /* Disable frame error interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, false);\r\n    }\r\n\r\n    /* Disable LPUART interrupts. */\r\n    INT_SYS_DisableIRQ(g_linLpuartRxTxIrqId[instance]);\r\n#ifdef LPUART_ERR_IRQS\r\n    INT_SYS_DisableIRQ(g_linLpuartErrIrqId[instance]);\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_GotoIdleState\r\n * Description   : This function puts current node to Idle state.\r\n *\r\n * Implements    : LIN_LPUART_DRV_GotoIdleState_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_GotoIdleState(uint32_t instance)\r\n{\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    linCurrentState->currentEventId = LIN_NO_EVENT;\r\n\r\n    /* Set Break char detect length as 13 bits minimum */\r\n    LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_13_BIT_MINIMUM);\r\n\r\n    /* Set Receive data not inverted */\r\n    LPUART_SetRxDataPolarity(base, false);\r\n\r\n    /* Enable RX complete interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, true);\r\n\r\n    /* Disable RXEDG interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_ACTIVE_EDGE, false);\r\n\r\n    /* Enable frame error interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_FRAME_ERR_FLAG, true);\r\n\r\n    /* Enable LIN break detect interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, true);\r\n\r\n    /* Change node's current state to IDLE */\r\n    linCurrentState->currentNodeState = LIN_NODE_STATE_IDLE;\r\n\r\n    /* Clear Bus busy Flag */\r\n    linCurrentState->isBusBusy = false;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_WaitComplete\r\n * Description   : This function waits until transmission/reception is complete and\r\n * returns status of the transaction.\r\n *\r\n * Implements    : LIN_LPUART_DRV_WaitComplete_Activity\r\n *END**************************************************************************/\r\nstatic status_t LIN_LPUART_DRV_WaitComplete(uint32_t instance,\r\n                                            uint32_t timeoutMSec)\r\n{\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n    status_t retVal = STATUS_SUCCESS;\r\n\r\n    if (linCurrentState->isTxBlocking == true)\r\n    {\r\n        if (OSIF_SemaWait(&linCurrentState->txCompleted, timeoutMSec) == STATUS_TIMEOUT)\r\n        {\r\n            retVal = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    if (linCurrentState->isRxBlocking == true)\r\n    {\r\n        if (OSIF_SemaWait(&linCurrentState->rxCompleted, timeoutMSec) == STATUS_TIMEOUT)\r\n        {\r\n            retVal = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_IRQHandler\r\n * Description   : Interrupt handler for LPUART.\r\n * This handler uses the buffers stored in the lin_state_t struct to transfer\r\n * data. This is not a public API as it is called by IRQ whenever an interrupt\r\n * occurs.\r\n *\r\n * Implements    : LIN_LPUART_DRV_IRQHandler_Activity\r\n *END**************************************************************************/\r\nvoid LIN_LPUART_DRV_IRQHandler(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    uint8_t tmpByte = 0U;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check RX Input Active Edge interrupt enable */\r\n    bool activeEdgeIntState = LPUART_GetIntMode(base, LPUART_INT_RX_ACTIVE_EDGE);\r\n\r\n    /* If LIN break character has been detected. */\r\n    if (LPUART_GetStatusFlag(base, LPUART_LIN_BREAK_DETECT))\r\n    {\r\n        LIN_LPUART_DRV_ProcessBreakDetect(instance);\r\n    }\r\n    else\r\n    {\r\n        /* If LPUART_RX Pin Active Edge has been detected. */\r\n        if (LPUART_GetStatusFlag(base, LPUART_RX_ACTIVE_EDGE_DETECT) && activeEdgeIntState)\r\n        {\r\n            /* Clear LPUART_RX Pin Active Edge Interrupt Flag. */\r\n            (void)LPUART_ClearStatusFlag(base, LPUART_RX_ACTIVE_EDGE_DETECT);\r\n\r\n            /* Check if a wakeup signal has been received */\r\n            LIN_LPUART_DRV_CheckWakeupSignal(instance);\r\n        }\r\n        else\r\n        {\r\n            /* If Framing Error has been detected */\r\n            if (LPUART_GetStatusFlag(base, LPUART_FRAME_ERR))\r\n            {\r\n                /* Clear Framing Error Interrupt Flag */\r\n                (void)LPUART_ClearStatusFlag(base, LPUART_FRAME_ERR);\r\n\r\n                /* Read dummy to clear LPUART_RX_DATA_REG_FULL flag */\r\n                LPUART_Getchar(base, &tmpByte);\r\n\r\n                /* Set current event id to LIN_FRAME_ERROR */\r\n                linCurrentState->currentEventId = LIN_FRAME_ERROR;\r\n\r\n                /* Check if LIN current node state is LIN_NODE_STATE_SEND_DATA */\r\n                if (linCurrentState->currentNodeState == LIN_NODE_STATE_SEND_DATA)\r\n                {\r\n                    /* Callback function to handle Framing Error Event */\r\n                    if (linCurrentState->Callback != NULL)\r\n                    {\r\n                        linCurrentState->Callback(instance, linCurrentState);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    /* Check if LIN current node state is LIN_NODE_STATE_RECV_DATA */\r\n                    if (linCurrentState->currentNodeState == LIN_NODE_STATE_RECV_DATA)\r\n                    {\r\n                        /* Callback function to handle Framing Error Event */\r\n                        if (linCurrentState->Callback != NULL)\r\n                        {\r\n                            linCurrentState->Callback(instance, linCurrentState);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /* Change node's state to IDLE */\r\n                (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n            }\r\n            else\r\n            {\r\n                if (LPUART_GetStatusFlag(base, LPUART_RX_DATA_REG_FULL))\r\n                {\r\n                    /* Get data from Data Register & Clear LPUART_RX_DATA_REG_FULL flag */\r\n                    LPUART_Getchar(base, &tmpByte);\r\n\r\n                    /* Process data in Data Register while receive, send data */\r\n                    LIN_LPUART_DRV_ProcessFrame(instance, tmpByte);\r\n                }\r\n            } /* End else: if (LPUART_GetStatusFlag(base, LPUART_FRAME_ERR) == 0) */\r\n        } /* End else: if (LPUART_GetStatusFlag(base, LPUART_RX_ACTIVE_EDGE_DETECT) == 0) */\r\n    } /* End else: if (LPUART_GetStatusFlag(base, LPUART_LIN_BREAK_DETECT) == 0) */\r\n\r\n    /* Get status RX overrun flag */\r\n    if (LPUART_GetStatusFlag(base, LPUART_RX_OVERRUN))\r\n    {\r\n        /* Clear overrun flag */\r\n        (void)LPUART_ClearStatusFlag(base, LPUART_RX_OVERRUN);\r\n\r\n        /* Set current event id to LIN_RX_OVERRUN */\r\n        linCurrentState->currentEventId = LIN_RX_OVERRUN;\r\n\r\n        /* Callback function to handle RX Overrun Event */\r\n        if (linCurrentState->Callback != NULL)\r\n        {\r\n            linCurrentState->Callback(instance, linCurrentState);\r\n        }\r\n    }\r\n} /* End void LIN_LPUART_DRV_IRQHandler(uint32_t instance) */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_ProcessBreakDetect\r\n * Description   : This function process break detect for LIN communication.\r\n *\r\n * Implements    : LIN_LPUART_DRV_ProcessBreakDetect_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_ProcessBreakDetect(uint32_t instance)\r\n{\r\n    /* Get the current LIN user configure structure of this LPUART instance. */\r\n    const lin_user_config_t * linUserConfig = g_linUserconfigPtr[instance];\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Clear LIN Break Detect Interrupt Flag */\r\n    (void)LPUART_ClearStatusFlag(base, LPUART_LIN_BREAK_DETECT);\r\n\r\n    /* Set Break char detect length as 10 bits minimum */\r\n    LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n    /* Disable LIN Break Detect Interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, false);\r\n\r\n    /* Check if the current node is MASTER */\r\n    if (linUserConfig->nodeFunction == (bool)MASTER)\r\n    {\r\n        /* Check if LIN current node state is LIN_NODE_STATE_SEND_BREAK_FIELD */\r\n        if (linCurrentState->currentNodeState == LIN_NODE_STATE_SEND_BREAK_FIELD)\r\n        {\r\n            /* Set flag LIN bus busy */\r\n            linCurrentState->isBusBusy = true;\r\n            /* Change the node's current state to SENDING PID to send PID after send SYNC */\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_SEND_PID;\r\n            /* Send Sync Field 0x55 */\r\n            LPUART_Putchar(base, 0x55);\r\n        }\r\n    }\r\n    /* If the current node is SLAVE */\r\n    else\r\n    {\r\n        /* Set flag LIN bus busy */\r\n        linCurrentState->isBusBusy = true;\r\n        /* Change the node's current state to RECEIVED BREAK FIELD */\r\n        linCurrentState->currentEventId = LIN_RECV_BREAK_FIELD_OK;\r\n        /* Callback function */\r\n        if (linCurrentState->Callback != NULL)\r\n        {\r\n            linCurrentState->Callback(instance, linCurrentState);\r\n        }\r\n        /* Change the node's current state to RECEIVING SYNC FIELD */\r\n        linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_SYNC;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_CheckWakeupSignal\r\n * Description   : This function check if a dominant signal received is a wakeup\r\n *                signal.\r\n *\r\n * Implements    : LIN_LPUART_DRV_CheckWakeupSignal_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_CheckWakeupSignal(uint32_t instance)\r\n{\r\n    uint32_t wakeupSignalLength = 0U;\r\n\r\n    /* Get the current LIN user config structure of this LPUART instance. */\r\n    const lin_user_config_t * linUserConfig = g_linUserconfigPtr[instance];\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* if LPUART_GetRxDataPolarity is 0: Receive Data is not inverted */\r\n    if (LPUART_GetRxDataPolarity(base) == false)\r\n    {\r\n        /* Start measure time */\r\n        (void)linUserConfig->timerGetTimeIntervalCallback(&wakeupSignalLength);\r\n\r\n        /* Set Receive Data Inverted */\r\n        LPUART_SetRxDataPolarity(base, true);\r\n    }\r\n    else\r\n    {\r\n        /* Set Receive Data is Not Inverted */\r\n        LPUART_SetRxDataPolarity(base, false);\r\n\r\n        /* Calculate time interval between the falling and rising edge */\r\n        (void)linUserConfig->timerGetTimeIntervalCallback(&wakeupSignalLength);\r\n\r\n        /* If length of the dominant signal is longer than 150us, it is a wakeup signal */\r\n        if (wakeupSignalLength >= 150000U)\r\n        {\r\n            linCurrentState->currentEventId = LIN_WAKEUP_SIGNAL;\r\n\r\n            /* Callback to handle event: Received a wakeup signal */\r\n            if (linCurrentState->Callback != NULL)\r\n            {\r\n                linCurrentState->Callback(instance, linCurrentState);\r\n            }\r\n\r\n            /* Change node's state to IDLE */\r\n            (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_ProcessFrame\r\n * Description   : Part of Interrupt handler for receiving and sending data.\r\n * Receive Header, Data and Send Data.\r\n *\r\n * Implements    : LIN_LPUART_DRV_ProcessFrame_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_ProcessFrame(uint32_t instance,\r\n                                        uint8_t tmpByte)\r\n{\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    const lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check node's current state */\r\n    switch (linCurrentState->currentNodeState)\r\n    {\r\n        /* if current state is RECEIVE SYNC FIELD */\r\n        case LIN_NODE_STATE_RECV_SYNC:\r\n\r\n        /* if current state is MASTER SENDING PID */\r\n        case LIN_NODE_STATE_SEND_PID:\r\n\r\n        /* if current state is RECEIVE PID */\r\n        case LIN_NODE_STATE_RECV_PID:\r\n            LIN_LPUART_DRV_ProcessFrameHeader(instance, tmpByte);\r\n            break;\r\n        /* if current state is RECEIVE DATA */\r\n        case LIN_NODE_STATE_RECV_DATA:\r\n            LIN_LPUART_DRV_ProcessReceiveFrameData(instance, tmpByte);\r\n            break;\r\n        /* if current state is SENDING DATA */\r\n        case LIN_NODE_STATE_SEND_DATA:\r\n            LIN_LPUART_DRV_ProcessSendFrameData(instance, tmpByte);\r\n            break;\r\n\r\n        default:\r\n            /* Other node state */\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_ProcessFrameHeader\r\n * Description   : Part of Interrupt handler for receiving and sending data.\r\n * Receive Sync byte, PID and Send PID.\r\n *\r\n * Implements    : LIN_LPUART_DRV_ProcessFrameHeader_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_ProcessFrameHeader(uint32_t instance,\r\n                                              uint8_t tmpByte)\r\n{\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN user config structure of this LPUART instance. */\r\n    const lin_user_config_t * linUserConfig = g_linUserconfigPtr[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check node's current state */\r\n    switch (linCurrentState->currentNodeState)\r\n    {\r\n        /* If current state is RECEIVE SYNC FIELD */\r\n        case LIN_NODE_STATE_RECV_SYNC:\r\n            if (tmpByte == 0x55U)\r\n            {\r\n                /* Set current event ID to Sync byte is correct */\r\n                linCurrentState->currentEventId = LIN_SYNC_OK;\r\n                /* Change node's current state to RECEIVE PID */\r\n                linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_PID;\r\n            }\r\n            else\r\n            {\r\n                /* Set current event ID to Sync byte is incorrect */\r\n                linCurrentState->currentEventId = LIN_SYNC_ERROR;\r\n                /* Callback function to handle event RECEIVED SYNC FIELD ERROR */\r\n                if (linCurrentState->Callback != NULL)\r\n                {\r\n                    linCurrentState->Callback(instance, linCurrentState);\r\n                }\r\n\r\n                /* Change node's current state to IDLE */\r\n                (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n            }\r\n\r\n            break;\r\n        /* If current state is MASTER SENDING PID */\r\n        case LIN_NODE_STATE_SEND_PID:\r\n            /* Check if master node sent SYNC byte correctly before send PID */\r\n            if (tmpByte == 0x55U)\r\n            {\r\n                /* Change node's current state to RECEIVING PID */\r\n                linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_PID;\r\n                /* Send the current PID byte */\r\n                LPUART_Putchar(base, linCurrentState->currentPid);\r\n            }\r\n            /* In case of errors during header transmission, it is up to the implementer\r\n             * how to handle these errors (stop/continue transmission) and to decide if the\r\n             * corresponding response is valid or not.\r\n             * By default, LIN Driver set isBusBusy to false, and change node's state to IDLE.\r\n             */\r\n            else\r\n            {\r\n                /* Set current event ID to Sync byte is incorrect */\r\n                linCurrentState->currentEventId = LIN_SYNC_ERROR;\r\n                /* Clear Bus bus flag */\r\n                linCurrentState->isBusBusy = false;\r\n                /* Change node's current state to IDLE */\r\n                linCurrentState->currentNodeState = LIN_NODE_STATE_IDLE;\r\n\r\n                /* Callback function to handle event SENT SYNC BYTE ERROR */\r\n                if (linCurrentState->Callback != NULL)\r\n                {\r\n                    linCurrentState->Callback(instance, linCurrentState);\r\n                }\r\n            }\r\n\r\n            break;\r\n        /* If current state is RECEIVE PID */\r\n        case LIN_NODE_STATE_RECV_PID:\r\n            /* If the node is MASTER */\r\n            if (linUserConfig->nodeFunction == (bool)MASTER)\r\n            {\r\n                /* Check if master node sent PID correctly */\r\n                if (tmpByte == linCurrentState->currentPid)\r\n                {\r\n                    /* Set current event ID to PID correct */\r\n                    linCurrentState->currentEventId = LIN_PID_OK;\r\n\r\n                    /* Check receiving data is blocking */\r\n                    if (linCurrentState->isRxBlocking == true)\r\n                    {\r\n                        /* Starting receive data blocking */\r\n                        linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_DATA;\r\n                        linCurrentState->isBusBusy = true;\r\n                        linCurrentState->isRxBusy = true;\r\n\r\n                        /* Set Break char detect length as 10 bits minimum */\r\n                        LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n                    }\r\n                    else\r\n                    {\r\n                        /* Clear Bus bus flag */\r\n                        linCurrentState->isBusBusy = false;\r\n\r\n                        /* Callback function to handle correct PID */\r\n                        if (linCurrentState->Callback != NULL)\r\n                        {\r\n                            linCurrentState->Callback(instance, linCurrentState);\r\n                        }\r\n                    }\r\n                }\r\n                /* In case of errors during header transmission, it is up to the implementer\r\n                 * how to handle these errors (stop/continue transmission) and to decide if the\r\n                 * corresponding response is valid or not.\r\n                 * By default, LIN Driver set isBusBusy to false, and change node's state to IDLE.\r\n                 */\r\n                else\r\n                {\r\n                    /* Set current event ID to PID incorrect */\r\n                    linCurrentState->currentEventId = LIN_PID_ERROR;\r\n                    /* Clear bus busy flag */\r\n                    linCurrentState->isBusBusy = false;\r\n                    /* Change node's current state to IDLE */\r\n                    linCurrentState->currentNodeState = LIN_NODE_STATE_IDLE;\r\n                    /* Callback function to handle event MASTER SENT PID ERROR */\r\n                    if (linCurrentState->Callback != NULL)\r\n                    {\r\n                        linCurrentState->Callback(instance, linCurrentState);\r\n                    }\r\n                }\r\n            }\r\n            /* If the node is SLAVE */\r\n            else\r\n            {\r\n                /* Check the received PID */\r\n                linCurrentState->currentId = LIN_DRV_ProcessParity(tmpByte, CHECK_PARITY);\r\n                linCurrentState->currentPid = tmpByte;\r\n                if (linCurrentState->currentId != 0xFFU)\r\n                {\r\n                    /* Set current event ID to PID correct */\r\n                    linCurrentState->currentEventId = LIN_PID_OK;\r\n\r\n                    /* Check receiving data is blocking */\r\n                    if (linCurrentState->isRxBlocking == true)\r\n                    {\r\n                        /* Starting receive data blocking */\r\n                        linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_DATA;\r\n                        linCurrentState->isBusBusy = true;\r\n                        linCurrentState->isRxBusy = true;\r\n\r\n                        /* Set Break char detect length as 10 bits minimum */\r\n                        LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n                    }\r\n                    else\r\n                    {\r\n                        /* Clear Bus bus flag */\r\n                        linCurrentState->isBusBusy = false;\r\n\r\n                        /* Callback function to handle event PID correct */\r\n                        if (linCurrentState->Callback != NULL)\r\n                        {\r\n                            linCurrentState->Callback(instance, linCurrentState);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    /* Set current event ID to PID ERROR */\r\n                    linCurrentState->currentEventId = LIN_PID_ERROR;\r\n\r\n                    /* Callback function to handle event PID incorrect */\r\n                    if (linCurrentState->Callback != NULL)\r\n                    {\r\n                        linCurrentState->Callback(instance, linCurrentState);\r\n                    }\r\n\r\n                    /* Change node's current state to IDLE */\r\n                    (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                }\r\n            }\r\n\r\n            break;\r\n        default:\r\n            /* Other node state */\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_ProcessReceiveFrameData\r\n * Description   : Part of Interrupt handler for receiving.\r\n *\r\n * Implements    : LIN_LPUART_DRV_ProcessReceiveFrameData_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_ProcessReceiveFrameData(uint32_t instance,\r\n                                                   uint8_t tmpByte)\r\n{\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    if (linCurrentState->rxSize > (linCurrentState->cntByte + 1U))\r\n    {\r\n        *(linCurrentState->rxBuff) = tmpByte;\r\n        linCurrentState->rxBuff++;\r\n    }\r\n    else\r\n    {\r\n        if ((linCurrentState->rxSize - linCurrentState->cntByte) == 1U)\r\n        {\r\n            linCurrentState->checkSum = tmpByte;\r\n        }\r\n    }\r\n\r\n    linCurrentState->cntByte++;\r\n    if (linCurrentState->cntByte == linCurrentState->rxSize)\r\n    {\r\n        /* Restore rxBuffer pointer */\r\n        linCurrentState->rxBuff -= linCurrentState->rxSize - 1U;\r\n        if (LIN_LPUART_DRV_MakeChecksumByte(instance, linCurrentState->rxBuff, linCurrentState->rxSize - 1U, linCurrentState->currentPid) == linCurrentState->checkSum)\r\n        {\r\n            linCurrentState->currentEventId = LIN_RX_COMPLETED;\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_DATA_COMPLETED;\r\n\r\n            /* callback function to handle RX COMPLETED */\r\n            if (linCurrentState->Callback != NULL)\r\n            {\r\n                linCurrentState->Callback(instance, linCurrentState);\r\n            }\r\n\r\n            /* Check if the reception is non-blocking */\r\n            if (linCurrentState->isRxBlocking == false)\r\n            {\r\n                /* Clear Bus busy flag */\r\n                linCurrentState->isBusBusy = false;\r\n\r\n                /* Clear Rx busy flag */\r\n                linCurrentState->isRxBusy = false;\r\n\r\n                /* In case of receiving a go to sleep request, after callback, node is in SLEEP MODE */\r\n                /* In this case, node is in SLEEP MODE state */\r\n                if (linCurrentState->currentNodeState != LIN_NODE_STATE_SLEEP_MODE)\r\n                {\r\n                    (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Post Semaphore to signal Rx Completed*/\r\n                (void)OSIF_SemaPost(&linCurrentState->rxCompleted);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            linCurrentState->currentEventId = LIN_CHECKSUM_ERROR;\r\n            /* callback function to handle checksum error */\r\n            if (linCurrentState->Callback != NULL)\r\n            {\r\n                linCurrentState->Callback(instance, linCurrentState);\r\n            }\r\n\r\n            /* Clear Rx busy flag */\r\n            linCurrentState->isRxBusy = false;\r\n\r\n            /* Change node's current state to IDLE */\r\n            (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_ProcessSendFrameData\r\n * Description   : Part of Interrupt handler for sending data.\r\n *\r\n * Implements    : LIN_LPUART_DRV_ProcessSendFrameData_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_ProcessSendFrameData(uint32_t instance,\r\n                                                uint8_t tmpByte)\r\n{\r\n    bool sendFlag = true;\r\n    uint8_t tmpSize;\r\n    bool tmpCheckSumAndSize;\r\n    bool tmpBuffAndSize;\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check if Tx data register empty flag is false */\r\n    if (LPUART_GetStatusFlag(base, LPUART_TX_DATA_REG_EMPTY) == false)\r\n    {\r\n        linCurrentState->currentEventId = LIN_READBACK_ERROR;\r\n        /* callback function to handle Readback error */\r\n        if (linCurrentState->Callback != NULL)\r\n        {\r\n            linCurrentState->Callback(instance, linCurrentState);\r\n        }\r\n\r\n        /* Check if the transmission is non-blocking */\r\n        if (linCurrentState->isTxBlocking == false)\r\n        {\r\n            /* Clear Tx busy flag */\r\n            linCurrentState->isTxBusy = false;\r\n\r\n            /* Change node's current state to IDLE */\r\n            (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n        }\r\n\r\n        sendFlag = false;\r\n    }\r\n    else\r\n    {\r\n        tmpSize = (uint8_t)(linCurrentState->txSize - linCurrentState->cntByte);\r\n        tmpCheckSumAndSize = (tmpSize == 1U) && (linCurrentState->checkSum != tmpByte);\r\n        tmpBuffAndSize = (*linCurrentState->txBuff != tmpByte) && (tmpSize != 1U);\r\n        if (tmpBuffAndSize || tmpCheckSumAndSize)\r\n        {\r\n            linCurrentState->currentEventId = LIN_READBACK_ERROR;\r\n\r\n            /* callback function to handle Readback error */\r\n            if (linCurrentState->Callback != NULL)\r\n            {\r\n                linCurrentState->Callback(instance, linCurrentState);\r\n            }\r\n\r\n            /* Check if the transmission is non-blocking */\r\n            if (linCurrentState->isTxBlocking == false)\r\n            {\r\n                /* Clear Tx busy flag */\r\n                linCurrentState->isTxBusy = false;\r\n\r\n                /* Change node's current state to IDLE */\r\n                (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n            }\r\n\r\n            sendFlag = false;\r\n        }\r\n        else\r\n        {\r\n            linCurrentState->txBuff++;\r\n            linCurrentState->cntByte++;\r\n        }\r\n    }\r\n\r\n    if (sendFlag)\r\n    {\r\n        if (linCurrentState->cntByte < linCurrentState->txSize)\r\n        {\r\n            /* Send checksum byte */\r\n            if ((linCurrentState->txSize - linCurrentState->cntByte) == 1U)\r\n            {\r\n                LPUART_Putchar(base, linCurrentState->checkSum);\r\n            }\r\n            /* Send data bytes */\r\n            else\r\n            {\r\n                LPUART_Putchar(base, *linCurrentState->txBuff);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            linCurrentState->currentEventId = LIN_TX_COMPLETED;\r\n            linCurrentState->currentNodeState = LIN_NODE_STATE_SEND_DATA_COMPLETED;\r\n\r\n            LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, false);\r\n            /* callback function to handle event TX COMPLETED */\r\n            if (linCurrentState->Callback != NULL)\r\n            {\r\n                linCurrentState->Callback(instance, linCurrentState);\r\n            }\r\n\r\n            /* Check if the transmission is non-blocking */\r\n            if (linCurrentState->isTxBlocking == false)\r\n            {\r\n                /* Clear Tx busy flag */\r\n                linCurrentState->isTxBusy = false;\r\n\r\n                /* In this case, node is in SLEEP MODE state */\r\n                if (linCurrentState->currentNodeState != LIN_NODE_STATE_SLEEP_MODE)\r\n                {\r\n                    /* Change node's current state to IDLE */\r\n                    (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                /* Post Semaphore to signal Tx Completed*/\r\n                (void)OSIF_SemaPost(&linCurrentState->txCompleted);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_AutobaudTimerValEval\r\n * Description   : This function calculate LIN bus baudrate and set slave's baudrate accordingly.\r\n * Autobaud process runs only once after reset. After setting slave's baudrate to LIN bus baudrate,\r\n * slave does not evaluate LIN bus baudrate anymore.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n * Implements    : LIN_LPUART_DRV_AutobaudTimerValEval_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_AutobaudTimerValEval(uint32_t instance,\r\n                                                uint32_t twoBitTimeLength)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    uint32_t MasterBaudRate = 0U;\r\n\r\n    /* Get the current LIN user config structure of this LPUART instance. */\r\n    lin_user_config_t * linUserConfig = g_linUserconfigPtr[instance];\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    /* Check whether current node state is receive sync */\r\n    bool checkNodeState = (linCurrentState->currentNodeState == LIN_NODE_STATE_RECV_SYNC);\r\n\r\n    /* Evaluate average value against baudrate */\r\n    LIN_LPUART_DRV_EvalTwoBitTimeLength(instance, twoBitTimeLength);\r\n\r\n    if ((linCurrentState->fallingEdgeInterruptCount > 4U) && checkNodeState)\r\n    {\r\n        if ((twoBitTimeLength >= TWO_BIT_DURATION_MIN_19200) && (twoBitTimeLength <= TWO_BIT_DURATION_MAX_19200))\r\n        {\r\n            MasterBaudRate = 19200U;\r\n        }\r\n        else if ((twoBitTimeLength >= TWO_BIT_DURATION_MIN_14400) && (twoBitTimeLength <= TWO_BIT_DURATION_MAX_14400))\r\n        {\r\n            MasterBaudRate = 14400U;\r\n        }\r\n        else if ((twoBitTimeLength >= TWO_BIT_DURATION_MIN_9600) && (twoBitTimeLength <= TWO_BIT_DURATION_MAX_9600))\r\n        {\r\n            MasterBaudRate = 9600U;\r\n        }\r\n        else if ((twoBitTimeLength >= TWO_BIT_DURATION_MIN_4800) && (twoBitTimeLength <= TWO_BIT_DURATION_MAX_4800))\r\n        {\r\n            MasterBaudRate = 4800U;\r\n        }\r\n        else if ((twoBitTimeLength >= TWO_BIT_DURATION_MIN_2400) && (twoBitTimeLength <= TWO_BIT_DURATION_MAX_2400))\r\n        {\r\n            MasterBaudRate = 2400U;\r\n        }\r\n        else\r\n        {\r\n            /* Complete if-elseif-else block to avoid violating MISRA 2012 Rule 15.7 */\r\n        }\r\n\r\n        /* Check Master Baudrate against node's current baudrate */\r\n        if ((MasterBaudRate != 0U) && (linUserConfig->baudRate != MasterBaudRate))\r\n        {\r\n            linUserConfig->baudRate = MasterBaudRate;\r\n\r\n            /* Set new baud rate */\r\n            (void)LPUART_DRV_SetBaudRate(instance, linUserConfig->baudRate);\r\n\r\n            /* Assign wakeup signal to satisfy LIN Specifications specifies that\r\n             * wakeup signal shall be in range from 250us to 5 ms.\r\n             */\r\n            if (linUserConfig->baudRate > 10000U)\r\n            {\r\n                /* Wakeup signal will be range from 400us to 800us depend on baudrate */\r\n                s_wakeupSignal[instance] = 0x80U;\r\n            }\r\n            else\r\n            {\r\n                /* Wakeup signal will be range from 400us to 4ms depend on baudrate */\r\n                s_wakeupSignal[instance] = 0xF8U;\r\n            }\r\n        }\r\n\r\n        linCurrentState->currentEventId = LIN_BAUDRATE_ADJUSTED;\r\n        /* Disable baudrate evaluation process */\r\n        linCurrentState->baudrateEvalEnable = false;\r\n        /* Callback function to handle this event */\r\n        if (linCurrentState->Callback != NULL)\r\n        {\r\n            linCurrentState->Callback(instance, linCurrentState);\r\n        }\r\n\r\n        /* Update current state and current event */\r\n        linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_PID;\r\n        linCurrentState->currentEventId = LIN_SYNC_OK;\r\n\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_EvalTwoBitTimeLength\r\n * Description   : This function check time of double bit in sync byte for support autobaud.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n * Implements    : LIN_LPUART_DRV_EvalTwoBitTimeLength_Activity\r\n *END**************************************************************************/\r\nstatic void LIN_LPUART_DRV_EvalTwoBitTimeLength(uint32_t instance,\r\n                                                uint32_t twoBitTimeLength)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n\r\n    if (linCurrentState->fallingEdgeInterruptCount < 5U)\r\n    {\r\n        if (linCurrentState->fallingEdgeInterruptCount > 0U)\r\n        {\r\n            if ((twoBitTimeLength < TWO_BIT_DURATION_MIN_19200) ||\r\n                ((twoBitTimeLength > TWO_BIT_DURATION_MAX_19200) && (twoBitTimeLength < TWO_BIT_DURATION_MIN_14400)) ||\r\n                ((twoBitTimeLength > TWO_BIT_DURATION_MAX_14400) && (twoBitTimeLength < TWO_BIT_DURATION_MIN_9600)) ||\r\n                ((twoBitTimeLength > TWO_BIT_DURATION_MAX_9600) && (twoBitTimeLength < TWO_BIT_DURATION_MIN_4800)) ||\r\n                ((twoBitTimeLength > TWO_BIT_DURATION_MAX_4800) && (twoBitTimeLength < TWO_BIT_DURATION_MIN_2400)) ||\r\n                (twoBitTimeLength > TWO_BIT_DURATION_MAX_2400))\r\n            {\r\n                /* Change node's current state to IDLE */\r\n                (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                linCurrentState->fallingEdgeInterruptCount = 0U;\r\n            }\r\n            else\r\n            {\r\n                if (linCurrentState->fallingEdgeInterruptCount > 1U)\r\n                {\r\n                    if ((twoBitTimeLength < ((100U - BIT_RATE_TOLERANCE_UNSYNC) * s_previousTwoBitTimeLength[instance] / 100U)) ||\r\n                        (twoBitTimeLength > ((100U + BIT_RATE_TOLERANCE_UNSYNC) * s_previousTwoBitTimeLength[instance] / 100U)))\r\n                    {\r\n                        /* Change node's current state to IDLE */\r\n                        (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                        linCurrentState->fallingEdgeInterruptCount = 0U;\r\n                    }\r\n                }\r\n            }\r\n\r\n            s_previousTwoBitTimeLength[instance] = twoBitTimeLength;\r\n        }\r\n    }\r\n\r\n    linCurrentState->fallingEdgeInterruptCount += 1U;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LIN_LPUART_DRV_AutoBaudCapture\r\n * Description   : This function capture bits time to detect break char, calculate\r\n * baudrate from sync bits and enable transceiver if autobaud successful.\r\n * This function should only be used in Slave.\r\n *\r\n * Implements    : LIN_LPUART_DRV_AutoBaudCapture_Activity\r\n *END**************************************************************************/\r\nstatus_t LIN_LPUART_DRV_AutoBaudCapture(uint32_t instance)\r\n{\r\n    /* Assert parameters. */\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    /* Get base address of the LPUART instance. */\r\n    LPUART_Type * base = g_linLpuartBase[instance];\r\n    /* Get the current LIN user config structure of this LPUART instance. */\r\n    const lin_user_config_t * linUserConfig = g_linUserconfigPtr[instance];\r\n    /* Get the current LIN state of this LPUART instance. */\r\n    lin_state_t * linCurrentState = g_linStatePtr[instance];\r\n    status_t retVal = STATUS_BUSY;\r\n    uint32_t tmpTime = 0U;\r\n\r\n    if (linCurrentState->baudrateEvalEnable)\r\n    {\r\n        /* Calculate time between two bit (for service autobaud) */\r\n        (void)linUserConfig->timerGetTimeIntervalCallback(&tmpTime);\r\n\r\n        /* Get two bits time length */\r\n        s_timeMeasure[instance] += tmpTime;\r\n        s_countMeasure[instance]++;\r\n        if ((s_countMeasure[instance] > 1U))\r\n        {\r\n            switch (linCurrentState->currentNodeState)\r\n            {\r\n                /* If current state is SLEEP MODE */\r\n                case LIN_NODE_STATE_SLEEP_MODE:\r\n                    /* If length of the dominant signal is longer than 150us, it is a wakeup signal */\r\n                    if (tmpTime >= 150000U)\r\n                    {\r\n                        linCurrentState->currentEventId = LIN_WAKEUP_SIGNAL;\r\n\r\n                         /* Callback to handle event: Received a wakeup signal */\r\n                        if (linCurrentState->Callback != NULL)\r\n                        {\r\n                            linCurrentState->Callback(instance, linCurrentState);\r\n                        }\r\n\r\n                        /* Change node's state to IDLE */\r\n                        (void)LIN_LPUART_DRV_GotoIdleState(instance);\r\n                    }\r\n                    else\r\n                    {\r\n                        retVal = STATUS_ERROR;\r\n                    }\r\n                    s_countMeasure[instance] = 0U;\r\n\r\n                    break;\r\n                /* If current state is IDLE */\r\n                case LIN_NODE_STATE_IDLE:\r\n                    /* Check break time minimum */\r\n                    if (tmpTime >= AUTOBAUD_BREAK_TIME_MIN)\r\n                    {\r\n                        /* Set Break char detect length as 10 bits minimum */\r\n                        LPUART_SetBreakCharDetectLength(base, LPUART_BREAK_CHAR_10_BIT_MINIMUM);\r\n\r\n                        /* Disable LIN Break Detect Interrupt */\r\n                        LPUART_SetIntMode(base, LPUART_INT_LIN_BREAK_DETECT, false);\r\n\r\n                        /* Set flag LIN bus busy */\r\n                        linCurrentState->isBusBusy = true;\r\n\r\n                        /* Change the node's current state to RECEIVED BREAK FIELD */\r\n                        linCurrentState->currentEventId = LIN_RECV_BREAK_FIELD_OK;\r\n\r\n                        /* Callback function */\r\n                        if (linCurrentState->Callback != NULL)\r\n                        {\r\n                            linCurrentState->Callback(instance, linCurrentState);\r\n                        }\r\n\r\n                        /* Change the node's current state to RECEIVING SYNC FIELD */\r\n                        linCurrentState->currentNodeState = LIN_NODE_STATE_RECV_SYNC;\r\n\r\n                        /* Start Autobaud Count(initialize number of measurements in sync byte) */\r\n                        linCurrentState->fallingEdgeInterruptCount = 0U;\r\n\r\n                        s_countMeasure[instance] = 1U;\r\n                    }\r\n                    else\r\n                    {\r\n                        s_countMeasure[instance] = 0U;\r\n                        retVal = STATUS_ERROR;\r\n                    }\r\n\r\n                    break;\r\n                /* If current state is RECEIVE SYNC */\r\n                default:\r\n                    /* Calculate baudrate */\r\n                    LIN_LPUART_DRV_AutobaudTimerValEval(instance, s_timeMeasure[instance]);\r\n\r\n                    /* Reset to measure in next times */\r\n                    s_countMeasure[instance] = 0U;\r\n                    s_timeMeasure[instance] = 0U;\r\n\r\n                    if (linCurrentState->currentNodeState == LIN_NODE_STATE_IDLE)\r\n                    {\r\n                        retVal = STATUS_ERROR;\r\n                    }\r\n\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (linCurrentState->fallingEdgeInterruptCount > 4U)\r\n        {\r\n            /* Enable the LPUART transmitter and receiver */\r\n            LPUART_SetTransmitterCmd(base, true);\r\n            LPUART_SetReceiverCmd(base, true);\r\n\r\n            linCurrentState->fallingEdgeInterruptCount = 0U;\r\n        }\r\n\r\n        retVal = STATUS_SUCCESS;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lin_lpuart_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lin_lpuart_driver.h\r\n */\r\n\r\n#ifndef LIN_LPUART_DRIVER_H\r\n#define LIN_LPUART_DRIVER_H\r\n\r\n/*******************************************************************************\r\n * Includes\r\n ******************************************************************************/\r\n#include \"lpuart_hw_access.h\"\r\n#include \"clock_manager.h\"\r\n#include \"lin_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*! @brief Table of base addresses for LPUART instances. */\r\nextern LPUART_Type * const g_linLpuartBase[LPUART_INSTANCE_COUNT];\r\n\r\n/*! @brief Table to save LPUART IRQ enumeration numbers defined in the device header file */\r\nextern const IRQn_Type g_linLpuartRxTxIrqId[LPUART_INSTANCE_COUNT];\r\n\r\n#ifdef LPUART_ERR_IRQS\r\n/*! @brief Table to save LPUART_ERR IRQ enumeration numbers defined in the device header file */\r\nextern const IRQn_Type g_linLpuartErrIrqId[LPUART_INSTANCE_COUNT];\r\n#endif\r\n\r\n/*! @brief Table to save LPUART state structure pointers */\r\nextern lin_state_t * g_linStatePtr[LPUART_INSTANCE_COUNT];\r\n\r\n/*! @brief Table to save LIN user config structure pointers */\r\nextern lin_user_config_t * g_linUserconfigPtr[LPUART_INSTANCE_COUNT];\r\n\r\n/* Accept Master baudrate deviation from the slave baudrate to be 2% */\r\n#define AUTOBAUD_BAUDRATE_TOLERANCE (uint32_t)2U\r\n#define BIT_RATE_TOLERANCE_UNSYNC   (uint32_t)14U\r\n/* calculate range of one bit time with baudrate 19200 by formula {1000000/19200*(100 + AUTOBAUD_BAUDRATE_TOLERANCE))/100} */\r\n#define BIT_DURATION_MAX_19200      (uint32_t)(100000U * (100U + AUTOBAUD_BAUDRATE_TOLERANCE) / 192U)\r\n#define BIT_DURATION_MIN_19200      (uint32_t)(100000U * (100U - AUTOBAUD_BAUDRATE_TOLERANCE) / 192U)\r\n/* calculate range of one bit time with baudrate 14400 by formula {1000000/14400*(100 + AUTOBAUD_BAUDRATE_TOLERANCE))/100} */\r\n#define BIT_DURATION_MAX_14400      (uint32_t)(100000U * (100U + AUTOBAUD_BAUDRATE_TOLERANCE) / 144U)\r\n#define BIT_DURATION_MIN_14400      (uint32_t)(100000U * (100U - AUTOBAUD_BAUDRATE_TOLERANCE) / 144U)\r\n/* calculate range of one bit time with baudrate 9600 by formula {1000000/9600*(100 + AUTOBAUD_BAUDRATE_TOLERANCE))/100} */\r\n#define BIT_DURATION_MAX_9600       (uint32_t)(100000U * (100U + AUTOBAUD_BAUDRATE_TOLERANCE) / 96U)\r\n#define BIT_DURATION_MIN_9600       (uint32_t)(100000U * (100U - AUTOBAUD_BAUDRATE_TOLERANCE) / 96U)\r\n/* calculate range of one bit time with baudrate 4800 by formula {1000000/4800*(100 + AUTOBAUD_BAUDRATE_TOLERANCE))/100} */\r\n#define BIT_DURATION_MAX_4800       (uint32_t)(100000U * (100U + AUTOBAUD_BAUDRATE_TOLERANCE) / 48U)\r\n#define BIT_DURATION_MIN_4800       (uint32_t)(100000U * (100U - AUTOBAUD_BAUDRATE_TOLERANCE) / 48U)\r\n/* calculate range of one bit time with baudrate 2400 by formula {1000000/2400*(100 + AUTOBAUD_BAUDRATE_TOLERANCE))/100} */\r\n#define BIT_DURATION_MAX_2400       (uint32_t)(100000U * (100U + AUTOBAUD_BAUDRATE_TOLERANCE) / 24U)\r\n#define BIT_DURATION_MIN_2400       (uint32_t)(100000U * (100U - AUTOBAUD_BAUDRATE_TOLERANCE) / 24U)\r\n\r\n/* calculate range of two bit time with baudrate 19200 */\r\n#define TWO_BIT_DURATION_MAX_19200 (2U * BIT_DURATION_MAX_19200)\r\n#define TWO_BIT_DURATION_MIN_19200 (2U * BIT_DURATION_MIN_19200)\r\n/* calculate range of two bit time with baudrate 14400 */\r\n#define TWO_BIT_DURATION_MAX_14400 (2U * BIT_DURATION_MAX_14400)\r\n#define TWO_BIT_DURATION_MIN_14400 (2U * BIT_DURATION_MIN_14400)\r\n/* calculate range of two bit time with baudrate 9600 */\r\n#define TWO_BIT_DURATION_MAX_9600  (2U * BIT_DURATION_MAX_9600)\r\n#define TWO_BIT_DURATION_MIN_9600  (2U * BIT_DURATION_MIN_9600)\r\n/* calculate range of two bit time with baudrate 4800 */\r\n#define TWO_BIT_DURATION_MAX_4800  (2U * BIT_DURATION_MAX_4800)\r\n#define TWO_BIT_DURATION_MIN_4800  (2U * BIT_DURATION_MIN_4800)\r\n/* calculate range of two bit time with baudrate 2400 */\r\n#define TWO_BIT_DURATION_MAX_2400  (2U * BIT_DURATION_MAX_2400)\r\n#define TWO_BIT_DURATION_MIN_2400  (2U * BIT_DURATION_MIN_2400)\r\n\r\n/* calculate range of 13 bit time minimum with baudrate 19200 for autobaud feature */\r\n#define AUTOBAUD_BREAK_TIME_MIN    (13U * BIT_DURATION_MIN_19200)\r\n\r\n/*******************************************************************************\r\n * LPUART API\r\n ******************************************************************************/\r\n/*!\r\n * @brief Returns whether the receive data is inverted or not.\r\n *\r\n * This function returns the polarity of the receive data.\r\n *\r\n * @param base LPUART base pointer.\r\n * @return Rx data polarity; true: inverted, false: not inverted.\r\n */\r\nstatic inline bool LPUART_GetRxDataPolarity(const LPUART_Type * base)\r\n{\r\n    return (((base->STAT >> LPUART_STAT_RXINV_SHIFT) & 1U) > 0U);\r\n}\r\n\r\n/*!\r\n * @brief Sets whether the recevie data is inverted or not.\r\n *\r\n * This function sets the polarity of the receive data.\r\n *\r\n * @param base LPUART base pointer.\r\n * @param polarity  Rx Data polarity; true: inverted, false: not inverted.\r\n */\r\nstatic inline void LPUART_SetRxDataPolarity(LPUART_Type * base, bool polarity)\r\n{\r\n    base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK & ~LPUART_STAT_RXINV_MASK)) | \\\r\n                 ((polarity ? 1UL : 0UL) << LPUART_STAT_RXINV_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief  LPUART break character transmit length configuration\r\n *\r\n * This function configures the break char length.\r\n * In some LPUART instances, the user should disable the transmitter before calling\r\n * this function. Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *\r\n * @param base LPUART base pointer\r\n * @param length   LPUART break character length setting: 0 - minimum 10-bit times (default),\r\n *                   1 - minimum 13-bit times\r\n */\r\nstatic inline void LPUART_SetBreakCharTransmitLength(LPUART_Type * base,\r\n                                                         lpuart_break_char_length_t length)\r\n{\r\n    base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK & ~LPUART_STAT_BRK13_MASK)) | \\\r\n                 ((uint32_t)length << LPUART_STAT_BRK13_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief  LPUART break character detect length configuration\r\n *\r\n * This function sets the LPUART detectable break character length.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param length  LPUART break character length setting: 0 - minimum 10-bit times (default),\r\n *                  1 - minimum 13-bit times\r\n */\r\nstatic inline void LPUART_SetBreakCharDetectLength(LPUART_Type * base,\r\n                                                       lpuart_break_char_length_t length)\r\n{\r\n    base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK & ~LPUART_STAT_LBKDE_MASK)) | \\\r\n                 ((uint32_t)length << LPUART_STAT_LBKDE_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief  LPUART transmit sends break character configuration.\r\n *\r\n * This function sets break character transmission in queue mode.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n */\r\n\r\nstatic inline void LPUART_QueueBreakField(LPUART_Type * base)\r\n{\r\n    base->DATA = LPUART_DATA_FRETSC(1U);\r\n}\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Initializes an LIN_LPUART instance for LIN Network.\r\n *\r\n * The caller provides memory for the driver state structures during initialization.\r\n * The user must select the LIN_LPUART clock source in the application to initialize the LIN_LPUART.\r\n * This function initializes a LPUART instance for operation.\r\n * This function will initialize the run-time state structure to keep track of\r\n * the on-going transfers, initialize the module to user defined settings and\r\n * default settings, set break field length to be 13 bit times minimum, enable\r\n * the break detect interrupt, Rx complete interrupt, frame error detect interrupt,\r\n * and enable the LPUART module transmitter and receiver\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param linUserConfig user configuration structure of type #lin_user_config_t\r\n * @param linCurrentState pointer to the LIN_LPUART driver state structure\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : Operation was successful.\r\n *         - STATUS_ERROR   : Operation failed due to semaphores initialize error.\r\n */\r\nstatus_t LIN_LPUART_DRV_Init(uint32_t instance,\r\n                             lin_user_config_t * linUserConfig,\r\n                             lin_state_t * linCurrentState);\r\n\r\n/*!\r\n * @brief Shuts down the LIN_LPUART by disabling interrupts and transmitter/receiver.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return void\r\n */\r\nvoid LIN_LPUART_DRV_Deinit(uint32_t instance);\r\n\r\n/*!\r\n * @brief Initializes the LIN user configuration structure with default values.\r\n *\r\n * This function initializes a configuration structure received from the application\r\n * with default values.\r\n * Note: Users shall assign measurement callback function pointer that is timerGetTimeIntervalCallback\r\n * for linUserConfig. Users can see detail in doxygen.\r\n *\r\n * @param[in] isMaster Node function:\r\n                - true if node is MASTER\r\n                - false if node is SLAVE\r\n * @param[out] linUserConfig the default configuration\r\n * @return void\r\n */\r\nvoid LIN_LPUART_DRV_GetDefaultConfig(bool isMaster,\r\n                                     lin_user_config_t * linUserConfig);\r\n\r\n/*!\r\n * @brief Installs callback function that is used for LIN_LPUART_DRV_IRQHandler.\r\n *\r\n * @note After a callback is installed, it bypasses part of the LIN_LPUART IRQHandler logic.\r\n * Therefore, the callback needs to handle the indexes of txBuff and txSize.\r\n *\r\n * @param instance The LIN_LPUART instance number.\r\n * @param function The LIN_LPUART receive callback function.\r\n * @return Former LIN callback function pointer.\r\n */\r\nlin_callback_t LIN_LPUART_DRV_InstallCallback(uint32_t instance,\r\n                                              lin_callback_t function);\r\n\r\n/*!\r\n * @brief Sends Frame data out through the LIN_LPUART module using blocking method.\r\n *  This function will calculate the checksum byte and send it with the frame data.\r\n *  Blocking means that the function does not return until the transmission is complete.\r\n *  This function checks if txSize is in range from 1 to 8.\r\n *  If not, it will return STATUS_ERROR. This function also returns STATUS_ERROR\r\n *  if node's current state is in SLEEP mode. This function checks if the isBusBusy\r\n *  is false, if not it will return STATUS_BUSY. The function does not return\r\n *  until the transmission is complete. If the transmission is successful, it\r\n *  will return STATUS_SUCCESS. If not, it will return STATUS_TIMEOUT.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param txBuff  source buffer containing 8-bit data chars to send\r\n * @param txSize the number of bytes to send\r\n * @param timeoutMSec timeout value in milliseconds\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_TIMEOUT : The transmission isn't successful.\r\n */\r\nstatus_t LIN_LPUART_DRV_SendFrameDataBlocking(uint32_t instance,\r\n                                              const uint8_t * txBuff,\r\n                                              uint8_t txSize,\r\n                                              uint32_t timeoutMSec);\r\n\r\n/*!\r\n * @brief Sends frame data out through the LIN_LPUART module using non-blocking method.\r\n *  This enables an a-sync method for transmitting data.\r\n *  Non-blocking  means that the function returns immediately.\r\n *  The application has to get the transmit status to know when the transmit is complete.\r\n *  This function will calculate the checksum byte and send it with the frame data.\r\n *  If txSize is equal to 0 or greater than 8 or node's current state is in SLEEP mode\r\n *  then the function will return STATUS_ERROR. If isBusBusy is currently true then the\r\n *  function will return STATUS_BUSY.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param txBuff  source buffer containing 8-bit data chars to send\r\n * @param txSize  the number of bytes to send\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_BUSY    : Operation failed due to isBusBusy is currently true.\r\n *         - STATUS_ERROR   : Operation failed due to txSize is equal to 0 or greater than 8\r\n *                            or node's current state is in SLEEP mode\r\n */\r\nstatus_t LIN_LPUART_DRV_SendFrameData(uint32_t instance,\r\n                                      const uint8_t * txBuff,\r\n                                      uint8_t txSize);\r\n\r\n/*!\r\n * @brief Get status of an on-going non-blocking transmission\r\n *  While sending frame data using non-blocking method, users can\r\n *  use this function to get status of that transmission.\r\n *  This function return STATUS_BUSY while sending, or STATUS_TIMEOUT\r\n *  if timeout has occurred, or return STATUS_SUCCESS when the transmission is complete.\r\n *  The bytesRemaining shows number of bytes that still needed to transmit.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param bytesRemaining  Number of bytes still needed to transmit\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_BUSY    : The transmission is sending\r\n *         - STATUS_TIMEOUT : Operation failed due to timeout has occurred.\r\n */\r\nstatus_t LIN_LPUART_DRV_GetTransmitStatus(uint32_t instance,\r\n                                          uint8_t * bytesRemaining);\r\n\r\n/*!\r\n * @brief Receives frame data through the LIN_LPUART module using blocking method.\r\n *  The function does not return until the receive is complete. The interrupt\r\n *  handler LIN_LPUART_DRV_IRQHandler will check the checksum byte. If the checksum\r\n *  is correct, it will receive the frame data. If the checksum is incorrect, this\r\n *  function will return STATUS_TIMEOUT and data in rxBuff might be wrong. This function\r\n *  also check if rxSize is in range from 1 to 8. If not, it will return STATUS_ERROR.\r\n *  This function also returns STATUS_ERROR if node's current state is in SLEEP mode.\r\n *  This function checks if the isBusBusy is false, if not it will return\r\n *  STATUS_BUSY.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param rxBuff  buffer containing 8-bit received data\r\n * @param rxSize the number of bytes to receive\r\n * @param timeoutMSec timeout value in milliseconds\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The receives frame data is successful.\r\n *         - STATUS_TIMEOUT : The checksum is incorrect.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n *         - STATUS_ERROR   : Operation failed due is equal to 0 or greater than 8 or\r\n *                            node's current state is in SLEEP mode\r\n */\r\nstatus_t LIN_LPUART_DRV_RecvFrmDataBlocking(uint32_t instance,\r\n                                            uint8_t * rxBuff,\r\n                                            uint8_t rxSize,\r\n                                            uint32_t timeoutMSec);\r\n\r\n/*!\r\n * @brief Receives frame data through the LIN_LPUART module using non-blocking method.\r\n *  This function returns immediately after initiating the receive function.\r\n *  The application has to get the receive status to see when the receive is complete.\r\n *  The interrupt handler LIN_LPUART_DRV_IRQHandler will check the checksum byte.\r\n *  If the checksum is correct, it will receive the frame data.\r\n *  If the checksum is incorrect, this function will return STATUS_TIMEOUT and data in\r\n *  rxBuff might be wrong. This function also check if rxSize is in range from 1 to 8.\r\n *  If not, it will return STATUS_ERROR. This function also returns STATUS_ERROR if\r\n *  node's current state is in SLEEP mode. This function checks if the isBusBusy is\r\n *  false, if not it will return STATUS_BUSY.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param rxBuff  buffer containing 8-bit received data\r\n * @param rxSize the number of bytes to receive\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The receives frame data is successful.\r\n *         - STATUS_TIMEOUT : The checksum is incorrect.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n *         - STATUS_ERROR   : Operation failed due is equal to 0 or greater than 8 or\r\n *                            node's current state is in SLEEP mode\r\n */\r\nstatus_t LIN_LPUART_DRV_RecvFrmData(uint32_t instance,\r\n                                    uint8_t * rxBuff,\r\n                                    uint8_t rxSize);\r\n\r\n/*!\r\n * @brief Aborts an on-going non-blocking transmission/reception.\r\n *  While performing a non-blocking transferring data, users can call this function\r\n *  to terminate immediately the transferring.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return function always return STATUS_SUCCESS\r\n */\r\nstatus_t LIN_LPUART_DRV_AbortTransferData(uint32_t instance);\r\n\r\n/*!\r\n * @brief Get status of an on-going non-blocking reception\r\n *  While receiving frame data using non-blocking method, users can\r\n *  use this function to get status of that receiving.\r\n *  This function return the current event ID, STATUS_BUSY while receiving\r\n *  and return STATUS_SUCCESS, or timeout (STATUS_TIMEOUT) when the reception is complete.\r\n *  The bytesRemaining shows number of bytes that still needed to receive.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @param bytesRemaining  Number of bytes still needed to receive\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The reception is complete.\r\n *         - STATUS_TIMEOUT : The reception isn't complete.\r\n *         - STATUS_BUSY    : The reception is on going\r\n */\r\nstatus_t LIN_LPUART_DRV_GetReceiveStatus(uint32_t instance,\r\n                                         uint8_t * bytesRemaining);\r\n\r\n/*!\r\n * @brief This function puts current node to sleep mode\r\n * This function changes current node state to LIN_NODE_STATE_SLEEP_MODE\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return function always return STATUS_SUCCESS\r\n */\r\nstatus_t LIN_LPUART_DRV_GoToSleepMode(uint32_t instance);\r\n\r\n/*!\r\n * @brief Puts current LIN node to Idle state\r\n * This function changes current node state to LIN_NODE_STATE_IDLE\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return function always return STATUS_SUCCESS\r\n */\r\nstatus_t LIN_LPUART_DRV_GotoIdleState(uint32_t instance);\r\n\r\n/*!\r\n * @brief Sends a wakeup signal through the LIN_LPUART interface\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : Bus busy flag is false.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n */\r\nstatus_t LIN_LPUART_DRV_SendWakeupSignal(uint32_t instance);\r\n\r\n/*!\r\n * @brief Get the current LIN node state\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return current LIN node state\r\n */\r\nlin_node_state_t LIN_LPUART_DRV_GetCurrentNodeState(uint32_t instance);\r\n\r\n/*!\r\n * @brief Callback function for Timer Interrupt Handler\r\n * Users shall initialize a timer (for example FTM) in Output compare mode\r\n * with period of 500 micro seconds. In timer IRQ handler, call this function.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return void\r\n */\r\nvoid LIN_LPUART_DRV_TimeoutService(uint32_t instance);\r\n\r\n/*!\r\n * @brief Set Value for Timeout Counter that is used in LIN_LPUART_DRV_TimeoutService\r\n *\r\n * @param instance LPUART instance number\r\n * @param timeoutValue  Timeout Value to be set\r\n * @return void\r\n */\r\nvoid LIN_LPUART_DRV_SetTimeoutCounter(uint32_t instance,\r\n                                      uint32_t timeoutValue);\r\n\r\n/*!\r\n * @brief Sends frame header out through the LIN_LPUART module using a non-blocking method.\r\n * This function sends LIN Break field, sync field then the ID with\r\n * correct parity. This function checks if the interface is Master, if not, it will\r\n * return STATUS_ERROR.This function checks if id is in range from 0 to 0x3F, if not\r\n * it will return STATUS_ERROR.\r\n *\r\n * @param instance LIN_LPUART instance number.\r\n * @param id  Frame Identifier.\r\n * @return operation status:\r\n *         - STATUS_SUCCESS : The transmission is successful.\r\n *         - STATUS_BUSY    : Bus busy flag is true.\r\n *         - STATUS_ERROR   : The interface isn't Master or id isn't in range from 0 to 0x3F\r\n *                            or node's current state is in SLEEP mode.\r\n */\r\nstatus_t LIN_LPUART_DRV_MasterSendHeader(uint32_t instance,\r\n                                         uint8_t id);\r\n\r\n/*!\r\n * @brief Enables LIN_LPUART hardware interrupts.\r\n *\r\n * @param instance LIN_LPUART instance number.\r\n * @return function always return STATUS_SUCCESS.\r\n */\r\nstatus_t LIN_LPUART_DRV_EnableIRQ(uint32_t instance);\r\n\r\n/*!\r\n * @brief Disables LIN_LPUART hardware interrupts.\r\n *\r\n * @param instance LIN_LPUART instance number.\r\n * @return function always return STATUS_SUCCESS.\r\n */\r\nstatus_t LIN_LPUART_DRV_DisableIRQ(uint32_t instance);\r\n\r\n/*!\r\n * @brief LIN_LPUART interrupt handler for RX_TX and Error interrupts.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return void\r\n */\r\nvoid LIN_LPUART_DRV_IRQHandler(uint32_t instance);\r\n\r\n/*!\r\n * @brief LIN_LPUART capture time interval to set baudrate automatically\r\n * when enable autobaud feature.\r\n * This function should only be used in Slave.\r\n * The timer should be in input capture mode of both rising and falling edges.\r\n * The timer input capture pin should be externally connected to RXD pin.\r\n *\r\n * @param instance LIN_LPUART instance number\r\n * @return operation status\r\n *        - STATUS_SUCCESS: Operation was successful.\r\n *        - STATUS_BUSY:    Operation is running.\r\n *        - STATUS_ERROR:   Operation failed due to break char incorrect,\r\n *                          wakeup signal incorrect\r\n *                          or calculate baudrate failed.\r\n */\r\nstatus_t LIN_LPUART_DRV_AutoBaudCapture(uint32_t instance);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n#endif /* LIN_LPUART_DRIVER_H */\r\n/******************************************************************************/\r\n/* EOF */\r\n/******************************************************************************/\r\n"},{"name":"lpit_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lpit_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3,  Taking address of near auto variable.\r\n * The code is not dynamically linked. An absolute stack address is obtained\r\n * when taking the address of the near auto variable.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n */\r\n\r\n#include <stddef.h>\r\n#include \"lpit_driver.h\"\r\n#include \"lpit_hw_access.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"clock_manager.h\"\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/* Table of base addresses for LPIT instances */\r\nstatic LPIT_Type * const s_lpitBase[] = LPIT_BASE_PTRS;\r\n/* Table to save LPIT indexes in PCC register map for clock configuration */\r\nstatic const clock_names_t s_lpitClkNames[LPIT_INSTANCE_COUNT] = LPIT_CLOCK_NAMES;\r\n/* LPIT functional clock variable which will be updated in some driver functions */\r\nstatic uint32_t s_lpitSourceClockFrequency[LPIT_INSTANCE_COUNT] = {0};\r\n\r\n/******************************************************************************\r\n * Code\r\n *****************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetDefaultConfig\r\n * Description   : This function gets default LPIT module configuration structure.\r\n *\r\n * Implements    : LPIT_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_GetDefaultConfig(lpit_user_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->enableRunInDebug = false;\r\n    config->enableRunInDoze = false;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetDefaultChanConfig\r\n * Description   : This function gets default timer channel configuration structure.\r\n *\r\n * Implements    : LPIT_DRV_GetDefaultChanConfig_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_GetDefaultChanConfig(lpit_user_channel_config_t * const config)\r\n{\r\n    DEV_ASSERT(config != NULL);\r\n\r\n    config->timerMode = LPIT_PERIODIC_COUNTER;\r\n    config->periodUnits = LPIT_PERIOD_UNITS_MICROSECONDS;\r\n    config->period = 1000000U;\r\n    config->triggerSource = LPIT_TRIGGER_SOURCE_EXTERNAL;\r\n    config->triggerSelect = 0U;\r\n    config->enableReloadOnTrigger = false;\r\n    config->enableStopOnInterrupt = false;\r\n    config->enableStartOnTrigger = false;\r\n    config->chainChannel = false;\r\n    config->isInterruptEnabled = true;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_Init\r\n * Description   : Initializes LPIT module.\r\n * This function resets LPIT module, enables the LPIT module, configures LPIT\r\n * module operation in Debug and DOZE mode. The LPIT configuration structure shall\r\n * be passed as arguments.\r\n * This configuration structure affects all timer channels.\r\n * This function should be called before calling any other LPIT driver function.\r\n *\r\n * Implements    : LPIT_DRV_Init_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_Init(uint32_t instance,\r\n                   const lpit_user_config_t *userConfig)\r\n{\r\n    LPIT_Type * base;\r\n    status_t clkErr;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(userConfig != NULL);\r\n\r\n    /* Gets current functional clock frequency of LPIT instance */\r\n    clkErr = CLOCK_SYS_GetFreq(s_lpitClkNames[instance], &s_lpitSourceClockFrequency[instance]);\r\n    /* Checks the functional clock of LPIT module */\r\n    (void)clkErr;\r\n    DEV_ASSERT(clkErr == STATUS_SUCCESS);\r\n    DEV_ASSERT(s_lpitSourceClockFrequency[instance] > 0U);\r\n    /* When resetting the LPIT module, a delay of 4 peripheral clock cycles\r\n        must be ensured. This peripheral clock and the core clock running the\r\n        code could be very different, two distinct cases are identified:\r\n         - core_clk > peripheral_clk. This requires a delay loop to be implemented,\r\n            and the delay value based on the ratio between the two frequencies.\r\n         - core_clk <= peripheral_clk. This requires a short delay, which is usually\r\n            below the delay caused naturally by the read-modify-write operation.\r\n     */\r\n    uint32_t core_freq = 0u;\r\n    clkErr = CLOCK_SYS_GetFreq(CORE_CLK, &core_freq);\r\n    (void)clkErr;\r\n    uint32_t lpit_freq = s_lpitSourceClockFrequency[instance];\r\n    uint32_t core_to_per_clock_ratio = (core_freq + (lpit_freq >> 1u)) / lpit_freq;\r\n    base = s_lpitBase[instance];\r\n    /* Resets LPIT module */\r\n    LPIT_Reset(base, core_to_per_clock_ratio);\r\n    /* Enables functional clock of LPIT module*/\r\n    LPIT_Enable(base, core_to_per_clock_ratio);\r\n    /* Sets LPIT operation in Debug and DOZE mode*/\r\n    LPIT_SetTimerRunInDebugCmd(base, userConfig->enableRunInDebug);\r\n    LPIT_SetTimerRunInDozeCmd(base, userConfig->enableRunInDoze);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_Deinit\r\n * Description   : De-initializes LPIT module.\r\n * This function disables LPIT module.\r\n * In order to use the LPIT module again, LPIT_DRV_Init must be called.\r\n *\r\n * Implements    : LPIT_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_Deinit(uint32_t instance)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Disables LPIT module functional clock*/\r\n    LPIT_Disable(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_InitChannel\r\n * Description   : Initializes LPIT channel.\r\n * This function initializes the LPIT timers by using a channel, this function\r\n * configures timer channel chaining, timer channel mode, timer channel period,\r\n * interrupt generation, trigger source, trigger select, reload on trigger,\r\n * stop on interrupt and start on trigger.\r\n * The timer channel number and its configuration structure shall be passed as arguments.\r\n * Timer channels do not start counting by default after calling this function.\r\n * The function LPIT_DRV_StartTimerChannels must be called to start the timer channel counting.\r\n * In order to re-configures the period, call the LPIT_DRV_SetTimerPeriodByUs or\r\n * LPIT_DRV_SetTimerPeriodByCount.\r\n *\r\n * Implements    : LPIT_DRV_InitChannel_Activity\r\n *END**************************************************************************/\r\nstatus_t LPIT_DRV_InitChannel(uint32_t instance,\r\n                              uint32_t channel,\r\n                              const lpit_user_channel_config_t * userChannelConfig)\r\n{\r\n    LPIT_Type * base;\r\n    status_t reVal = STATUS_SUCCESS;\r\n    const IRQn_Type lpitIrqId[] = LPIT_IRQS;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(userChannelConfig != NULL);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    base = s_lpitBase[instance];\r\n\r\n    if ((channel == 0U) && (userChannelConfig->chainChannel))\r\n    {\r\n        reVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        /* Setups the timer channel chaining  */\r\n        LPIT_SetTimerChannelChainCmd(base, channel, userChannelConfig->chainChannel);\r\n        /*  Setups the timer channel operation mode */\r\n        LPIT_SetTimerChannelModeCmd(base, channel, userChannelConfig->timerMode);\r\n        if (userChannelConfig->periodUnits == LPIT_PERIOD_UNITS_MICROSECONDS)\r\n        {\r\n            /* Setups timer channel period in microsecond unit */\r\n            reVal = LPIT_DRV_SetTimerPeriodByUs(instance, channel, userChannelConfig->period);\r\n        }\r\n        else\r\n        {\r\n            /* Setups timer channel period in count unit */\r\n            LPIT_DRV_SetTimerPeriodByCount(instance, channel, userChannelConfig->period);\r\n        }\r\n\r\n        if (reVal == STATUS_SUCCESS)\r\n        {\r\n            /* Setups the timer channel trigger source, trigger select, reload on trigger,\r\n            stop on timeout, start on trigger and channel chaining */\r\n            LPIT_SetTriggerSourceCmd(base, channel, userChannelConfig->triggerSource);\r\n            LPIT_SetTriggerSelectCmd(base, channel, userChannelConfig->triggerSelect);\r\n            LPIT_SetReloadOnTriggerCmd(base, channel, userChannelConfig->enableReloadOnTrigger);\r\n            LPIT_SetStopOnInterruptCmd(base, channel, userChannelConfig->enableStopOnInterrupt);\r\n            LPIT_SetStartOnTriggerCmd(base, channel, userChannelConfig->enableStartOnTrigger);\r\n            /* Setups interrupt generation for timer channel */\r\n            if (userChannelConfig->isInterruptEnabled)\r\n            {\r\n                /* Enables interrupt generation */\r\n                LPIT_EnableInterruptTimerChannels(base, (uint32_t)1U << channel);\r\n                INT_SYS_EnableIRQ(lpitIrqId[channel]);\r\n            }\r\n            else\r\n            {\r\n                /* Disables interrupt generation */\r\n                LPIT_DisableInterruptTimerChannels(base, (uint32_t)1U << channel);\r\n                /* Only disable channel interrupt globally if each channel has a separate interrupt line */\r\n#if (FEATURE_LPIT_HAS_NUM_IRQS_CHANS == LPIT_TMR_COUNT)\r\n                INT_SYS_DisableIRQ(lpitIrqId[channel]);\r\n#endif\r\n            }\r\n        }\r\n    }\r\n    return reVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_StartTimerChannels\r\n * Description   : Starts timer channel counting.\r\n * This function allows starting timer channels simultaneously .\r\n * After calling this function, timer channels are going operate depend on mode and\r\n * control bits which controls timer channel start, reload and restart.\r\n *\r\n * Implements    : LPIT_DRV_StartTimerChannels_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_StartTimerChannels(uint32_t instance,\r\n                                 uint32_t mask)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(mask < (1UL << LPIT_TMR_COUNT));\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Starts timer channel counting */\r\n    LPIT_StartTimerChannels(base, mask);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_StopTimerChannels\r\n * Description   : Stop timer channel from counting.\r\n * This function allows stop timer channels simultaneously from counting.\r\n * Timer channels reload their periods respectively after the next time\r\n * they call the LPIT_DRV_StartTimerChannels. Note that: In 32-bit Trigger Accumulator\r\n * mode, the counter will load on the first trigger rising edge.\r\n *\r\n * Implements    : LPIT_DRV_StopTimerChannels_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_StopTimerChannels(uint32_t instance,\r\n                                uint32_t mask)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(mask < (1UL << LPIT_TMR_COUNT));\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Stops timer channel from counting */\r\n    LPIT_StopTimerChannels(base, mask);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_SetTimerPeriodByUs\r\n * Description   : Sets timer channel period in microseconds unit.\r\n * This function sets the timer channel period in microseconds\r\n * when timer channel mode is 32 bit periodic or dual 16 bit counter mode.\r\n * The period range depends on the frequency of the LPIT functional clock and\r\n * operation mode of timer channel.\r\n * If the required period is out of range, use the suitable mode if applicable.\r\n * This function is only valid for one single channel.\r\n *\r\n * Implements    : LPIT_DRV_SetTimerPeriodByUs_Activity\r\n *END**************************************************************************/\r\nstatus_t LPIT_DRV_SetTimerPeriodByUs(uint32_t instance,\r\n                                     uint32_t channel,\r\n                                     uint32_t periodUs)\r\n{\r\n    LPIT_Type * base;\r\n    lpit_timer_modes_t timerMode;\r\n    status_t clkErr;\r\n    status_t reVal = STATUS_SUCCESS;\r\n    uint64_t count;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    /* Gets current functional clock frequency of LPIT instance */\r\n    clkErr = CLOCK_SYS_GetFreq(s_lpitClkNames[instance], &s_lpitSourceClockFrequency[instance]);\r\n    /* Checks the functional clock of LPIT module */\r\n    (void)clkErr;\r\n    DEV_ASSERT(clkErr == STATUS_SUCCESS);\r\n    DEV_ASSERT(s_lpitSourceClockFrequency[instance] > 0U);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Calculates the count value, assign it to timer channel counter register.*/\r\n    count = ((uint64_t)periodUs) * s_lpitSourceClockFrequency[instance];\r\n    count = (count / 1000000U) - 1U;\r\n    /* Gets current timer channel operation mode */\r\n    timerMode = LPIT_GetTimerChannelModeCmd(base, channel);\r\n    /* Checks whether the count is valid with timer channel operation mode */\r\n    if (count <= MAX_PERIOD_COUNT)\r\n    {\r\n        if (timerMode == LPIT_DUAL_PERIODIC_COUNTER)\r\n        {\r\n            if (count > MAX_PERIOD_COUNT_IN_DUAL_16BIT_MODE)\r\n            {\r\n                reVal = STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                if (count > MAX_PERIOD_COUNT_16_BIT)\r\n                {\r\n                    /* Calculates the count value for dual 16 bit periodic counter mode */\r\n                    count = ((count - (MAX_PERIOD_COUNT_16_BIT + 1U)) << 16U)\r\n                            | (MAX_PERIOD_COUNT_16_BIT);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        reVal = STATUS_ERROR;\r\n    }\r\n    if (reVal == STATUS_SUCCESS)\r\n    {\r\n        /* Sets the timer channel period in count unit */\r\n        LPIT_SetTimerPeriodByCount(base, channel, (uint32_t)count);\r\n    }\r\n    return reVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_SetTimerPeriodInDual16ModeByUs\r\n * Description   : Sets timer channel period in microseconds unit.\r\n * This function sets the timer channel period in microseconds\r\n * when timer channel mode is dual 16 bit periodic counter mode.\r\n * The period range depends on the frequency of the LPIT functional clock and\r\n * operation mode of timer channel.\r\n * If the required period is out of range, use the suitable mode if applicable.\r\n * This function is only valid for one single channel.\r\n *\r\n * Implements    : LPIT_DRV_SetTimerPeriodInDual16ModeByUs_Activity\r\n *END**************************************************************************/\r\nstatus_t LPIT_DRV_SetTimerPeriodInDual16ModeByUs(uint32_t instance,\r\n                                                 uint32_t channel,\r\n                                                 uint16_t periodHigh,\r\n                                                 uint16_t periodLow)\r\n{\r\n    LPIT_Type * base;\r\n    status_t reVal = STATUS_SUCCESS;\r\n    status_t clkErr;\r\n    uint64_t periodHighCount;\r\n    uint64_t periodLowCount;\r\n    uint64_t periodCount;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    /* Gets current functional clock frequency of LPIT instance */\r\n    clkErr = CLOCK_SYS_GetFreq(s_lpitClkNames[instance], &s_lpitSourceClockFrequency[instance]);\r\n    /* Checks the functional clock of LPIT module */\r\n    (void)clkErr;\r\n    DEV_ASSERT(clkErr == STATUS_SUCCESS);\r\n    DEV_ASSERT(s_lpitSourceClockFrequency[instance] > 0U);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Calculates the count value of 16 bit higher period.*/\r\n    periodHighCount = ((uint64_t)periodHigh) * s_lpitSourceClockFrequency[instance];\r\n    periodHighCount = (periodHighCount / 1000000U) - 1U;\r\n\r\n    /* Calculates the count value of 16 bit lower period.*/\r\n    periodLowCount = ((uint64_t)periodLow) * s_lpitSourceClockFrequency[instance];\r\n    periodLowCount = (periodLowCount / 1000000U) - 1U;\r\n    /* Checks whether the count is valid */\r\n    if ((periodHighCount > MAX_PERIOD_COUNT_16_BIT) || (periodLowCount > MAX_PERIOD_COUNT_16_BIT))\r\n    {\r\n        reVal = STATUS_ERROR;\r\n    }\r\n    else\r\n    {\r\n        periodCount = (periodHighCount << 16U) | periodLowCount;\r\n        LPIT_SetTimerPeriodByCount(base, channel, (uint32_t)periodCount);\r\n    }\r\n\r\n    return reVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetTimerPeriodByUs\r\n * Description   : Gets the timer channel period in microseconds.\r\n * The returned period here makes sense if the operation mode of timer channel\r\n * is 32 bit periodic counter or dual 16 bit periodic counter.\r\n *\r\n * Implements    : LPIT_DRV_GetTimerPeriodByUs_Activity\r\n *END**************************************************************************/\r\nuint64_t LPIT_DRV_GetTimerPeriodByUs(uint32_t instance,\r\n                                     uint32_t channel)\r\n{\r\n    const LPIT_Type * base;\r\n    status_t clkErr;\r\n    lpit_timer_modes_t timerMode;\r\n    uint64_t currentPeriod;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    /* Gets current functional clock frequency of LPIT instance */\r\n    clkErr = CLOCK_SYS_GetFreq(s_lpitClkNames[instance], &s_lpitSourceClockFrequency[instance]);\r\n    /* Checks the functional clock of LPIT module */\r\n    (void)clkErr;\r\n    DEV_ASSERT(clkErr == STATUS_SUCCESS);\r\n    DEV_ASSERT(s_lpitSourceClockFrequency[instance] > 0U);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Gets current timer channel period in count.*/\r\n    currentPeriod = LPIT_GetTimerPeriodByCount(base, channel);\r\n    /* Gets current timer channel operation mode */\r\n    timerMode = LPIT_GetTimerChannelModeCmd(base, channel);\r\n\r\n    if (timerMode == LPIT_DUAL_PERIODIC_COUNTER)\r\n    {\r\n        if (currentPeriod > MAX_PERIOD_COUNT_16_BIT)\r\n        {\r\n            currentPeriod = (((currentPeriod >> 16U) + (currentPeriod & MAX_PERIOD_COUNT_16_BIT) + 2U) * 1000000U)\r\n                              / s_lpitSourceClockFrequency[instance];\r\n        }\r\n        else\r\n        {\r\n            /* Converts period from count unit to microseconds unit for other modes */\r\n            currentPeriod = ((currentPeriod + 1U) * 1000000U) / s_lpitSourceClockFrequency[instance];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* Converts period from count unit to microseconds unit for other modes */\r\n        currentPeriod = ((currentPeriod + 1U) * 1000000U) / s_lpitSourceClockFrequency[instance];\r\n    }\r\n    return currentPeriod;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetCurrentTimerUs\r\n * Description   : Gets current timer channel counting value in microseconds unit.\r\n * This function returns an absolute time stamp in microseconds.\r\n * One common use of this function is to measure the running time of a part of\r\n * code. Call this function at both the beginning and end of code. The time\r\n * difference between these two time stamps is the running time.\r\n * The return counting value here makes sense if the operation mode of timer channel\r\n * is 32 bit periodic counter or dual 16 bit periodic counter or 32-bit trigger input capture.\r\n * Need to make sure the running time will not exceed the timer channel period.\r\n *\r\n * Implements    : LPIT_DRV_GetCurrentTimerUs_Activity\r\n *END**************************************************************************/\r\nuint64_t LPIT_DRV_GetCurrentTimerUs(uint32_t instance,\r\n                                    uint32_t channel)\r\n{\r\n    const LPIT_Type * base;\r\n    status_t clkErr;\r\n    lpit_timer_modes_t timerMode;\r\n    uint64_t currentTime = 0U;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    /* Gets current functional clock frequency of LPIT instance */\r\n    clkErr = CLOCK_SYS_GetFreq(s_lpitClkNames[instance], &s_lpitSourceClockFrequency[instance]);\r\n    (void)clkErr;\r\n    DEV_ASSERT(s_lpitSourceClockFrequency[instance] > 0U);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Gets current timer channel counting value */\r\n    currentTime = LPIT_GetCurrentTimerCount(base, channel);\r\n    /* Gets current timer channel operation mode */\r\n    timerMode = LPIT_GetTimerChannelModeCmd(base, channel);\r\n\r\n    if (timerMode == LPIT_DUAL_PERIODIC_COUNTER)\r\n    {\r\n        currentTime = (((currentTime >> 16U) + (currentTime & MAX_PERIOD_COUNT_16_BIT)) * 1000000U)\r\n                          / s_lpitSourceClockFrequency[instance];\r\n    }\r\n    else\r\n    {\r\n        /* Converts counting value to microseconds unit for other modes */\r\n        currentTime = (currentTime * 1000000U) / s_lpitSourceClockFrequency[instance];\r\n    }\r\n\r\n    return currentTime;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_SetTimerPeriodByCount\r\n * Description   : Sets the timer channel period in count unit.\r\n * This function sets the timer channel period in count unit.\r\n * The counter period of a running timer channel can be modified by first setting\r\n * a new load value, the value will be loaded after the timer channel expires.\r\n * To abort the current cycle and start a timer channel period with the new value,\r\n * the timer channel must be disabled and enabled again.\r\n *\r\n * Implements    : LPIT_DRV_SetTimerPeriodByCount_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_SetTimerPeriodByCount(uint32_t instance,\r\n                                    uint32_t channel,\r\n                                    uint32_t count)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Sets the timer channel period in count unit */\r\n    LPIT_SetTimerPeriodByCount(base, channel, count);\r\n\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_SetTimerPeriodInDual16ModeByCount\r\n * Description   : Sets the timer channel period in count unit.\r\n * This function sets the timer channel period in count unit when timer channel\r\n * mode is dual 16 periodic counter mode.\r\n * The counter period of a running timer channel can be modified by first setting\r\n * a new load value, the value will be loaded after the timer channel expires.\r\n * To abort the current cycle and start a timer channel period with the new value,\r\n * the timer channel must be disabled and enabled again.\r\n *\r\n * Implements    : LPIT_DRV_SetTimerPeriodInDual16ModeByCount_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_SetTimerPeriodInDual16ModeByCount(uint32_t instance,\r\n                                                uint32_t channel,\r\n                                                uint16_t periodHigh,\r\n                                                uint16_t periodLow)\r\n{\r\n    LPIT_Type * base;\r\n    uint32_t period;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    base = s_lpitBase[instance];\r\n\r\n    period = ((uint32_t)periodHigh << 16U) | periodLow;\r\n    /* Sets the timer channel period in count unit */\r\n    LPIT_SetTimerPeriodByCount(base, channel, period);\r\n\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetTimerPeriodByCount\r\n * Description   : Gets the current timer channel period in count unit.\r\n *\r\n * Implements    : LPIT_DRV_GetTimerPeriodByCount_Activity\r\n *END**************************************************************************/\r\nuint32_t LPIT_DRV_GetTimerPeriodByCount(uint32_t instance,\r\n                                        uint32_t channel)\r\n{\r\n    const LPIT_Type * base;\r\n    lpit_timer_modes_t timerMode;\r\n    uint32_t currentPeriod;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Gets current timer channel period by count.*/\r\n    currentPeriod = LPIT_GetTimerPeriodByCount(base, channel);\r\n    /* Gets current timer channel operation mode */\r\n    timerMode = LPIT_GetTimerChannelModeCmd(base, channel);\r\n\r\n    if (timerMode == LPIT_DUAL_PERIODIC_COUNTER)\r\n    {\r\n        /* Calculates the period for dual 16 bit periodic counter mode */\r\n        currentPeriod = (currentPeriod >> 16U) + (currentPeriod & MAX_PERIOD_COUNT_16_BIT);\r\n    }\r\n    return currentPeriod;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetCurrentTimerCount\r\n * Description   : Gets the current timer channel counting value in count.\r\n * This function returns the real-time timer channel counting value, the value in\r\n * a range from 0 to timer channel period.\r\n * Need to make sure the running time does not exceed the timer channel period.\r\n *\r\n * Implements    : LPIT_DRV_GetCurrentTimerCount_Activity\r\n *END**************************************************************************/\r\nuint32_t LPIT_DRV_GetCurrentTimerCount(uint32_t instance,\r\n                                       uint32_t channel)\r\n{\r\n    const LPIT_Type * base;\r\n    lpit_timer_modes_t timerMode;\r\n    uint32_t currentTime;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(channel < LPIT_TMR_COUNT);\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Gets current timer channel counting value */\r\n    currentTime = LPIT_GetCurrentTimerCount(base, channel);\r\n    /* Gets current timer channel operation mode */\r\n    timerMode = LPIT_GetTimerChannelModeCmd(base, channel);\r\n\r\n    if (timerMode == LPIT_DUAL_PERIODIC_COUNTER)\r\n    {\r\n        /* Calculates the current counting value for dual 16 bit periodic counter mode */\r\n        currentTime = (currentTime >> 16U) + (currentTime & MAX_PERIOD_COUNT_16_BIT);\r\n    }\r\n    return currentTime;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_EnableTimerChannelInterrupt\r\n * Description   : This function allows enabling interrupt generation of timer channel\r\n * when timeout occurs or input trigger occurs.\r\n *\r\n * Implements    : LPIT_DRV_EnableTimerChannelInterrupt_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_EnableTimerChannelInterrupt(uint32_t instance,\r\n                                          uint32_t mask)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(mask < (1UL << LPIT_TMR_COUNT));\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Enable interrupt of timer channels */\r\n    LPIT_EnableInterruptTimerChannels(base, mask);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_DisableTimerChannelInterrupt\r\n * Description   : This function allows disabling interrupt generation of timer channel\r\n * when timeout occurs or input trigger occurs.\r\n *\r\n * Implements    : LPIT_DRV_DisableTimerChannelInterrupt_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_DisableTimerChannelInterrupt(uint32_t instance,\r\n                                           uint32_t mask)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(mask < (1UL << LPIT_TMR_COUNT));\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Disable interrupt of timer channels */\r\n    LPIT_DisableInterruptTimerChannels(base, mask);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_GetInterruptFlagTimerChannels\r\n * Description   : Gets the current interrupt flag of timer channels.\r\n * In compare modes, the flag sets to 1 at the end of the timer period.\r\n * In capture modes, the flag sets to 1 when the trigger asserts.\r\n *\r\n * Implements    : LPIT_DRV_GetInterruptFlagTimerChannels_Activity\r\n *END**************************************************************************/\r\nuint32_t LPIT_DRV_GetInterruptFlagTimerChannels(uint32_t instance,\r\n                                                uint32_t mask)\r\n{\r\n    const LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(mask < (1UL << LPIT_TMR_COUNT));\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Gets the interrupt flag for timer channels */\r\n    return LPIT_GetInterruptFlagTimerChannels(base, mask);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPIT_DRV_ClearInterruptFlagTimerChannels\r\n * Description   : Clears the interrupt flag of timer channels.\r\n * This function clears the interrupt flag of timer channels after\r\n * their interrupt event occurred.\r\n * Implements    : LPIT_DRV_ClearInterruptFlagTimerChannels_Activity\r\n *END**************************************************************************/\r\nvoid LPIT_DRV_ClearInterruptFlagTimerChannels(uint32_t instance,\r\n                                              uint32_t mask)\r\n{\r\n    LPIT_Type * base;\r\n\r\n    DEV_ASSERT(instance < LPIT_INSTANCE_COUNT);\r\n    DEV_ASSERT(mask < (1UL << LPIT_TMR_COUNT));\r\n\r\n    base = s_lpitBase[instance];\r\n    /* Clears the interrupt flag for timer channels */\r\n    LPIT_ClearInterruptFlagTimerChannels(base, mask);\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpit_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\inc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lpit_driver.h\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macros define the maximum of timer period in some modes and might be used by user.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n */\r\n\r\n#ifndef LPIT_DRIVER_H\r\n#define LPIT_DRIVER_H\r\n\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n#include \"status.h\"\r\n\r\n/*!\r\n * @addtogroup lpit_drv\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*! @brief Max period in count of all operation mode except for dual 16 bit periodic counter mode */\r\n#define MAX_PERIOD_COUNT                    (0xFFFFFFFFU)\r\n/*! @brief Max period in count of dual 16 bit periodic counter mode                               */\r\n#define MAX_PERIOD_COUNT_IN_DUAL_16BIT_MODE (0x1FFFEU)\r\n/*! @brief Max count of 16 bit                                */\r\n#define MAX_PERIOD_COUNT_16_BIT (0xFFFFU)\r\n\r\n/*!\r\n * @brief Mode options available for the LPIT timer\r\n * Implements : lpit_timer_modes_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPIT_PERIODIC_COUNTER      = 0x00U,  /*!< 32-bit Periodic Counter        */\r\n    LPIT_DUAL_PERIODIC_COUNTER = 0x01U,  /*!< Dual 16-bit Periodic Counter   */\r\n    LPIT_TRIGGER_ACCUMULATOR   = 0x02U,  /*!< 32-bit Trigger Accumulator     */\r\n    LPIT_INPUT_CAPTURE         = 0x03U   /*!< 32-bit Trigger Input Capture   */\r\n} lpit_timer_modes_t;\r\n\r\n/*!\r\n * @brief Trigger source options.\r\n *\r\n * This is used for both internal and external trigger sources. The actual trigger\r\n * options available is SoC specific, user should refer to the reference manual.\r\n * Implements : lpit_trigger_source_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPIT_TRIGGER_SOURCE_EXTERNAL = 0x00U, /*!< Use external trigger  */\r\n    LPIT_TRIGGER_SOURCE_INTERNAL = 0x01U  /*!< Use internal trigger  */\r\n}  lpit_trigger_source_t;\r\n\r\n/*!\r\n * @brief Unit options for LPIT period.\r\n *\r\n * This is used to determine unit of timer period\r\n * Implements : lpit_period_units_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPIT_PERIOD_UNITS_COUNTS        = 0x00U, /*!< Period value unit is count */\r\n    LPIT_PERIOD_UNITS_MICROSECONDS  = 0x01U  /*!< Period value unit is microsecond */\r\n} lpit_period_units_t;\r\n\r\n/*!\r\n * @brief LPIT configuration structure\r\n *\r\n * This structure holds the configuration settings for the LPIT peripheral to\r\n * enable or disable LPIT module in DEBUG and DOZE mode\r\n * Implements : lpit_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    bool enableRunInDebug; /*!< True: Timer channels continue to run in debug mode\r\n                                False: Timer channels stop in debug mode            */\r\n    bool enableRunInDoze;  /*!< True: Timer channels continue to run in doze mode\r\n                                False: Timer channels stop in doze mode             */\r\n} lpit_user_config_t;\r\n\r\n/*! @brief Structure to configure the channel timer\r\n *\r\n * This structure holds the configuration settings for the LPIT timer channel\r\n * Implements : lpit_user_channel_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    lpit_timer_modes_t timerMode;        /*!< Operation mode of timer channel                               */\r\n    lpit_period_units_t periodUnits;     /*!< Timer period value units                                      */\r\n    uint32_t period;                     /*!< Period of timer channel                                       */\r\n    lpit_trigger_source_t triggerSource; /*!< Selects between internal and external trigger sources         */\r\n    uint32_t triggerSelect;              /*!< Selects one trigger from the internal trigger sources\r\n                                              this field makes sense if trigger source is internal          */\r\n    bool enableReloadOnTrigger;          /*!< True: Timer channel will reload on selected trigger\r\n                                              False: Timer channel will not reload on selected trigger      */\r\n    bool enableStopOnInterrupt;          /*!< True: Timer will stop after timeout\r\n                                              False: Timer channel does not stop after timeout              */\r\n    bool enableStartOnTrigger;           /*!< True: Timer channel starts to decrement when rising edge\r\n                                              on selected trigger is detected.\r\n                                              False: Timer starts to decrement immediately based on\r\n                                              restart condition                                             */\r\n    bool chainChannel;                   /*!< Channel chaining enable                                       */\r\n    bool isInterruptEnabled;             /*!< Timer channel interrupt generation enable                     */\r\n} lpit_user_channel_config_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name Initialization and De-initialization\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Gets the default LPIT configuration\r\n *\r\n * This function gets default LPIT module configuration structure, with the following settings:\r\n * - PIT runs in debug mode: Disable\r\n * - PIT runs in doze mode: Disable\r\n *\r\n * @param[out] config The configuration structure\r\n */\r\nvoid LPIT_DRV_GetDefaultConfig(lpit_user_config_t * const config);\r\n\r\n/*!\r\n * @brief Gets the default timer channel configuration\r\n *\r\n * This function gets the default timer channel configuration structure, with the following settings:\r\n * - Timer mode: 32-bit Periodic Counter\r\n * - Period unit: Period value unit is microsecond\r\n * - Period: 1000000 microseconds(1 second)\r\n * - Trigger sources: External trigger\r\n * - Trigger select: Trigger from channel 0\r\n * - Reload on trigger: Disable\r\n * - Stop on interrupt : Disable\r\n * - Start on trigger: Disable\r\n * - Channel chaining: Disable\r\n * - Interrupt generating: Enable\r\n *\r\n * @param[out] config The channel configuration structure\r\n */\r\nvoid LPIT_DRV_GetDefaultChanConfig(lpit_user_channel_config_t * const config);\r\n\r\n/*!\r\n * @brief Initializes the LPIT module.\r\n *\r\n * This function resets LPIT module, enables the LPIT module, configures LPIT\r\n * module operation in Debug and DOZE mode. The LPIT configuration structure shall\r\n * be passed as arguments.\r\n * This configuration structure affects all timer channels.\r\n * This function should be called before calling any other LPIT driver function.\r\n *\r\n * This is an example demonstrating how to define a LPIT configuration structure:\r\n   @code\r\n   lpit_user_config_t lpitInit =\r\n   {\r\n        .enableRunInDebug = false,\r\n        .enableRunInDoze = true\r\n   };\r\n   @endcode\r\n *\r\n * @param[in] instance LPIT module instance number.\r\n * @param[in] userConfig Pointer to LPIT configuration structure.\r\n */\r\nvoid LPIT_DRV_Init(uint32_t instance,\r\n                   const lpit_user_config_t * userConfig);\r\n\r\n/*!\r\n * @brief De-Initializes the LPIT module.\r\n *\r\n * This function disables LPIT module.\r\n * In order to use the LPIT module again, LPIT_DRV_Init must be called.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n */\r\nvoid LPIT_DRV_Deinit(uint32_t instance);\r\n\r\n/*!\r\n * @brief Initializes the LPIT channel.\r\n *\r\n * This function initializes the LPIT timers by using a channel, this function\r\n * configures timer channel chaining, timer channel mode, timer channel period,\r\n * interrupt generation, trigger source, trigger select, reload on trigger,\r\n * stop on interrupt and start on trigger.\r\n * The timer channel number and its configuration structure shall be passed as arguments.\r\n * Timer channels do not start counting by default after calling this function.\r\n * The function LPIT_DRV_StartTimerChannels must be called to start the timer channel counting.\r\n * In order to re-configures the period, call the LPIT_DRV_SetTimerPeriodByUs or\r\n * LPIT_DRV_SetTimerPeriodByCount.\r\n *\r\n * This is an example demonstrating how to define a LPIT channel configuration structure:\r\n   @code\r\n   lpit_user_channel_config_t lpitTestInit =\r\n   {\r\n    .timerMode = LPIT_PERIODIC_COUNTER,\r\n    .periodUnits = LPTT_PERIOD_UNITS_MICROSECONDS,\r\n    .period = 1000000U,\r\n    .triggerSource = LPIT_TRIGGER_SOURCE_INTERNAL,\r\n    .triggerSelect = 1U,\r\n    .enableReloadOnTrigger = false,\r\n    .enableStopOnInterrupt = false,\r\n    .enableStartOnTrigger = false,\r\n    .chainChannel = false,\r\n    .isInterruptEnabled = true\r\n   };\r\n   @endcode\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @param[in] userChannelConfig Pointer to LPIT channel configuration structure\r\n * @return Operation status\r\n *         - STATUS_SUCCESS: Operation was successful.\r\n *         - STATUS_ERROR: The channel 0 is chained.\r\n *         - STATUS_ERROR: The input period is invalid.\r\n */\r\nstatus_t LPIT_DRV_InitChannel(uint32_t instance,\r\n                              uint32_t channel,\r\n                              const lpit_user_channel_config_t * userChannelConfig);\r\n\r\n/* @} */\r\n\r\n/*!\r\n * @name Timer Start and Stop\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Starts the timer channel counting.\r\n *\r\n * This function allows starting timer channels simultaneously .\r\n * After calling this function, timer channels are going operate depend on mode and\r\n * control bits which controls timer channel start, reload and restart.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] mask Timer channels starting mask that decides which channels\r\n * will be started\r\n * - For example:\r\n *      - with mask = 0x01U then channel 0 will be started\r\n *      - with mask = 0x02U then channel 1 will be started\r\n *      - with mask = 0x03U then channel 0 and channel 1 will be started\r\n */\r\nvoid LPIT_DRV_StartTimerChannels(uint32_t instance,\r\n                                 uint32_t mask);\r\n\r\n/*!\r\n * @brief Stops the timer channel counting.\r\n *\r\n * This function allows stop timer channels simultaneously from counting.\r\n * Timer channels reload their periods respectively after the next time\r\n * they call the LPIT_DRV_StartTimerChannels. Note that: In 32-bit Trigger Accumulator\r\n * mode, the counter will load on the first trigger rising edge.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] mask Timer channels stopping mask that decides which channels\r\n * will be stopped\r\n * - For example:\r\n *      - with mask = 0x01U then channel 0 will be stopped\r\n *      - with mask = 0x02U then channel 1 will be stopped\r\n *      - with mask = 0x03U then channel 0 and channel 1 will be stopped\r\n */\r\nvoid LPIT_DRV_StopTimerChannels(uint32_t instance,\r\n                                uint32_t mask);\r\n\r\n/* @} */\r\n\r\n/*!\r\n * @name Timer Period\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sets the timer channel period in microseconds.\r\n *\r\n * This function sets the timer channel period in microseconds\r\n * when timer channel mode is 32 bit periodic or dual 16 bit counter mode.\r\n * The period range depends on the frequency of the LPIT functional clock and\r\n * operation mode of timer channel.\r\n * If the required period is out of range, use the suitable mode if applicable.\r\n * This function is only valid for one single channel.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @param[in] periodUs Timer channel period in microseconds\r\n * @return Operation status\r\n *         - STATUS_SUCCESS: Input period of timer channel is valid.\r\n *         - STATUS_ERROR: Input period of timer channel is invalid.\r\n */\r\nstatus_t LPIT_DRV_SetTimerPeriodByUs(uint32_t instance,\r\n                                     uint32_t channel,\r\n                                     uint32_t periodUs);\r\n\r\n/*!\r\n * @brief Sets the timer channel period in microseconds.\r\n *\r\n * This function sets the timer channel period in microseconds\r\n * when timer channel mode is dual 16 bit periodic counter mode.\r\n * The period range depends on the frequency of the LPIT functional clock and\r\n * operation mode of timer channel.\r\n * If the required period is out of range, use the suitable mode if applicable.\r\n * This function is only valid for one single channel.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @param[in] periodHigh Period of higher 16 bit in microseconds\r\n * @param[in] periodLow Period of lower 16 bit in microseconds\r\n * @return Operation status\r\n *         - STATUS_SUCCESS: Input period of timer channel is valid.\r\n *         - STATUS_ERROR: Input period of timer channel is invalid.\r\n */\r\nstatus_t LPIT_DRV_SetTimerPeriodInDual16ModeByUs(uint32_t instance,\r\n                                                 uint32_t channel,\r\n                                                 uint16_t periodHigh,\r\n                                                 uint16_t periodLow);\r\n\r\n/*!\r\n * @brief Gets the timer channel period in microseconds.\r\n *\r\n * This function gets the timer channel period in microseconds.\r\n * The returned period here makes sense if the operation mode of timer channel\r\n * is 32 bit periodic counter or dual 16 bit periodic counter.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @return Timer channel period in microseconds\r\n */\r\nuint64_t LPIT_DRV_GetTimerPeriodByUs(uint32_t instance,\r\n                                     uint32_t channel);\r\n\r\n/*!\r\n * @brief Gets the current timer channel counting value in microseconds.\r\n *\r\n * This function returns an absolute time stamp in microseconds.\r\n * One common use of this function is to measure the running time of a part of\r\n * code. Call this function at both the beginning and end of code. The time\r\n * difference between these two time stamps is the running time.\r\n * The return counting value here makes sense if the operation mode of timer channel\r\n * is 32 bit periodic counter or dual 16 bit periodic counter or 32-bit trigger input capture.\r\n * Need to make sure the running time will not exceed the timer channel period.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @return Current timer channel counting value in microseconds\r\n */\r\nuint64_t LPIT_DRV_GetCurrentTimerUs(uint32_t instance,\r\n                                    uint32_t channel);\r\n\r\n/*!\r\n * @brief Sets the timer channel period in count unit.\r\n *\r\n * This function sets the timer channel period in count unit.\r\n * The counter period of a running timer channel can be modified by first setting\r\n * a new load value, the value will be loaded after the timer channel expires.\r\n * To abort the current cycle and start a timer channel period with the new value,\r\n * the timer channel must be disabled and enabled again.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @param[in] count Timer channel period in count unit\r\n */\r\nvoid LPIT_DRV_SetTimerPeriodByCount(uint32_t instance,\r\n                                    uint32_t channel,\r\n                                    uint32_t count);\r\n\r\n/*!\r\n * @brief Sets the timer channel period in count unit.\r\n *\r\n * This function sets the timer channel period in count unit when timer channel\r\n * mode is dual 16 periodic counter mode.\r\n * The counter period of a running timer channel can be modified by first setting\r\n * a new load value, the value will be loaded after the timer channel expires.\r\n * To abort the current cycle and start a timer channel period with the new value,\r\n * the timer channel must be disabled and enabled again.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @param[in] periodHigh Period of higher 16 bit in count unit\r\n * @param[in] periodLow Period of lower 16 bit in count unit\r\n */\r\nvoid LPIT_DRV_SetTimerPeriodInDual16ModeByCount(uint32_t instance,\r\n                                                uint32_t channel,\r\n                                                uint16_t periodHigh,\r\n                                                uint16_t periodLow);\r\n\r\n/*!\r\n * @brief Gets the current timer channel period in count unit.\r\n *\r\n * This function returns current period of timer channel given as argument.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @return Timer channel period in count unit\r\n */\r\nuint32_t LPIT_DRV_GetTimerPeriodByCount(uint32_t instance,\r\n                                        uint32_t channel);\r\n\r\n/*!\r\n * @brief Gets the current timer channel counting value in count.\r\n *\r\n * This function returns the real-time timer channel counting value, the value in\r\n * a range from 0 to timer channel period.\r\n * Need to make sure the running time does not exceed the timer channel period.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] channel Timer channel number\r\n * @return Current timer channel counting value in count\r\n */\r\nuint32_t LPIT_DRV_GetCurrentTimerCount(uint32_t instance,\r\n                                       uint32_t channel);\r\n/* @} */\r\n\r\n/*!\r\n * @name Interrupt\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Enables the interrupt generation of timer channel.\r\n *\r\n * This function allows enabling interrupt generation of timer channel\r\n * when timeout occurs or input trigger occurs.\r\n *\r\n * @param[in] instance LPIT module instance number.\r\n * @param[in] mask The mask that decides which channels will be enabled interrupt.\r\n * - For example:\r\n *      - with mask = 0x01u then the interrupt of channel 0 will be enabled\r\n *      - with mask = 0x02u then the interrupt of channel 1 will be enabled\r\n *      - with mask = 0x03u then the interrupt of channel 0 and channel 1 will be enabled\r\n */\r\nvoid LPIT_DRV_EnableTimerChannelInterrupt(uint32_t instance,\r\n                                          uint32_t mask);\r\n\r\n/*!\r\n * @brief Disables the interrupt generation of timer channel.\r\n *\r\n * This function allows disabling interrupt generation of timer channel\r\n * when timeout occurs or input trigger occurs.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] mask The mask that decides which channels will be disable interrupt.\r\n * - For example:\r\n *      - with mask = 0x01u then the interrupt of channel 0 will be disable\r\n *      - with mask = 0x02u then the interrupt of channel 1 will be disable\r\n *      - with mask = 0x03u then the interrupt of channel 0 and channel 1 will be disable\r\n */\r\nvoid LPIT_DRV_DisableTimerChannelInterrupt(uint32_t instance,\r\n                                           uint32_t mask);\r\n\r\n/*!\r\n * @brief Gets the current interrupt flag of timer channels.\r\n *\r\n * This function gets the current interrupt flag of timer channels.\r\n * In compare modes, the flag sets to 1 at the end of the timer period.\r\n * In capture modes, the flag sets to 1 when the trigger asserts.\r\n *\r\n * @param[in] instance LPIT module instance number.\r\n * @param[in] mask The interrupt flag getting mask that decides which channels will\r\n * be got interrupt flag.\r\n * - For example:\r\n *      - with mask = 0x01u then the interrupt flag of channel 0 only will be got\r\n *      - with mask = 0x02u then the interrupt flag of channel 1 only will be got\r\n *      - with mask = 0x03u then the interrupt flags of channel 0 and channel 1 will be got\r\n * @return Current the interrupt flag of timer channels\r\n */\r\nuint32_t LPIT_DRV_GetInterruptFlagTimerChannels(uint32_t instance,\r\n                                                uint32_t mask);\r\n\r\n/*!\r\n * @brief Clears the interrupt flag of timer channels.\r\n *\r\n * This function clears the interrupt flag of timer channels after\r\n * their interrupt event occurred.\r\n *\r\n * @param[in] instance LPIT module instance number\r\n * @param[in] mask The interrupt flag clearing mask that decides which channels will\r\n * be cleared interrupt flag\r\n * - For example:\r\n *      - with mask = 0x01u then the interrupt flag of channel 0 only will be cleared\r\n *      - with mask = 0x02u then the interrupt flag of channel 1 only will be cleared\r\n *      - with mask = 0x03u then the interrupt flags of channel 0 and channel 1 will be cleared\r\n */\r\nvoid LPIT_DRV_ClearInterruptFlagTimerChannels(uint32_t instance,\r\n                                              uint32_t mask);\r\n\r\n/* @} */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* LPIT_DRIVER_H*/\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpit_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright 2017-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef LPIT_HW_ACCESS_H\r\n#define LPIT_HW_ACCESS_H\r\n\r\n#include <stdbool.h>\r\n#include \"device_registers.h\"\r\n#include \"lpit_driver.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Enables the LPIT module.\r\n *\r\n * This function enables the functional clock of LPIT module (Note: this function\r\n * does not un-gate the system clock gating control). It should be called before\r\n * setup any timer channel.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n */\r\nstatic inline void LPIT_Enable(LPIT_Type * const base, volatile uint32_t delay)\r\n{\r\n    base->MCR |= LPIT_MCR_M_CEN_MASK;\r\n    /* Run this counter down to zero\r\n        If the delay is 0, the four clock delay between setting and clearing\r\n        the SW_RST bit is ensured by the read-modify-write operation.\r\n    */\r\n    while(delay != 0u)\r\n    {\r\n        /* Since we need a four cycle delay, we assume the decrement is one cycle\r\n            and insert three NOP instructions. The actual delay will be larger because\r\n            of the loop overhead and the compiler optimization.\r\n        */\r\n        delay--;\r\n        NOP();\r\n        NOP();\r\n        NOP();\r\n    }\r\n}\r\n\r\n/*!\r\n * @brief Disables the LPIT module.\r\n *\r\n * This function disables functional clock of LPIT module (Note: it does not\r\n * affect the system clock gating control).\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n */\r\nstatic inline void LPIT_Disable(LPIT_Type * const base)\r\n{\r\n    base->MCR &= ~LPIT_MCR_M_CEN_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Resets the LPIT module.\r\n *\r\n * This function sets all LPIT registers to reset value,\r\n * except the Module Control Register.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n */\r\nstatic inline void LPIT_Reset(LPIT_Type * const base, volatile uint32_t delay)\r\n{\r\n    base->MCR |= LPIT_MCR_SW_RST_MASK;\r\n    /* Run this counter down to zero\r\n        If the delay is 0, the four clock delay between setting and clearing\r\n        the SW_RST bit is ensured by the read-modify-write operation.\r\n    */\r\n    while(delay != 0u)\r\n    {\r\n        /* Since we need a four cycle delay, we assume the decrement is one cycle\r\n            and insert three NOP instructions. The actual delay will be larger because\r\n            of the loop overhead and the compiler optimization.\r\n        */\r\n        delay--;\r\n        NOP();\r\n        NOP();\r\n        NOP();\r\n    }\r\n    base->MCR &= ~LPIT_MCR_SW_RST_MASK;\r\n}\r\n\r\n/*!\r\n  @brief Starts the timer channel counting.\r\n *\r\n * This function allows starting timer channels simultaneously .\r\n * After calling this function, timer channels are going operate depend on mode and\r\n * control bits which controls timer channel start, reload and restart.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] mask Timer channels starting mask that decides which channels\r\n * will be started\r\n * - For example:\r\n *      - with mask = 0x01U then channel 0 will be started\r\n *      - with mask = 0x02U then channel 1 will be started\r\n *      - with mask = 0x03U then channel 0 and channel 1 will be started\r\n */\r\nstatic inline void LPIT_StartTimerChannels(LPIT_Type * const base,\r\n                                           uint32_t mask)\r\n{\r\n    base->SETTEN |= mask;\r\n}\r\n\r\n/*!\r\n * @brief Stops the timer channel from counting.\r\n *\r\n * This function allows stop timer channels simultaneously from counting.\r\n * Timer channels reload their periods respectively after the next time\r\n * they call the LPIT_DRV_StartTimerChannels. Note that: In 32-bit Trigger Accumulator\r\n * mode, the counter will load on the first trigger rising edge.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] mask Timer channels stopping mask that decides which channels\r\n * will be stopped\r\n * - For example:\r\n *      - with mask = 0x01U then channel 0 will be stopped\r\n *      - with mask = 0x02U then channel 1 will be stopped\r\n *      - with mask = 0x03U then channel 0 and channel 1 will be stopped\r\n */\r\nstatic inline void LPIT_StopTimerChannels(LPIT_Type * const base,\r\n                                          uint32_t mask)\r\n{\r\n    base->CLRTEN |= mask;\r\n}\r\n\r\n/*!\r\n * @brief Sets the timer channel period in count unit.\r\n *\r\n * This function sets the timer channel period in count unit.\r\n * The period range depends on the frequency of the LPIT functional clock and\r\n * operation mode of timer channel.\r\n * If the required period is out of range, use the suitable mode if applicable.\r\n * Timer channel begins counting from the value that is set by this function.\r\n * The counter period of a running timer channel can be modified by first setting\r\n * a new load value, the value will be loaded after the timer channel expires.\r\n * To abort the current cycle and start a timer channel period with the new value,\r\n * the timer channel must be disabled and enabled again.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] count Timer channel period in count unit\r\n */\r\nstatic inline void LPIT_SetTimerPeriodByCount(LPIT_Type * const base,\r\n                                              uint32_t channel,\r\n                                              uint32_t count)\r\n{\r\n    base->TMR[channel].TVAL = count;\r\n}\r\n\r\n/*!\r\n * @brief Gets the timer channel period in count unit.\r\n *\r\n * This function returns current period of timer channel given as argument.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @return Timer channel period in count unit\r\n */\r\nstatic inline uint32_t LPIT_GetTimerPeriodByCount(const LPIT_Type * base,\r\n                                                  uint32_t channel)\r\n{\r\n    return (base->TMR[channel].TVAL);\r\n}\r\n\r\n/*!\r\n * @brief Gets the current timer channel counting value.\r\n *\r\n * This function returns the real-time timer channel counting value, the value in\r\n * a range from 0 to timer channel period.\r\n * Need to make sure the running time does not exceed the timer channel period.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @return Current timer channel counting value\r\n */\r\nstatic inline uint32_t LPIT_GetCurrentTimerCount(const LPIT_Type * base,\r\n                                                 uint32_t channel)\r\n{\r\n    return (base->TMR[channel].CVAL);\r\n}\r\n\r\n/*!\r\n * @brief Enables the interrupt generation for timer channels.\r\n *\r\n * This function allows enabling interrupt generation for timer channels simultaneously.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] mask The interrupt enabling mask that decides which channels will\r\n * be enabled interrupt.\r\n * - For example:\r\n *      - with mask = 0x01u then will enable interrupt for channel 0 only\r\n *      - with mask = 0x02u then will enable interrupt for channel 1 only\r\n *      - with mask = 0x03u then will enable interrupt for channel 0 and channel 1\r\n */\r\nstatic inline void LPIT_EnableInterruptTimerChannels(LPIT_Type * const base,\r\n                                                     uint32_t mask)\r\n{\r\n    base->MIER |= mask;\r\n}\r\n\r\n/*!\r\n * @brief Disables the interrupt generation for timer channels.\r\n *\r\n * This function allows disabling interrupt generation for timer channels simultaneously.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] mask The interrupt disabling mask that decides which channels will\r\n * be disabled interrupt.\r\n * - For example:\r\n *      - with mask = 0x01u then will disable interrupt for channel 0 only\r\n *      - with mask = 0x02u then will disable interrupt for channel 1 only\r\n *      - with mask = 0x03u then will disable interrupt for channel 0 and channel 1\r\n */\r\nstatic inline void LPIT_DisableInterruptTimerChannels(LPIT_Type * const base,\r\n                                                      uint32_t mask)\r\n{\r\n    base->MIER &= ~mask;\r\n}\r\n\r\n/*!\r\n * @brief Gets the interrupt flag of timer channels.\r\n *\r\n * This function gets current interrupt flag of timer channels.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] mask The interrupt flag getting mask that decides which channels will\r\n * be got interrupt flag.\r\n * - For example:\r\n *      - with mask = 0x01u then the interrupt flag of channel 0 only will be got\r\n *      - with mask = 0x02u then the interrupt flag of channel 1 only will be got\r\n *      - with mask = 0x03u then the interrupt flags of channel 0 and channel 1 will be got\r\n * @return The interrupt flag of timer channels.\r\n */\r\nstatic inline uint32_t LPIT_GetInterruptFlagTimerChannels(const LPIT_Type * base,\r\n                                                          uint32_t mask)\r\n{\r\n    return (base->MSR) & mask;\r\n}\r\n\r\n/*!\r\n * @brief Clears the interrupt flag of timer channels.\r\n *\r\n * This function clears current interrupt flag of timer channels.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] mask The interrupt flag clearing mask that decides which channels will\r\n * be cleared interrupt flag.\r\n * - For example:\r\n *      - with mask = 0x01u then the interrupt flag of channel 0 only will be cleared\r\n *      - with mask = 0x02u then the interrupt flag of channel 1 only will be cleared\r\n *      - with mask = 0x03u then the interrupt flags of channel 0 and channel 1 will be cleared\r\n */\r\nstatic inline void LPIT_ClearInterruptFlagTimerChannels(LPIT_Type * const base,\r\n                                                        uint32_t mask)\r\n{\r\n    /* Write 1 to clear the interrupt flag. */\r\n    base->MSR = mask;\r\n#ifdef ERRATA_E9005\r\n    /* Read-after-write sequence to guarantee required serialization of memory operations */\r\n    base->MSR;\r\n#endif\r\n}\r\n\r\n/*!\r\n * @brief Sets operation mode of timer channel\r\n *\r\n * This function sets the timer channel operation mode which control how\r\n * the timer channel decrements.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] mode Operation mode of timer channel that is member of lpit_timer_modes_t\r\n */\r\nstatic inline void LPIT_SetTimerChannelModeCmd(LPIT_Type * const base,\r\n                                               uint32_t channel,\r\n                                               lpit_timer_modes_t mode)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_MODE_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_MODE(mode);\r\n}\r\n\r\n/*!\r\n * @brief Gets current operation mode of timer channel.\r\n *\r\n * This function gets current operation mode of the timer channel given as argument.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @return Operation mode of timer channel that is one of lpit_timer_modes_t\r\n */\r\nstatic inline lpit_timer_modes_t LPIT_GetTimerChannelModeCmd(const LPIT_Type * base,\r\n                                                             uint32_t channel)\r\n{\r\n    uint32_t tmp;\r\n    lpit_timer_modes_t mode;\r\n\r\n    tmp = (((base->TMR[channel].TCTRL) & LPIT_TMR_TCTRL_MODE_MASK)\r\n                                 >> LPIT_TMR_TCTRL_MODE_SHIFT);\r\n    switch (tmp)\r\n    {\r\n        case 0x00U:\r\n            mode = LPIT_PERIODIC_COUNTER;\r\n            break;\r\n        case 0x01U:\r\n            mode = LPIT_DUAL_PERIODIC_COUNTER;\r\n            break;\r\n        case 0x02U:\r\n            mode = LPIT_TRIGGER_ACCUMULATOR;\r\n            break;\r\n        case 0x03U:\r\n            mode = LPIT_INPUT_CAPTURE;\r\n            break;\r\n        default:\r\n            mode = LPIT_PERIODIC_COUNTER;\r\n            break;\r\n    }\r\n    return mode;\r\n}\r\n\r\n/*!\r\n * @brief Sets internal trigger source for timer channel\r\n *\r\n * This function selects one trigger from the set of internal triggers that is\r\n * generated by other timer channels.\r\n * The selected trigger is used for starting and/or reloading the timer channel.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] triggerChannelSelect Number of the channel which is selected to be trigger source\r\n */\r\nstatic inline void LPIT_SetTriggerSelectCmd(LPIT_Type * const base,\r\n                                            uint32_t channel,\r\n                                            uint32_t triggerChannelSelect)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_TRG_SEL_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_TRG_SEL(triggerChannelSelect);\r\n}\r\n\r\n/*!\r\n * @brief Sets trigger source of timer channel.\r\n *\r\n * This function sets trigger source of the timer channel to be internal or external trigger.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] triggerSource Trigger source of timer channel(internal or external source)\r\n */\r\nstatic inline void LPIT_SetTriggerSourceCmd(LPIT_Type * const base,\r\n                                            uint32_t channel,\r\n                                            lpit_trigger_source_t triggerSource)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_TRG_SRC_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_TRG_SRC(triggerSource);\r\n}\r\n\r\n/*!\r\n * @brief Sets timer channel reload on trigger.\r\n *\r\n * This function sets the timer channel to reload/don't reload on trigger.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] isReloadOnTrigger Timer channel reload on trigger\r\n *        - True : timer channel will reload on trigger\r\n *        - False : timer channel will not reload on trigger\r\n */\r\nstatic inline void LPIT_SetReloadOnTriggerCmd(LPIT_Type * const base,\r\n                                              uint32_t channel,\r\n                                              bool isReloadOnTrigger)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_TROT_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_TROT(isReloadOnTrigger ? 1UL : 0UL);\r\n}\r\n\r\n/*!\r\n * @brief Sets timer channel stop on interrupt.\r\n *\r\n * This function sets the timer channel to stop or don't stop after it times out.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] isStopOnInterrupt Timer channel stop on interrupt\r\n *        - True : Timer channel will stop after it times out\r\n *        - False : Timer channel will not stop after it times out\r\n */\r\nstatic inline void LPIT_SetStopOnInterruptCmd(LPIT_Type * const base,\r\n                                              uint32_t channel,\r\n                                              bool isStopOnInterrupt)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_TSOI_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_TSOI(isStopOnInterrupt ? 1UL : 0UL);\r\n}\r\n\r\n/*!\r\n * @brief Sets timer channel start on trigger.\r\n *\r\n * This function sets the timer channel to starts/don't start on trigger.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number\r\n * @param[in] isStartOnTrigger Timer channel start on trigger\r\n *        - True : Timer channel starts to decrement when rising edge on selected trigger is detected\r\n *        - False : Timer channel starts to decrement immediately based on restart condition\r\n *                      (controlled by Timer Stop On Interrupt bit)\r\n */\r\nstatic inline void LPIT_SetStartOnTriggerCmd(LPIT_Type * const base,\r\n                                             uint32_t channel,\r\n                                             bool isStartOnTrigger)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_TSOT_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_TSOT(isStartOnTrigger ? 1UL : 0UL);\r\n}\r\n\r\n/*!\r\n * @brief Sets timer channel chaining.\r\n *\r\n * This function sets the timer channel to be chained or not chained.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] channel Timer channel number(Note: The timer channel 0 cannot be chained)\r\n * @param[in] isChannelChained Timer channel chaining\r\n *        - True : Timer channel is chained. Timer channel decrements on previous channel's timeout\r\n *        - False : Timer channel is not chained. Timer channel runs independently\r\n */\r\nstatic inline void LPIT_SetTimerChannelChainCmd(LPIT_Type * const base,\r\n                                                uint32_t channel,\r\n                                                bool isChannelChained)\r\n{\r\n    base->TMR[channel].TCTRL &= ~LPIT_TMR_TCTRL_CHAIN_MASK;\r\n    base->TMR[channel].TCTRL |=  LPIT_TMR_TCTRL_CHAIN(isChannelChained ? 1UL : 0UL);\r\n}\r\n\r\n/*!\r\n * @brief Sets operation of LPIT in debug mode.\r\n *\r\n * When the device enters debug mode, the timer channels may or may not be frozen,\r\n * based on the configuration of this function. This is intended to aid software development,\r\n * allowing the developer to halt the processor, investigate the current state of\r\n * the system (for example, the timer channel values), and continue the operation.\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] isRunInDebug LPIT run in debug mode\r\n *        - True: LPIT continue to run when the device enters debug mode\r\n *        - False: LPIT stop when the device enters debug mode\r\n */\r\nstatic inline void LPIT_SetTimerRunInDebugCmd(LPIT_Type * const base,\r\n                                              bool isRunInDebug)\r\n{\r\n    base->MCR &= ~LPIT_MCR_DBG_EN_MASK;\r\n    base->MCR |= LPIT_MCR_DBG_EN(isRunInDebug ? 1UL: 0UL);\r\n}\r\n\r\n/*!\r\n * @brief Sets operation of LPIT in DOZE mode.\r\n *\r\n * When the device enters debug mode, the timer channels may or may not be frozen,\r\n * based on the configuration of this function. The LPIT must use an external or\r\n * internal clock source which remains operating during DOZE modes(low power mode).\r\n *\r\n * @param[in] base LPIT peripheral base address\r\n * @param[in] isRunInDoze LPIT run in DOZE mode\r\n *        - True: LPIT continue to run when the device enters DOZE mode\r\n *        - False: LPIT channels stop when the device enters DOZE mode\r\n */\r\nstatic inline void LPIT_SetTimerRunInDozeCmd(LPIT_Type * const base,\r\n                                             bool isRunInDoze)\r\n{\r\n    base->MCR &= ~LPIT_MCR_DOZE_EN_MASK;\r\n    base->MCR |= LPIT_MCR_DOZE_EN(isRunInDoze ? 1UL : 0UL);\r\n}\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n#endif /* LPIT_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpuart_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lpuart_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, There shall be no occurrence of\r\n * undefined or critical unspecified behavior.\r\n * This is caused because the addresses of some uninitialized variables are\r\n * passed as parameters. Those variables are not initialized as they are used as\r\n * output parameters by the functions.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.1, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.2, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.4, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 5.5, identifier clash\r\n * The supported compilers use more than 31 significant characters for identifiers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, could define variable at block scope\r\n * The variables are defined in the common source file to make transition to other\r\n * platforms easier.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.7, Composite expression with smaller\r\n * essential type than other operand.\r\n * The expression is safe as the baud rate calculation algorithm cannot overflow\r\n * the result.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be\r\n * performed between a pointer to object and an integer type.\r\n * The cast is required as source and destination addresses for DMA transfers must\r\n * be written to registers as 32-bit unsigned integers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The cast is required as source and destination addresses for DMA transfers must\r\n * be written to registers as 32-bit unsigned integers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 15.4, More than one 'break' terminates loop\r\n * This operation is necessary because more than one error flag can stop the reception.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 15.5, Return statement before end of function.\r\n * The return statement before end of function is used for simpler code structure\r\n * and better readability.\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdbool.h>\r\n#include \"lpuart_hw_access.h\"\r\n#include \"lpuart_irq.h\"\r\n#include \"clock_manager.h\"\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/* Pointer to lpuart runtime state structure */\r\nstatic lpuart_state_t * s_lpuartStatePtr[LPUART_INSTANCE_COUNT] = {NULL};\r\n\r\n/* Table of base addresses for lpuart instances. */\r\nstatic LPUART_Type * const s_lpuartBase[LPUART_INSTANCE_COUNT] = LPUART_BASE_PTRS;\r\n\r\n/* Table to save LPUART enum numbers defined in CMSIS files. */\r\nstatic const IRQn_Type s_lpuartRxTxIrqId[LPUART_INSTANCE_COUNT] = LPUART_RX_TX_IRQS;\r\n\r\n/* Table to save LPUART clock names as defined in clock manager. */\r\nstatic const clock_names_t s_lpuartClkNames[LPUART_INSTANCE_COUNT] = LPUART_CLOCK_NAMES;\r\n\r\n/*******************************************************************************\r\n * Private Functions\r\n ******************************************************************************/\r\nstatic status_t LPUART_DRV_StartSendDataUsingInt(uint32_t instance,\r\n                                                 const uint8_t * txBuff,\r\n                                                 uint32_t txSize);\r\nstatic void LPUART_DRV_CompleteSendDataUsingInt(uint32_t instance);\r\nstatic status_t LPUART_DRV_StartReceiveDataUsingInt(uint32_t instance,\r\n                                                    uint8_t * rxBuff,\r\n                                                    uint32_t rxSize);\r\nstatic void LPUART_DRV_CompleteReceiveDataUsingInt(uint32_t instance);\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\nstatic void LPUART_DRV_StopTxDma(uint32_t instance);\r\nstatic void LPUART_DRV_StopRxDma(uint32_t instance);\r\nstatic status_t LPUART_DRV_StartSendDataUsingDma(uint32_t instance,\r\n                                                 const uint8_t * txBuff,\r\n                                                 uint32_t txSize);\r\nstatic void LPUART_DRV_TxDmaCallback(void * parameter, edma_chn_status_t status);\r\nstatic status_t LPUART_DRV_StartReceiveDataUsingDma(uint32_t instance,\r\n                                                    uint8_t * rxBuff,\r\n                                                    uint32_t rxSize);\r\nstatic void LPUART_DRV_RxDmaCallback(void * parameter, edma_chn_status_t status);\r\n#endif\r\nstatic void LPUART_DRV_PutData(uint32_t instance);\r\nstatic void LPUART_DRV_GetData(uint32_t instance);\r\nstatic void LPUART_DRV_RxIrqHandler(uint32_t instance);\r\nstatic void LPUART_DRV_TxEmptyIrqHandler(uint32_t instance);\r\nstatic void LPUART_DRV_TxCompleteIrqHandler(uint32_t instance);\r\nstatic void LPUART_DRV_ErrIrqHandler(uint32_t instance);\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_GetDefaultConfig\r\n * Description   : Initializes the LPUART configuration structure with\r\n *                 default values.\r\n *\r\n * Implements    : LPUART_DRV_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid LPUART_DRV_GetDefaultConfig(lpuart_user_config_t * lpuartUserConfig)\r\n{\r\n    DEV_ASSERT(lpuartUserConfig != NULL);\r\n\r\n    lpuartUserConfig->transferType = LPUART_USING_INTERRUPTS;\r\n    lpuartUserConfig->baudRate = 9600U;\r\n    lpuartUserConfig->parityMode = LPUART_PARITY_DISABLED;\r\n    lpuartUserConfig->stopBitCount = LPUART_ONE_STOP_BIT;\r\n    lpuartUserConfig->bitCountPerChar = LPUART_8_BITS_PER_CHAR;\r\n    lpuartUserConfig->rxDMAChannel = 0U;\r\n    lpuartUserConfig->txDMAChannel = 0U;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_Init\r\n * Description   : This function initializes a LPUART instance for operation.\r\n * This function will initialize the run-time state structure to keep track of\r\n * the on-going transfers, ungate the clock to the LPUART module, initialize the\r\n * module to user defined settings and default settings, configure the IRQ state\r\n * structure and enable the module-level interrupt to the core, and enable the\r\n * LPUART module transmitter and receiver.\r\n * The following is an example of how to set up the lpuart_state_t and the\r\n * lpuart_user_config_t parameters and how to call the LPUART_DRV_Init function\r\n * by passing in these parameters:\r\n *    lpuart_user_config_t lpuartConfig;\r\n *    lpuartConfig.baudRate = 9600;\r\n *    lpuartConfig.bitCountPerChar = LPUART_8_BITS_PER_CHAR;\r\n *    lpuartConfig.parityMode = LPUART_PARITY_DISABLED;\r\n *    lpuartConfig.stopBitCount = LPUART_ONE_STOP_BIT;\r\n *    lpuartConfig.transferType = LPUART_USING_INTERRUPTS;\r\n *    lpuart_state_t lpuartState;\r\n *    LPUART_DRV_Init(instance, &lpuartState, &lpuartConfig);\r\n *\r\n * Implements    : LPUART_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_Init(uint32_t instance, lpuart_state_t * lpuartStatePtr,\r\n                         const lpuart_user_config_t * lpuartUserConfig)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(lpuartStatePtr != NULL);\r\n    DEV_ASSERT(lpuartUserConfig != NULL);\r\n\r\n    status_t osStatusRxSem;\r\n    status_t osStatusTxSem;\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    uint32_t idx;\r\n    uint32_t lpuartSourceClock;\r\n    clock_names_t instanceClkName = s_lpuartClkNames[instance];\r\n\r\n    /* Get the LPUART clock as configured in the clock manager */\r\n    (void)CLOCK_SYS_GetFreq(instanceClkName, &lpuartSourceClock);\r\n\r\n    /* Check if current instance is clock gated off. */\r\n    DEV_ASSERT(lpuartSourceClock > 0U);\r\n\r\n    /* Check if current instance is already initialized. */\r\n    DEV_ASSERT(s_lpuartStatePtr[instance] == NULL);\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    /* In DMA mode, only 8-bits chars are supported */\r\n    DEV_ASSERT((lpuartUserConfig->transferType != LPUART_USING_DMA) ||\r\n               (lpuartUserConfig->bitCountPerChar == LPUART_8_BITS_PER_CHAR));\r\n#endif\r\n\r\n    /* For 10 bits per char, parity bit cannot be enabled */\r\n    DEV_ASSERT((lpuartUserConfig->bitCountPerChar != LPUART_10_BITS_PER_CHAR) ||\r\n               (lpuartUserConfig->parityMode == LPUART_PARITY_DISABLED));\r\n\r\n    /* Clear the state struct for this instance. */\r\n    uint8_t *clearStructPtr = (uint8_t *)lpuartStatePtr;\r\n    for (idx = 0; idx < sizeof(lpuart_state_t); idx++)\r\n    {\r\n        clearStructPtr[idx] = 0;\r\n    }\r\n\r\n    /* Save runtime structure pointer.*/\r\n    s_lpuartStatePtr[instance] = lpuartStatePtr;\r\n\r\n    /* Save the transfer information for runtime retrieval */\r\n    lpuartStatePtr->transferType = lpuartUserConfig->transferType;\r\n    lpuartStatePtr->bitCountPerChar = lpuartUserConfig->bitCountPerChar;\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    lpuartStatePtr->rxDMAChannel = lpuartUserConfig->rxDMAChannel;\r\n    lpuartStatePtr->txDMAChannel = lpuartUserConfig->txDMAChannel;\r\n#endif\r\n\r\n    /* initialize the LPUART instance */\r\n    LPUART_Init(base);\r\n\r\n    /* initialize the parameters of the LPUART config structure with desired data */\r\n    (void)LPUART_DRV_SetBaudRate(instance, lpuartUserConfig->baudRate);\r\n\r\n    if (lpuartUserConfig->parityMode != LPUART_PARITY_DISABLED)\r\n    {\r\n        LPUART_SetBitCountPerChar(base, lpuartUserConfig->bitCountPerChar, true);\r\n    }\r\n    else\r\n    {\r\n        LPUART_SetBitCountPerChar(base, lpuartUserConfig->bitCountPerChar, false);\r\n    }\r\n    LPUART_SetParityMode(base, lpuartUserConfig->parityMode);\r\n    LPUART_SetStopBitCount(base, lpuartUserConfig->stopBitCount);\r\n\r\n    /* initialize last driver operation status */\r\n    lpuartStatePtr->transmitStatus = STATUS_SUCCESS;\r\n    lpuartStatePtr->receiveStatus = STATUS_SUCCESS;\r\n\r\n    /* Create the synchronization objects */\r\n    osStatusRxSem = OSIF_SemaCreate(&lpuartStatePtr->rxComplete, 0);\r\n    osStatusTxSem = OSIF_SemaCreate(&lpuartStatePtr->txComplete, 0);\r\n    if ((osStatusRxSem == STATUS_ERROR) || (osStatusTxSem == STATUS_ERROR))\r\n    {\r\n        return STATUS_ERROR;\r\n    }\r\n\r\n    /* Install LPUART irq handler */\r\n    INT_SYS_InstallHandler(s_lpuartRxTxIrqId[instance], g_lpuartIsr[instance], (isr_t*) 0);\r\n\r\n    /* Enable LPUART interrupt. */\r\n    INT_SYS_EnableIRQ(s_lpuartRxTxIrqId[instance]);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_Deinit\r\n * Description   : This function shuts down the UART by disabling interrupts and\r\n *                 transmitter/receiver.\r\n *\r\n * Implements    : LPUART_DRV_Deinit_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_Deinit(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    clock_names_t instanceClkName = s_lpuartClkNames[instance];\r\n    uint32_t lpuartSourceClock;\r\n    const LPUART_Type * base = s_lpuartBase[instance];\r\n    const lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    (void)CLOCK_SYS_GetFreq(instanceClkName, &lpuartSourceClock);\r\n\r\n    /* Check if current instance is already de-initialized or is gated.*/\r\n    DEV_ASSERT(s_lpuartStatePtr[instance] != NULL);\r\n    DEV_ASSERT(lpuartSourceClock > 0U);\r\n\r\n    /* Wait until the data is completely shifted out of shift register */\r\n    while (!LPUART_GetStatusFlag(base, LPUART_TX_COMPLETE)) {}\r\n\r\n    /* Destroy the synchronization objects */\r\n    (void)OSIF_SemaDestroy(&lpuartState->rxComplete);\r\n    (void)OSIF_SemaDestroy(&lpuartState->txComplete);\r\n\r\n    /* Disable LPUART interrupt. */\r\n    INT_SYS_DisableIRQ(s_lpuartRxTxIrqId[instance]);\r\n\r\n    /* Restore default handler. */\r\n    INT_SYS_InstallHandler(s_lpuartRxTxIrqId[instance], DefaultISR, (isr_t*) 0);\r\n\r\n    /* Clear our saved pointer to the state structure */\r\n    s_lpuartStatePtr[instance] = NULL;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_InstallRxCallback\r\n * Description   : Install receive data callback function.\r\n *\r\n * Implements    : LPUART_DRV_InstallRxCallback_Activity\r\n *END**************************************************************************/\r\nuart_callback_t LPUART_DRV_InstallRxCallback(uint32_t instance,\r\n                                             uart_callback_t function,\r\n                                             void * callbackParam)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    uart_callback_t currentCallback = lpuartState->rxCallback;\r\n    lpuartState->rxCallback = function;\r\n    lpuartState->rxCallbackParam = callbackParam;\r\n\r\n    return currentCallback;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_InstallTxCallback\r\n * Description   : Install transmit data callback function, pass in NULL pointer\r\n * as callback will uninstall.\r\n *\r\n * Implements    : LPUART_DRV_InstallTxCallback_Activity\r\n *END**************************************************************************/\r\nuart_callback_t LPUART_DRV_InstallTxCallback(uint32_t instance,\r\n                                             uart_callback_t function,\r\n                                             void * callbackParam)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    uart_callback_t currentCallback = lpuartState->txCallback;\r\n    lpuartState->txCallback = function;\r\n    lpuartState->txCallbackParam = callbackParam;\r\n\r\n    return currentCallback;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_SendDataBlocking\r\n * Description   : This function sends data out through the LPUART module using\r\n * blocking method. The function does not return until the transmit is complete.\r\n *\r\n * Implements    : LPUART_DRV_SendDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_SendDataBlocking(uint32_t instance,\r\n                                     const uint8_t * txBuff,\r\n                                     uint32_t txSize,\r\n                                     uint32_t timeout)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(txBuff != NULL);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    status_t retVal = STATUS_SUCCESS;\r\n    status_t syncStatus;\r\n\r\n    /* Indicates this is a blocking transaction. */\r\n    lpuartState->isTxBlocking = true;\r\n\r\n    DEV_ASSERT((lpuartState->transferType == LPUART_USING_INTERRUPTS) ||\r\n               (lpuartState->transferType == LPUART_USING_DMA));\r\n\r\n    if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n    {\r\n        /* Start the transmission process using interrupts */\r\n        retVal = LPUART_DRV_StartSendDataUsingInt(instance, txBuff, txSize);\r\n    }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n        /* Start the transmission process using DMA */\r\n        retVal = LPUART_DRV_StartSendDataUsingDma(instance, txBuff, txSize);\r\n    }\r\n#endif\r\n\r\n    if (retVal == STATUS_SUCCESS)\r\n    {\r\n        /* Wait until the transmit is complete. */\r\n        syncStatus = OSIF_SemaWait(&lpuartState->txComplete, timeout);\r\n\r\n        /* Finish the transmission if timeout expired */\r\n        if (syncStatus == STATUS_TIMEOUT)\r\n        {\r\n            lpuartState->isTxBlocking = false;\r\n            lpuartState->transmitStatus = STATUS_TIMEOUT;\r\n\r\n            if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n            {\r\n                LPUART_DRV_CompleteSendDataUsingInt(instance);\r\n            }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n            else\r\n            {\r\n                LPUART_DRV_StopTxDma(instance);\r\n            }\r\n#endif\r\n        }\r\n    }\r\n\r\n    return lpuartState->transmitStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_SendDataPolling\r\n * Description   : Send out multiple bytes of data using polling method.\r\n *\r\n * Implements    : LPUART_DRV_SendDataPolling_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_SendDataPolling(uint32_t instance,\r\n                                const uint8_t *txBuff,\r\n                                uint32_t txSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(txBuff != NULL);\r\n\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check the validity of the parameters */\r\n    DEV_ASSERT(txSize > 0U);\r\n    DEV_ASSERT((lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR) ||\r\n               ((txSize & 1U) == 0U));\r\n\r\n    /* Check driver is not busy transmitting data from a previous asynchronous call */\r\n    if (lpuartState->isTxBusy)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    /* Enable the LPUART transmitter */\r\n    LPUART_SetTransmitterCmd(base, true);\r\n\r\n    while (txSize > 0U)\r\n    {\r\n        while (!LPUART_GetStatusFlag(base, LPUART_TX_DATA_REG_EMPTY))\r\n        {}\r\n\r\n        lpuartState->txBuff = txBuff;\r\n        LPUART_DRV_PutData(instance);\r\n\r\n        if (lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR)\r\n        {\r\n            ++txBuff;\r\n            --txSize;\r\n        }\r\n        else\r\n        {\r\n            ++txBuff;\r\n            ++txBuff;\r\n            txSize -= 2U;\r\n        }\r\n    }\r\n\r\n    /* Disable the LPUART transmitter */\r\n    LPUART_SetTransmitterCmd(base, false);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_SendData\r\n * Description   : This function sends data out through the LPUART module using\r\n * non-blocking method. The function will return immediately after calling this\r\n * function.\r\n *\r\n * Implements    : LPUART_DRV_SendData_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_SendData(uint32_t instance,\r\n                             const uint8_t * txBuff,\r\n                             uint32_t txSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(txBuff != NULL);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Indicates this is a non-blocking transaction. */\r\n    lpuartState->isTxBlocking = false;\r\n\r\n    DEV_ASSERT((lpuartState->transferType == LPUART_USING_INTERRUPTS) ||\r\n               (lpuartState->transferType == LPUART_USING_DMA));\r\n\r\n    if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n    {\r\n        /* Start the transmission process using interrupts */\r\n        retVal = LPUART_DRV_StartSendDataUsingInt(instance, txBuff, txSize);\r\n    }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n        /* Start the transmission process using DMA */\r\n        retVal = LPUART_DRV_StartSendDataUsingDma(instance, txBuff, txSize);\r\n    }\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_GetTransmitStatus\r\n * Description   : This function returns whether the previous LPUART transmit has\r\n * finished. When performing non-blocking transmit, the user can call this\r\n * function to ascertain the state of the current transmission:\r\n * in progress (or busy) or complete (success). In addition, if the transmission\r\n * is still in progress, the user can obtain the number of words that have been\r\n * currently transferred.\r\n *\r\n * Implements    : LPUART_DRV_GetTransmitStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_GetTransmitStatus(uint32_t instance, uint32_t * bytesRemaining)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    const lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    if (bytesRemaining != NULL)\r\n    {\r\n        if (lpuartState->isTxBusy)\r\n        {\r\n            /* Fill in the bytes not transferred yet. */\r\n            if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n            {\r\n                /* In interrupt-based communication, the remaining bytes are retrieved\r\n                 * from the state structure\r\n                 */\r\n                *bytesRemaining = lpuartState->txSize;;\r\n            }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n            else\r\n            {\r\n                /* In DMA-based communication, the remaining bytes are retrieved\r\n                 * from the current DMA major loop count\r\n                 */\r\n                *bytesRemaining = EDMA_DRV_GetRemainingMajorIterationsCount(lpuartState->txDMAChannel);\r\n            }\r\n#endif\r\n        }\r\n        else\r\n        {\r\n            *bytesRemaining = 0;\r\n        }\r\n    }\r\n\r\n    return lpuartState->transmitStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_AbortSendingData\r\n * Description   : This function terminates an non-blocking LPUART transmission\r\n * early. During a non-blocking LPUART transmission, the user has the option to\r\n * terminate the transmission early if the transmission is still in progress.\r\n *\r\n * Implements    : LPUART_DRV_AbortSendingData_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_AbortSendingData(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check if a transfer is running. */\r\n    if (!lpuartState->isTxBusy)\r\n    {\r\n        return STATUS_SUCCESS;\r\n    }\r\n\r\n    /* Update the tx status */\r\n    lpuartState->transmitStatus = STATUS_UART_ABORTED;\r\n\r\n    /* Stop the running transfer. */\r\n    if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n    {\r\n        LPUART_DRV_CompleteSendDataUsingInt(instance);\r\n    }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n        LPUART_DRV_StopTxDma(instance);\r\n    }\r\n#endif\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_ReceiveDataBlocking\r\n * Description   : This function receives data from LPUART module using blocking\r\n * method, the function does not return until the receive is complete.\r\n *\r\n * Implements    : LPUART_DRV_ReceiveDataBlocking_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_ReceiveDataBlocking(uint32_t instance,\r\n                                        uint8_t * rxBuff,\r\n                                        uint32_t rxSize,\r\n                                        uint32_t timeout)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(rxBuff != NULL);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    status_t retVal = STATUS_SUCCESS;\r\n    status_t syncStatus;\r\n\r\n    /* Indicates this is a blocking transaction. */\r\n    lpuartState->isRxBlocking = true;\r\n\r\n    DEV_ASSERT((lpuartState->transferType == LPUART_USING_INTERRUPTS) ||\r\n               (lpuartState->transferType == LPUART_USING_DMA));\r\n\r\n    if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n    {\r\n         /* Start the reception process using interrupts */\r\n         retVal = LPUART_DRV_StartReceiveDataUsingInt(instance, rxBuff, rxSize);\r\n    }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n        /* Start the reception process using DMA */\r\n        retVal = LPUART_DRV_StartReceiveDataUsingDma(instance, rxBuff, rxSize);\r\n    }\r\n#endif\r\n\r\n    if (retVal == STATUS_SUCCESS)\r\n    {\r\n        /* Wait until the receive is complete. */\r\n        syncStatus = OSIF_SemaWait(&lpuartState->rxComplete, timeout);\r\n\r\n        /* Finish the reception if timeout expired */\r\n        if (syncStatus == STATUS_TIMEOUT)\r\n        {\r\n            lpuartState->isRxBlocking = false;\r\n            lpuartState->receiveStatus = STATUS_TIMEOUT;\r\n\r\n            if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n            {\r\n                LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n            }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n            else\r\n            {\r\n                LPUART_DRV_StopRxDma(instance);\r\n            }\r\n#endif\r\n        }\r\n    }\r\n\r\n    return lpuartState->receiveStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_ReceiveDataPolling\r\n * Description   : Receive multiple bytes of data using polling method.\r\n *\r\n * Implements    : LPUART_DRV_ReceiveDataPolling_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_ReceiveDataPolling(uint32_t instance,\r\n                                       uint8_t *rxBuff,\r\n                                       uint32_t rxSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(rxBuff != NULL);\r\n\r\n    uint8_t tmpByte;\r\n    status_t retVal = STATUS_SUCCESS;\r\n    status_t tmpState = STATUS_SUCCESS;\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check the validity of the parameters */\r\n    DEV_ASSERT(rxSize > 0U);\r\n    DEV_ASSERT((lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR) ||\r\n               ((rxSize & 1U) == 0U));\r\n\r\n    /* Check driver is not busy receiving data from a previous asynchronous call */\r\n    if (lpuartState->isRxBusy)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    /* Enable the LPUART receiver */\r\n    LPUART_SetReceiverCmd((LPUART_Type *)base, true);\r\n\r\n    while (rxSize > 0U)\r\n    {\r\n        while (!LPUART_GetStatusFlag(base, LPUART_RX_DATA_REG_FULL))\r\n        {}\r\n\r\n        lpuartState->rxBuff = rxBuff;\r\n        LPUART_DRV_GetData(instance);\r\n\r\n        if (lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR)\r\n        {\r\n            ++rxBuff;\r\n            --rxSize;\r\n        }\r\n        else\r\n        {\r\n            ++rxBuff;\r\n            ++rxBuff;\r\n            rxSize -= 2U;\r\n        }\r\n\r\n        /* Check for errors on received data */\r\n        if (LPUART_GetStatusFlag(base, LPUART_FRAME_ERR))\r\n        {\r\n            tmpState = STATUS_UART_FRAMING_ERROR;\r\n            /* Disable the LPUART receiver */\r\n            LPUART_SetReceiverCmd((LPUART_Type *)base, false);\r\n            /* Clear the flag */\r\n            (void)LPUART_ClearStatusFlag(base, LPUART_FRAME_ERR);\r\n            break;\r\n        }\r\n        if (LPUART_GetStatusFlag(base, LPUART_NOISE_DETECT))\r\n        {\r\n            tmpState = STATUS_UART_NOISE_ERROR;\r\n            /* Disable the LPUART receiver */\r\n            LPUART_SetReceiverCmd((LPUART_Type *)base, false);\r\n            /* Clear the flag */\r\n            (void)LPUART_ClearStatusFlag(base, LPUART_NOISE_DETECT);\r\n            break;\r\n        }\r\n        if (LPUART_GetStatusFlag(base, LPUART_PARITY_ERR))\r\n        {\r\n            tmpState = STATUS_UART_PARITY_ERROR;\r\n            /* Disable the LPUART receiver */\r\n            LPUART_SetReceiverCmd((LPUART_Type *)base, false);\r\n            /* Clear the flag */\r\n            (void)LPUART_ClearStatusFlag(base, LPUART_PARITY_ERR);\r\n            break;\r\n        }\r\n        if (LPUART_GetStatusFlag(base, LPUART_RX_OVERRUN))\r\n        {\r\n            tmpState = STATUS_UART_RX_OVERRUN;\r\n            /* Disable the LPUART receiver */\r\n            LPUART_SetReceiverCmd((LPUART_Type *)base, false);\r\n            /* Clear the flag */\r\n            (void)LPUART_ClearStatusFlag(base, LPUART_RX_OVERRUN);\r\n            break;\r\n        }\r\n    }\r\n\r\n    /* Update received status */\r\n    if ((rxSize == 0U) && (tmpState == STATUS_UART_RX_OVERRUN))\r\n    {\r\n        retVal = STATUS_SUCCESS;\r\n    }\r\n    else\r\n    {\r\n        retVal = tmpState;\r\n    }\r\n\r\n    if (retVal == STATUS_SUCCESS)\r\n    {\r\n        /* Disable the LPUART receiver */\r\n        LPUART_SetReceiverCmd((LPUART_Type *)base, false);\r\n    }\r\n\r\n    /* Read dummy to clear RDRF flag */\r\n    LPUART_Getchar(base, &tmpByte);\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_ReceiveData\r\n * Description   : This function receives data from LPUART module using\r\n * non-blocking method.  This function returns immediately after initiating the\r\n * receive function. The application has to get the receive status to see when\r\n * the receive is complete. In other words, after calling non-blocking get\r\n * function, the application must get the receive status to check if receive\r\n * is completed or not.\r\n *\r\n * Implements    : LPUART_DRV_ReceiveData_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_ReceiveData(uint32_t instance,\r\n                                uint8_t * rxBuff,\r\n                                uint32_t rxSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(rxBuff != NULL);\r\n\r\n    status_t retVal = STATUS_SUCCESS;\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Indicates this is a non-blocking transaction. */\r\n    lpuartState->isRxBlocking = false;\r\n\r\n    DEV_ASSERT((lpuartState->transferType == LPUART_USING_INTERRUPTS) ||\r\n               (lpuartState->transferType == LPUART_USING_DMA));\r\n\r\n    if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n    {\r\n        /* Start the reception process using interrupts */\r\n        retVal = LPUART_DRV_StartReceiveDataUsingInt(instance, rxBuff, rxSize);\r\n    }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n        /* Start the reception process using DMA */\r\n        retVal = LPUART_DRV_StartReceiveDataUsingDma(instance, rxBuff, rxSize);\r\n    }\r\n#endif\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_GetReceiveStatus\r\n * Description   : This function returns whether the previous LPUART receive is\r\n * complete. When performing a non-blocking receive, the user can call this\r\n * function to ascertain the state of the current receive progress: in progress\r\n * or complete. In addition, if the receive is still in progress, the user can\r\n * obtain the number of words that have been currently received.\r\n *\r\n * Implements    : LPUART_DRV_GetReceiveStatus_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_GetReceiveStatus(uint32_t instance,\r\n                                     uint32_t * bytesRemaining)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    const lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    if (bytesRemaining != NULL)\r\n    {\r\n        if (lpuartState->isRxBusy)\r\n        {\r\n            /* Fill in the bytes transferred. */\r\n            if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n            {\r\n                /* In interrupt-based communication, the remaining bytes are retrieved\r\n                 * from the state structure\r\n                 */\r\n                *bytesRemaining = lpuartState->rxSize;\r\n            }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n            else\r\n            {\r\n                /* In DMA-based communication, the remaining bytes are retrieved\r\n                 * from the current DMA major loop count\r\n                 */\r\n                *bytesRemaining = EDMA_DRV_GetRemainingMajorIterationsCount(lpuartState->rxDMAChannel);\r\n            }\r\n#endif\r\n        }\r\n        else\r\n        {\r\n            *bytesRemaining = 0;\r\n        }\r\n    }\r\n\r\n    return lpuartState->receiveStatus;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_AbortReceivingData\r\n * Description   : Terminates a non-blocking receive early.\r\n *\r\n * Implements    : LPUART_DRV_AbortReceivingData_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_AbortReceivingData(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check if a transfer is running. */\r\n    if (!lpuartState->isRxBusy)\r\n    {\r\n        return STATUS_SUCCESS;\r\n    }\r\n\r\n    /* Update the rx status */\r\n    lpuartState->receiveStatus = STATUS_UART_ABORTED;\r\n\r\n    /* Stop the running transfer. */\r\n    if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n    {\r\n        LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n    }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    else\r\n    {\r\n        LPUART_DRV_StopRxDma(instance);\r\n    }\r\n#endif\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_SetBaudRate\r\n * Description   : Configures the LPUART baud rate.\r\n * In some LPUART instances the user must disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *\r\n * Implements    : LPUART_DRV_SetBaudRate_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_SetBaudRate(uint32_t instance, uint32_t desiredBaudRate)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    uint16_t sbr, sbrTemp, i;\r\n    uint32_t osr, tempDiff, calculatedBaud, baudDiff, maxOsr;\r\n    uint32_t lpuartSourceClock;\r\n    clock_names_t instanceClkName = s_lpuartClkNames[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    const lpuart_state_t * lpuartState;\r\n    lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    if (lpuartState != NULL)\r\n    {\r\n        /* Check if there is an ongoing transfer */\r\n        if (lpuartState->isTxBusy == true)\r\n        {\r\n            return STATUS_BUSY;\r\n        }\r\n        if (lpuartState->isRxBusy == true)\r\n        {\r\n            return STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    /* Get the LPUART clock as configured in the clock manager */\r\n    (void)CLOCK_SYS_GetFreq(instanceClkName, &lpuartSourceClock);\r\n\r\n    /* Check if current instance is clock gated off. */\r\n    DEV_ASSERT(lpuartSourceClock > 0U);\r\n    /* Check if the desired baud rate can be configured with the current protocol clock. */\r\n    DEV_ASSERT(lpuartSourceClock >= (desiredBaudRate * 4U));\r\n\r\n    /* This lpuart instantiation uses a slightly different baud rate calculation\r\n     * The idea is to use the best OSR (over-sampling rate) possible\r\n     * Note, osr is typically hard-set to 16 in other lpuart instantiations\r\n     * First calculate the baud rate using the minimum OSR possible (4) */\r\n    osr = 4;\r\n    sbr = (uint16_t)(lpuartSourceClock / (desiredBaudRate * osr));\r\n    calculatedBaud = (lpuartSourceClock / (osr * sbr));\r\n    if (calculatedBaud > desiredBaudRate)\r\n    {\r\n        baudDiff = calculatedBaud - desiredBaudRate;\r\n    }\r\n    else\r\n    {\r\n        baudDiff = desiredBaudRate - calculatedBaud;\r\n    }\r\n    /* find maximum osr */\r\n    maxOsr = lpuartSourceClock / desiredBaudRate;\r\n    if (maxOsr > 32U)\r\n    {\r\n        maxOsr = 32U;\r\n    }\r\n    /* loop to find the best osr value possible, one that generates minimum baudDiff\r\n     * iterate through the rest of the supported values of osr */\r\n    if (maxOsr >= 5U)\r\n    {\r\n        for (i = 5U; i <= maxOsr; i++)\r\n        {\r\n            /* calculate the temporary sbr value   */\r\n            sbrTemp = (uint16_t)(lpuartSourceClock / (desiredBaudRate * i));\r\n            /* calculate the baud rate based on the temporary osr and sbr values */\r\n            calculatedBaud = (lpuartSourceClock / (i * sbrTemp));\r\n\r\n            if (calculatedBaud > desiredBaudRate)\r\n            {\r\n                tempDiff = calculatedBaud - desiredBaudRate;\r\n            }\r\n            else\r\n            {\r\n                tempDiff = desiredBaudRate - calculatedBaud;\r\n            }\r\n\r\n            if (tempDiff <= baudDiff)\r\n            {\r\n                baudDiff = tempDiff;\r\n                osr = i;  /* update and store the best osr value calculated */\r\n                sbr = sbrTemp;  /* update store the best sbr value calculated */\r\n            }\r\n        }\r\n    }\r\n    /* Check if osr is between 4x and 7x oversampling.\r\n     * If so, then \"BOTHEDGE\" sampling must be turned on */\r\n    if (osr < 8U)\r\n    {\r\n    \tLPUART_EnableBothEdgeSamplingCmd(base);\r\n    }\r\n\r\n    /* program the osr value (bit value is one less than actual value) */\r\n    LPUART_SetOversamplingRatio(base, (osr - 1U));\r\n\r\n    /* write the sbr value to the BAUD registers */\r\n    LPUART_SetBaudRateDivisor(base, sbr);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_GetBaudRate\r\n * Description   : Returns the LPUART configured baud rate.\r\n *\r\n * Implements    : LPUART_DRV_GetBaudRate_Activity\r\n *END**************************************************************************/\r\nvoid LPUART_DRV_GetBaudRate(uint32_t instance, uint32_t * configuredBaudRate)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(configuredBaudRate != NULL);\r\n\r\n    uint8_t osr;\r\n    uint16_t sbr;\r\n    uint32_t lpuartSourceClock;\r\n    clock_names_t instanceClkName = s_lpuartClkNames[instance];\r\n    const LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    /* Get the LPUART clock as configured in the clock manager */\r\n    (void)CLOCK_SYS_GetFreq(instanceClkName, &lpuartSourceClock);\r\n\r\n    osr = LPUART_GetOversamplingRatio(base);\r\n    sbr = LPUART_GetBaudRateDivisor(base);\r\n\r\n    *configuredBaudRate = (lpuartSourceClock / ((osr + 1UL) * sbr));\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_SetTxBuffer\r\n * Description   : Sets the driver internal reference to the tx buffer.\r\n *                 Can be called from the tx callback to provide a different\r\n *                 buffer for continuous transmission.\r\n *\r\n * Implements    : LPUART_DRV_SetTxBuffer_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_SetTxBuffer(uint32_t instance,\r\n                                const uint8_t * txBuff,\r\n                                uint32_t txSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(txBuff != NULL);\r\n    DEV_ASSERT(txSize > 0U);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    lpuartState->txBuff = txBuff;\r\n    lpuartState->txSize = txSize;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_SetRxBuffer\r\n * Description   : Sets the driver internal reference to the rx buffer.\r\n *                 Can be called from the rx callback to provide a different\r\n *                 buffer for continuous reception.\r\n *\r\n * Implements    : LPUART_DRV_SetRxBuffer_Activity\r\n *END**************************************************************************/\r\nstatus_t LPUART_DRV_SetRxBuffer(uint32_t instance,\r\n                                uint8_t * rxBuff,\r\n                                uint32_t rxSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(rxBuff != NULL);\r\n    DEV_ASSERT(rxSize > 0U);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    lpuartState->rxBuff = rxBuff;\r\n    lpuartState->rxSize = rxSize;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_IRQHandler\r\n * Description   : Interrupt handler for LPUART.\r\n * This handler uses the buffers stored in the lpuart_state_t structs to transfer\r\n * data. This is not a public API as it is called by IRQ whenever an interrupt\r\n * occurs.\r\n *\r\n *END**************************************************************************/\r\nvoid LPUART_DRV_IRQHandler(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    const LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    LPUART_DRV_ErrIrqHandler(instance);\r\n\r\n    /* Handle receive data full interrupt */\r\n    if (LPUART_GetIntMode(base, LPUART_INT_RX_DATA_REG_FULL))\r\n    {\r\n        if (LPUART_GetStatusFlag(base, LPUART_RX_DATA_REG_FULL))\r\n        {\r\n            LPUART_DRV_RxIrqHandler(instance);\r\n        }\r\n    }\r\n\r\n    /* Handle transmitter data register empty interrupt */\r\n    if (LPUART_GetIntMode(base, LPUART_INT_TX_DATA_REG_EMPTY))\r\n    {\r\n        if (LPUART_GetStatusFlag(base, LPUART_TX_DATA_REG_EMPTY))\r\n        {\r\n            LPUART_DRV_TxEmptyIrqHandler(instance);\r\n        }\r\n    }\r\n\r\n    /* Handle transmission complete interrupt */\r\n    if (LPUART_GetIntMode(base, LPUART_INT_TX_COMPLETE))\r\n    {\r\n        if (LPUART_GetStatusFlag(base, LPUART_TX_COMPLETE))\r\n        {\r\n            LPUART_DRV_TxCompleteIrqHandler(instance);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_RxIrqHandler\r\n * Description   : Rx Interrupt handler for LPUART.\r\n * This function treats the rx full interrupt.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_RxIrqHandler(uint32_t instance)\r\n{\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Get data and put in receive buffer  */\r\n    LPUART_DRV_GetData(instance);\r\n\r\n    /* Update the internal state */\r\n    if (lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR)\r\n    {\r\n        ++lpuartState->rxBuff;\r\n        --lpuartState->rxSize;\r\n    }\r\n    else\r\n    {\r\n        lpuartState->rxBuff = &lpuartState->rxBuff[2];\r\n        lpuartState->rxSize -= 2U;\r\n    }\r\n\r\n    /* Check if this was the last byte in the current buffer */\r\n    if (lpuartState->rxSize == 0U)\r\n    {\r\n        /* Invoke callback if there is one (callback may reset the rx buffer for continuous reception) */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_RX_FULL, lpuartState->rxCallbackParam);\r\n        }\r\n    }\r\n\r\n    /* Finish reception if this was the last byte received */\r\n    if (lpuartState->rxSize == 0U)\r\n    {\r\n        /* Complete transfer (disable rx logic) */\r\n        LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_END_TRANSFER, lpuartState->rxCallbackParam);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_TxEmptyIrqHandler\r\n * Description   : Tx Empty Interrupt handler for LPUART.\r\n * This function treats the tx empty interrupt.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_TxEmptyIrqHandler(uint32_t instance)\r\n{\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    /* Check if there are any more bytes to send */\r\n    if (lpuartState->txSize > 0U)\r\n    {\r\n        /* Transmit the data */\r\n        LPUART_DRV_PutData(instance);\r\n\r\n        /* Update the internal state */\r\n        if (lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR)\r\n        {\r\n            ++lpuartState->txBuff;\r\n            --lpuartState->txSize;\r\n        }\r\n        else\r\n        {\r\n            lpuartState->txBuff = &lpuartState->txBuff[2];\r\n            lpuartState->txSize -= 2U;\r\n        }\r\n\r\n        /* Check if this was the last byte in the current buffer */\r\n        if (lpuartState->txSize == 0U)\r\n        {\r\n            /* Invoke callback if there is one (callback may reset the tx buffer for continuous transmission)*/\r\n            if (lpuartState->txCallback != NULL)\r\n            {\r\n                lpuartState->txCallback(lpuartState, UART_EVENT_TX_EMPTY, lpuartState->txCallbackParam);\r\n            }\r\n\r\n            /* If there's no new data, disable tx empty interrupt and enable transmission complete interrupt */\r\n            if (lpuartState->txSize == 0U)\r\n            {\r\n                LPUART_SetIntMode(base, LPUART_INT_TX_DATA_REG_EMPTY, false);\r\n                LPUART_SetIntMode(base, LPUART_INT_TX_COMPLETE, true);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_TxCompleteIrqHandler\r\n * Description   : Tx Complete Interrupt handler for LPUART.\r\n * This function treats the tx complete interrupt.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_TxCompleteIrqHandler(uint32_t instance)\r\n{\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    if (lpuartState->txSize == 0U)\r\n    {\r\n        if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n        {\r\n            /* Complete the interrupt based transfer */\r\n            LPUART_DRV_CompleteSendDataUsingInt(instance);\r\n        }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n        else\r\n        {\r\n            /* Complete the DMA based transfer */\r\n            LPUART_DRV_StopTxDma(instance);\r\n        }\r\n#endif\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->txCallback != NULL)\r\n        {\r\n            lpuartState->txCallback(lpuartState, UART_EVENT_END_TRANSFER, lpuartState->txCallbackParam);\r\n        }\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_ErrIrqHandler\r\n * Description   : Error Interrupt handler for LPUART.\r\n * This function treats the error interrupts.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_ErrIrqHandler(uint32_t instance)\r\n{\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    /* Handle receive overrun interrupt */\r\n    if (LPUART_GetStatusFlag(base, LPUART_RX_OVERRUN))\r\n    {\r\n        /* Update the internal status */\r\n        lpuartState->receiveStatus = STATUS_UART_RX_OVERRUN;\r\n        if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n        {\r\n            /* Complete the transfer (disable rx logic) */\r\n            LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n        }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n        else\r\n        {\r\n            /* Complete the transfer (stop DMA channel) */\r\n            LPUART_DRV_StopRxDma(instance);\r\n        }\r\n#endif\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_ERROR, lpuartState->rxCallbackParam);\r\n        }\r\n\r\n        /* Clear the flags */\r\n        LPUART_DRV_ClearErrorFlags(base);\r\n    }\r\n    /* Handle framing error interrupt */\r\n    if (LPUART_GetStatusFlag(base, LPUART_FRAME_ERR))\r\n    {\r\n        /* Update the internal status */\r\n        lpuartState->receiveStatus = STATUS_UART_FRAMING_ERROR;\r\n        if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n        {\r\n            /* Complete the transfer (disable rx logic) */\r\n            LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n        }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n        else\r\n        {\r\n            /* Complete the transfer (stop DMA channel) */\r\n            LPUART_DRV_StopRxDma(instance);\r\n        }\r\n#endif\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_ERROR, lpuartState->rxCallbackParam);\r\n        }\r\n\r\n        /* Clear the flags */\r\n        LPUART_DRV_ClearErrorFlags(base);\r\n    }\r\n    /* Handle parity error interrupt */\r\n    if (LPUART_GetStatusFlag(base, LPUART_PARITY_ERR))\r\n    {\r\n        /* Update the internal status */\r\n        lpuartState->receiveStatus = STATUS_UART_PARITY_ERROR;\r\n        if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n        {\r\n            /* Complete the transfer (disable rx logic) */\r\n            LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n        }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n        else\r\n        {\r\n            /* Complete the transfer (stop DMA channel) */\r\n            LPUART_DRV_StopRxDma(instance);\r\n        }\r\n#endif\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_ERROR, lpuartState->rxCallbackParam);\r\n        }\r\n\r\n        /* Clear the flags */\r\n        LPUART_DRV_ClearErrorFlags(base);\r\n    }\r\n    /* Handle noise error interrupt */\r\n    if (LPUART_GetStatusFlag(base, LPUART_NOISE_DETECT))\r\n    {\r\n        /* Update the internal status */\r\n        lpuartState->receiveStatus = STATUS_UART_NOISE_ERROR;\r\n        if (lpuartState->transferType == LPUART_USING_INTERRUPTS)\r\n        {\r\n            /* Complete transfer (disable rx logic) */\r\n            LPUART_DRV_CompleteReceiveDataUsingInt(instance);\r\n        }\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n        else\r\n        {\r\n            /* Complete the transfer (stop DMA channel) */\r\n            LPUART_DRV_StopRxDma(instance);\r\n        }\r\n#endif\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_ERROR, lpuartState->rxCallbackParam);\r\n        }\r\n\r\n        /* Clear the flags */\r\n        LPUART_DRV_ClearErrorFlags(base);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_StartSendDataUsingInt\r\n * Description   : Initiate (start) a transmit by beginning the process of\r\n * sending data and enabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t LPUART_DRV_StartSendDataUsingInt(uint32_t instance,\r\n                                                 const uint8_t * txBuff,\r\n                                                 uint32_t txSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(txBuff != NULL);\r\n\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check it's not busy transmitting data from a previous function call */\r\n    if (lpuartState->isTxBusy)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    /* Check the validity of the parameters */\r\n    DEV_ASSERT(txSize > 0U);\r\n    DEV_ASSERT((lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR) ||\r\n               ((txSize & 1U) == 0U));\r\n\r\n    /* initialize the module driver state structure */\r\n    lpuartState->txBuff = txBuff;\r\n    lpuartState->txSize = txSize;\r\n    lpuartState->isTxBusy = true;\r\n    lpuartState->transmitStatus = STATUS_BUSY;\r\n\r\n    /* Enable the LPUART transmitter */\r\n    LPUART_SetTransmitterCmd(base, true);\r\n\r\n    /* Enable tx empty interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_TX_DATA_REG_EMPTY, true);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_StartSendDataUsingDma\r\n * Description   : Initiate (start) a transmit by beginning the process of\r\n * sending data using DMA transfers.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t LPUART_DRV_StartSendDataUsingDma(uint32_t instance,\r\n                                                 const uint8_t * txBuff,\r\n                                                 uint32_t txSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(txBuff != NULL);\r\n\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check it's not busy transmitting data from a previous function call */\r\n    if (lpuartState->isTxBusy)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    DEV_ASSERT(txSize > 0U);\r\n\r\n    /* Update state structure */\r\n    lpuartState->txBuff = txBuff;\r\n    lpuartState->txSize = 0U;\r\n    lpuartState->isTxBusy = true;\r\n    lpuartState->transmitStatus = STATUS_BUSY;\r\n\r\n    /* Configure the transfer control descriptor for the previously allocated channel */\r\n    (void)EDMA_DRV_ConfigMultiBlockTransfer(lpuartState->txDMAChannel, EDMA_TRANSFER_MEM2PERIPH, (uint32_t)txBuff,\r\n                                             (uint32_t)(&(base->DATA)), EDMA_TRANSFER_SIZE_1B, 1U, txSize, true);\r\n\r\n    /* Call driver function to end the transmission when the DMA transfer is done */\r\n    (void)EDMA_DRV_InstallCallback(lpuartState->txDMAChannel,\r\n                                   (edma_callback_t)(LPUART_DRV_TxDmaCallback),\r\n                                   (void*)(instance));\r\n\r\n    /* Start the DMA channel */\r\n    (void)EDMA_DRV_StartChannel(lpuartState->txDMAChannel);\r\n\r\n    /* Enable the LPUART transmitter */\r\n    LPUART_SetTransmitterCmd(base, true);\r\n\r\n    /* Enable tx DMA requests for the current instance */\r\n    LPUART_SetTxDmaCmd(base, true);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_CompleteSendDataUsingInt\r\n * Description   : Finish up a transmit by completing the process of sending\r\n * data and disabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_CompleteSendDataUsingInt(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    if (lpuartState->transmitStatus == STATUS_BUSY)\r\n    {\r\n        /* If the transfer is completed, update the transmit status */\r\n        lpuartState->transmitStatus = STATUS_SUCCESS;\r\n    }\r\n    else\r\n    {\r\n        /* If the transfer is aborted or timed out, disable tx empty interrupt */\r\n        LPUART_SetIntMode(base, LPUART_INT_TX_DATA_REG_EMPTY, false);\r\n    }\r\n\r\n    /* Disable transmission complete interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_TX_COMPLETE, false);\r\n\r\n    /* Disable transmitter */\r\n    LPUART_SetTransmitterCmd(base, false);\r\n\r\n    /* Update the internal busy flag */\r\n    lpuartState->isTxBusy = false;\r\n\r\n    /* Signal the synchronous completion object. */\r\n    if (lpuartState->isTxBlocking)\r\n    {\r\n        (void)OSIF_SemaPost(&lpuartState->txComplete);\r\n    }\r\n}\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_TxDmaCallback\r\n * Description   : Finish up a transmit by completing the process of sending\r\n * data and disabling the DMA requests. This is a callback for DMA major loop\r\n * completion, so it must match the DMA callback signature.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_TxDmaCallback(void * parameter, edma_chn_status_t status)\r\n{\r\n    uint32_t instance = ((uint32_t)parameter);\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    /* Check if the DMA transfer completed with errors */\r\n    if (status == EDMA_CHN_ERROR)\r\n    {\r\n        /* Update the status */\r\n        lpuartState->transmitStatus = STATUS_ERROR;\r\n        /* Stop the transfer */\r\n        LPUART_DRV_StopTxDma(instance);\r\n        /* Notify the application that an error occurred */\r\n        if (lpuartState->txCallback != NULL)\r\n        {\r\n            lpuartState->txCallback(lpuartState, UART_EVENT_ERROR, lpuartState->txCallbackParam);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* Invoke callback if there is one */\r\n        if (lpuartState->txCallback != NULL)\r\n        {\r\n            /* Allow the user to provide a new buffer, for continuous transmission */\r\n            lpuartState->txCallback(lpuartState, UART_EVENT_TX_EMPTY, lpuartState->txCallbackParam);\r\n        }\r\n\r\n        /* If the callback has updated the tx buffer, update the DMA descriptor to continue the transfer;\r\n         * otherwise, stop the current transfer.\r\n         */\r\n        if (lpuartState->txSize > 0U)\r\n        {\r\n            /* Set the source address and the number of minor loops (bytes to be transfered) */\r\n            EDMA_DRV_SetSrcAddr(lpuartState->txDMAChannel, (uint32_t)(lpuartState->txBuff));\r\n            EDMA_DRV_SetMajorLoopIterationCount(lpuartState->txDMAChannel, lpuartState->txSize);\r\n\r\n            /* Now that this tx is set up, clear remaining bytes count */\r\n            lpuartState->txSize = 0U;\r\n\r\n            /* Re-start the channel */\r\n            (void)EDMA_DRV_StartChannel(lpuartState->txDMAChannel);\r\n        }\r\n        else\r\n        {\r\n            /* Enable transmission complete interrupt */\r\n            LPUART_SetIntMode(base, LPUART_INT_TX_COMPLETE, true);\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_StartReceiveDataUsingInt\r\n * Description   : Initiate (start) a receive by beginning the process of\r\n * receiving data and enabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t LPUART_DRV_StartReceiveDataUsingInt(uint32_t instance,\r\n                                                    uint8_t * rxBuff,\r\n                                                    uint32_t rxSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(rxBuff != NULL);\r\n\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    /* Check it's not busy receiving data from a previous function call */\r\n    if (lpuartState->isRxBusy)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    /* Check the validity of the parameters */\r\n    DEV_ASSERT(rxSize > 0U);\r\n    DEV_ASSERT((lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR) ||\r\n               ((rxSize & 1U) == 0U));\r\n\r\n    /* Initialize the module driver state struct to indicate transfer in progress\r\n     * and with the buffer and byte count data. */\r\n    lpuartState->isRxBusy = true;\r\n    lpuartState->rxBuff = rxBuff;\r\n    lpuartState->rxSize = rxSize;\r\n    lpuartState->receiveStatus = STATUS_BUSY;\r\n\r\n    /* Enable the receiver */\r\n    LPUART_SetReceiverCmd(base, true);\r\n\r\n    /* Enable error interrupts */\r\n    LPUART_SetErrorInterrupts(base, true);\r\n\r\n    /* Enable receive data full interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, true);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_StartReceiveDataUsingDma\r\n * Description   : Initiate (start) a receive by beginning the process of\r\n * receiving data using DMA transfers.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t LPUART_DRV_StartReceiveDataUsingDma(uint32_t instance,\r\n                                                    uint8_t * rxBuff,\r\n                                                    uint32_t rxSize)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n    DEV_ASSERT(rxBuff != NULL);\r\n\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Check it's not busy transmitting data from a previous function call */\r\n    if (lpuartState->isRxBusy)\r\n    {\r\n        return STATUS_BUSY;\r\n    }\r\n\r\n    DEV_ASSERT(rxSize > 0U);\r\n\r\n    /* Configure the transfer control descriptor for the previously allocated channel */\r\n    (void)EDMA_DRV_ConfigMultiBlockTransfer(lpuartState->rxDMAChannel, EDMA_TRANSFER_PERIPH2MEM,\r\n                                            (uint32_t)(&(base->DATA)), (uint32_t)rxBuff, EDMA_TRANSFER_SIZE_1B,\r\n                                            1U, rxSize, true);\r\n\r\n    /* Call driver function to end the reception when the DMA transfer is done */\r\n    (void)EDMA_DRV_InstallCallback(lpuartState->rxDMAChannel,\r\n                                   (edma_callback_t)(LPUART_DRV_RxDmaCallback),\r\n                                   (void*)(instance));\r\n\r\n    /* Start the DMA channel */\r\n    (void)EDMA_DRV_StartChannel(lpuartState->rxDMAChannel);\r\n\r\n    /* Update the state structure */\r\n    lpuartState->rxBuff = rxBuff;\r\n    lpuartState->rxSize = 0U;\r\n    lpuartState->isRxBusy = true;\r\n    lpuartState->receiveStatus = STATUS_BUSY;\r\n\r\n    /* Enable the receiver */\r\n    LPUART_SetReceiverCmd(base, true);\r\n\r\n    /* Enable error interrupts */\r\n    LPUART_SetErrorInterrupts(base, true);\r\n\r\n    /* Enable rx DMA requests for the current instance */\r\n    LPUART_SetRxDmaCmd(base, true);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_CompleteReceiveDataUsingInt\r\n * Description   : Finish up a receive by completing the process of receiving data\r\n * and disabling the interrupt.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_CompleteReceiveDataUsingInt(uint32_t instance)\r\n{\r\n    DEV_ASSERT(instance < LPUART_INSTANCE_COUNT);\r\n\r\n    uint8_t tmpByte;\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    /* Disable receiver */\r\n    LPUART_SetReceiverCmd(base, false);\r\n\r\n    /* Disable error interrupts */\r\n    LPUART_SetErrorInterrupts(base, false);\r\n\r\n    /* Read dummy to clear RDRF flag */\r\n    LPUART_Getchar(base, &tmpByte);\r\n\r\n    /* Disable receive data full and rx overrun interrupt. */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_DATA_REG_FULL, false);\r\n\r\n    /* Signal the synchronous completion object. */\r\n    if (lpuartState->isRxBlocking)\r\n    {\r\n        (void)OSIF_SemaPost(&lpuartState->rxComplete);\r\n        lpuartState->isRxBlocking = false;\r\n    }\r\n\r\n    /* Update the information of the module driver state */\r\n    lpuartState->isRxBusy = false;\r\n    if (lpuartState->receiveStatus == STATUS_BUSY)\r\n    {\r\n        lpuartState->receiveStatus = STATUS_SUCCESS;\r\n    }\r\n}\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_RxDmaCallback\r\n * Description   : Finish up a receive by completing the process of receiving data\r\n * and disabling the DMA requests. This is a callback for DMA major loop\r\n * completion, so it must match the DMA callback signature.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_RxDmaCallback(void * parameter, edma_chn_status_t status)\r\n{\r\n    uint32_t instance = ((uint32_t)parameter);\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n\r\n    if (status == EDMA_CHN_ERROR)\r\n    {\r\n        /* Update the status */\r\n        lpuartState->receiveStatus = STATUS_ERROR;\r\n        /* Stop the transfer */\r\n        LPUART_DRV_StopRxDma(instance);\r\n        /* Notify the application that an error occurred */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_ERROR, lpuartState->rxCallbackParam);\r\n        }\r\n\r\n        /* Clear the flags */\r\n        LPUART_DRV_ClearErrorFlags(base);\r\n    }\r\n\r\n    /* Return if an error occurred; error cases are treated by the interrupt handler */\r\n    if (lpuartState->receiveStatus != STATUS_BUSY)\r\n    {\r\n        return;\r\n    }\r\n\r\n    /* Invoke callback if there is one */\r\n    if (lpuartState->rxCallback != NULL)\r\n    {\r\n        /* Allow the user to provide a new buffer inside the callback, to continue the reception */\r\n        lpuartState->rxCallback(lpuartState, UART_EVENT_RX_FULL, lpuartState->rxCallbackParam);\r\n    }\r\n\r\n    /* If the callback has updated the rx buffer, update the DMA descriptor to continue the transfer;\r\n     * otherwise, stop the current transfer.\r\n     */\r\n    if (lpuartState->rxSize > 0U)\r\n    {\r\n        /* Set the source address and the number of minor loops (bytes to be transfered) */\r\n        EDMA_DRV_SetDestAddr(lpuartState->rxDMAChannel, (uint32_t)(lpuartState->rxBuff));\r\n        EDMA_DRV_SetMajorLoopIterationCount(lpuartState->rxDMAChannel, lpuartState->rxSize);\r\n\r\n        /* Now that this rx is set up, clear remaining bytes count */\r\n        lpuartState->rxSize = 0U;\r\n\r\n        /* Re-start the channel */\r\n        (void)EDMA_DRV_StartChannel(lpuartState->rxDMAChannel);\r\n    }\r\n    else\r\n    {\r\n        /* Stop the reception */\r\n        LPUART_DRV_StopRxDma(instance);\r\n\r\n        /* Invoke the callback to notify the end of the transfer */\r\n        if (lpuartState->rxCallback != NULL)\r\n        {\r\n            lpuartState->rxCallback(lpuartState, UART_EVENT_END_TRANSFER, lpuartState->rxCallbackParam);\r\n        }\r\n\r\n        /* Clear the flags */\r\n        LPUART_DRV_ClearErrorFlags(base);\r\n    }\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_PutData\r\n * Description   : Write data to the buffer register, according to configured\r\n * word length.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_PutData(uint32_t instance)\r\n{\r\n    const lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    uint16_t data;\r\n    const uint8_t *txBuff = lpuartState->txBuff;\r\n\r\n    if (lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR)\r\n    {\r\n        /* Transmit the data */\r\n        LPUART_Putchar(base, *txBuff);\r\n    }\r\n    else if (lpuartState->bitCountPerChar == LPUART_9_BITS_PER_CHAR)\r\n    {\r\n        /* Create a 16-bits integer from two bytes */\r\n        data = (uint16_t)(*txBuff);\r\n        ++txBuff;\r\n        data |= (uint16_t)(((uint16_t)(*txBuff)) << 8U);\r\n\r\n        /* Transmit the data */\r\n        LPUART_Putchar9(base, data);\r\n    }\r\n    else\r\n    {\r\n        /* Create a 16-bits integer from two bytes */\r\n        data = (uint16_t)(*txBuff);\r\n        ++txBuff;\r\n        data |= (uint16_t)(((uint16_t)(*txBuff)) << 8U);\r\n\r\n        /* Transmit the data */\r\n        LPUART_Putchar10(base, data);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_GetData\r\n * Description   : Read data from the buffer register, according to configured\r\n * word length.\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_GetData(uint32_t instance)\r\n{\r\n    const lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    const LPUART_Type * base = s_lpuartBase[instance];\r\n    uint16_t data;\r\n    uint8_t *rxBuff = lpuartState->rxBuff;\r\n\r\n    if (lpuartState->bitCountPerChar == LPUART_8_BITS_PER_CHAR)\r\n    {\r\n        /* Receive the data */\r\n        LPUART_Getchar(base, rxBuff);\r\n    }\r\n    else if (lpuartState->bitCountPerChar == LPUART_9_BITS_PER_CHAR)\r\n    {\r\n        /* Receive the data */\r\n        LPUART_Getchar9(base, &data);\r\n\r\n        /* Write the least significant bits to the receive buffer */\r\n        *rxBuff = (uint8_t)(data & 0xFFU);\r\n        ++rxBuff;\r\n        /* Write the ninth bit to the subsequent byte in the rx buffer */\r\n        *rxBuff = (uint8_t)(data >> 8U);\r\n    }\r\n    else\r\n    {\r\n        /* Receive the data */\r\n        LPUART_Getchar10(base, &data);\r\n\r\n        /* Write the least significant bits to the receive buffer */\r\n        *rxBuff = (uint8_t)(data & 0xFFU);\r\n        ++rxBuff;\r\n        /* Write the ninth and tenth bits to the subsequent byte in the rx buffer */\r\n        *rxBuff = (uint8_t)(data >> 8U);\r\n    }\r\n}\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_StopTxDma\r\n * Description   : Finish up a DMA transmission by disabling the DMA requests,\r\n * transmission complete interrupt and tx logic. This function also resets the\r\n * internal driver state (busy flag/tx semaphore).\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_StopTxDma(uint32_t instance)\r\n{\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n\r\n    /* Disable tx DMA requests for the current instance */\r\n    LPUART_SetTxDmaCmd(base, false);\r\n\r\n    /* Stop the dma channel */\r\n    (void)EDMA_DRV_StopChannel(lpuartState->txDMAChannel);\r\n\r\n    /* Disable transmission complete interrupt */\r\n    LPUART_SetIntMode(base, LPUART_INT_TX_COMPLETE, false);\r\n\r\n    /* Disable transmitter */\r\n    LPUART_SetTransmitterCmd(base, false);\r\n\r\n    /* Signal the synchronous completion object. */\r\n    if (lpuartState->isTxBlocking)\r\n    {\r\n        (void)OSIF_SemaPost(&lpuartState->txComplete);\r\n    }\r\n\r\n    if (lpuartState->transmitStatus == STATUS_BUSY)\r\n    {\r\n        /* If the transfer is completed, update the transmit status */\r\n        lpuartState->transmitStatus = STATUS_SUCCESS;\r\n    }\r\n\r\n    /* Update the internal busy flag */\r\n    lpuartState->isTxBusy = false;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_DRV_StopRxDma\r\n * Description   : Finish up a DMA reception by disabling the DMA requests,\r\n * error interrupts and rx logic. This function also resets the internal driver\r\n * state (busy flag/rx semaphore).\r\n * This is not a public API as it is called from other driver functions.\r\n *\r\n *END**************************************************************************/\r\nstatic void LPUART_DRV_StopRxDma(uint32_t instance)\r\n{\r\n    LPUART_Type * base = s_lpuartBase[instance];\r\n    lpuart_state_t * lpuartState = (lpuart_state_t *)s_lpuartStatePtr[instance];\r\n    uint8_t tmpByte;\r\n\r\n    /* Disable receiver */\r\n    LPUART_SetReceiverCmd(base, false);\r\n\r\n    /* Disable error interrupts */\r\n    LPUART_SetErrorInterrupts(base, false);\r\n\r\n    /* Disable rx DMA requests for the current instance */\r\n    LPUART_SetRxDmaCmd(base, false);\r\n\r\n    /* Read dummy to clear RDRF flag */\r\n    LPUART_Getchar(base, &tmpByte);\r\n\r\n    /* Stop the DMA channel */\r\n    (void)EDMA_DRV_StopChannel(lpuartState->rxDMAChannel);\r\n\r\n    /* Signal the synchronous completion object. */\r\n    if (lpuartState->isRxBlocking)\r\n    {\r\n        (void)OSIF_SemaPost(&lpuartState->rxComplete);\r\n        lpuartState->isRxBlocking = false;\r\n    }\r\n\r\n    /* Update the internal driver status */\r\n    if (lpuartState->receiveStatus == STATUS_BUSY)\r\n    {\r\n        lpuartState->receiveStatus = STATUS_SUCCESS;\r\n    }\r\n\r\n    /* Update the information of the module driver state */\r\n    lpuartState->isRxBusy = false;\r\n}\r\n#endif\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpuart_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef LPUART_DRIVER_H__\r\n#define LPUART_DRIVER_H__\r\n\r\n#include <stddef.h>\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"osif.h\"\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n#include \"edma_driver.h\"\r\n#endif\r\n#include \"callbacks.h\"\r\n\r\n/*!\r\n * @addtogroup lpuart_driver\r\n * @{\r\n */\r\n\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*! @brief Type of LPUART transfer (based on interrupts or DMA).\r\n *\r\n * Implements : lpuart_transfer_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_USING_DMA         = 0,    /*!< The driver will use DMA to perform UART transfer */\r\n    LPUART_USING_INTERRUPTS          /*!< The driver will use interrupts to perform UART transfer */\r\n} lpuart_transfer_type_t;\r\n\r\n/*! @brief LPUART number of bits in a character\r\n *\r\n * Implements : lpuart_bit_count_per_char_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_8_BITS_PER_CHAR  = 0x0U, /*!< 8-bit data characters */\r\n    LPUART_9_BITS_PER_CHAR  = 0x1U, /*!< 9-bit data characters */\r\n    LPUART_10_BITS_PER_CHAR = 0x2U  /*!< 10-bit data characters */\r\n} lpuart_bit_count_per_char_t;\r\n\r\n/*! @brief LPUART parity mode\r\n *\r\n * Implements : lpuart_parity_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_PARITY_DISABLED = 0x0U, /*!< parity disabled */\r\n    LPUART_PARITY_EVEN     = 0x2U, /*!< parity enabled, type even, bit setting: PE|PT = 10 */\r\n    LPUART_PARITY_ODD      = 0x3U  /*!< parity enabled, type odd,  bit setting: PE|PT = 11 */\r\n} lpuart_parity_mode_t;\r\n\r\n/*! @brief LPUART number of stop bits\r\n *\r\n * Implements : lpuart_stop_bit_count_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_ONE_STOP_BIT = 0x0U, /*!< one stop bit */\r\n    LPUART_TWO_STOP_BIT = 0x1U  /*!< two stop bits */\r\n} lpuart_stop_bit_count_t;\r\n\r\n/*!\r\n * @brief Runtime state of the LPUART driver.\r\n *\r\n * Note that the caller provides memory for the driver state structures during\r\n * initialization because the driver does not statically allocate memory.\r\n *\r\n * Implements : lpuart_state_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    const uint8_t * txBuff;              /*!< The buffer of data being sent.*/\r\n    uint8_t * rxBuff;                    /*!< The buffer of received data.*/\r\n    volatile uint32_t txSize;            /*!< The remaining number of bytes to be transmitted. */\r\n    volatile uint32_t rxSize;            /*!< The remaining number of bytes to be received. */\r\n    volatile bool isTxBusy;              /*!< True if there is an active transmit.*/\r\n    volatile bool isRxBusy;              /*!< True if there is an active receive.*/\r\n    volatile bool isTxBlocking;          /*!< True if transmit is blocking transaction. */\r\n    volatile bool isRxBlocking;          /*!< True if receive is blocking transaction. */\r\n    lpuart_bit_count_per_char_t bitCountPerChar; /*!< number of bits in a char (8/9/10) */\r\n    uart_callback_t rxCallback;          /*!< Callback to invoke for data receive\r\n                                              Note: when the transmission is interrupt based, the callback\r\n                                              is being called upon receiving a byte; when DMA transmission\r\n                                              is used, the bytes are copied to the rx buffer by the DMA engine\r\n                                              and the callback is called when all the bytes have been transferred. */\r\n    void * rxCallbackParam;              /*!< Receive callback parameter pointer.*/\r\n    uart_callback_t txCallback;          /*!< Callback to invoke for data send\r\n                                              Note: when the transmission is interrupt based, the callback\r\n                                              is being called upon sending a byte; when DMA transmission\r\n                                              is used, the bytes are copied to the tx buffer by the DMA engine\r\n                                              and the callback is called when all the bytes have been transferred. */\r\n    void * txCallbackParam;              /*!< Transmit callback parameter pointer.*/\r\n    lpuart_transfer_type_t transferType; /*!< Type of LPUART transfer (interrupt/dma based) */\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n    uint8_t rxDMAChannel;                /*!< DMA channel number for DMA-based rx. */\r\n    uint8_t txDMAChannel;                /*!< DMA channel number for DMA-based tx. */\r\n#endif\r\n    semaphore_t rxComplete;              /*!< Synchronization object for blocking Rx timeout condition */\r\n    semaphore_t txComplete;              /*!< Synchronization object for blocking Tx timeout condition */\r\n    volatile status_t transmitStatus;    /*!< Status of last driver transmit operation */\r\n    volatile status_t receiveStatus;     /*!< Status of last driver receive operation */\r\n} lpuart_state_t;\r\n\r\n/*! @brief LPUART configuration structure\r\n *\r\n * Implements : lpuart_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint32_t baudRate;                           /*!< LPUART baud rate */\r\n    lpuart_parity_mode_t parityMode;             /*!< parity mode, disabled (default), even, odd */\r\n    lpuart_stop_bit_count_t stopBitCount;        /*!< number of stop bits, 1 stop bit (default) or 2 stop bits */\r\n    lpuart_bit_count_per_char_t bitCountPerChar; /*!< number of bits in a character (8-default, 9 or 10);\r\n                                                      for 9/10 bits chars, users must provide appropriate buffers\r\n                                                      to the send/receive functions (bits 8/9 in subsequent bytes);\r\n                                                      for DMA transmission only 8-bit char is supported. */\r\n    lpuart_transfer_type_t transferType;         /*!< Type of LPUART transfer (interrupt/dma based) */\r\n    uint8_t rxDMAChannel;                        /*!< Channel number for DMA rx channel.\r\n                                                      If DMA mode isn't used this field will be ignored. */\r\n    uint8_t txDMAChannel;                        /*!< Channel number for DMA tx channel.\r\n                                                      If DMA mode isn't used this field will be ignored. */\r\n} lpuart_user_config_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name LPUART Driver\r\n * @{\r\n */\r\n\r\n /*!\r\n * @brief Initializes the LPUART configuration structure with default values.\r\n *\r\n * This function initializes a configuration structure received from the application\r\n * with default values.\r\n *\r\n * @param lpuartUserConfig user configuration structure of type #lpuart_user_config_t\r\n */\r\nvoid LPUART_DRV_GetDefaultConfig(lpuart_user_config_t * lpuartUserConfig);\r\n\r\n/*!\r\n * @brief Initializes an LPUART operation instance.\r\n *\r\n * The caller provides memory for the driver state structures during initialization.\r\n * The user must select the LPUART clock source in the application to initialize the LPUART.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param lpuartUserConfig user configuration structure of type #lpuart_user_config_t\r\n * @param lpuartStatePtr pointer to the LPUART driver state structure\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_ERROR if an error occurred\r\n */\r\nstatus_t LPUART_DRV_Init(uint32_t instance, lpuart_state_t * lpuartStatePtr,\r\n                         const lpuart_user_config_t * lpuartUserConfig);\r\n\r\n/*!\r\n * @brief Shuts down the LPUART by disabling interrupts and transmitter/receiver.\r\n *\r\n * @param instance  LPUART instance number\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_ERROR if an error occurred\r\n */\r\nstatus_t LPUART_DRV_Deinit(uint32_t instance);\r\n\r\n/*!\r\n * @brief Installs callback function for the LPUART receive.\r\n *\r\n * @note After a callback is installed, it bypasses part of the LPUART IRQHandler logic.\r\n * Therefore, the callback needs to handle the indexes of txBuff and txSize.\r\n *\r\n * @param instance The LPUART instance number.\r\n * @param function The LPUART receive callback function.\r\n * @param rxBuff The receive buffer used inside IRQHandler. This buffer must be kept as long as the callback is alive.\r\n * @param callbackParam The LPUART receive callback parameter pointer.\r\n * @return Former LPUART receive callback function pointer.\r\n */\r\nuart_callback_t LPUART_DRV_InstallRxCallback(uint32_t instance,\r\n                                             uart_callback_t function,\r\n                                             void * callbackParam);\r\n\r\n/*!\r\n * @brief Installs callback function for the LPUART transmit.\r\n *\r\n * @note After a callback is installed, it bypasses part of the LPUART IRQHandler logic.\r\n * Therefore, the callback needs to handle the indexes of txBuff and txSize.\r\n *\r\n * @param instance The LPUART instance number.\r\n * @param function The LPUART transmit callback function.\r\n * @param txBuff The transmit buffer used inside IRQHandler. This buffer must be kept as long as the callback is alive.\r\n * @param callbackParam The LPUART transmit callback parameter pointer.\r\n * @return Former LPUART transmit callback function pointer.\r\n */\r\nuart_callback_t LPUART_DRV_InstallTxCallback(uint32_t instance,\r\n                                             uart_callback_t function,\r\n                                             void * callbackParam);\r\n\r\n/*!\r\n * @brief Sends data out through the LPUART module using a blocking method.\r\n *\r\n *  Blocking means that the function does not return until the transmission is complete.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param txBuff  source buffer containing 8-bit data chars to send\r\n * @param txSize the number of bytes to send\r\n * @param timeout timeout value in milliseconds\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_TIMEOUT if the timeout was reached;\r\n *         STATUS_BUSY if the resource is busy;\r\n *         STATUS_ERROR if an error occurred\r\n */\r\nstatus_t LPUART_DRV_SendDataBlocking(uint32_t instance,\r\n                                     const uint8_t * txBuff,\r\n                                     uint32_t txSize,\r\n                                     uint32_t timeout);\r\n\r\n/*!\r\n * @brief Send out multiple bytes of data using polling method.\r\n *\r\n * @param   instance  LPUART instance number.\r\n * @param   txBuff The buffer pointer which saves the data to be sent.\r\n * @param   txSize Size of data to be sent in unit of byte.\r\n * @return  STATUS_SUCCESS if successful;\r\n *          STATUS_BUSY if the resource is busy;\r\n */\r\nstatus_t LPUART_DRV_SendDataPolling(uint32_t instance, const uint8_t *txBuff, uint32_t txSize);\r\n\r\n/*!\r\n * @brief Sends data out through the LPUART module using a non-blocking method.\r\n *  This enables an a-sync method for transmitting data. When used with\r\n *  a non-blocking receive, the LPUART can perform a full duplex operation.\r\n *  Non-blocking  means that the function returns immediately.\r\n *  The application has to get the transmit status to know when the transmit is complete.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param txBuff  source buffer containing 8-bit data chars to send\r\n * @param txSize  the number of bytes to send\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_BUSY if the resource is busy;\r\n */\r\nstatus_t LPUART_DRV_SendData(uint32_t instance,\r\n                             const uint8_t * txBuff,\r\n                             uint32_t txSize);\r\n\r\n/*!\r\n * @brief Returns whether the previous transmit is complete.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param bytesRemaining Pointer to value that is populated with the number of bytes that\r\n *        have been sent in the active transfer\r\n *        @note In DMA mode, this parameter may not be accurate, in case the transfer completes\r\n *              right after calling this function; in this edge-case, the parameter will reflect\r\n *              the initial transfer size, due to automatic reloading of the major loop count\r\n *              in the DMA transfer descriptor.\r\n * @return The transmit status.\r\n * @retval STATUS_SUCCESS The transmit has completed successfully.\r\n * @retval STATUS_BUSY The transmit is still in progress. @a bytesRemaining will be\r\n *         filled with the number of bytes that are yet to be transmitted.\r\n * @retval STATUS_UART_ABORTED The transmit was aborted.\r\n * @retval STATUS_TIMEOUT A timeout was reached.\r\n * @retval STATUS_ERROR An error occurred.\r\n */\r\nstatus_t LPUART_DRV_GetTransmitStatus(uint32_t instance, uint32_t * bytesRemaining);\r\n\r\n/*!\r\n * @brief Terminates a non-blocking transmission early.\r\n *\r\n * @param instance  LPUART instance number\r\n * @return Whether the aborting is successful or not.\r\n */\r\nstatus_t LPUART_DRV_AbortSendingData(uint32_t instance);\r\n\r\n/*!\r\n * @brief Gets data from the LPUART module by using a blocking method.\r\n *  Blocking means that the function does not return until the\r\n *  receive is complete.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param rxBuff  buffer containing 8-bit read data chars received\r\n * @param rxSize the number of bytes to receive\r\n * @param timeout timeout value in milliseconds\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_TIMEOUT if the timeout was reached;\r\n *         STATUS_BUSY if the resource is busy;\r\n *         STATUS_UART_FRAMING_ERROR if a framing error occurred;\r\n *         STATUS_UART_NOISE_ERROR if a noise error occurred;\r\n *         STATUS_UART_PARITY_ERROR if a parity error occurred;\r\n *         STATUS_UART_RX_OVERRUN if an overrun error occurred;\r\n *         STATUS_ERROR if a DMA error occurred;\r\n */\r\nstatus_t LPUART_DRV_ReceiveDataBlocking(uint32_t instance,\r\n                                        uint8_t * rxBuff,\r\n                                        uint32_t rxSize,\r\n                                        uint32_t timeout);\r\n\r\n/*!\r\n * @brief Receive multiple bytes of data using polling method.\r\n *\r\n *\r\n * @param   instance  LPUART instance number.\r\n * @param   rxBuff The buffer pointer which saves the data to be received.\r\n * @param   rxSize Size of data need to be received in unit of byte.\r\n * @return  STATUS_SUCCESS if the transaction is successful;\r\n *          STATUS_BUSY if the resource is busy;\r\n *          STATUS_UART_RX_OVERRUN if an overrun error occurred.\r\n */\r\nstatus_t LPUART_DRV_ReceiveDataPolling(uint32_t instance, uint8_t *rxBuff, uint32_t rxSize);\r\n\r\n/*!\r\n * @brief Gets data from the LPUART module by using a non-blocking method.\r\n *  This enables an a-sync method for receiving data. When used with\r\n *  a non-blocking transmission, the LPUART can perform a full duplex operation.\r\n *  Non-blocking means that the function returns immediately.\r\n *  The application has to get the receive status to know when the receive is complete.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param rxBuff  buffer containing 8-bit read data chars received\r\n * @param rxSize  the number of bytes to receive\r\n * @return STATUS_SUCCESS if successful;\r\n *         STATUS_BUSY if the resource is busy\r\n */\r\nstatus_t LPUART_DRV_ReceiveData(uint32_t instance,\r\n                                uint8_t * rxBuff,\r\n                                uint32_t rxSize);\r\n\r\n/*!\r\n * @brief Returns whether the previous receive is complete.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param bytesRemaining pointer to value that is filled  with the number of bytes that\r\n *        still need to be received in the active transfer.\r\n *        @note In DMA mode, this parameter may not be accurate, in case the transfer completes\r\n *              right after calling this function; in this edge-case, the parameter will reflect\r\n *              the initial transfer size, due to automatic reloading of the major loop count\r\n *              in the DMA transfer descriptor.\r\n * @return The receive status.\r\n * @retval STATUS_SUCCESS the receive has completed successfully.\r\n * @retval STATUS_BUSY the receive is still in progress. @a bytesReceived will be\r\n *     filled with the number of bytes that have been received so far.\r\n * @retval STATUS_UART_ABORTED The receive was aborted.\r\n * @retval STATUS_TIMEOUT A timeout was reached.\r\n * @retval STATUS_UART_RX_OVERRUN, STATUS_UART_FRAMING_ERROR, STATUS_UART_PARITY_ERROR,\r\n           or STATUS_UART_NOISE_ERROR, STATUS_ERROR An error occurred during reception.\r\n */\r\nstatus_t LPUART_DRV_GetReceiveStatus(uint32_t instance, uint32_t * bytesRemaining);\r\n\r\n/*!\r\n * @brief Terminates a non-blocking receive early.\r\n *\r\n * @param instance  LPUART instance number\r\n *\r\n * @return Whether the receiving was successful or not.\r\n */\r\nstatus_t LPUART_DRV_AbortReceivingData(uint32_t instance);\r\n\r\n/*!\r\n * @brief Configures the LPUART baud rate.\r\n *\r\n * This function configures the LPUART baud rate.\r\n * In some LPUART instances the user must disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *\r\n * @param instance  LPUART instance number.\r\n * @param desiredBaudRate LPUART desired baud rate.\r\n * @return STATUS_BUSY if called during an on-going transfer, STATUS_SUCCESS otherwise\r\n */\r\nstatus_t LPUART_DRV_SetBaudRate(uint32_t instance, uint32_t desiredBaudRate);\r\n\r\n/*!\r\n * @brief Returns the LPUART baud rate.\r\n *\r\n * This function returns the LPUART configured baud rate.\r\n *\r\n * @param instance  LPUART instance number.\r\n * @param[out] configuredBaudRate LPUART configured baud rate.\r\n */\r\nvoid LPUART_DRV_GetBaudRate(uint32_t instance, uint32_t * configuredBaudRate);\r\n\r\n/*!\r\n * @brief Sets the internal driver reference to the tx buffer.\r\n *\r\n * This function can be called from the tx callback to provide the driver\r\n * with a new buffer, for continuous transmission.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param txBuff  source buffer containing 8-bit data chars to send\r\n * @param txSize  the number of bytes to send\r\n * @return STATUS_SUCCESS\r\n */\r\nstatus_t LPUART_DRV_SetTxBuffer(uint32_t instance,\r\n                                const uint8_t * txBuff,\r\n                                uint32_t txSize);\r\n\r\n/*!\r\n * @brief Sets the internal driver reference to the rx buffer.\r\n *\r\n * This function can be called from the rx callback to provide the driver\r\n * with a new buffer, for continuous reception.\r\n *\r\n * @param instance  LPUART instance number\r\n * @param rxBuff  destination buffer containing 8-bit data chars to receive\r\n * @param rxSize  the number of bytes to receive\r\n * @return STATUS_SUCCESS\r\n */\r\nstatus_t LPUART_DRV_SetRxBuffer(uint32_t instance,\r\n                                uint8_t * rxBuff,\r\n                                uint32_t rxSize);\r\n\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* LPUART_DRIVER_H__ */\r\n/******************************************************************************/\r\n/* EOF */\r\n/******************************************************************************/\r\n"},{"name":"lpuart_hw_access.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lpuart_hw_access.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * The functions are only used by LPUART driver, errors appear for LIN driver where\r\n * they are not used.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.3, Expression assigned to a\r\n * narrower or different essential type.\r\n * The assign operations are safe as the baud rate calculation algorithm cannot\r\n * overflow the result.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 15.5, Return statement before end of\r\n * function .\r\n * The return statement before end of function is used for simpler code structure\r\n * and better readability.\r\n */\r\n\r\n#include \"lpuart_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_Init\r\n * Description   : Initializes the LPUART controller to known state, using\r\n *                 register reset values defined in the reference manual.\r\n *END**************************************************************************/\r\nvoid LPUART_Init(LPUART_Type * base)\r\n{\r\n    /* Set the default oversampling ratio (16) and baud-rate divider (4) */\r\n    base->BAUD = ((uint32_t)((FEATURE_LPUART_DEFAULT_OSR << LPUART_BAUD_OSR_SHIFT) | \\\r\n                 (FEATURE_LPUART_DEFAULT_SBR << LPUART_BAUD_SBR_SHIFT)));\r\n    /* Clear the error/interrupt flags */\r\n    base->STAT = FEATURE_LPUART_STAT_REG_FLAGS_MASK;\r\n    /* Reset all features/interrupts by default */\r\n    base->CTRL = 0x00000000;\r\n    /* Reset match addresses */\r\n    base->MATCH = 0x00000000;\r\n#if FEATURE_LPUART_HAS_MODEM_SUPPORT\r\n    /* Reset IrDA modem features */\r\n    base->MODIR = 0x00000000;\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n    /* Reset FIFO feature */\r\n    base->FIFO = FEATURE_LPUART_FIFO_RESET_MASK;\r\n    /* Reset FIFO Watermark values */\r\n    base->WATER = 0x00000000;\r\n#endif\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_SetBitCountPerChar\r\n * Description   : Configures the number of bits per char in LPUART controller.\r\n * In some LPUART instances, the user should disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *END**************************************************************************/\r\nvoid LPUART_SetBitCountPerChar(LPUART_Type * base, lpuart_bit_count_per_char_t bitCountPerChar, bool parity)\r\n{\r\n    uint32_t tmpBitCountPerChar = (uint32_t)bitCountPerChar;\r\n    if (parity)\r\n    {\r\n        tmpBitCountPerChar += 1U;\r\n    }\r\n\r\n    if (tmpBitCountPerChar == (uint32_t)LPUART_10_BITS_PER_CHAR)\r\n    {\r\n        base->BAUD = (base->BAUD & ~LPUART_BAUD_M10_MASK) | ((uint32_t)1U << LPUART_BAUD_M10_SHIFT);\r\n    }\r\n    else\r\n    {\r\n        /* config 8-bit (M=0) or 9-bits (M=1) */\r\n        base->CTRL = (base->CTRL & ~LPUART_CTRL_M_MASK) | (tmpBitCountPerChar << LPUART_CTRL_M_SHIFT);\r\n        /* clear M10 to make sure not 10-bit mode */\r\n        base->BAUD &= ~LPUART_BAUD_M10_MASK;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_SetParityMode\r\n * Description   : Configures parity mode in the LPUART controller.\r\n * In some LPUART instances, the user should disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *END**************************************************************************/\r\nvoid LPUART_SetParityMode(LPUART_Type * base, lpuart_parity_mode_t parityModeType)\r\n{\r\n    base->CTRL = (base->CTRL & ~LPUART_CTRL_PE_MASK) | (((uint32_t)parityModeType >> 1U) << LPUART_CTRL_PE_SHIFT);\r\n    base->CTRL = (base->CTRL & ~LPUART_CTRL_PT_MASK) | (((uint32_t)parityModeType & 1U) << LPUART_CTRL_PT_SHIFT);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_Putchar9\r\n * Description   : Sends the LPUART 9-bit character.\r\n *END**************************************************************************/\r\nvoid LPUART_Putchar9(LPUART_Type * base, uint16_t data)\r\n{\r\n    uint8_t ninthDataBit;\r\n    volatile uint8_t * dataRegBytes = (volatile uint8_t *)(&(base->DATA));\r\n\r\n\r\n    ninthDataBit = (uint8_t)((data >> 8U) & 0x1U);\r\n\r\n    /* write to ninth data bit T8(where T[0:7]=8-bits, T8=9th bit) */\r\n    base->CTRL = (base->CTRL & ~LPUART_CTRL_R9T8_MASK) | ((uint32_t)(ninthDataBit) << LPUART_CTRL_R9T8_SHIFT);\r\n\r\n    /* write 8-bits to the data register*/\r\n    dataRegBytes[0] = (uint8_t)data;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_Putchar10\r\n * Description   : Sends the LPUART 10-bit character.\r\n *END**************************************************************************/\r\nvoid LPUART_Putchar10(LPUART_Type * base, uint16_t data)\r\n{\r\n    uint8_t ninthDataBit, tenthDataBit;\r\n    uint32_t ctrlRegVal;\r\n    volatile uint8_t * dataRegBytes = (volatile uint8_t *)(&(base->DATA));\r\n\r\n    ninthDataBit = (uint8_t)((data >> 8U) & 0x1U);\r\n    tenthDataBit = (uint8_t)((data >> 9U) & 0x1U);\r\n\r\n    /* write to ninth/tenth data bit (T[0:7]=8-bits, T8=9th bit, T9=10th bit) */\r\n    ctrlRegVal = base->CTRL;\r\n    ctrlRegVal = (ctrlRegVal & ~LPUART_CTRL_R9T8_MASK) | ((uint32_t)ninthDataBit << LPUART_CTRL_R9T8_SHIFT);\r\n    ctrlRegVal = (ctrlRegVal & ~LPUART_CTRL_R8T9_MASK) | ((uint32_t)tenthDataBit << LPUART_CTRL_R8T9_SHIFT);\r\n    base->CTRL = ctrlRegVal;\r\n\r\n    /* write to 8-bits to the data register */\r\n    dataRegBytes[0] = (uint8_t)data;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_Getchar9\r\n * Description   : Gets the LPUART 9-bit character.\r\n *END**************************************************************************/\r\nvoid LPUART_Getchar9(const LPUART_Type * base, uint16_t *readData)\r\n{\r\n    DEV_ASSERT(readData != NULL);\r\n\r\n    /* get ninth bit from lpuart data register */\r\n    *readData = (uint16_t)(((base->CTRL >> LPUART_CTRL_R8T9_SHIFT) & 1U) << 8);\r\n\r\n    /* get 8-bit data from the lpuart data register */\r\n    *readData |= (uint8_t)base->DATA;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_Getchar10\r\n * Description   : Gets the LPUART 10-bit character\r\n *END**************************************************************************/\r\nvoid LPUART_Getchar10(const LPUART_Type * base, uint16_t *readData)\r\n{\r\n    DEV_ASSERT(readData != NULL);\r\n\r\n    /* read tenth data bit */\r\n    *readData = (uint16_t)(((base->CTRL >> LPUART_CTRL_R9T8_SHIFT) & 1U) << 9);\r\n    /* read ninth data bit */\r\n    *readData |= (uint16_t)(((base->CTRL >> LPUART_CTRL_R8T9_SHIFT) & 1U) << 8);\r\n\r\n    /* get 8-bit data */\r\n    *readData |= (uint8_t)base->DATA;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_SetIntMode\r\n * Description   : Configures the LPUART module interrupts to enable/disable\r\n * various interrupt sources.\r\n *END**************************************************************************/\r\nvoid LPUART_SetIntMode(LPUART_Type * base, lpuart_interrupt_t intSrc, bool enable)\r\n{\r\n    uint32_t reg = (uint32_t)(intSrc) >> LPUART_SHIFT;\r\n    uint32_t intRegOffset = (uint16_t)(intSrc);\r\n\r\n    switch (reg)\r\n    {\r\n        case LPUART_BAUD_REG_ID:\r\n            base->BAUD = (base->BAUD & ~(1UL << intRegOffset)) | ((enable ? 1U : 0U) << intRegOffset);\r\n            break;\r\n        case LPUART_CTRL_REG_ID:\r\n            base->CTRL = (base->CTRL & ~(1UL << intRegOffset)) | ((enable ? 1U : 0U) << intRegOffset);\r\n            break;\r\n#if FEATURE_LPUART_HAS_MODEM_SUPPORT\r\n        case LPUART_MODIR_REG_ID:\r\n            base->MODIR = (base->MODIR & ~(1UL << intRegOffset)) | ((enable ? 1U : 0U) << intRegOffset);\r\n            break;\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n        case LPUART_FIFO_REG_ID:\r\n            base->FIFO = (base->FIFO & (~FEATURE_LPUART_FIFO_REG_FLAGS_MASK & ~(1UL << intRegOffset))) | \\\r\n                         ((enable ? 1U : 0U) << intRegOffset);\r\n            break;\r\n#endif\r\n        default :\r\n            /* Invalid parameter: return */\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_GetIntMode\r\n * Description   : Returns whether LPUART module interrupt is enabled/disabled.\r\n *END**************************************************************************/\r\nbool LPUART_GetIntMode(const LPUART_Type * base, lpuart_interrupt_t intSrc)\r\n{\r\n    uint32_t reg = (uint32_t)(intSrc) >> LPUART_SHIFT;\r\n    bool retVal = false;\r\n\r\n    switch ( reg )\r\n    {\r\n        case LPUART_BAUD_REG_ID:\r\n            retVal = (((base->BAUD >> (uint16_t)(intSrc)) & 1U) > 0U);\r\n            break;\r\n        case LPUART_CTRL_REG_ID:\r\n            retVal = (((base->CTRL >> (uint16_t)(intSrc)) & 1U) > 0U);\r\n            break;\r\n#if FEATURE_LPUART_HAS_MODEM_SUPPORT\r\n        case LPUART_MODIR_REG_ID:\r\n            retVal = (((base->MODIR >> (uint16_t)(intSrc)) & 1U) > 0U);\r\n            break;\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n        case LPUART_FIFO_REG_ID:\r\n            retVal = (((base->FIFO >> (uint16_t)(intSrc)) & 1U) > 0U);\r\n            break;\r\n#endif\r\n        default :\r\n            /* Invalid parameter: return */\r\n            break;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_GetStatusFlag\r\n * Description   : LPUART get status flag by passing flag enum.\r\n *END**************************************************************************/\r\nbool LPUART_GetStatusFlag(const LPUART_Type * base, lpuart_status_flag_t statusFlag)\r\n{\r\n    uint32_t reg = (uint32_t)(statusFlag) >> LPUART_SHIFT;\r\n    bool retVal = false;\r\n\r\n    switch ( reg )\r\n    {\r\n        case LPUART_STAT_REG_ID:\r\n            retVal = (((base->STAT >> (uint16_t)(statusFlag)) & 1U) > 0U);\r\n            break;\r\n        case LPUART_DATA_REG_ID:\r\n            retVal = (((base->DATA >> (uint16_t)(statusFlag)) & 1U) > 0U);\r\n            break;\r\n#if FEATURE_LPUART_HAS_MODEM_SUPPORT\r\n        case LPUART_MODIR_REG_ID:\r\n            retVal = (((base->MODIR >> (uint16_t)(statusFlag)) & 1U) > 0U);\r\n            break;\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n        case LPUART_FIFO_REG_ID:\r\n            retVal = (((base->FIFO >> (uint16_t)(statusFlag)) & 1U) > 0U);\r\n            break;\r\n#endif\r\n        default:\r\n            /* Invalid parameter: return */\r\n            break;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_ClearStatusFlag\r\n * Description   : LPUART clears an individual status flag\r\n * (see lpuart_status_flag_t for list of status bits).\r\n *END**************************************************************************/\r\nstatus_t LPUART_ClearStatusFlag(LPUART_Type * base,\r\n                                    lpuart_status_flag_t statusFlag)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n\r\n    switch(statusFlag)\r\n    {\r\n        /* These flags are cleared automatically by other lpuart operations\r\n         * and cannot be manually cleared, return error code */\r\n        case LPUART_TX_DATA_REG_EMPTY:\r\n        case LPUART_TX_COMPLETE:\r\n        case LPUART_RX_DATA_REG_FULL:\r\n        case LPUART_RX_ACTIVE:\r\n#if FEATURE_LPUART_HAS_EXTENDED_DATA_REGISTER_FLAGS\r\n        case LPUART_NOISE_IN_CURRENT_WORD:\r\n        case LPUART_PARITY_ERR_IN_CURRENT_WORD:\r\n#endif\r\n            returnCode = STATUS_ERROR;\r\n            break;\r\n\r\n        case LPUART_IDLE_LINE_DETECT:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_IDLE_MASK;\r\n            break;\r\n\r\n        case LPUART_RX_OVERRUN:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_OR_MASK;\r\n            break;\r\n\r\n        case LPUART_NOISE_DETECT:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_NF_MASK;\r\n            break;\r\n\r\n        case LPUART_FRAME_ERR:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_FE_MASK;\r\n            break;\r\n\r\n        case LPUART_PARITY_ERR:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_PF_MASK;\r\n            break;\r\n\r\n        case LPUART_LIN_BREAK_DETECT:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_LBKDIF_MASK;\r\n            break;\r\n\r\n        case LPUART_RX_ACTIVE_EDGE_DETECT:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_RXEDGIF_MASK;\r\n            break;\r\n\r\n#if FEATURE_LPUART_HAS_ADDRESS_MATCHING\r\n        case LPUART_MATCH_ADDR_ONE:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_MA1F_MASK;\r\n            break;\r\n        case LPUART_MATCH_ADDR_TWO:\r\n            base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | LPUART_STAT_MA2F_MASK;\r\n            break;\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n        case LPUART_FIFO_TX_OF:\r\n            base->FIFO = (base->FIFO & (~FEATURE_LPUART_FIFO_REG_FLAGS_MASK)) | LPUART_FIFO_TXOF_MASK;\r\n            break;\r\n        case LPUART_FIFO_RX_UF:\r\n            base->FIFO = (base->FIFO & (~FEATURE_LPUART_FIFO_REG_FLAGS_MASK)) | LPUART_FIFO_RXUF_MASK;\r\n            break;\r\n#endif\r\n        default:\r\n            returnCode = STATUS_ERROR;\r\n            break;\r\n    }\r\n\r\n    return (returnCode);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : LPUART_SetErrorInterrupts\r\n * Description   : Enable or disable the LPUART error interrupts.\r\n *END**************************************************************************/\r\nvoid LPUART_SetErrorInterrupts(LPUART_Type * base, bool enable)\r\n{\r\n    /* Configure the error interrupts */\r\n    LPUART_SetIntMode(base, LPUART_INT_RX_OVERRUN, enable);\r\n    LPUART_SetIntMode(base, LPUART_INT_PARITY_ERR_FLAG, enable);\r\n    LPUART_SetIntMode(base, LPUART_INT_NOISE_ERR_FLAG, enable);\r\n    LPUART_SetIntMode(base, LPUART_INT_FRAME_ERR_FLAG, enable);\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpuart_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n /*!\r\n * @file lpuart_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, Global typedef not referenced.\r\n * This increases ease of use: allows users to access the corresponding field in the register\r\n * using an already defined type.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macros were defined for consistency reasons, all the registers have a corresponding ID.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.3, Expression assigned to a narrower or different essential type.\r\n * The cast is required to perform a conversion between an unsigned integer and an enum type.\r\n */\r\n\r\n#ifndef LPUART_HW_ACCESS_H__\r\n#define LPUART_HW_ACCESS_H__\r\n\r\n#include \"lpuart_driver.h\"\r\n\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n#define LPUART_SHIFT (16U)\r\n#define LPUART_BAUD_REG_ID (1U)\r\n#define LPUART_STAT_REG_ID (2U)\r\n#define LPUART_CTRL_REG_ID (3U)\r\n#define LPUART_DATA_REG_ID (4U)\r\n#define LPUART_MATCH_REG_ID (5U)\r\n#define LPUART_MODIR_REG_ID (6U)\r\n#define LPUART_FIFO_REG_ID (7U)\r\n\r\n/*! @brief LPUART wakeup from standby method constants\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_IDLE_LINE_WAKE = 0x0U, /*!< Idle-line wakes the LPUART receiver from standby. */\r\n    LPUART_ADDR_MARK_WAKE = 0x1U  /*!< Addr-mark wakes LPUART receiver from standby.*/\r\n} lpuart_wakeup_method_t;\r\n\r\n/*!\r\n * @brief LPUART break character length settings for transmit/detect.\r\n *\r\n * The actual maximum bit times may vary depending on the LPUART instance.\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_BREAK_CHAR_10_BIT_MINIMUM = 0x0U, /*!< LPUART break char length 10 bit times (if M = 0, SBNS = 0)\r\n                                                  or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,\r\n                                                  SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1) */\r\n    LPUART_BREAK_CHAR_13_BIT_MINIMUM = 0x1U  /*!< LPUART break char length 13 bit times (if M = 0, SBNS = 0\r\n                                                  or M10 = 0, SBNS = 1) or 14 (if M = 1, SBNS = 0 or M = 1,\r\n                                                  SBNS = 1) or 15 (if M10 = 1, SBNS = 1 or M10 = 1, SNBS = 0) */\r\n} lpuart_break_char_length_t;\r\n\r\n/*!\r\n * @brief LPUART status flags.\r\n *\r\n * This provides constants for the LPUART status flags for use in the UART functions.\r\n */\r\ntypedef enum\r\n{\r\n    LPUART_TX_DATA_REG_EMPTY          = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_TDRE_SHIFT), \\\r\n                                        /*!< Tx data register empty flag, sets when Tx buffer is empty */\r\n    LPUART_TX_COMPLETE                = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_TC_SHIFT), \\\r\n                                        /*!< Transmission complete flag, sets when transmission activity complete */\r\n    LPUART_RX_DATA_REG_FULL           = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_RDRF_SHIFT), \\\r\n                                        /*!< Rx data register full flag, sets when the receive data buffer is full */\r\n    LPUART_IDLE_LINE_DETECT           = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_IDLE_SHIFT), \\\r\n                                        /*!< Idle line detect flag, sets when idle line detected */\r\n    LPUART_RX_OVERRUN                 = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_OR_SHIFT), \\\r\n                                        /*!< Rx Overrun sets if new data is received before data is read */\r\n    LPUART_NOISE_DETECT               = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_NF_SHIFT), \\\r\n                                        /*!< Rx takes 3 samples of each received bit. If these differ, the flag sets */\r\n    LPUART_FRAME_ERR                  = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_FE_SHIFT), \\\r\n                                        /*!< Frame error flag, sets if logic 0 was detected where stop bit expected */\r\n    LPUART_PARITY_ERR                 = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_PF_SHIFT), \\\r\n                                        /*!< If parity enabled, sets upon parity error detection */\r\n    LPUART_LIN_BREAK_DETECT           = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_LBKDIF_SHIFT), \\\r\n                                        /*!< LIN break detect interrupt flag, sets when LIN break char detected */\r\n    LPUART_RX_ACTIVE_EDGE_DETECT      = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_RXEDGIF_SHIFT), \\\r\n                                        /*!< Rx pin active edge interrupt flag, sets when active edge detected */\r\n    LPUART_RX_ACTIVE                  = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_RAF_SHIFT), \\\r\n                                        /*!< Receiver Active Flag (RAF), sets at beginning of valid start bit */\r\n    LPUART_NOISE_IN_CURRENT_WORD      = (((uint32_t)LPUART_DATA_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_DATA_NOISY_SHIFT), \\\r\n                                        /*!< NOISY bit, sets if noise detected in current data word */\r\n    LPUART_PARITY_ERR_IN_CURRENT_WORD = (((uint32_t)LPUART_DATA_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_DATA_PARITYE_SHIFT), \\\r\n                                        /*!< PARITYE bit, sets if noise detected in current data word */\r\n#if FEATURE_LPUART_HAS_ADDRESS_MATCHING\r\n    LPUART_MATCH_ADDR_ONE             = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_MA1F_SHIFT), \\\r\n                                        /*!< Address one match flag */\r\n    LPUART_MATCH_ADDR_TWO             = (((uint32_t)LPUART_STAT_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_STAT_MA2F_SHIFT), \\\r\n                                        /*!< Address two match flag */\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n    LPUART_FIFO_TX_OF                 = (((uint32_t)LPUART_FIFO_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_FIFO_TXOF_SHIFT), \\\r\n                                        /*!< Transmitter FIFO buffer overflow */\r\n    LPUART_FIFO_RX_UF                 = (((uint32_t)LPUART_FIFO_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                        | (uint32_t)LPUART_FIFO_RXUF_SHIFT) \\\r\n                                        /*!< Receiver FIFO buffer underflow */\r\n#endif\r\n} lpuart_status_flag_t;\r\n\r\n/*! @brief LPUART interrupt configuration structure, default settings are 0 (disabled) */\r\ntypedef enum\r\n{\r\n    LPUART_INT_LIN_BREAK_DETECT  = (((uint32_t)LPUART_BAUD_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_BAUD_LBKDIE_SHIFT),  /*!< LIN break detect. */\r\n    LPUART_INT_RX_ACTIVE_EDGE    = (((uint32_t)LPUART_BAUD_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_BAUD_RXEDGIE_SHIFT), /*!< RX Active Edge. */\r\n    LPUART_INT_TX_DATA_REG_EMPTY = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_TIE_SHIFT),     /*!< Transmit data register empty. */\r\n    LPUART_INT_TX_COMPLETE       = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_TCIE_SHIFT),    /*!< Transmission complete. */\r\n    LPUART_INT_RX_DATA_REG_FULL  = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_RIE_SHIFT),     /*!< Receiver data register full. */\r\n    LPUART_INT_IDLE_LINE         = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_ILIE_SHIFT),    /*!< Idle line. */\r\n    LPUART_INT_RX_OVERRUN        = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_ORIE_SHIFT),    /*!< Receiver Overrun. */\r\n    LPUART_INT_NOISE_ERR_FLAG    = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_NEIE_SHIFT),    /*!< Noise error flag. */\r\n    LPUART_INT_FRAME_ERR_FLAG    = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_FEIE_SHIFT),    /*!< Framing error flag. */\r\n    LPUART_INT_PARITY_ERR_FLAG   = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_PEIE_SHIFT),    /*!< Parity error flag. */\r\n#if FEATURE_LPUART_HAS_ADDRESS_MATCHING\r\n    LPUART_INT_MATCH_ADDR_ONE    = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_MA1IE_SHIFT),   /*!< Match address one flag. */\r\n    LPUART_INT_MATCH_ADDR_TWO    = (((uint32_t)LPUART_CTRL_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_CTRL_MA2IE_SHIFT),   /*!< Match address two flag. */\r\n#endif\r\n#if FEATURE_LPUART_FIFO_SIZE > 0U\r\n    LPUART_INT_FIFO_TXOF         = (((uint32_t)LPUART_FIFO_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_FIFO_TXOFE_SHIFT),    /*!< Transmitter FIFO buffer interrupt */\r\n    LPUART_INT_FIFO_RXUF         = (((uint32_t)LPUART_FIFO_REG_ID << (uint32_t)LPUART_SHIFT) \\\r\n                                   | (uint32_t)LPUART_FIFO_RXUFE_SHIFT)     /*!< Receiver FIFO buffer interrupt */\r\n#endif\r\n} lpuart_interrupt_t;\r\n\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name LPUART Common Configurations\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Initializes the LPUART controller.\r\n *\r\n * This function Initializes the LPUART controller to known state.\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n */\r\nvoid LPUART_Init(LPUART_Type * base);\r\n\r\n/*!\r\n * @brief Enable/Disable the LPUART transmitter.\r\n *\r\n * This function enables or disables the LPUART transmitter, based on the\r\n * parameter received.\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n * @param enable Enable(true) or disable(false) transmitter.\r\n */\r\nstatic inline void LPUART_SetTransmitterCmd(LPUART_Type * base, bool enable)\r\n{\r\n    base->CTRL = (base->CTRL & ~LPUART_CTRL_TE_MASK) | ((enable ? 1UL : 0UL) << LPUART_CTRL_TE_SHIFT);\r\n    /* Wait for the register write operation to complete */\r\n    while((bool)((base->CTRL & LPUART_CTRL_TE_MASK) != 0U) != enable) {}\r\n}\r\n\r\n/*!\r\n * @brief Enable/Disable the LPUART receiver.\r\n *\r\n * This function enables or disables the LPUART receiver, based on the\r\n * parameter received.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param enable Enable(true) or disable(false) receiver.\r\n */\r\nstatic inline void LPUART_SetReceiverCmd(LPUART_Type * base, bool enable)\r\n{\r\n    base->CTRL = (base->CTRL & ~LPUART_CTRL_RE_MASK) | ((enable ? 1UL : 0UL) << LPUART_CTRL_RE_SHIFT);\r\n    /* Wait for the register write operation to complete */\r\n    while((bool)((base->CTRL & LPUART_CTRL_RE_MASK) != 0U) != enable) {}\r\n}\r\n\r\n/*!\r\n * @brief Sets the LPUART baud rate modulo divisor.\r\n *\r\n * This function sets the LPUART baud rate modulo divisor.\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n * @param baudRateDivisor The baud rate modulo division \"SBR\"\r\n */\r\nstatic inline void LPUART_SetBaudRateDivisor(LPUART_Type * base, uint32_t baudRateDivisor)\r\n{\r\n    DEV_ASSERT((baudRateDivisor <= 0x1FFFU) && (baudRateDivisor >= 1U));\r\n    uint32_t baudRegValTemp;\r\n\r\n    baudRegValTemp = base->BAUD;\r\n    baudRegValTemp &= ~(LPUART_BAUD_SBR_MASK);\r\n    /* Removed the shift operation as the SBR field position is zero; shifting with 0 violates MISRA */\r\n    baudRegValTemp |= baudRateDivisor & LPUART_BAUD_SBR_MASK;\r\n    base->BAUD = baudRegValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the LPUART baud rate modulo divisor.\r\n *\r\n * This function gets the LPUART baud rate modulo divisor.\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n * @return The baud rate modulo division \"SBR\"\r\n */\r\nstatic inline uint16_t LPUART_GetBaudRateDivisor(const LPUART_Type * base)\r\n{\r\n    return ((uint16_t)((base->BAUD & LPUART_BAUD_SBR_MASK) >> LPUART_BAUD_SBR_SHIFT));\r\n}\r\n\r\n#if FEATURE_LPUART_HAS_BAUD_RATE_OVER_SAMPLING_SUPPORT\r\n/*!\r\n * @brief Sets the LPUART baud rate oversampling ratio\r\n *\r\n * This function sets the LPUART baud rate oversampling ratio.\r\n * (Note: Feature available on select LPUART instances used together with baud rate programming)\r\n * The oversampling ratio should be set between 4x (00011) and 32x (11111). Writing\r\n * an invalid oversampling ratio results in an error and is set to a default\r\n * 16x (01111) oversampling ratio.\r\n * Disable the transmitter/receiver before calling this function.\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n * @param overSamplingRatio The oversampling ratio \"OSR\"\r\n */\r\nstatic inline void LPUART_SetOversamplingRatio(LPUART_Type * base, uint32_t overSamplingRatio)\r\n{\r\n    DEV_ASSERT(overSamplingRatio <= 0x1FU);\r\n    uint32_t baudRegValTemp;\r\n\r\n    baudRegValTemp = base->BAUD;\r\n    baudRegValTemp &= ~(LPUART_BAUD_OSR_MASK);\r\n    baudRegValTemp |= LPUART_BAUD_OSR(overSamplingRatio);\r\n    base->BAUD = baudRegValTemp;\r\n}\r\n\r\n/*!\r\n * @brief Gets the LPUART baud rate oversampling ratio\r\n *\r\n * This function gets the LPUART baud rate oversampling ratio.\r\n * (Note: Feature available on select LPUART instances used together with baud rate programming)\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n * @return The oversampling ratio \"OSR\"\r\n */\r\nstatic inline uint8_t LPUART_GetOversamplingRatio(const LPUART_Type * base)\r\n{\r\n    return ((uint8_t)((base->BAUD & LPUART_BAUD_OSR_MASK) >> LPUART_BAUD_OSR_SHIFT));\r\n}\r\n#endif\r\n\r\n#if FEATURE_LPUART_HAS_BOTH_EDGE_SAMPLING_SUPPORT\r\n/*!\r\n * @brief Configures the LPUART baud rate both edge sampling\r\n *\r\n * This function configures the LPUART baud rate both edge sampling.\r\n * (Note: Feature available on select LPUART instances used with baud rate programming)\r\n * When enabled, the received data is sampled on both edges of the baud rate clock.\r\n * This must be set when the oversampling ratio is between 4x and 7x.\r\n * This function should only be called when the receiver is disabled.\r\n *\r\n *\r\n * @param base LPUART base pointer.\r\n * @param enable   Enable (1) or Disable (0) Both Edge Sampling\r\n */\r\nstatic inline void LPUART_EnableBothEdgeSamplingCmd(LPUART_Type * base)\r\n{\r\n    base->BAUD |= LPUART_BAUD_BOTHEDGE_MASK;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Configures the number of bits per character in the LPUART controller.\r\n *\r\n * This function configures the number of bits per character in the LPUART controller.\r\n * In some LPUART instances, the user should disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *\r\n * @param base LPUART base pointer.\r\n * @param bitCountPerChar  Number of bits per char (8, 9, or 10, depending on the LPUART instance)\r\n * @param parity  Specifies whether parity bit is enabled\r\n */\r\nvoid LPUART_SetBitCountPerChar(LPUART_Type * base, lpuart_bit_count_per_char_t bitCountPerChar, bool parity);\r\n\r\n/*!\r\n * @brief Configures parity mode in the LPUART controller.\r\n *\r\n * This function configures parity mode in the LPUART controller.\r\n * In some LPUART instances, the user should disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *\r\n * @param base LPUART base pointer.\r\n * @param parityModeType  Parity mode (enabled, disable, odd, even - see parity_mode_t struct)\r\n */\r\nvoid LPUART_SetParityMode(LPUART_Type * base, lpuart_parity_mode_t parityModeType);\r\n\r\n/*!\r\n * @brief Configures the number of stop bits in the LPUART controller.\r\n *\r\n * This function configures the number of stop bits in the LPUART controller.\r\n * In some LPUART instances, the user should disable the transmitter/receiver\r\n * before calling this function.\r\n * Generally, this may be applied to all LPUARTs to ensure safe operation.\r\n *\r\n * @param base LPUART base pointer.\r\n * @param stopBitCount Number of stop bits (1 or 2 - see lpuart_stop_bit_count_t struct)\r\n */\r\nstatic inline void LPUART_SetStopBitCount(LPUART_Type * base, lpuart_stop_bit_count_t stopBitCount)\r\n{\r\n    base->BAUD = (base->BAUD & ~LPUART_BAUD_SBNS_MASK) | ((uint32_t)stopBitCount << LPUART_BAUD_SBNS_SHIFT);\r\n}\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name LPUART Interrupts and DMA\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Configures the LPUART module interrupts.\r\n *\r\n * This function configures the LPUART module interrupts to enable/disable various interrupt sources.\r\n *\r\n *\r\n * @param   base LPUART module base pointer.\r\n * @param   intSrc LPUART interrupt configuration data.\r\n * @param   enable   true: enable, false: disable.\r\n */\r\nvoid LPUART_SetIntMode(LPUART_Type * base, lpuart_interrupt_t intSrc, bool enable);\r\n\r\n/*!\r\n * @brief Returns LPUART module interrupts state.\r\n *\r\n * This function returns whether a certain LPUART module interrupt is enabled or disabled.\r\n *\r\n *\r\n * @param   base LPUART module base pointer.\r\n * @param   intSrc LPUART interrupt configuration data.\r\n * @return  true: enable, false: disable.\r\n */\r\nbool LPUART_GetIntMode(const LPUART_Type * base, lpuart_interrupt_t intSrc);\r\n\r\n#if FEATURE_LPUART_HAS_DMA_ENABLE\r\n/*!\r\n * @brief Configures DMA requests.\r\n *\r\n * This function configures DMA requests for LPUART Transmitter.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param enable Transmit DMA request configuration (enable:1 /disable: 0)\r\n */\r\nstatic inline void LPUART_SetTxDmaCmd(LPUART_Type * base, bool enable)\r\n{\r\n    base->BAUD = (base->BAUD & ~LPUART_BAUD_TDMAE_MASK) | ((enable ? 1UL : 0UL) << LPUART_BAUD_TDMAE_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Configures DMA requests.\r\n *\r\n * This function configures DMA requests for LPUART Receiver.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param enable Receive DMA request configuration (enable: 1/disable: 0)\r\n */\r\nstatic inline void LPUART_SetRxDmaCmd(LPUART_Type * base, bool enable)\r\n{\r\n    base->BAUD = (base->BAUD & ~LPUART_BAUD_RDMAE_MASK) | ((enable ? 1UL : 0UL) << LPUART_BAUD_RDMAE_SHIFT);\r\n}\r\n#endif\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name LPUART Transfer Functions\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Sends the LPUART 8-bit character.\r\n *\r\n * This functions sends an 8-bit character.\r\n *\r\n *\r\n * @param base LPUART Instance\r\n * @param data     data to send (8-bit)\r\n */\r\nstatic inline void LPUART_Putchar(LPUART_Type * base, uint8_t data)\r\n{\r\n    volatile uint8_t * dataRegBytes = (volatile uint8_t *)(&(base->DATA));\r\n    dataRegBytes[0] = data;\r\n}\r\n\r\n/*!\r\n * @brief Sends the LPUART 9-bit character.\r\n *\r\n * This functions sends a 9-bit character.\r\n *\r\n *\r\n * @param base LPUART Instance\r\n * @param data     data to send (9-bit)\r\n */\r\nvoid LPUART_Putchar9(LPUART_Type * base, uint16_t data);\r\n\r\n/*!\r\n * @brief Sends the LPUART 10-bit character (Note: Feature available on select LPUART instances).\r\n *\r\n * This functions sends a 10-bit character.\r\n *\r\n *\r\n * @param base LPUART Instance\r\n * @param data   data to send (10-bit)\r\n */\r\nvoid LPUART_Putchar10(LPUART_Type * base, uint16_t data);\r\n\r\n/*!\r\n * @brief Gets the LPUART 8-bit character.\r\n *\r\n * This functions receives an 8-bit character.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param readData Data read from receive (8-bit)\r\n */\r\nstatic inline void LPUART_Getchar(const LPUART_Type * base, uint8_t *readData)\r\n{\r\n    DEV_ASSERT(readData != NULL);\r\n\r\n    *readData = (uint8_t)base->DATA;\r\n}\r\n\r\n/*!\r\n * @brief Gets the LPUART 9-bit character.\r\n *\r\n * This functions receives a 9-bit character.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param readData Data read from receive (9-bit)\r\n */\r\nvoid LPUART_Getchar9(const LPUART_Type * base, uint16_t *readData);\r\n\r\n/*!\r\n * @brief Gets the LPUART 10-bit character.\r\n *\r\n * This functions receives a 10-bit character.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param readData Data read from receive (10-bit)\r\n */\r\nvoid LPUART_Getchar10(const LPUART_Type * base, uint16_t *readData);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name LPUART Status Flags\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief  LPUART get status flag\r\n *\r\n * This function returns the state of a status flag.\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param statusFlag  The status flag to query\r\n * @return Whether the current status flag is set(true) or not(false).\r\n */\r\nbool LPUART_GetStatusFlag(const LPUART_Type * base, lpuart_status_flag_t statusFlag);\r\n\r\n/*!\r\n * @brief LPUART clears an individual status flag.\r\n *\r\n * This function clears an individual status flag (see lpuart_status_flag_t for list of status bits).\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param statusFlag  Desired LPUART status flag to clear\r\n * @return STATUS_SUCCESS if successful or STATUS_ERROR if an error occured\r\n */\r\nstatus_t LPUART_ClearStatusFlag(LPUART_Type * base, lpuart_status_flag_t statusFlag);\r\n\r\n/*@}*/\r\n\r\n/*!\r\n * @name LPUART Special Feature Configurations\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Enable or disable the LPUART error interrupts.\r\n *\r\n * This function configures the error interrupts (parity, noise, overrun, framing).\r\n *\r\n *\r\n * @param base LPUART base pointer\r\n * @param enable true - enable, false - disable error interrupts\r\n */\r\nvoid LPUART_SetErrorInterrupts(LPUART_Type * base, bool enable);\r\n\r\n/*!\r\n * @brief  Clears the error flags treated by the driver\r\n *\r\n * This function clears the error flags treated by the driver.\r\n * *\r\n * @param base LPUART base pointer\r\n */\r\nstatic inline void LPUART_DRV_ClearErrorFlags(LPUART_Type * base)\r\n{\r\n    uint32_t mask = LPUART_STAT_OR_MASK | \\\r\n                    LPUART_STAT_NF_MASK | \\\r\n                    LPUART_STAT_FE_MASK | \\\r\n                    LPUART_STAT_PF_MASK;\r\n\r\n    base->STAT = (base->STAT & (~FEATURE_LPUART_STAT_REG_FLAGS_MASK)) | mask;\r\n}\r\n\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n#endif /* LPUART_HW_ACCESS_H__ */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpuart_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file lpuart_irq.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, Function not defined with external linkage.\r\n * The functions are not defined static because they are referenced in .s startup files.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, Could define variable at block scope\r\n * The variable is used in driver c file, so it must remain global.\r\n */\r\n\r\n#include \"lpuart_irq.h\"\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n/* Implementation of LPUART0 handler named in startup code. */\r\nvoid LPUART0_IrqHandler(void)\r\n{\r\n    LPUART_DRV_IRQHandler(0);\r\n}\r\n#endif\r\n\r\n#if (LPUART_INSTANCE_COUNT > 1U)\r\n/* Implementation of LPUART1 handler named in startup code. */\r\nvoid LPUART1_IrqHandler(void)\r\n{\r\n    LPUART_DRV_IRQHandler(1);\r\n}\r\n#endif\r\n\r\n#if (LPUART_INSTANCE_COUNT > 2U)\r\n/* Implementation of LPUART2 handler named in startup code. */\r\nvoid LPUART2_IrqHandler(void)\r\n{\r\n    LPUART_DRV_IRQHandler(2);\r\n}\r\n#endif\r\n\r\n#if (LPUART_INSTANCE_COUNT > 3U)\r\n/* Implementation of LPUART3 handler named in startup code. */\r\nvoid LPUART3_IrqHandler(void)\r\n{\r\n    LPUART_DRV_IRQHandler(3);\r\n}\r\n#endif\r\n\r\n/* Array storing references to LPUART irq handlers */\r\nisr_t g_lpuartIsr[LPUART_INSTANCE_COUNT] =\r\n{\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n    LPUART0_IrqHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 1U)\r\n    LPUART1_IrqHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 2U)\r\n    LPUART2_IrqHandler,\r\n#endif\r\n#if (LPUART_INSTANCE_COUNT > 3U)\r\n    LPUART3_IrqHandler,\r\n#endif\r\n};\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"lpuart_irq.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef LPUART_IRQ_H__\r\n#define LPUART_IRQ_H__\r\n\r\n#include \"device_registers.h\"\r\n#include \"interrupt_manager.h\"\r\n\r\n/*******************************************************************************\r\n * Prototypes\r\n ******************************************************************************/\r\nvoid LPUART_DRV_IRQHandler(uint32_t instance);\r\n\r\n/*******************************************************************************\r\n *  Default interrupt handlers signatures\r\n ******************************************************************************/\r\n\r\n#if (LPUART_INSTANCE_COUNT > 0U)\r\n/*! @brief LPUART0 interrupt handler. */\r\nvoid LPUART0_IrqHandler(void);\r\n#endif\r\n\r\n#if (LPUART_INSTANCE_COUNT > 1U)\r\n/*! @brief LPUART1 interrupt handler. */\r\nvoid LPUART1_IrqHandler(void);\r\n#endif\r\n\r\n#if (LPUART_INSTANCE_COUNT > 2U)\r\n/*! @brief LPUART2 interrupt handler. */\r\nvoid LPUART2_IrqHandler(void);\r\n#endif\r\n\r\n#if (LPUART_INSTANCE_COUNT > 3U)\r\n/*! @brief LPUART3 interrupt handler. */\r\nvoid LPUART3_IrqHandler(void);\r\n#endif\r\n\r\n/*! Array storing references to LPUART irq handlers */\r\nextern isr_t g_lpuartIsr[LPUART_INSTANCE_COUNT];\r\n\r\n#endif /* LPUART_IRQ_H__ */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"mbd_adc_irq.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright (c) 2017, NXP.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of Freescale Semiconductor, Inc. nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#include \"mbd_adc_irq.h\"\r\n\r\n/******************************************************************************\r\n * Variables\r\n *****************************************************************************/\r\n\r\nstatic adc_callback_type adcCallbackTable[ADC_INSTANCE_COUNT][ADC_SC1_COUNT] = { 0 };\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\nvoid ADC_CommonIRQHandler(uint32_t instance)\r\n{\r\n    uint32_t chnGroup;\r\n    volatile bool fDummy = 0;\r\n    ADC_Type * const pADC[] = ADC_BASE_PTRS;\r\n    ADC_Type * base = pADC[instance];\r\n\r\n    for (chnGroup = 0U; chnGroup < ADC_SC1_COUNT; chnGroup++)\r\n    {\r\n        if (ADC_DRV_GetConvCompleteFlag(instance, chnGroup))\r\n        {\r\n            if (adcCallbackTable[instance][chnGroup] != 0)\r\n            {\r\n                (*adcCallbackTable[instance][chnGroup])();\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Workaround for unexpected extra interrupt: because write buffer in\r\n       the peripheral bridge is enabled, it makes it possible for an\r\n       exception handler to clear a peripheral interrupt by writing to the\r\n       peripherals, exit the handler, and then enter the interrupt again\r\n       as the peripheral cannot de-assert the interrupt request fast enough.\r\n\r\n       Adding memory barrier instruction (e.g. DSB) doesn't always help\r\n       because the buffer is outside the processor. But it might introduce\r\n       just enough delay to allow the interrupt to be cleared.\r\n\r\n       Adding dummy read access to the peripheral to make sure clearing\r\n       interrupt flag completed before go out ISR */\r\n    fDummy = ADC_DRV_GetConvCompleteFlag(instance, chnGroup);\r\n    /* Suppress warning message */\r\n    fDummy = fDummy;\r\n}\r\n\r\n/* Install the user-defined callback in ADC0 interrupt. */\r\nvoid ADC_InstallCallback(uint32_t instance, uint32_t chnGroup, adc_callback_type pCallback)\r\n{\r\n    adcCallbackTable[instance][chnGroup] = pCallback;\r\n}\r\n\r\n/* ISRs */\r\nvoid ADC0_IRQHandler(void)\r\n{\r\n    ADC_CommonIRQHandler(0);\r\n}\r\n\r\nvoid ADC1_IRQHandler(void)\r\n{\r\n    ADC_CommonIRQHandler(1);\r\n}\r\n\r\n/******************************************************************************\r\n * EOF\r\n *****************************************************************************/"},{"name":"mbd_adc_irq.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright (c) 2017, NXP.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of Freescale Semiconductor, Inc. nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n#ifndef __MBD_ADC_IRQ_H__\r\n#define __MBD_ADC_IRQ_H__\r\n\r\n#include <stdint.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include \"adc_driver.h\"\r\n\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\ntypedef void (*adc_callback_type)(void);\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n/* Install the user-defined callback in ADC0 interrupt. */\r\nvoid ADC_InstallCallback(uint32_t instance, uint32_t chnGroup, adc_callback_type pCallback);\r\n\r\n#endif\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"mbd_main.c","type":"source","group":"","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mbd_main.c\r\n *\r\n * Code generated for Simulink model 'Final_project_template'.\r\n *\r\n * Model version                   : 10.22\r\n * Simulink Coder version          : 9.8 (R2022b) 13-May-2022\r\n * MBDT for S32K1xx Series Version : 4.3.0 (R2016a-R2022a) 13-Sep-2022\r\n * C/C++ source code generated on  : Thu Apr 11 13:55:15 2024\r\n *\r\n * Target selection: mbd_s32k.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Traceability\r\n * Validation result: Not run\r\n */\r\n\r\n/* Model's headers */\r\n#include \"device_registers.h\"\r\n#include \"Final_project_template.h\"\r\n#include \"interrupt_manager.h\"\r\n#include \"clock_manager.h\"\r\n#include \"lpit_driver.h\"\r\n#include \"lpit_hw_access.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"s32k_clock_init.h\"\r\n\r\nvoid SYSTEM_INIT_TASK(void)\r\n{\r\n  /* Initialize model */\r\n  Final_project_template_initialize();\r\n}\r\n\r\nvoid SYSTEM_TASK(void)\r\n{\r\n  boolean_T eventFlags[3];             /* Model has 3 rates */\r\n  int_T i;\r\n\r\n  /*\r\n   * For a bare-board target (i.e., no operating system), the rates\r\n   * that execute this base step are buffered locally to allow for\r\n   * overlapping preemption.\r\n   */\r\n  Final_project_template_SetEventsForThisBaseStep(eventFlags);\r\n\r\n  /* Set model inputs associated with base rate here */\r\n  Final_project_template_step(0);\r\n\r\n  /* Get model outputs here */\r\n  for (i = 1; i < 3; i++) {\r\n    if (eventFlags[i]) {\r\n      Final_project_template_step(i);\r\n\r\n      /* Get model outputs here */\r\n    }\r\n  }\r\n}\r\n\r\nvoid LPIT0_Ch0_IRQHandler (void)\r\n{\r\n  SYSTEM_TASK();\r\n  LPIT_DRV_ClearInterruptFlagTimerChannels(0, (1 << 0));\r\n}\r\n\r\nvoid lpit0_init_step_timer()\r\n{\r\n  static const lpit_user_channel_config_t lpit0InitStruct = {\r\n    .timerMode = LPIT_PERIODIC_COUNTER,\r\n    .periodUnits = LPIT_PERIOD_UNITS_MICROSECONDS,\r\n    .period = 500,\r\n    .triggerSource = LPIT_TRIGGER_SOURCE_INTERNAL,\r\n    .triggerSelect = 1U,\r\n    .enableReloadOnTrigger = false,\r\n    .enableStopOnInterrupt = false,\r\n    .enableStartOnTrigger = false,\r\n    .chainChannel = false,\r\n    .isInterruptEnabled = true\r\n  };\r\n\r\n  /* Initialize PIT timer channel. */\r\n  LPIT_DRV_InitChannel(0, 0, &lpit0InitStruct);\r\n\r\n  /* Set priority for LPIT ISR */\r\n  INT_SYS_SetPriority(LPIT0_Ch0_IRQn, 15);\r\n  INT_SYS_InstallHandler(LPIT0_Ch0_IRQn, LPIT0_Ch0_IRQHandler, (isr_t *)0);\r\n\r\n  /* Start the timer. */\r\n  LPIT_DRV_StartTimerChannels(0, LPIT0->SETTEN | (1 << 0));\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\r\n#ifdef __FPU_USED\r\n\r\n  /* FPU ENABLE */\r\n  /* Enable CP10 and CP11 coprocessors */\r\n  S32_SCB->CPACR |= (S32_SCB_CPACR_CP10_MASK | S32_SCB_CPACR_CP11_MASK);\r\n\r\n#endif\r\n\r\n  /* Disable all interrupts.*/\r\n  INT_SYS_DisableIRQGlobal();\r\n\r\n  /* Clock initialization */\r\n  Clock_Setup();\r\n\r\n  /* Initialize system timer clock */\r\n  lpit0_clock_init();\r\n\r\n  /* Initialize the processor. */\r\n  SYSTEM_INIT_TASK();\r\n\r\n  /* Enable all interrupts.*/\r\n  INT_SYS_EnableIRQGlobal();           /* interrupt_manager.c */\r\n\r\n  /* Initialize step timer interrupt. */\r\n  lpit0_init_step_timer();\r\n  while (1) {\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"osif.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef OSIF_H\r\n#define OSIF_H\r\n\r\n#include <stdint.h>\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * The macro defines a value that will be interpreted as an infinite timeout.\r\n *\r\n */\r\n\r\n/*! @file */\r\n\r\n/*!\r\n * @addtogroup osif\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*! @cond DRIVER_INTERNAL_USE_ONLY */\r\n\r\n#ifdef USING_OS_FREERTOS\r\n/* FreeRTOS implementation */\r\n#include \"FreeRTOS.h\"\r\n#include \"semphr.h\"\r\n\r\n#if configSUPPORT_STATIC_ALLOCATION == 1\r\n    typedef struct {\r\n        SemaphoreHandle_t handle;\r\n        StaticSemaphore_t buffer;\r\n    } semaphore_t;\r\n\r\n    typedef semaphore_t mutex_t;\r\n#else /* configSUPPORT_STATIC_ALLOCATION == 0, it's dynamic allocation */\r\n    /*! @brief Type for a mutex. */\r\n    typedef SemaphoreHandle_t mutex_t;\r\n    /*! @brief Type for a semaphore. */\r\n    typedef SemaphoreHandle_t semaphore_t;\r\n#endif /* configSUPPORT_STATIC_ALLOCATION == 1 */\r\n#else\r\n/* Bare-metal implementation */\r\n/*! @brief Type for a mutex. */\r\ntypedef uint8_t mutex_t;\r\n/*! @brief Type for a semaphore. */\r\ntypedef volatile uint8_t semaphore_t;\r\n#endif /* ifdef USING_OS_FREERTOS */\r\n\r\n/*! @endcond */\r\n\r\n#define OSIF_WAIT_FOREVER 0xFFFFFFFFu\r\n\r\n#include \"status.h\"\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined (__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Delays execution for a number of milliseconds.\r\n *\r\n * @param[in] delay Time delay in milliseconds.\r\n */\r\nvoid OSIF_TimeDelay(const uint32_t delay);\r\n\r\n/*!\r\n * @brief Returns the number of miliseconds elapsed since starting the internal timer\r\n * or starting the scheduler.\r\n *\r\n * @return the number of miliseconds elapsed\r\n */\r\nuint32_t OSIF_GetMilliseconds(void);\r\n\r\n/*!\r\n * @brief Waits for a mutex and locks it.\r\n *\r\n * @param[in] pMutex reference to the mutex object\r\n * @param[in] timeout time-out value in milliseconds\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: mutex lock operation success\r\n * - STATUS_ERROR: mutex already owned by current thread\r\n * - STATUS_TIMEOUT: mutex lock operation timed out\r\n *\r\n */\r\nstatus_t OSIF_MutexLock(const mutex_t * const pMutex,\r\n                        const uint32_t timeout);\r\n\r\n/*!\r\n * @brief Unlocks a previously locked mutex.\r\n *\r\n * @param[in] pMutex reference to the mutex object\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: mutex unlock operation success\r\n * - STATUS_ERROR: mutex unlock failed\r\n */\r\nstatus_t OSIF_MutexUnlock(const mutex_t * const pMutex);\r\n\r\n\r\n/*!\r\n * @brief Create an unlocked mutex.\r\n *\r\n * @param[in] pMutex reference to the mutex object\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: mutex created\r\n * - STATUS_ERROR: mutex could not be created\r\n */\r\nstatus_t OSIF_MutexCreate(mutex_t * const pMutex);\r\n\r\n/*!\r\n * @brief Destroys a previously created mutex.\r\n *\r\n * @param[in] pMutex reference to the mutex object\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: mutex destroyed\r\n */\r\nstatus_t OSIF_MutexDestroy(const mutex_t * const pMutex);\r\n\r\n\r\n/*!\r\n * @brief Decrement a semaphore with timeout.\r\n *\r\n * @param[in] pSem reference to the semaphore object\r\n * @param[in] timeout time-out value in milliseconds\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: semaphore wait operation success\r\n * - STATUS_TIMEOUT: semaphore wait timed out\r\n */\r\nstatus_t OSIF_SemaWait(semaphore_t * const pSem,\r\n                       const uint32_t timeout);\r\n\r\n\r\n/*!\r\n * @brief Increment a semaphore\r\n *\r\n * @param[in] pSem reference to the semaphore object\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: semaphore post operation success\r\n * - STATUS_ERROR: semaphore could not be incremented\r\n */\r\nstatus_t OSIF_SemaPost(semaphore_t * const pSem);\r\n\r\n\r\n/*!\r\n * @brief Creates a semaphore with a given value.\r\n *\r\n * @param[in] pSem reference to the semaphore object\r\n * @param[in] initValue initial value of the semaphore\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: semaphore created\r\n * - STATUS_ERROR: semaphore could not be created\r\n */\r\nstatus_t OSIF_SemaCreate(semaphore_t * const pSem,\r\n                         const uint8_t initValue);\r\n\r\n\r\n/*!\r\n * @brief Destroys a previously created semaphore.\r\n *\r\n * @param[in] pSem reference to the semaphore object\r\n * @return  One of the possible status codes:\r\n * - STATUS_SUCCESS: semaphore destroyed\r\n */\r\nstatus_t OSIF_SemaDestroy(const semaphore_t * const pSem);\r\n\r\n/*! @}*/\r\n#if defined (__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* OSIF_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"osif_baremetal.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/*!\r\n * @file osif_baremetal.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, Taking address of near auto variable.\r\n * The code is not dynamically linked. An absolute stack address is obtained\r\n * when taking the address of the near auto variable. A source of error in\r\n * writing dynamic code is that the stack segment may be different from the data\r\n * segment.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Directive 4.9, Function-like macro defined.\r\n * The macros are used to validate input parameters to driver functions.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define, representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * This is required for initializing pointers to the module's memory map, which is located at a\r\n * fixed address.\r\n *\r\n */\r\n\r\n#include \"osif.h\"\r\n#include <stddef.h>\r\n\r\n#include \"device_registers.h\"\r\n\r\n#include \"devassert.h\"\r\n\r\n#if defined (USING_OS_FREERTOS)\r\n#error \"Wrong OSIF selected. Please define symbol USING_OS_BAREMETAL (or no OS define) in project settings or change the OSIF variant\"\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * Private Functions\r\n ******************************************************************************/\r\n\r\n/*! @cond DRIVER_INTERNAL_USE_ONLY */\r\n\r\n/*! @brief Converts milliseconds to ticks - in this case, one tick = one millisecond */\r\n#define MSEC_TO_TICK(msec) (msec)\r\n\r\n#if (FEATURE_OSIF_USE_SYSTICK != 0) || (FEATURE_OSIF_USE_PIT != 0)\r\n/* Only include headers for configurations that need them. */\r\n#include \"interrupt_manager.h\"\r\n#include \"clock_manager.h\"\r\n\r\nstatic volatile uint32_t s_osif_tick_cnt = 0u;\r\n\r\nstatic inline void osif_Tick(void)\r\n{\r\n    s_osif_tick_cnt++;\r\n}\r\n\r\nstatic inline uint32_t osif_GetCurrentTickCount(void)\r\n{\r\n    return s_osif_tick_cnt;\r\n}\r\n\r\n#endif /* (FEATURE_OSIF_USE_SYSTICK != 0) || (FEATURE_OSIF_USE_PIT != 0) */\r\n\r\n#if FEATURE_OSIF_USE_SYSTICK\r\n\r\nvoid SysTick_Handler(void);\r\n\r\nvoid SysTick_Handler(void)\r\n{\r\n    osif_Tick();\r\n}\r\n\r\nstatic inline void osif_UpdateTickConfig(void)\r\n{\r\n    uint32_t core_freq = 0u;\r\n    static bool first_init = true;\r\n    /* Get the correct name of the core clock */\r\n    clock_names_t coreclk = CORE_CLK;\r\n    status_t clk_status = CLOCK_SYS_GetFreq(coreclk, &core_freq);\r\n    DEV_ASSERT(clk_status == STATUS_SUCCESS);\r\n    DEV_ASSERT(core_freq > 0u);\r\n    (void)clk_status;\r\n\r\n    /* For Cortex-M0 devices the systick counter is initialized with an undefined\r\n     value, so make sure to initialize it to 0 before starting */\r\n    S32_SysTick->CSR = S32_SysTick_CSR_ENABLE(0u);\r\n    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(core_freq / 1000u);\r\n    if (first_init)\r\n    {\r\n        /* only initialize CVR on the first entry, to not cause time drift */\r\n        S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);\r\n        first_init = false;\r\n    }\r\n    S32_SysTick->CSR = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(1u) | S32_SysTick_CSR_CLKSOURCE(1u);\r\n}\r\n\r\nstatic inline void osif_DisableIrqGlobal(void)\r\n{\r\n    INT_SYS_DisableIRQGlobal();\r\n}\r\n\r\nstatic inline void osif_EnableIrqGlobal(void)\r\n{\r\n    INT_SYS_EnableIRQGlobal();\r\n}\r\n\r\n#elif FEATURE_OSIF_USE_PIT\r\n\r\nvoid OSIF_PIT_IRQHandler(void);\r\n\r\nvoid OSIF_PIT_IRQHandler(void)\r\n{\r\n    OSIF_PIT->TIMER[OSIF_PIT_CHAN_ID].TFLG = PIT_TFLG_TIF(1u);\r\n\r\n    osif_Tick();\r\n}\r\n\r\nstatic inline void osif_UpdateTickConfig(void)\r\n{\r\n    uint32_t tick_freq = 0u;\r\n    PIT_Type * base = OSIF_PIT;\r\n\r\n    /* get the clock frequency for the timer and compute ticks for 1 ms */\r\n    status_t clk_status = CLOCK_SYS_GetFreq(PITRTI0_CLK, &tick_freq);\r\n    DEV_ASSERT(clk_status == STATUS_SUCCESS);\r\n    DEV_ASSERT(tick_freq > 0u);\r\n    (void)clk_status;\r\n    uint32_t tick_1ms = tick_freq / 1000u;\r\n\r\n    /* setup timer and enable interrupt */\r\n    base->MCR &= ~PIT_MCR_MDIS(1u); /* make sure module is started */\r\n    base->MCR |= PIT_MCR_FRZ(1u); /* stop in Debug */\r\n    base->TIMER[OSIF_PIT_CHAN_ID].LDVAL = tick_1ms;\r\n    base->TIMER[OSIF_PIT_CHAN_ID].TCTRL |= PIT_TCTRL_TEN(1u) | PIT_TCTRL_TIE(1u);\r\n    static const IRQn_Type pitIrqId[PIT_INSTANCE_COUNT][PIT_IRQS_CH_COUNT] = PIT_IRQS;\r\n\r\n    INT_SYS_InstallHandler(pitIrqId[0U][OSIF_PIT_CHAN_ID], OSIF_PIT_IRQHandler, NULL);\r\n    INT_SYS_EnableIRQ(pitIrqId[0U][OSIF_PIT_CHAN_ID]);\r\n}\r\n\r\nstatic inline void osif_DisableIrqGlobal(void)\r\n{\r\n    INT_SYS_DisableIRQGlobal();\r\n}\r\n\r\nstatic inline void osif_EnableIrqGlobal(void)\r\n{\r\n    INT_SYS_EnableIRQGlobal();\r\n}\r\n\r\n#else /* FEATURE_OSIF_USE_SYSTICK == 0, FEATURE_OSIF_USE_PIT == 0 */\r\n\r\nstatic inline uint32_t osif_GetCurrentTickCount(void)\r\n{\r\n    return 0u;\r\n}\r\n\r\nstatic inline void osif_UpdateTickConfig(void)\r\n{\r\n    /* do not update tick */\r\n}\r\n\r\n#define osif_DisableIrqGlobal() (void)0;\r\n\r\n#define osif_EnableIrqGlobal() (void)0;\r\n\r\n#endif /* FEATURE_OSIF_USE_SYSTICK */\r\n\r\n/*! @endcond */\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_TimeDelay\r\n * Description   : This function blocks execution for a number of milliseconds.\r\n *\r\n * Implements : OSIF_TimeDelay_baremetal_Activity\r\n *END**************************************************************************/\r\nvoid OSIF_TimeDelay(const uint32_t delay)\r\n{\r\n    osif_UpdateTickConfig();\r\n    uint32_t start = osif_GetCurrentTickCount();\r\n    uint32_t crt_ticks = osif_GetCurrentTickCount();\r\n    uint32_t delta = crt_ticks - start;\r\n    uint32_t delay_ticks = MSEC_TO_TICK(delay);\r\n    while (delta < delay_ticks)\r\n    {\r\n        crt_ticks = osif_GetCurrentTickCount();\r\n        delta = crt_ticks - start;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_GetMilliseconds\r\n * Description   : This function returns the number of miliseconds elapsed since\r\n *                  starting the internal timer. To initialize the internal timer\r\n *                  (Systick) in bare-metal, call either OSIF_TimeDelay or\r\n *                  OSIF_SemaWait functions. Calling OSIF_TimeDelay(0) will initialize\r\n *                  the timer without any side-effects (no delay).\r\n *\r\n * Implements : OSIF_GetMilliseconds_baremetal_Activity\r\n *END**************************************************************************/\r\nuint32_t OSIF_GetMilliseconds(void)\r\n{\r\n    /*\r\n     * Please make sure the timer is initialized before calling this function.\r\n     * For example, calling OSIF_TimeDelay(0) ensures that the timer is initialized\r\n     * without any other side-effects. If OSIF_TimeDelay or OSIF_SemaWait functions\r\n     * have been called, the timer is already initialized.\r\n     */\r\n    return osif_GetCurrentTickCount(); /* This assumes that 1 tick = 1 millisecond */\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_MutexLock\r\n * Description   : This function locks a mutex (mock operation in baremetal case).\r\n *\r\n * Implements : OSIF_MutexLock_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_MutexLock(const mutex_t * const pMutex,\r\n                        const uint32_t timeout)\r\n{\r\n    (void)pMutex;\r\n    (void)timeout;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_MutexUnlock\r\n * Description   : This function unlocks a mutex (mock operation in baremetal case).\r\n *\r\n * Implements : OSIF_MutexUnlock_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_MutexUnlock(const mutex_t * const pMutex)\r\n{\r\n    (void)pMutex;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_MutexCreate\r\n * Description   : This function creates a mutex (mock operation in baremetal case).\r\n *\r\n * Implements : OSIF_MutexCreate_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_MutexCreate(mutex_t * const pMutex)\r\n{\r\n    (void)pMutex;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_MutexDestroy\r\n * Description   : This function destroys a mutex (mock operation in baremetal case).\r\n *\r\n * Implements : OSIF_MutexDestroy_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_MutexDestroy(const mutex_t * const pMutex)\r\n{\r\n    (void)pMutex;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_SemaWait\r\n * Description   : This function performs the 'wait' (decrement) operation on a semaphore.\r\n *      When timeout value is 0, it's the equivalent of TryWait - try to decrement but return\r\n *      immediately if it fails (counter is 0).\r\n *\r\n * Implements : OSIF_SemaWait_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_SemaWait(semaphore_t * const pSem,\r\n                       const uint32_t timeout)\r\n{\r\n    DEV_ASSERT(pSem != NULL);\r\n\r\n    status_t osif_ret_code = STATUS_SUCCESS;\r\n\r\n    osif_UpdateTickConfig();\r\n    if ((timeout == 0u))\r\n    {\r\n        /* when the timeout is 0 the wait operation is the equivalent of try_wait,\r\n            meaning that if the semaphore is 0 return immediately with an error code\r\n        */\r\n        if (*pSem == 0u)\r\n        {\r\n            osif_ret_code = STATUS_TIMEOUT;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* timeout is not 0 */\r\n        uint32_t timeoutTicks;\r\n        if (timeout == OSIF_WAIT_FOREVER)\r\n        {\r\n            timeoutTicks = OSIF_WAIT_FOREVER;\r\n        }\r\n        else\r\n        {\r\n            /* Convert timeout from milliseconds to ticks. */\r\n            timeoutTicks = MSEC_TO_TICK(timeout);\r\n        }\r\n        uint32_t start = osif_GetCurrentTickCount();\r\n        uint32_t end = (uint32_t)(start + timeoutTicks);\r\n        uint32_t max = end - start;\r\n        while (*pSem == 0u)\r\n        {\r\n            uint32_t crt_ticks = osif_GetCurrentTickCount();\r\n            uint32_t delta = crt_ticks - start;\r\n            if ((timeoutTicks != OSIF_WAIT_FOREVER) && (delta > max))\r\n            {\r\n                /* Timeout occured, stop waiting and return fail code */\r\n                osif_ret_code = STATUS_TIMEOUT;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (osif_ret_code == STATUS_SUCCESS)\r\n    {\r\n        osif_DisableIrqGlobal();\r\n        --(*pSem);\r\n        osif_EnableIrqGlobal();\r\n    }\r\n\r\n    return osif_ret_code;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_SemaPost\r\n * Description   : This function performs the 'post' (increment) operation on a semaphore.\r\n *\r\n * Implements : OSIF_SemaPost_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_SemaPost(semaphore_t * const pSem)\r\n{\r\n    DEV_ASSERT(pSem != NULL);\r\n\r\n    status_t osif_ret_code = STATUS_SUCCESS;\r\n    osif_DisableIrqGlobal();\r\n    if (*pSem != 255u)\r\n    {\r\n        ++(*pSem);\r\n    }\r\n    else\r\n    {\r\n        osif_ret_code = STATUS_ERROR;\r\n    }\r\n\r\n    osif_EnableIrqGlobal();\r\n\r\n    return osif_ret_code;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_SemaCreate\r\n * Description   : This function creates (initializes) a semaphore.\r\n *\r\n * Implements : OSIF_SemaCreate_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_SemaCreate(semaphore_t * const pSem,\r\n                         const uint8_t initValue)\r\n{\r\n    DEV_ASSERT(pSem != NULL);\r\n    osif_DisableIrqGlobal();\r\n    *pSem = initValue;\r\n    osif_EnableIrqGlobal();\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : OSIF_SemaDestroy\r\n * Description   : This function destroys a semaphore object (mock operation in baremetal case).\r\n *\r\n * Implements : OSIF_SemaDestroy_baremetal_Activity\r\n *END**************************************************************************/\r\nstatus_t OSIF_SemaDestroy(const semaphore_t * const pSem)\r\n{\r\n    DEV_ASSERT(pSem != NULL);\r\n\r\n    (void)pSem;\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"path_data.c","type":"source","group":"legacy","path":"N:\\project","tag":"","groupDisplay":"Other files","code":"/* path_data.c - generated by write_path_data1_h.m */\r\n\r\n#include \"path_data.h\"\r\n\r\nstruct road_seg_type rs[MAX_RS] = {\r\n\t{ STRAIGHT, 0.000000000000e+000 , { 1.000000000000e+002, -2.000000000000e+001, 0.000000000000e+000, 8.000000000000e+001, 0.000000000000e+000, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.000000000000e+002 , { 4.000000000000e+001, 8.000000000000e+001, 4.000000000000e+001, -1.570796326795e+000, 0.000000000000e+000, 1 }},\r\n\t{ STRAIGHT, 1.628318530718e+002 , { 8.000000000000e+001, 1.200000000000e+002, 4.000000000000e+001, 1.200000000000e+002, 1.200000000000e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 2.428318530718e+002 , { 4.000000000000e+001, 1.600000000000e+002, 1.200000000000e+002, 3.141592653590e+000, 2.617993877991e+000, -1 }},\r\n\t{ STRAIGHT, 2.637758040957e+002 , { 7.000000000000e+001, 1.253589838486e+002, 1.400000000000e+002, 1.603589838486e+002, 2.006217782649e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 3.337758040957e+002 , { 4.000000000000e+001, 1.257179676972e+002, 2.206217782649e+002, -5.235987755983e-001, 5.235987755983e-001, 1 }},\r\n\t{ STRAIGHT, 3.756637061436e+002 , { 1.200000000000e+002, 1.603589838486e+002, 2.406217782649e+002, 1.003589838486e+002, 3.445448267190e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 4.956637061436e+002 , { 4.000000000000e+001, 1.350000000000e+002, 3.645448267190e+002, 3.665191429188e+000, 2.094395102393e+000, -1 }},\r\n\t{ STRAIGHT, 5.584955592154e+002 , { 1.000000000000e+002, 1.150000000000e+002, 3.991858428704e+002, 2.016025403784e+002, 4.491858428704e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 6.584955592154e+002 , { 4.000000000000e+001, 1.816025403784e+002, 4.838268590218e+002, -1.047197551197e+000, -1.745329251994e-001, 1 }},\r\n\t{ STRAIGHT, 6.934021442553e+002 , { 1.100000000000e+002, 2.209948504989e+002, 4.768809319151e+002, 2.400961500423e+002, 5.852097847465e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 8.034021442553e+002 , { 4.000000000000e+001, 2.007038399218e+002, 5.921557118531e+002, -1.745329251994e-001, 1.570796326795e+000, 1 }},\r\n\t{ STRAIGHT, 8.732153143350e+002 , { 6.000000000000e+001, 2.007038399218e+002, 6.321557118531e+002, 1.407038399218e+002, 6.321557118531e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 9.332153143350e+002 , { 4.000000000000e+001, 1.407038399218e+002, 6.721557118531e+002, 4.712388980385e+000, 3.141592653590e+000, -1 }},\r\n\t{ STRAIGHT, 9.960471674068e+002 , { 8.000000000000e+001, 1.007038399218e+002, 6.721557118531e+002, 1.007038399218e+002, 7.521557118531e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.076047167407e+003 , { 4.000000000000e+001, 1.407038399218e+002, 7.521557118531e+002, 3.141592653590e+000, 1.570796326795e+000, -1 }},\r\n\t{ STRAIGHT, 1.138879020479e+003 , { 1.000000000000e+002, 1.407038399218e+002, 7.921557118531e+002, 2.407038399218e+002, 7.921557118531e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.238879020479e+003 , { 4.000000000000e+001, 2.407038399218e+002, 8.321557118531e+002, -1.570796326795e+000, 0.000000000000e+000, 1 }},\r\n\t{ STRAIGHT, 1.301710873550e+003 , { 8.000000000000e+001, 2.807038399218e+002, 8.321557118531e+002, 2.807038399218e+002, 9.121557118531e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.381710873550e+003 , { 4.000000000000e+001, 3.207038399218e+002, 9.121557118531e+002, 3.141592653590e+000, 2.617993877991e+000, -1 }},\r\n\t{ STRAIGHT, 1.402654824574e+003 , { 7.000000000000e+001, 2.860628237704e+002, 9.321557118531e+002, 3.210628237704e+002, 9.927774901181e+002, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.472654824574e+003 , { 4.000000000000e+001, 2.864218076191e+002, 1.012777490118e+003, -5.235987755983e-001, 5.235987755983e-001, 1 }},\r\n\t{ STRAIGHT, 1.514542726622e+003 , { 1.200000000000e+002, 3.210628237704e+002, 1.032777490118e+003, 2.610628237704e+002, 1.136700538572e+003, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.634542726622e+003 , { 4.000000000000e+001, 2.957038399218e+002, 1.156700538572e+003, 3.665191429188e+000, 2.094395102393e+000, -1 }},\r\n\t{ STRAIGHT, 1.697374579694e+003 , { 1.000000000000e+002, 2.757038399218e+002, 1.191341554724e+003, 3.623063803003e+002, 1.241341554724e+003, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.797374579694e+003 , { 4.000000000000e+001, 3.423063803003e+002, 1.275982570875e+003, -1.047197551197e+000, -1.745329251994e-001, 1 }},\r\n\t{ STRAIGHT, 1.832281164734e+003 , { 1.100000000000e+002, 3.816986904207e+002, 1.269036643768e+003, 4.007999899641e+002, 1.377365496600e+003, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 1.942281164734e+003 , { 4.000000000000e+001, 3.614076798436e+002, 1.384311423706e+003, -1.745329251994e-001, 1.570796326795e+000, 1 }},\r\n\t{ STRAIGHT, 2.012094334814e+003 , { 6.000000000000e+001, 3.614076798436e+002, 1.424311423706e+003, 3.014076798436e+002, 1.424311423706e+003, 0 /*space*/ }},\r\n\t{ CONST_CURVE, 2.072094334814e+003 , { 4.000000000000e+001, 3.014076798436e+002, 1.464311423706e+003, 4.712388980385e+000, 3.141592653590e+000, -1 }},\r\n\t{ STRAIGHT, 2.134926187885e+003 , { 8.000000000000e+001, 2.614076798436e+002, 1.464311423706e+003, 2.614076798436e+002, 1.544311423706e+003, 0 /*space*/ }}\r\n};\r\n\r\n  "},{"name":"pcc_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\clock\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef PCC_HW_ACCESS_H\r\n#define PCC_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n\r\n/*!\r\n * @file pcc_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to implement enumeration entries as macro.\r\n * Enumeration entries (macros) are referenced from application code.\r\n */\r\n\r\n/*!\r\n * @ingroup pcc_hw_access\r\n * @defgroup pcc_hw_access\r\n * @{\r\n */\r\n\r\n\r\n/*! @brief Clock name mappings\r\n *         Constant array storing the mappings between clock names and peripheral clock control indexes.\r\n *         If there is no peripheral clock control index for a clock name, then the corresponding value is\r\n *         PCC_INVALID_INDEX.\r\n */\r\nextern const uint16_t clockNameMappings[CLOCK_NAME_COUNT];\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*!\r\n* @brief Sets SOSC control register\r\n*\r\n* @param[in] base        pcc base pointer\r\n* @param[in] monitorMode clock monitor enablement\r\n* @param[in] clockGate    control register can be written or not\r\n*/\r\nstatic inline void PCC_SetPeripheralClockControl(PCC_Type* base, clock_names_t clockName, bool clockGate, uint32_t clockSource, uint32_t divider, uint32_t multiplier)\r\n{\r\n   /* Configure the peripheral clock source, the fractional clock divider and the clock gate */\r\n   uint32_t value =  PCC_PCCn_PCS(clockSource)              |\r\n                     PCC_PCCn_FRAC(multiplier)              |\r\n                     PCC_PCCn_PCD(divider)                  |\r\n                     PCC_PCCn_CGC(clockGate ? 1UL : 0UL );\r\n\r\n   base->PCCn[clockNameMappings[clockName]] = value;\r\n}\r\n\r\n/*!\r\n* @brief Enables/disables the clock for a given peripheral.\r\n* For example, to enable the ADC0 clock, use like this:\r\n* @code\r\n*  PCC_SetClockMode(PCC, PCC_ADC0_CLOCK, true);\r\n* @endcode\r\n*\r\n* @param[in] base        pcc base pointer\r\n* @param[in] clockName   is the name of the peripheral clock\r\n* must be one of the following values (see the clock_names_t type from S32K144_clock_names.h)\r\n*    PCC_DMA0_CLOCK\r\n*    PCC_MPU0_CLOCK\r\n*    ...\r\n*    PCC_LPUART3_CLOCK\r\n* @param[in] isClockEnabled  is the value of the command that enables/disables the clock\r\n*/\r\nstatic inline void PCC_SetClockMode(PCC_Type* const base,\r\n                                       const clock_names_t clockName,\r\n                                       const bool isClockEnabled)\r\n{\r\n   if (isClockEnabled)\r\n   {\r\n       base->PCCn[clockNameMappings[clockName]] |= PCC_PCCn_CGC(1UL);\r\n   }\r\n   else\r\n   {\r\n       base->PCCn[clockNameMappings[clockName]] &= (uint32_t)(~(PCC_PCCn_CGC_MASK));\r\n   }\r\n}\r\n\r\n\r\n\r\n/*!\r\n* @brief Gets the clock gate control mode.\r\n*\r\n* @param[in] base        pcc base pointer\r\n* @param[in] clockName   is the name of the peripheral clock\r\n* must be one of the following values (see the clock_names_t type from S32K144_clock_names.h)\r\n*    PCC_DMA0_CLOCK\r\n*    PCC_MPU0_CLOCK\r\n*    ...\r\n*    PCC_LPUART3_CLOCK\r\n* @return  the clock gate control mode\r\n*        - false : Clock is disabled\r\n*        - true : Clock is enabled\r\n*/\r\nstatic inline bool PCC_GetClockMode(const PCC_Type* const base,\r\n                                       const clock_names_t clockName)\r\n{\r\n   uint32_t regValue = (uint32_t)base->PCCn[clockNameMappings[clockName]];\r\n   regValue = (regValue & PCC_PCCn_CGC_MASK) >> PCC_PCCn_CGC_SHIFT;\r\n   return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n* @brief Gets the selection of a clock source for a specific peripheral\r\n*\r\n* @param[in] base        pcc base pointer\r\n* @param[in] clockName   is the name of the peripheral clock\r\n* must be one of the following values (see the clock_names_t type from S32K144_clock_names.h)\r\n*    PCC_DMA0_CLOCK\r\n*    PCC_MPU0_CLOCK\r\n*    ...\r\n*    PCC_LPUART3_CLOCK\r\n* @return  the clock source\r\n*/\r\nstatic inline uint32_t PCC_GetClockSourceSel(const PCC_Type* const base,\r\n                                                                 const clock_names_t clockName)\r\n{\r\n   return ((base->PCCn[clockNameMappings[clockName]] & PCC_PCCn_PCS_MASK) >> PCC_PCCn_PCS_SHIFT);\r\n}\r\n\r\n/*!\r\n* @brief Gets the selection of the fractional value for a specific peripheral\r\n*\r\n* @param[in] base        pcc base pointer\r\n* @param[in] clockName   is the name of the peripheral clock\r\n* must be one of the following values (see the clock_names_t type from S32K144_clock_names.h)\r\n*    PCC_DMA0_CLOCK\r\n*    PCC_MPU0_CLOCK\r\n*    ...\r\n*    PCC_LPUART3_CLOCK\r\n* @return  the fractional value\r\n*        - PCC_MULTPCCnLY_BY_ONE : Fractional value is zero\r\n*        - PCC_MULTPCCnLY_BY_TWO : Fractional value is one\r\n*/\r\nstatic inline uint32_t PCC_GetFracValueSel(const PCC_Type* const base,\r\n                                               const clock_names_t clockName)\r\n{\r\n   return ((base->PCCn[clockNameMappings[clockName]] & PCC_PCCn_FRAC_MASK) >> PCC_PCCn_FRAC_SHIFT);\r\n}\r\n\r\n/*!\r\n* @brief Gets the selection of the divider value for a specific peripheral\r\n*\r\n* @param[in] base        pcc base pointer\r\n* @param[in] clockName   is the name of the peripheral clock\r\n* must be one of the following values (see the clock_names_t type from S32K144_clock_names.h)\r\n*    PCC_DMA0_CLOCK\r\n*    PCC_MPU0_CLOCK\r\n*    ...\r\n*    PCC_LPUART3_CLOCK\r\n* @return  the divider value\r\n*        - PCC_DIVIDE_BY_ONE   : Divide by 1\r\n*        - PCC_DIVIDE_BY_TWO   : Divide by 2\r\n*        - PCC_DIVIDE_BY_THREE : Divide by 3\r\n*        - PCC_DIVIDE_BY_FOUR  : Divide by 4\r\n*        - PCC_DIVIDE_BY_FIVE  : Divide by 5\r\n*        - PCC_DIVIDE_BY_SIX   : Divide by 6\r\n*        - PCC_DIVIDE_BY_SEVEN : Divide by 7\r\n*        - PCC_DIVIDE_BY_EIGTH : Divide by 8\r\n*/\r\nstatic inline uint32_t PCC_GetDividerSel(const PCC_Type* const base,\r\n                                             const clock_names_t clockName)\r\n{\r\n   return ((base->PCCn[clockNameMappings[clockName]] & PCC_PCCn_PCD_MASK) >> PCC_PCCn_PCD_SHIFT);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*! @}*/\r\n\r\n#endif /* PCC_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"pins_driver.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file pins_driver.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n */\r\n\r\n#include \"device_registers.h\"\r\n#include \"pins_gpio_hw_access.h\"\r\n#if defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n#include \"pins_siul2_hw_access.h\"\r\n#elif defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n#include \"pins_port_hw_access.h\"\r\n#endif\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * Variables\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_Init\r\n * Description   : This function configures the pins with the options provided\r\n * in the given structure.\r\n *\r\n * Implements    : PINS_DRV_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t PINS_DRV_Init(uint32_t pinCount,\r\n                       const pin_settings_config_t config[])\r\n{\r\n    uint32_t i;\r\n    for (i = 0U; i < pinCount; i++)\r\n    {\r\n        PINS_Init(&config[i]);\r\n    }\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPullSel\r\n * Description   : This function configures the internal resistor.\r\n *\r\n * Implements    : PINS_DRV_SetPullSel_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPullSel(PORT_Type * const base,\r\n                         uint32_t pin,\r\n                         port_pull_config_t pullConfig)\r\n{\r\n    PINS_SetPullSel(base, pin, pullConfig);\r\n}\r\n\r\n#endif /* FEATURE_PINS_HAS_PULL_SELECTION */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetMuxModeSel\r\n * Description   : This function configures the pin muxing.\r\n *\r\n * Implements    : PINS_DRV_SetMuxModeSel_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetMuxModeSel(PORT_Type * const base,\r\n                            uint32_t pin,\r\n                            port_mux_t mux)\r\n{\r\n    PINS_SetMuxModeSel(base, pin, mux);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPinIntSel\r\n * Description   : This function configures the port pin interrupt/DMA request.\r\n *\r\n * Implements    : PINS_DRV_SetPinIntSel_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPinIntSel(PORT_Type * const base,\r\n                           uint32_t pin,\r\n                           port_interrupt_config_t intConfig)\r\n{\r\n    PINS_SetPinIntSel(base, pin, intConfig);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetPinIntSel\r\n * Description   : This function gets the current port pin interrupt/DMA request configuration.\r\n *\r\n * Implements    : PINS_DRV_GetPinIntSel_Activity\r\n *END**************************************************************************/\r\nport_interrupt_config_t PINS_DRV_GetPinIntSel(const PORT_Type * const base,\r\n                                              uint32_t pin)\r\n{\r\n    return PINS_GetPinIntSel(base, pin);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ClearPinIntFlagCmd\r\n * Description   : This function clears the individual pin-interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_ClearPinIntFlagCmd_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ClearPinIntFlagCmd(PORT_Type * const base,\r\n                                 uint32_t pin)\r\n{\r\n    PINS_ClearPinIntFlagCmd(base, pin);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_EnableDigitalFilter\r\n * Description   : This function enables digital filter feature for digital pin muxing.\r\n *\r\n * Implements    : PINS_DRV_EnableDigitalFilter_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_EnableDigitalFilter(PORT_Type * const base,\r\n                                  uint32_t pin)\r\n{\r\n    PINS_EnableDigitalFilter(base, pin);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_DisableDigitalFilter\r\n * Description   : This function disables digital filter feature for digital\r\n * pin muxing.\r\n *\r\n * Implements    : PINS_DRV_DisableDigitalFilter_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_DisableDigitalFilter(PORT_Type * const base,\r\n                                   uint32_t pin)\r\n{\r\n    PINS_DisableDigitalFilter(base, pin);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ConfigDigitalFilter\r\n * Description   : This function configures digital filter for port with\r\n * given configuration.\r\n *\r\n * Implements    : PINS_DRV_ConfigDigitalFilter_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ConfigDigitalFilter(PORT_Type * const base,\r\n                                  const port_digital_filter_config_t * const config)\r\n{\r\n    PINS_ConfigDigitalFilter(base, config);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetPortIntFlag\r\n * Description   : This function reads the entire port interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_GetPortIntFlag_Activity\r\n *END**************************************************************************/\r\nuint32_t PINS_DRV_GetPortIntFlag(const PORT_Type * const base)\r\n{\r\n    return PINS_GetPortIntFlag(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ClearPortIntFlagCmd\r\n * Description   : This function clears the entire port interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_ClearPortIntFlagCmd_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ClearPortIntFlagCmd(PORT_Type * const base)\r\n{\r\n    PINS_ClearPortIntFlagCmd(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetPinsDirection\r\n * Description   : This function returns the current pins directions for a port. Pins\r\n * corresponding to bits with value of '1' are configured as output and\r\n * pins corresponding to bits with value of '0' are configured as input.\r\n *\r\n * Implements    : PINS_DRV_GetPinsDirection_Activity\r\n *END**************************************************************************/\r\npins_channel_type_t PINS_DRV_GetPinsDirection(const GPIO_Type * const base)\r\n{\r\n    return PINS_GPIO_GetPinsDirection(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPinDirection\r\n * Description   : This function configures the direction for the given pin, with the\r\n * given value('1' for pin to be configured as output and '0' for pin to\r\n * be configured as input).\r\n *\r\n * Implements    : PINS_DRV_SetPinDirection_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPinDirection(GPIO_Type * const base,\r\n                              pins_channel_type_t pin,\r\n                              pins_level_type_t direction)\r\n{\r\n    PINS_GPIO_SetPinDirection(base, pin, direction);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPinsDirection\r\n * Description   : This function sets the direction configuration for all pins\r\n * in a port. Pins corresponding to bits with value of '1' will be configured as\r\n * output and pins corresponding to bits with value of '0' will be configured as\r\n * input.\r\n *\r\n * Implements    : PINS_DRV_SetPinsDirection_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPinsDirection(GPIO_Type * const base,\r\n                               pins_channel_type_t pins)\r\n{\r\n    PINS_GPIO_SetPinsDirection(base, pins);\r\n}\r\n\r\n#if FEATURE_PORT_HAS_INPUT_DISABLE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPortInputDisable\r\n * Description   : This function sets the pins input state for a port.\r\n * Pins corresponding to bits with value of '1' will not be configured\r\n * as input and pins corresponding to bits with value of '0' will be configured\r\n * as input.\r\n *\r\n * Implements    : PINS_DRV_SetPortInputDisable_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPortInputDisable(GPIO_Type * const base,\r\n                                  pins_channel_type_t pins)\r\n{\r\n    PINS_GPIO_SetPortInputDisable(base, pins);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetPortInputDisable\r\n * Description   : This function returns the current pins input state for a port. Pins\r\n * corresponding to bits with value of '1' are not configured as input and\r\n * pins corresponding to bits with value of '0' are configured as input.\r\n *\r\n * Implements    : PINS_DRV_GetPortInputDisable_Activity\r\n *END**************************************************************************/\r\npins_channel_type_t PINS_DRV_GetPortInputDisable(const GPIO_Type * const base)\r\n{\r\n    return PINS_GPIO_GetPortInputDisable(base);\r\n}\r\n#endif /* FEATURE_PORT_HAS_INPUT_DISABLE */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetGlobalPinControl\r\n * Description   : This function quickly configures multiple pins within the one port for\r\n * the same peripheral function with the same pin configuration. Supports up to 16 pins with\r\n * the lower or upper half of pin registers at the same port.\r\n *\r\n * Implements    : PINS_DRV_SetGlobalPinControl_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetGlobalPinControl(PORT_Type * const base,\r\n                                  uint16_t pins,\r\n                                  uint16_t value,\r\n                                  port_global_control_pins_t halfPort)\r\n{\r\n    PINS_SetGlobalPinControl(base, pins, value, halfPort);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetGlobalIntControl\r\n * Description   : This function quickly configures multiple pins within the one port for\r\n * the same peripheral function with the same interrupt configuration. Supports up to 16 pins with\r\n * the lower or upper half of pin registers at the same port.\r\n *\r\n * Implements    : PINS_DRV_SetGlobalIntControl_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetGlobalIntControl(PORT_Type * const base,\r\n                                  uint16_t pins,\r\n                                  uint16_t value,\r\n                                  port_global_control_pins_t halfPort)\r\n{\r\n    PINS_SetGlobalIntControl(base, pins, value, halfPort);\r\n}\r\n\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetOverCurPortIntFlag\r\n * Description   : This function reads the entire over current port interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_GetOverCurPortIntFlag_Activity\r\n *END**************************************************************************/\r\nuint32_t PINS_DRV_GetOverCurPortIntFlag(const PORT_Type * const base)\r\n{\r\n    return PINS_GetOverCurPortIntFlag(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ClearOverCurPortIntFlag\r\n * Description   : This function clears the entire over current port interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_ClearOverCurPortIntFlag_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ClearOverCurPortIntFlag(PORT_Type * const base)\r\n{\r\n    PINS_ClearOverCurPortIntFlag(base);\r\n}\r\n#endif /* FEATURE_PINS_HAS_OVER_CURRENT */\r\n\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPullSel\r\n * Description   : This function configures the internal resistor.\r\n *\r\n * Implements    : PINS_DRV_SetPullSel_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPullSel(PORT_Type * const base,\r\n                         uint16_t pin,\r\n                         port_pull_config_t pullConfig)\r\n{\r\n    PINS_SetPullSel(base, pin, pullConfig);\r\n}\r\n\r\n#endif /* FEATURE_PINS_HAS_PULL_SELECTION */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetOutputBuffer\r\n * Description   : This function configures the output buffer.\r\n *\r\n * Implements    : PINS_DRV_SetOutputBuffer_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetOutputBuffer(PORT_Type * const base,\r\n                              uint16_t pin,\r\n                              bool enable,\r\n                              port_mux_t mux)\r\n{\r\n    PINS_SetOutputBuffer(base, pin, enable, mux);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetInputBuffer\r\n * Description   : This function configures the input buffer.\r\n *\r\n * Implements    : PINS_DRV_SetInputBuffer_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetInputBuffer(PORT_Type * const base,\r\n                             uint16_t pin,\r\n                             bool enable,\r\n                             uint32_t inputMuxReg,\r\n                             port_input_mux_t inputMux)\r\n{\r\n    PINS_SetInputBuffer(base, pin, enable, inputMuxReg, inputMux);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ConfigIntFilterClock\r\n * Description   : This function configures the interrupt filter clock prescaler.\r\n *\r\n * Implements    : PINS_DRV_ConfigIntFilterClock_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ConfigIntFilterClock(uint8_t prescaler)\r\n{\r\n    PINS_ConfigIntFilterClock(prescaler);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetExInt\r\n * Description   : This function configures the external interrupt.\r\n *\r\n * Implements    : PINS_DRV_SetExInt_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetExInt(siul2_interrupt_config_t intConfig)\r\n{\r\n    PINS_SetExInt(intConfig);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ClearPinExIntFlag\r\n * Description   : This function clears the individual pin external interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_ClearPinExIntFlag_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ClearPinExIntFlag(uint32_t eirqPinIdx)\r\n{\r\n    PINS_ClearPinExIntFlag(eirqPinIdx);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetPinExIntFlag\r\n * Description   : This function gets the individual pin external interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_GetPinExIntFlag_Activity\r\n *END**************************************************************************/\r\nbool PINS_DRV_GetPinExIntFlag(uint32_t eirqPinIdx)\r\n{\r\n    return PINS_GetPinExIntFlag(eirqPinIdx);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ClearExIntFlag\r\n * Description   : This function clears the entire external interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_ClearExIntFlag_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ClearExIntFlag(void)\r\n{\r\n    PINS_ClearExIntFlag();\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetExIntFlag\r\n * Description   : This function reads the entire external interrupt status flag.\r\n *\r\n * Implements    : PINS_DRV_GetExIntFlag_Activity\r\n *END**************************************************************************/\r\nuint32_t PINS_DRV_GetExIntFlag(void)\r\n{\r\n    return PINS_GetExIntFlag();\r\n}\r\n\r\n#endif /* FEATURE_PINS_DRIVER_USING_PORT */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_WritePin\r\n * Description   : This function writes the given pin from a port, with the given value\r\n * ('0' represents LOW, '1' represents HIGH).\r\n *\r\n * Implements    : PINS_DRV_WritePin_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_WritePin(GPIO_Type * const base,\r\n                       pins_channel_type_t pin,\r\n                       pins_level_type_t value)\r\n{\r\n    PINS_GPIO_WritePin(base, pin, value);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_WritePins\r\n * Description   : This function writes all pins configured as output with the values given in\r\n * the parameter pins. '0' represents LOW, '1' represents HIGH.\r\n *\r\n * Implements    : PINS_DRV_WritePins_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_WritePins(GPIO_Type * const base,\r\n                        pins_channel_type_t pins)\r\n{\r\n    PINS_GPIO_WritePins(base, pins);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_GetPinsOutput\r\n * Description   : This function returns the current output that is written to a port. Only pins\r\n * that are configured as output will have meaningful values.\r\n *\r\n * Implements    : PINS_DRV_GetPinsOutput_Activity\r\n *END**************************************************************************/\r\npins_channel_type_t PINS_DRV_GetPinsOutput(const GPIO_Type * const base)\r\n{\r\n    return PINS_GPIO_GetPinsOutput(base);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_SetPins\r\n * Description   : This function configures output pins listed in parameter pins (bits that are\r\n * '1') to have a value of 'set' (HIGH). Pins corresponding to '0' will be\r\n * unaffected.\r\n *\r\n * Implements    : PINS_DRV_SetPins_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_SetPins(GPIO_Type * const base,\r\n                      pins_channel_type_t pins)\r\n{\r\n    PINS_GPIO_SetPins(base, pins);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ClearPins\r\n * Description   : This function configures output pins listed in parameter pins (bits that are\r\n * '1') to have a 'cleared' value (LOW). Pins corresponding to '0' will be\r\n * unaffected.\r\n *\r\n * Implements    : PINS_DRV_ClearPins_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_ClearPins(GPIO_Type * const base,\r\n                        pins_channel_type_t pins)\r\n{\r\n    PINS_GPIO_ClearPins(base, pins);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_TogglePins\r\n * Description   : This function toggles output pins listed in parameter pins (bits that are\r\n * '1'). Pins corresponding to '0' will be unaffected.\r\n *\r\n * Implements    : PINS_DRV_TogglePins_Activity\r\n *END**************************************************************************/\r\nvoid PINS_DRV_TogglePins(GPIO_Type * const base,\r\n                         pins_channel_type_t pins)\r\n{\r\n    PINS_GPIO_TogglePins(base, pins);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_DRV_ReadPins\r\n * Description   : This function returns the current input values from a port. Only pins\r\n * configured as input will have meaningful values.\r\n *\r\n * Implements    : PINS_DRV_ReadPins_Activity\r\n *END**************************************************************************/\r\npins_channel_type_t PINS_DRV_ReadPins(const GPIO_Type * const base)\r\n{\r\n    return PINS_GPIO_ReadPins(base);\r\n}\r\n\r\n/******************************************************************************\r\n * EOF\r\n *****************************************************************************/\r\n"},{"name":"pins_driver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\inc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef PINS_DRIVER_H\r\n#define PINS_DRIVER_H\r\n\r\n#include <stddef.h>\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n\r\n/*!\r\n * @defgroup pins_driver PINS Driver\r\n * @ingroup pins\r\n * @details This section describes the programming interface of the PINS driver.\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n/*!\r\n * @brief Type of a GPIO channel representation\r\n * Implements : pins_channel_type_t_Class\r\n */\r\ntypedef uint32_t pins_channel_type_t;\r\n\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n/*!\r\n * @brief Type of a GPIO channel representation\r\n * Implements : pins_channel_type_t_Class\r\n */\r\ntypedef uint16_t pins_channel_type_t;\r\n\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n\r\n/*!\r\n * @brief Type of a port levels representation.\r\n * Implements : pins_level_type_t_Class\r\n */\r\ntypedef uint8_t pins_level_type_t;\r\n\r\n/*!\r\n * @brief Configures the port data direction\r\n * Implements : port_data_direction_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    GPIO_INPUT_DIRECTION       = 0x0U,  /*!< General purpose input direction.       */\r\n    GPIO_OUTPUT_DIRECTION      = 0x1U,  /*!< General purpose output direction.      */\r\n    GPIO_UNSPECIFIED_DIRECTION = 0x2U   /*!< General purpose unspecified direction. */\r\n} port_data_direction_t;\r\n\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n/*!\r\n * @brief Internal resistor pull feature selection\r\n * Implements : port_pull_config_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_INTERNAL_PULL_NOT_ENABLED   = 0U,  /*!< internal pull-down or pull-up resistor is not enabled.           */\r\n    PORT_INTERNAL_PULL_DOWN_ENABLED  = 1U,  /*!< internal pull-down resistor is enabled. @internal gui name=\"Down\"*/\r\n    PORT_INTERNAL_PULL_UP_ENABLED    = 2U   /*!< internal pull-up resistor is enabled. @internal gui name=\"Up\"    */\r\n} port_pull_config_t;\r\n#endif /* FEATURE_PINS_HAS_PULL_SELECTION */\r\n\r\n#if FEATURE_PINS_HAS_OPEN_DRAIN\r\n/*!\r\n * @brief Configures the Open Drain Enable field.\r\n * Implements : port_open_drain_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_OPEN_DRAIN_DISABLED  = 0U, /*!< Output is CMOS       */\r\n    PORT_OPEN_DRAIN_ENABLED   = 1U  /*!< Output is open drain */\r\n} port_open_drain_t;\r\n#endif /* FEATURE_PINS_HAS_OPEN_DRAIN */\r\n\r\n#if FEATURE_PINS_HAS_DRIVE_STRENGTH\r\n/*!\r\n * @brief Configures the drive strength.\r\n * Implements : port_drive_strength_t_Class\r\n */\r\ntypedef enum\r\n{\r\n#if FEATURE_PINS_HAS_DRIVE_STRENGTH_CONTROL\r\n    PORT_STRENGTH_DISABLED      = 0U, /*!< Output driver disabled                                         */\r\n    PORT_LOW_DRIVE_STRENGTH     = 1U, /*!< Low drive strength is configured. Resistor is set to 240 Ohm   */\r\n    PORT_STR1_DRIVE_STRENGTH    = 1U, /*!< Resistor is set to 240 Ohm                                     */\r\n    PORT_STR2_DRIVE_STRENGTH    = 2U, /*!< Resistor is set to 240 / 2 Ohm = 120 Ohm                       */\r\n    PORT_STR3_DRIVE_STRENGTH    = 3U, /*!< Resistor is set to 240 / 3 Ohm = 80 Ohm                        */\r\n    PORT_STR4_DRIVE_STRENGTH    = 4U, /*!< Resistor is set to 240 / 4 Ohm = 60 Ohm                        */\r\n    PORT_STR5_DRIVE_STRENGTH    = 5U, /*!< Resistor is set to 240 / 5 Ohm = 48 Ohm                        */\r\n    PORT_STR6_DRIVE_STRENGTH    = 6U, /*!< Resistor is set to 240 / 6 Ohm = 40 Ohm                        */\r\n    PORT_STR7_DRIVE_STRENGTH    = 7U, /*!< Resistor is set to 240 / 7 Ohm = 34 Ohm                        */\r\n    PORT_HIGH_DRIVE_STRENGTH    = 7U  /*!< High drive strength is configured. Resistor is set to 240 Ohm  */\r\n#else /* if not FEATURE_PINS_HAS_DRIVE_STRENGTH_CONTROL */\r\n    PORT_LOW_DRIVE_STRENGTH     = 0U,    /*!< low drive strength is configured. @internal gui name=\"Low\"  */\r\n    PORT_HIGH_DRIVE_STRENGTH    = 1U     /*!< high drive strength is configured. @internal gui name=\"High\"*/\r\n#endif /* if FEATURE_PINS_HAS_DRIVE_STRENGTH_CONTROL */\r\n} port_drive_strength_t;\r\n#endif /* FEATURE_PINS_HAS_DRIVE_STRENGTH */\r\n\r\n#ifdef FEATURE_PINS_DRIVER_USING_PORT\r\n/*!\r\n * @brief Configures the Pin mux selection\r\n * Implements : port_mux_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_PIN_DISABLED            = 0U,  /*!< corresponding pin is disabled, but is used as an analog pin       */\r\n    PORT_MUX_AS_GPIO             = 1U,  /*!< corresponding pin is configured as GPIO                           */\r\n    PORT_MUX_ALT2                = 2U,  /*!< chip-specific                                                     */\r\n    PORT_MUX_ALT3                = 3U,  /*!< chip-specific                                                     */\r\n    PORT_MUX_ALT4                = 4U,  /*!< chip-specific                                                     */\r\n    PORT_MUX_ALT5                = 5U,  /*!< chip-specific                                                     */\r\n    PORT_MUX_ALT6                = 6U,  /*!< chip-specific                                                     */\r\n    PORT_MUX_ALT7                = 7U,  /*!< chip-specific                                                     */\r\n#if FEATURE_PINS_HAS_ADC_INTERLEAVE_EN\r\n    PORT_MUX_ADC_INTERLEAVE      = 8U   /*!< when selected, ADC Interleaved channel is connected to current pin\r\n                                         *   and disconnected to opposed pin\r\n                                         * ADC1_SE14-PTB15 | ADC1_SE15-PTB16 | ADC0_SE8-PTC0  | ADC0_SE9-PTC1\r\n                                         * ADC1_SE14-PTB0  | ADC1_SE15-PTB1  | ADC0_SE8-PTB13 | ADC0_SE9-PTB14 */\r\n#endif /* FEATURE_PINS_HAS_ADC_INTERLEAVE_EN */\r\n} port_mux_t;\r\n\r\n/*!\r\n * @brief Configures the interrupt generation condition.\r\n * Implements : port_interrupt_config_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_DMA_INT_DISABLED  = 0x0U,  /*!< Interrupt/DMA request is disabled.                   */\r\n    PORT_DMA_RISING_EDGE   = 0x1U,  /*!< DMA request on rising edge.                          */\r\n    PORT_DMA_FALLING_EDGE  = 0x2U,  /*!< DMA request on falling edge.                         */\r\n    PORT_DMA_EITHER_EDGE   = 0x3U,  /*!< DMA request on either edge.                          */\r\n#if FEATURE_PORT_HAS_FLAG_SET_ONLY\r\n    PORT_FLAG_RISING_EDGE  = 0x5U,  /*!< Flag sets on rising edge, no interrupt is generated. */\r\n    PORT_FLAG_FALLING_EDGE = 0x6U,  /*!< Flag sets on falling edge, no interrupt is generated.*/\r\n    PORT_FLAG_EITHER_EDGE  = 0x7U,  /*!< Flag sets on either edge, no interrupt is generated. */\r\n#endif /* FEATURE_PORT_HAS_FLAG_SET_ONLY */\r\n    PORT_INT_LOGIC_ZERO    = 0x8U,  /*!< Interrupt when logic 0.                              */\r\n    PORT_INT_RISING_EDGE   = 0x9U,  /*!< Interrupt on rising edge.                            */\r\n    PORT_INT_FALLING_EDGE  = 0xAU,  /*!< Interrupt on falling edge.                           */\r\n    PORT_INT_EITHER_EDGE   = 0xBU,  /*!< Interrupt on either edge.                            */\r\n    PORT_INT_LOGIC_ONE     = 0xCU,  /*!< Interrupt when logic 1.                              */\r\n#if FEATURE_PORT_HAS_TRIGGER_OUT\r\n    PORT_HIGH_TRIGGER_OUT  = 0xDU,  /*!< Enable active high trigger output, flag is disabled. */\r\n    PORT_LOW_TRIGGER_OUT   = 0xEU   /*!< Enable active low trigger output, flag is disabled.  */\r\n#endif /* FEATURE_PORT_HAS_TRIGGER_OUT */\r\n} port_interrupt_config_t;\r\n\r\n#if FEATURE_PINS_HAS_SLEW_RATE\r\n/*!\r\n * @brief Configures the Slew Rate field.\r\n * Implements : port_slew_rate_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_FAST_SLEW_RATE     = 0U,   /*!< fast slew rate is configured. @internal gui name=\"Fast\" */\r\n    PORT_SLOW_SLEW_RATE     = 1U    /*!< slow slew rate is configured. @internal gui name=\"Slow\" */\r\n} port_slew_rate_t;\r\n#endif /* FEATURE_PINS_HAS_SLEW_RATE */\r\n\r\n/*!\r\n * @brief Clock source for the digital input filters\r\n * Implements : port_digital_filter_clock_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_DIGITAL_FILTER_BUS_CLOCK  = 0U, /*!< Digital filters are clocked by the bus clock. @internal gui name=\"BUS\" */\r\n    PORT_DIGITAL_FILTER_LPO_CLOCK  = 1U  /*!< Digital filters are clocked by the LPO clock. @internal gui name=\"LPO\" */\r\n} port_digital_filter_clock_t;\r\n\r\n/*!\r\n * @brief The digital filter configuration\r\n * Implements : port_digital_filter_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    port_digital_filter_clock_t clock;  /*!< The digital filter clock for port */\r\n    uint8_t                     width;  /*!< The digital filter width value */\r\n} port_digital_filter_config_t;\r\n\r\n/*!\r\n * @brief The port global pin/interuppt control registers\r\n * Implements : port_global_control_pins_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_GLOBAL_CONTROL_LOWER_HALF_PINS = 0U, /*!< the lower of pins is configured. @internal gui name=\"Lower\" */\r\n    PORT_GLOBAL_CONTROL_UPPER_HALF_PINS = 1U  /*!< the upper of pins is configured. @internal gui name=\"Upper\" */\r\n} port_global_control_pins_t;\r\n\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n/*!\r\n * @brief Over-current detection feature\r\n * Implements : port_over_current_config_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_OVER_CURRENT_DISABLED      = 0U,   /*!< Over-current feature pin is disabled.          */\r\n    PORT_OVER_CURRENT_INT_DISABLED  = 1U,   /*!< Over-current is enabled, interrupt is disabled */\r\n    PORT_OVER_CURRENT_INT_ENABLED   = 2U    /*!< Over-current is enabled, interrupt is enabled  */\r\n} port_over_current_config_t;\r\n#endif /* FEATURE_PINS_HAS_OVER_CURRENT */\r\n\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n#if FEATURE_SIUL2_HAS_DDR_PAD\r\n/*!\r\n * @brief Configures the DDR type to:\r\n *      DDR3, DDR3L modes   - 00\r\n *      LPDDR2 mode         - 10\r\n * Implements : port_ddr_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    DDR_DDR3_MODE       = 0x0U,  /*!< DDR3 / LPDDR3 mode  */\r\n    DDR_LPDDR2_MODE     = 0x2U   /*!< LPDDR2 mode         */\r\n} port_ddr_type_t;\r\n\r\n/*!\r\n * @brief Configures the DDR trimming delay to:\r\n *      min delay           - 00\r\n *      +50ps delay         - 01\r\n *      +100ps delay        - 10\r\n *      +150ps delay        - 11\r\n * Implements : port_ddr_trim_delay_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    DDR_MIN_DELAY       = 0x0U,  /*!< min delay     */\r\n    DDR_50PS_DELAY      = 0x1U,  /*!< +50ps delay   */\r\n    DDR_100PS_DELAY     = 0x2U,  /*!< +100ps delay  */\r\n    DDR_150PS_DELAY     = 0x3U   /*!< +150ps delay  */\r\n} port_ddr_trim_delay_t;\r\n\r\n/*!\r\n * @brief Configures the DDR crosspoint adjusment of DDR CLK cell output signal to:\r\n *      No crosspoint change                    - 00\r\n *      Output crosspoint is +70mV higher       - 01\r\n *      Output crosspoint is -70mV lower        - 10\r\n *      Output crosspoint is +140mV higher      - 11\r\n * Implements : port_ddr_crpoint_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    DDR_NO_CRPOINT      = 0x0U,  /*!< No crosspoint change               */\r\n    DDR_MINUS_CRPOINT   = 0x1U,  /*!< Output crosspoint is +70mV higher  */\r\n    DDR_PLUS_CRPOINT    = 0x2U,  /*!< Output crosspoint is -70mV lower   */\r\n    DDR_DOUBLE_CRPOINT  = 0x3U   /*!< Output crosspoint is +140mV higher */\r\n} port_ddr_crpoint_t;\r\n\r\n/*!\r\n * @brief Configures the DDR output signal duty cycle adjustment to:\r\n *      No duty cycle change            - 00\r\n *      Left side input pulse shrink    - 01\r\n *      Right side input pulse shrink   - 10\r\n *      Right side input pulse shrink   - 11\r\n * Implements : port_ddr_trim_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    DDR_NO_TRIM         = 0x0U,  /*!< No duty cycle change             */\r\n    DDR_LEFT_TRIM       = 0x1U,  /*!< Left side input pulse shrink     */\r\n    DDR_RIGHT_TRIM      = 0x2U   /*!< Right side input pulse shrink    */\r\n} port_ddr_trim_t;\r\n\r\n/*!\r\n * @brief Configures DDR input to select differential or CMOS input receiver mode.\r\n * Implements : port_ddr_input_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_DDR_INPUT_CMOS          = 0U, /*!< CMOS input receiver mode             */\r\n    PORT_DDR_INPUT_DIFFERENTIAL  = 1U  /*!< differential DDR input receiver mode */\r\n} port_ddr_input_t;\r\n\r\n/*!\r\n * @brief Configures the On die Termination to select ODT strength in DDR3 mode.\r\n * Implements : port_on_die_termination_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_STR0_ON_DIE_TERMINATION    = 0U, /*!< Not applicable                         */\r\n    PORT_STR1_ON_DIE_TERMINATION    = 1U, /*!< Termination resistor is set to 120 Ohm */\r\n    PORT_STR2_ON_DIE_TERMINATION    = 2U, /*!< Termination resistor is set to 60 Ohm  */\r\n    PORT_STR3_ON_DIE_TERMINATION    = 3U, /*!< Termination resistor is set to 40 Ohm  */\r\n    PORT_STR4_ON_DIE_TERMINATION    = 4U, /*!< Termination resistor is set to 30 Ohm  */\r\n    PORT_STR5_ON_DIE_TERMINATION    = 5U, /*!< Termination resistor is set to 24 Ohm  */\r\n    PORT_STR6_ON_DIE_TERMINATION    = 6U, /*!< Termination resistor is set to 20 Ohm  */\r\n    PORT_STR7_ON_DIE_TERMINATION    = 7U  /*!< Termination resistor is set to 17 Ohm  */\r\n} port_on_die_termination_t;\r\n\r\n/*!\r\n * @brief Defines the DDR configuration\r\n *\r\n * This structure is used to configure the pins for the DDR controller\r\n * Implements : pin_ddr_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    port_ddr_type_t         ddrSelection;           /*!< DDR type                   */\r\n    port_ddr_trim_delay_t   trimmingDelay;          /*!< DDR trimming delay value   */\r\n    port_ddr_crpoint_t      crosspointAdjustment;   /*!< Crosspoint adjusment       */\r\n    port_ddr_trim_t         trimmingAdjustment;     /*!< DDR trimming type          */\r\n} pin_ddr_config_t;\r\n\r\n#endif /* FEATURE_SIUL2_HAS_DDR_PAD */\r\n\r\n/*!\r\n * @brief Configures the Pin mux selection\r\n * Implements : port_mux_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_MUX_AS_GPIO    = 0U,   /*!< corresponding pin is configured as GPIO */\r\n    PORT_MUX_ALT1       = 1U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT2       = 2U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT3       = 3U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT4       = 4U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT5       = 5U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT6       = 6U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT7       = 7U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT8       = 8U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT9       = 9U,   /*!< chip-specific                           */\r\n    PORT_MUX_ALT10      = 10U,  /*!< chip-specific                           */\r\n    PORT_MUX_ALT11      = 11U,  /*!< chip-specific                           */\r\n    PORT_MUX_ALT12      = 12U,  /*!< chip-specific                           */\r\n    PORT_MUX_ALT13      = 13U,  /*!< chip-specific                           */\r\n    PORT_MUX_ALT14      = 14U,  /*!< chip-specific                           */\r\n    PORT_MUX_ALT15      = 15U   /*!< chip-specific                           */\r\n} port_mux_t;\r\n\r\n/*!\r\n * @brief Configures the interrupt generation condition.\r\n * Implements : siul2_interrupt_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SIUL2_INT_DISABLE       = 0x0U,  /*!< Interrupt disable.         */\r\n    SIUL2_INT_RISING_EDGE   = 0x1U,  /*!< Interrupt on rising edge.  */\r\n    SIUL2_INT_FALLING_EDGE  = 0x2U,  /*!< Interrupt on falling edge. */\r\n    SIUL2_INT_EITHER_EDGE   = 0x3U   /*!< Interrupt on either edge.  */\r\n} siul2_interrupt_type_t;\r\n\r\n#if FEATURE_SIUL2_EXTERNAL_INT_SUPPORT_DMA\r\n/*!\r\n * @brief Configures the interrupt DMA select.\r\n * Implements : siul2_interrupt_dma_select_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    SIUL2_INT_USING_INTERUPT = 0x0U, /*!< Executived by an interrupt request */\r\n    SIUL2_INT_USING_DMA      = 0x1U  /*!< Executived by an DMA request       */\r\n} siul2_interrupt_dma_select_t;\r\n#endif /* FEATURE_SIUL2_EXTERNAL_INT_SUPPORT_DMA */\r\n\r\n/*!\r\n * @brief Interrupt configuration structure.\r\n * Implements : siul2_interrupt_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    uint8_t                eirqPinIdx;      /*!< The interrupt pin index */\r\n    siul2_interrupt_type_t intEdgeSel;      /*!< The type of edge event  */\r\n    bool                   digitalFilter;   /*!< Enables digital filter  */\r\n    uint8_t                maxCnt;          /*!< Maximum interrupt filter value  */\r\n#if FEATURE_SIUL2_EXTERNAL_INT_SUPPORT_DMA\r\n    siul2_interrupt_dma_select_t intExeSel; /*!< Switch between DMA and interrupt request */\r\n#endif\r\n} siul2_interrupt_config_t;\r\n\r\n/*!\r\n * @brief Configures the Output Buffer Enable field.\r\n * Implements : port_output_buffer_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_OUTPUT_BUFFER_DISABLED     = 0U, /*!< Output buffer disabled */\r\n    PORT_OUTPUT_BUFFER_ENABLED      = 1U  /*!< Output buffer enabled  */\r\n} port_output_buffer_t;\r\n\r\n/*!\r\n * @brief Configures the Input Buffer Enable field.\r\n * Implements : port_input_buffer_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_INPUT_BUFFER_DISABLED     = 0U, /*!< Input buffer disabled */\r\n    PORT_INPUT_BUFFER_ENABLED      = 1U  /*!< Input buffer enabled  */\r\n} port_input_buffer_t;\r\n\r\n#if FEATURE_SIUL2_HAS_HYSTERESIS\r\n/*!\r\n * @brief Configures the Hysteresis Enable field.\r\n * Implements : port_hysteresis_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_HYSTERESYS_CMOS        = 0U, /*!< CMOS Input            */\r\n    PORT_HYSTERESYS_SCHMITT     = 1U, /*!< Schmitt trigger input */\r\n    PORT_HYSTERESYS_DISABLED    = 0U, /*!< DISABLED              */\r\n    PORT_HYSTERESYS_ENABLED     = 1U  /*!< ENABLED               */\r\n} port_hysteresis_t;\r\n#endif /* FEATURE_SIUL2_HAS_HYSTERESIS */\r\n\r\n#if FEATURE_SIUL2_HAS_INVERT_DATA_OUTPUT\r\n/*!\r\n * @brief Configures the Invert Data Output field.\r\n * Implements : port_invert_output_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_INVERT_OUTPUT_DISABLED  = 0U, /*!< Invert Data Output disabled */\r\n    PORT_INVERT_OUTPUT_ENABLED   = 1U  /*!< Invert Data Output enabled  */\r\n} port_invert_output_t;\r\n#endif /* FEATURE_SIUL2_HAS_INVERT_DATA_OUTPUT */\r\n\r\n#if FEATURE_SIUL2_HAS_INVERT_DATA_INPUT\r\n/*!\r\n * @brief Configures the Invert Data Input field.\r\n * Implements : port_invert_input_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_INVERT_INPUT_DISABLED   = 0U, /*!< Invert Data Input disabled  */\r\n    PORT_INVERT_INPUT_ENABLED    = 1U  /*!< Invert Data Input enabled   */\r\n} port_invert_input_t;\r\n#endif /* FEATURE_SIUL2_HAS_INVERT_DATA_INPUT */\r\n\r\n#if FEATURE_SIUL2_HAS_PULL_KEEPER\r\n/*!\r\n * @brief Configures the Pull / Keep Enable field.\r\n * Implements : port_pull_keep_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_PULL_KEEP_DISABLED  = 0U, /*!< Pull/Keeper Disabled  */\r\n    PORT_PULL_KEEP_ENABLED   = 1U  /*!< Pull/Keeper Enabled   */\r\n} port_pull_keep_t;\r\n\r\n/*!\r\n * @brief Configures the Pull / Keep Select Field (PUE).\r\n * Implements : port_pull_keeper_select_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_KEEPER_ENABLED      = 0U, /*!< Keeper enable                       */\r\n    PORT_PULL_ENABLED        = 1U  /*!< Pullup or pulldown resistors enable */\r\n} port_pull_keeper_select_t;\r\n\r\n/*!\r\n * @brief Configures the Pull Up / Down Config Field.\r\n * Implements : port_pull_up_down_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_PULL_DOWN_ENABLED   = 0U,  /*!< 100 kOhm pulldown */\r\n    PORT_PULL_UP_MEDIUM      = 1U,  /*!< 50 kOhm pullup    */\r\n    PORT_PULL_UP_HIGH        = 2U,  /*!< 100 kOhm pullup   */\r\n    PORT_PULL_UP_LOW         = 3U   /*!< 33 kOhm pullup    */\r\n} port_pull_up_down_t;\r\n\r\n#endif /* FEATURE_SIUL2_HAS_PULL_KEEPER */\r\n\r\n#if FEATURE_SIUL2_HAS_ANALOG_PAD\r\n/*!\r\n * @brief Configures the Analog Pad Control.\r\n * Implements : port_analog_pad_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_ANALOG_PAD_CONTROL_DISABLED = 0U, /*!< Disable (the switch is off)                                 */\r\n    PORT_ANALOG_PAD_CONTROL_ENABLED  = 1U  /*!< Enable (another module can control the state of the switch) */\r\n} port_analog_pad_t;\r\n#endif /* FEATURE_SIUL2_HAS_ANALOG_PAD */\r\n\r\n/*!\r\n * @brief Configures the DAISY (on CPU_S32V234) or SSS (on CPU_MPC5748G) bitfield in the IMCR register.\r\n * Implements : port_input_mux_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_INPUT_MUX_ALT0      = 0U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT1      = 1U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT2      = 2U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT3      = 3U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT4      = 4U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT5      = 5U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT6      = 6U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT7      = 7U,   /*!< Chip-specific     */\r\n#if (FEATURE_SIUL2_INPUT_SOURCE_SELECT_WIDTH >= 4U)\r\n    PORT_INPUT_MUX_ALT8      = 8U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT9      = 9U,   /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT10     = 10U,  /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT11     = 11U,  /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT12     = 12U,  /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT13     = 13U,  /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT14     = 14U,  /*!< Chip-specific     */\r\n    PORT_INPUT_MUX_ALT15     = 15U,  /*!< Chip-specific     */\r\n#endif\r\n    PORT_INPUT_MUX_NO_INIT           /*!< No initialization */\r\n} port_input_mux_t;\r\n\r\n/*!\r\n * @brief Configures the Safe Mode Control.\r\n * Implements : port_safe_mode_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_SAFE_MODE_DISABLED     = 0U, /*!< To drive pad in hi-z state using OBE = 0, when FCCU in fault state.\r\n                                       * The OBE will be driven by IP/SIUL when FCCU leaves the fault state. */\r\n    PORT_SAFE_MODE_ENABLED      = 1U  /*!< No effect on IP/SIUL driven OBE value */\r\n} port_safe_mode_t;\r\n\r\n#if FEATURE_SIUL2_HAS_SLEW_RATE_CONTROL\r\n/*!\r\n * @brief Configures the slew rate control.\r\n * Implements : port_slew_rate_control_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    HALF_STRENGTH_WITH_SLEWRATE_CONTROL     = 0u, /*!< Half Strength with Slewrate Control     */\r\n    FULL_STRENGTH_WITH_SLEWRATE_CONTROL     = 1u, /*!< Full Strength with Slewrate Control     */\r\n    HALF_STRENGTH_WITHOUT_SLEWRATE_CONTROL  = 2u, /*!< Half Strength without Slewrate Control  */\r\n    FULL_STRENGTH_WITHOUT_SLEWRATE_CONTROL  = 3u  /*!< Full Strength without Slewrate Control  */\r\n} port_slew_rate_control_t;\r\n#endif /* FEATURE_SIUL2_HAS_SLEW_RATE_CONTROL  */\r\n\r\n#if FEATURE_PINS_HAS_SLEW_RATE\r\n/*!\r\n * @brief Configures the Slew Rate field.\r\n * Implements : port_slew_rate_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    PORT_LOW_SLEW_RATE      = 0U,   /*!< Low    frequency slew rate (50 Mhz) */\r\n    PORT_MEDIUM_SLEW_RATE   = 1U,   /*!< Medium frequency slew rate (100Mhz) */\r\n    PORT_MEDIUM_SLEW_RATE2  = 2U,   /*!< Medium frequency slew rate (100Mhz) */\r\n    PORT_HIGH_SLEW_RATE     = 3U    /*!< High   frequency slew rate (200Mhz) */\r\n} port_slew_rate_t;\r\n#endif\r\n\r\n#endif /* FEATURE_PINS_DRIVER_USING_SIUL2 */\r\n\r\n/*!\r\n * @brief Defines the converter configuration\r\n *\r\n * This structure is used to configure the pins\r\n * Implements : pin_settings_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n#ifdef FEATURE_PINS_DRIVER_USING_PORT\r\n    PORT_Type         *         base;              /*!< Port base pointer.                        */\r\n#elif defined FEATURE_PINS_DRIVER_USING_SIUL2\r\n    SIUL2_Type        *         base;              /*!< SIUL2 base pointer.                       */\r\n#endif\r\n    uint32_t                    pinPortIdx;        /*!< Port pin number.                          */\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n    port_pull_config_t          pullConfig;        /*!< Internal resistor pull feature selection. */\r\n#endif\r\n#if FEATURE_PINS_HAS_SLEW_RATE\r\n    port_slew_rate_t            rateSelect;        /*!< Slew rate selection.                      */\r\n#endif\r\n#if FEATURE_PORT_HAS_PASSIVE_FILTER\r\n    bool                        passiveFilter;     /*!< Passive filter configuration.             */\r\n#endif\r\n#if FEATURE_PINS_HAS_OPEN_DRAIN\r\n    port_open_drain_t           openDrain;         /*!< Configures open drain.                    */\r\n#endif\r\n#if FEATURE_PINS_HAS_DRIVE_STRENGTH\r\n    port_drive_strength_t       driveSelect;       /*!< @brief Configures the drive strength.     */\r\n#endif\r\n    port_mux_t                  mux;               /*!< @brief Pin (C55: Out) mux selection.      */\r\n#if FEATURE_PORT_HAS_PIN_CONTROL_LOCK\r\n    bool                        pinLock;           /*!< Lock pin control register or not.         */\r\n#endif\r\n#ifdef FEATURE_PINS_DRIVER_USING_PORT\r\n    port_interrupt_config_t     intConfig;         /*!< Interrupt generation condition.           */\r\n    bool                        clearIntFlag;      /*!< Clears the interrupt status flag.         */\r\n    bool                        digitalFilter;     /*!< Enables digital filter.                   */\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n    bool                        clearOCurFlag;     /*!< Clears the Over-Current status flag.      */\r\n    port_over_current_config_t  overCurConfig;     /*!< Over-current detection feature.           */\r\n#endif\r\n#endif\r\n    GPIO_Type         *         gpioBase;          /*!< GPIO base pointer.                        */\r\n    port_data_direction_t       direction;         /*!< Configures the port data direction.       */\r\n#ifdef FEATURE_PINS_DRIVER_USING_SIUL2\r\n    port_input_mux_t    inputMux[FEATURE_SIUL2_INPUT_MUX_WIDTH];   /*!< Configures the input muxing selection */\r\n#if FEATURE_SIUL2_HAS_INVERT_DATA_INPUT\r\n    port_invert_input_t inputInvert[FEATURE_SIUL2_INPUT_MUX_WIDTH];/*!< Configures the Invert Data Input.     */\r\n#endif /* FEATURE_SIUL2_HAS_INVERT_DATA_INPUT */\r\n    uint32_t            inputMuxReg[FEATURE_SIUL2_INPUT_MUX_WIDTH];/*!< Configures the input muxing register  */\r\n    port_output_buffer_t        outputBuffer;      /*!< Configures the Output Buffer Enable.      */\r\n    port_input_buffer_t         inputBuffer;       /*!< Configures the Input Buffer Enable.       */\r\n    siul2_interrupt_config_t    intConfig;         /*!< Interrupt generation condition.           */\r\n#if FEATURE_SIUL2_HAS_SAFE_MODE_CONTROL\r\n    port_safe_mode_t            safeMode;          /*!< Configures the Safe Mode Control.         */\r\n#endif /* FEATURE_SIUL2_HAS_SAFE_MODE_CONTROL */\r\n#if FEATURE_SIUL2_HAS_SLEW_RATE_CONTROL\r\n    port_slew_rate_control_t    slewRateCtrlSel;   /*!< Configures the Slew Rate Control field.   */\r\n#endif /* FEATURE_SIUL2_HAS_SLEW_RATE_CONTROL */\r\n#if FEATURE_SIUL2_HAS_HYSTERESIS\r\n    port_hysteresis_t           hysteresisSelect;  /*!< Configures the Hysteresis Enable.         */\r\n#endif /* FEATURE_SIUL2_HAS_HYSTERESIS */\r\n#if FEATURE_SIUL2_HAS_DDR_PAD\r\n    pin_ddr_config_t            ddrConfiguration;  /*!< Structure that configures the DDR         */\r\n    port_ddr_input_t            inputMode;         /*!< Configures DDR input receiver mode.       */\r\n    port_on_die_termination_t   odtSelect;         /*!< Configures the ODT to select strength.    */\r\n#endif /* FEATURE_SIUL2_HAS_DDR_PAD */\r\n#if FEATURE_SIUL2_HAS_INVERT_DATA_OUTPUT\r\n    port_invert_output_t        invertOutput;      /*!< Configures the Invert Data Output.        */\r\n#endif /* FEATURE_SIUL2_HAS_INVERT_DATA_OUTPUT */\r\n#if FEATURE_SIUL2_HAS_PULL_KEEPER\r\n    port_pull_keep_t            pullKeepEnable;    /*!< Configures the Pull / Keep Enable.        */\r\n    port_pull_keeper_select_t   pullKeepSelect;    /*!< Configures the Pull / Keep Select.        */\r\n    port_pull_up_down_t         pullSelect;        /*!< Configures the Pull Up / Down Config.     */\r\n#endif /* FEATURE_SIUL2_HAS_PULL_KEEPER */\r\n#if FEATURE_SIUL2_HAS_ANALOG_PAD\r\n    port_analog_pad_t           analogPadCtrlSel;  /*!< Configures the Analog Pad Control         */\r\n#endif /* FEATURE_SIUL2_HAS_ANALOG_PAD */\r\n#endif /* FEATURE_PINS_DRIVER_USING_SIUL2 */\r\n    pins_level_type_t           initValue;         /*!< Initial value                             */\r\n} pin_settings_config_t;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n/*!\r\n * @name PINS DRIVER API.\r\n * @{\r\n */\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Initializes the pins with the given configuration structure\r\n *\r\n * This function configures the pins with the options provided in the\r\n * provided structure.\r\n *\r\n * @param[in] pinCount The number of configured pins in structure\r\n * @param[in] config The configuration structure\r\n * @return The status of the operation\r\n */\r\nstatus_t PINS_DRV_Init(uint32_t pinCount,\r\n                       const pin_settings_config_t config[]);\r\n\r\n#ifdef FEATURE_PINS_DRIVER_USING_PORT\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n/*!\r\n * @brief Configures the internal resistor.\r\n *\r\n * This function configures the internal resistor.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @param[in] pullConfig The pull configuration\r\n */\r\nvoid PINS_DRV_SetPullSel(PORT_Type * const base,\r\n                         uint32_t pin,\r\n                         port_pull_config_t pullConfig);\r\n\r\n#endif /* FEATURE_PINS_HAS_PULL_SELECTION */\r\n\r\n/*!\r\n * @brief Configures the pin muxing.\r\n *\r\n * This function configures the pin muxing.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @param[in] mux Pin muxing slot selection\r\n */\r\nvoid PINS_DRV_SetMuxModeSel(PORT_Type * const base,\r\n                            uint32_t pin,\r\n                            port_mux_t mux);\r\n\r\n/*!\r\n * @brief Configures the port pin interrupt/DMA request.\r\n *\r\n * This function configures the port pin interrupt/DMA request.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @param[in] intConfig  Interrupt configuration\r\n */\r\nvoid PINS_DRV_SetPinIntSel(PORT_Type * const base,\r\n                           uint32_t pin,\r\n                           port_interrupt_config_t intConfig);\r\n\r\n/*!\r\n * @brief Gets the current port pin interrupt/DMA request configuration.\r\n *\r\n * This function gets the current port pin interrupt/DMA request configuration.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @return Interrupt configuration\r\n */\r\nport_interrupt_config_t PINS_DRV_GetPinIntSel(const PORT_Type * const base,\r\n                                              uint32_t pin);\r\n\r\n/*!\r\n * @brief Clears the individual pin-interrupt status flag.\r\n *\r\n * This function clears the individual pin-interrupt status flag.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n */\r\nvoid PINS_DRV_ClearPinIntFlagCmd(PORT_Type * const base,\r\n                                 uint32_t pin);\r\n\r\n/*!\r\n * @brief Enables digital filter for digital pin muxing\r\n *\r\n * This function enables digital filter feature for digital pin muxing\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n */\r\nvoid PINS_DRV_EnableDigitalFilter(PORT_Type * const base,\r\n                                  uint32_t pin);\r\n\r\n/*!\r\n * @brief Disables digital filter for digital pin muxing\r\n *\r\n * This function disables digital filter feature for digital pin muxing\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n */\r\nvoid PINS_DRV_DisableDigitalFilter(PORT_Type * const base,\r\n                                   uint32_t pin);\r\n\r\n/*!\r\n * @brief Configures digital filter for port with given configuration\r\n *\r\n * This function configures digital filter for port with given configuration\r\n *\r\n * Note: Updating the filter configuration must be done only after all filters are disabled.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] config the digital filter configuration struct\r\n */\r\nvoid PINS_DRV_ConfigDigitalFilter(PORT_Type * const base,\r\n                                  const port_digital_filter_config_t * const config);\r\n\r\n/*!\r\n * @brief Reads the entire port interrupt status flag\r\n *\r\n * This function reads the entire port interrupt status flag.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @return All 32 pin interrupt status flags\r\n */\r\nuint32_t PINS_DRV_GetPortIntFlag(const PORT_Type * const base);\r\n\r\n/*!\r\n * @brief Clears the entire port interrupt status flag.\r\n *\r\n * This function clears the entire port interrupt status flag.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n */\r\nvoid PINS_DRV_ClearPortIntFlagCmd(PORT_Type * const base);\r\n\r\n/*!\r\n * @brief Quickly configures multiple pins with the same pin configuration.\r\n *\r\n * This function quickly configures multiple pins within the one port for the same peripheral\r\n * function with the same pin configuration. Supports up to 16 pins with the lower or upper\r\n * half of pin registers at the same port.\r\n *\r\n * Note: The set global interrupt control function (PINS_DRV_SetGlobalIntControl) cannot be\r\n * configured if you ever used this function at the same port\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pins Pin mask where each bit represents one pin. For each bit:\r\n *        - 0: pins corresponding to bits with value of '1' is updated with the value input\r\n *        - 1: pins corresponding to bits with value of '0' is not updated with the value input\r\n * @param[in] value the config value will be updated for the pins are set to '1'\r\n * @param[in] halfPort the lower or upper half of pin registers at the same port\r\n */\r\nvoid PINS_DRV_SetGlobalPinControl(PORT_Type * const base,\r\n                                  uint16_t pins,\r\n                                  uint16_t value,\r\n                                  port_global_control_pins_t halfPort);\r\n\r\n/*!\r\n * @brief Quickly configures multiple pins with the same interrupt configuration.\r\n *\r\n * This function quickly configures multiple pins within the one port for the same peripheral\r\n * function with the same interrupt configuration. Supports up to 16 pins with the lower or\r\n * upper half of pin registers at the same port.\r\n *\r\n * Note: The set global pin control function (PINS_DRV_SetGlobalPinControl) cannot be\r\n * configured if you ever used this function at the same port\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pins Pin mask where each bit represents one pin. For each bit:\r\n *        - 0: pins corresponding to bits with value of '1' is updated with the value input\r\n *        - 1: pins corresponding to bits with value of '0' is not updated with the value input\r\n * @param[in] value the config value will be updated for the pins are set to '1'\r\n * @param[in] halfPort the lower or upper half of pin registers at the same port\r\n */\r\nvoid PINS_DRV_SetGlobalIntControl(PORT_Type * const base,\r\n                                  uint16_t pins,\r\n                                  uint16_t value,\r\n                                  port_global_control_pins_t halfPort);\r\n\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n/*!\r\n * @brief Reads the entire over current port interrupt status flag\r\n *\r\n * This function reads the entire over current port interrupt status flag.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @return All 32 pin interrupt status flags\r\n */\r\nuint32_t PINS_DRV_GetOverCurPortIntFlag(const PORT_Type * const base);\r\n\r\n/*!\r\n * @brief Clears the entire over current port interrupt status flag.\r\n *\r\n * This function clears the entire over current port interrupt status flag.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n */\r\nvoid PINS_DRV_ClearOverCurPortIntFlag(PORT_Type * const base);\r\n#endif /* FEATURE_PINS_HAS_OVER_CURRENT */\r\n\r\n/*!\r\n * @brief Get the pins directions configuration for a port\r\n *\r\n * This function returns the current pins directions for a port. Pins\r\n * corresponding to bits with value of '1' are configured as output and\r\n * pins corresponding to bits with value of '0' are configured as input.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO directions. Each bit represents one pin (LSB is pin 0, MSB is\r\n * pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is set to output\r\n */\r\npins_channel_type_t PINS_DRV_GetPinsDirection(const GPIO_Type * const base);\r\n\r\n/*!\r\n * @brief Configure the direction for a certain pin from a port\r\n *\r\n * This function configures the direction for the given pin, with the\r\n * given value('1' for pin to be configured as output and '0' for pin to\r\n * be configured as input)\r\n *\r\n * Note: With some platforms when you want to set a pin as output only and disable\r\n * input completely, it is required to call PINS_DRV_SetPortInputDisable if platform\r\n * has this feature.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pin The pin number for which to configure the direction\r\n * @param[in] direction The pin direction:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is set to output\r\n */\r\nvoid PINS_DRV_SetPinDirection(GPIO_Type * const base,\r\n                              pins_channel_type_t pin,\r\n                              pins_level_type_t direction);\r\n\r\n/*!\r\n * @brief Set the pins directions configuration for a port\r\n *\r\n * This function sets the direction configuration for all pins\r\n * in a port. Pins corresponding to bits with value of '1' will be configured as\r\n * output and pins corresponding to bits with value of '0' will be configured as\r\n * input.\r\n *\r\n * Note: With some platforms when you want to set a pin as output only and disable\r\n * input completely, it is required to call PINS_DRV_SetPortInputDisable if platform\r\n * has this feature.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pins Pin mask where each bit represents one pin (LSB\r\n * is pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is set to output\r\n */\r\nvoid PINS_DRV_SetPinsDirection(GPIO_Type * const base,\r\n                               pins_channel_type_t pins);\r\n\r\n#if FEATURE_PORT_HAS_INPUT_DISABLE\r\n/*!\r\n * @brief Set the pins input disable state for a port\r\n *\r\n * This function sets the pins input state for a port.\r\n * Pins corresponding to bits with value of '1' will not be configured\r\n * as input and pins corresponding to bits with value of '0' will be configured\r\n * as input.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pins Pin mask where each bit represents one pin (LSB is pin 0, MSB is\r\n * pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is not set to input\r\n */\r\nvoid PINS_DRV_SetPortInputDisable(GPIO_Type * const base,\r\n                                  pins_channel_type_t pins);\r\n\r\n/*!\r\n * @brief Get the pins input disable state for a port\r\n *\r\n * This function returns the current pins input state for a port. Pins\r\n * corresponding to bits with value of '1' are not configured as input and\r\n * pins corresponding to bits with value of '0' are configured as input.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO input state. Each bit represents one pin (LSB is pin 0, MSB is\r\n * pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is not set to input\r\n */\r\npins_channel_type_t PINS_DRV_GetPortInputDisable(const GPIO_Type * const base);\r\n#endif /* FEATURE_PORT_HAS_INPUT_DISABLE */\r\n\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n/*!\r\n * @brief Configures the internal resistor.\r\n *\r\n * This function configures the internal resistor.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @param[in] pullConfig The pull configuration\r\n */\r\nvoid PINS_DRV_SetPullSel(PORT_Type * const base,\r\n                         uint16_t pin,\r\n                         port_pull_config_t pullConfig);\r\n\r\n#endif /* FEATURE_PINS_HAS_PULL_SELECTION */\r\n\r\n/*!\r\n * @brief Configures the output buffer.\r\n *\r\n * This function configures the output buffer.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @param[in] enable Enable output buffer\r\n * @param[in] mux Pin muxing slot selection\r\n */\r\nvoid PINS_DRV_SetOutputBuffer(PORT_Type * const base,\r\n                              uint16_t pin,\r\n                              bool enable,\r\n                              port_mux_t mux);\r\n\r\n/*!\r\n * @brief Configures the input buffer.\r\n *\r\n * This function configures the input buffer.\r\n *\r\n * @param[in] base Port base pointer (PORTA, PORTB, PORTC, etc.)\r\n * @param[in] pin Port pin number\r\n * @param[in] enable Enable input buffer\r\n * @param[in] inputMuxReg Pin muxing register slot selection\r\n * @param[in] inputMux Pin muxing slot selection\r\n */\r\nvoid PINS_DRV_SetInputBuffer(PORT_Type * const base,\r\n                             uint16_t pin,\r\n                             bool enable,\r\n                             uint32_t inputMuxReg,\r\n                             port_input_mux_t inputMux);\r\n\r\n/*!\r\n * @brief Configures the interrupt filter clock prescaler.\r\n *\r\n * This function configures the interrupt filter clock prescaler.\r\n *\r\n * @param[in] prescaler The clock prescaler value\r\n */\r\nvoid PINS_DRV_ConfigIntFilterClock(uint8_t prescaler);\r\n\r\n/*!\r\n * @brief Configures the external interrupt.\r\n *\r\n * This function configures the external interrupt.\r\n *\r\n * @param[in] intConfig The configuration for interrupt pin\r\n */\r\nvoid PINS_DRV_SetExInt(siul2_interrupt_config_t intConfig);\r\n\r\n/*!\r\n * @brief Clears the individual pin external interrupt status flag.\r\n *\r\n * This function clears the individual pin external interrupt status flag.\r\n *\r\n * @param[in] eirqPinIdx IRQ pin\r\n */\r\nvoid PINS_DRV_ClearPinExIntFlag(uint32_t eirqPinIdx);\r\n\r\n/*!\r\n * @brief Gets the individual pin external interrupt status flag.\r\n *\r\n * This function gets the individual pin external interrupt status flag.\r\n *\r\n * @param[in] eirqPinIdx IRQ pin\r\n * @return Pin external status flag\r\n */\r\nbool PINS_DRV_GetPinExIntFlag(uint32_t eirqPinIdx);\r\n\r\n/*!\r\n * @brief Clears the entire external interrupt status flag.\r\n *\r\n * This function clears the entire external interrupt status flag.\r\n */\r\nvoid PINS_DRV_ClearExIntFlag(void);\r\n\r\n/*!\r\n * @brief Reads the entire external interrupt status flag\r\n *\r\n * This function reads the entire external interrupt status flag.\r\n *\r\n * @return All 32 IRQ pins\r\n */\r\nuint32_t PINS_DRV_GetExIntFlag(void);\r\n\r\n#endif /* FEATURE_PINS_DRIVER_USING_PORT */\r\n\r\n/*!\r\n * @brief Write a pin of a port with a given value\r\n *\r\n * This function writes the given pin from a port, with the given value\r\n * ('0' represents LOW, '1' represents HIGH).\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pin Pin number to be written\r\n * @param[in] value Pin value to be written\r\n *        - 0: corresponding pin is set to LOW\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nvoid PINS_DRV_WritePin(GPIO_Type * const base,\r\n                       pins_channel_type_t pin,\r\n                       pins_level_type_t value);\r\n\r\n/*!\r\n * @brief Write all pins of a port\r\n *\r\n * This function writes all pins configured as output with the values given in\r\n * the parameter pins. '0' represents LOW, '1' represents HIGH.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pins Pin mask to be written\r\n *        - 0: corresponding pin is set to LOW\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nvoid PINS_DRV_WritePins(GPIO_Type * const base,\r\n                        pins_channel_type_t pins);\r\n\r\n/*!\r\n * @brief Get the current output from a port\r\n *\r\n * This function returns the current output that is written to a port. Only pins\r\n * that are configured as output will have meaningful values.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO outputs. Each bit represents one pin (LSB is pin 0, MSB is pin\r\n * 31). For each bit:\r\n *        - 0: corresponding pin is set to LOW\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\npins_channel_type_t PINS_DRV_GetPinsOutput(const GPIO_Type * const base);\r\n\r\n/*!\r\n * @brief Write pins with 'Set' value\r\n *\r\n * This function configures output pins listed in parameter pins (bits that are\r\n * '1') to have a value of 'set' (HIGH). Pins corresponding to '0' will be\r\n * unaffected.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pins Pin mask of bits to be set. Each bit represents one pin (LSB is\r\n * pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is unaffected\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nvoid PINS_DRV_SetPins(GPIO_Type * const base,\r\n                      pins_channel_type_t pins);\r\n\r\n/*!\r\n * @brief Write pins to 'Clear' value\r\n *\r\n * This function configures output pins listed in parameter pins (bits that are\r\n * '1') to have a 'cleared' value (LOW). Pins corresponding to '0' will be\r\n * unaffected.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pins Pin mask of bits to be cleared. Each bit represents one pin (LSB\r\n * is pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is unaffected\r\n *        - 1: corresponding pin is cleared(set to LOW)\r\n */\r\nvoid PINS_DRV_ClearPins(GPIO_Type * const base,\r\n                        pins_channel_type_t pins);\r\n\r\n/*!\r\n * @brief Toggle pins value\r\n *\r\n * This function toggles output pins listed in parameter pins (bits that are\r\n * '1'). Pins corresponding to '0' will be unaffected.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param[in] pins Pin mask of bits to be toggled.  Each bit represents one pin (LSB\r\n * is pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is unaffected\r\n *        - 1: corresponding pin is toggled\r\n */\r\nvoid PINS_DRV_TogglePins(GPIO_Type * const base,\r\n                         pins_channel_type_t pins);\r\n\r\n/*!\r\n * @brief Read input pins\r\n *\r\n * This function returns the current input values from a port. Only pins\r\n * configured as input will have meaningful values.\r\n *\r\n * @param[in] base GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO inputs. Each bit represents one pin (LSB is pin 0, MSB is pin\r\n * 31). For each bit:\r\n *        - 0: corresponding pin is read as LOW\r\n *        - 1: corresponding pin is read as HIGH\r\n */\r\npins_channel_type_t PINS_DRV_ReadPins(const GPIO_Type * const base);\r\n\r\n/*! @} */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n#endif /* PINS_DRIVER_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"pins_gpio_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef PINS_GPIO_HW_ACCESS_H\r\n#define PINS_GPIO_HW_ACCESS_H\r\n\r\n#include \"pins_driver.h\"\r\n\r\n/*! @file */\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Local macro not referenced.\r\n * The defined macro is used as include guard.\r\n *\r\n */\r\n\r\n/*!\r\n * pins_gpio_hw_access\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name GPIO\r\n * General GPIO functions.\r\n */\r\n/*! @{*/\r\n\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n/*!\r\n * @brief Get the pins directions configuration for a port\r\n *\r\n * This function returns the current pins directions for a port. Pins\r\n * corresponding to bits with value of '1' are configured as output and\r\n * pins corresponding to bits with value of '0' are configured as input.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO directions. Each bit represents one pin (LSB is pin 0, MSB is\r\n * pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is set to output\r\n */\r\nstatic inline pins_channel_type_t PINS_GPIO_GetPinsDirection(const GPIO_Type * const base)\r\n{\r\n    return (pins_channel_type_t)base->PDDR;\r\n}\r\n\r\n/*!\r\n * @brief Configure the direction for a certain pin from a port\r\n *\r\n * This function configures the direction for the given pin, with the\r\n * given value('1' for pin to be configured as output and '0' for pin to\r\n * be configured as input)\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pin the pin number for which to configure the direction\r\n * @param direction the pin direction:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is set to output\r\n */\r\nstatic inline void PINS_GPIO_SetPinDirection(GPIO_Type * const base,\r\n                                             pins_channel_type_t pin,\r\n                                             pins_level_type_t direction)\r\n{\r\n    pins_channel_type_t pinsDirections = (pins_channel_type_t)base->PDDR;\r\n    pinsDirections &= (pins_channel_type_t)(~((pins_channel_type_t)1U << pin));\r\n    pinsDirections |= (pins_channel_type_t)((pins_channel_type_t)direction << pin);\r\n    base->PDDR = GPIO_PDDR_PDD(pinsDirections);\r\n}\r\n\r\n/*!\r\n * @brief Set the pins directions configuration for a port\r\n *\r\n * This function sets the direction configuration for all pins\r\n * in a port. Pins corresponding to bits with value of '1' will be configured as\r\n * output and pins corresponding to bits with value of '0' will be configured as\r\n * input.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pins pin mask where each bit represents one pin (LSB\r\n * is pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is set to output\r\n */\r\nstatic inline void PINS_GPIO_SetPinsDirection(GPIO_Type * const base,\r\n                                              pins_channel_type_t pins)\r\n{\r\n    base->PDDR = GPIO_PDDR_PDD(pins);\r\n}\r\n\r\n#if FEATURE_PORT_HAS_INPUT_DISABLE\r\n/*!\r\n * @brief Set the pins input disable state for a port\r\n *\r\n * This function sets the pins input state for a port.\r\n * Pins corresponding to bits with value of '1' will not be configured\r\n * as input and pins corresponding to bits with value of '0' will be configured\r\n * as input.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pins pin mask where each bit represents one pin (LSB is pin 0, MSB is\r\n * pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is not set to input\r\n */\r\nstatic inline void PINS_GPIO_SetPortInputDisable(GPIO_Type * const base,\r\n                                                 pins_channel_type_t pins)\r\n{\r\n    base->PIDR = GPIO_PIDR_PID(pins);\r\n}\r\n\r\n/*!\r\n * @brief Get the pins input disable state for a port\r\n *\r\n * This function returns the current pins input state for a port. Pins\r\n * corresponding to bits with value of '1' are not configured as input and\r\n * pins corresponding to bits with value of '0' are configured as input.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO input state. Each bit represents one pin (LSB is pin 0, MSB is\r\n * pin 31). For each bit:\r\n *        - 0: corresponding pin is set to input\r\n *        - 1: corresponding pin is not set to input\r\n */\r\nstatic inline pins_channel_type_t PINS_GPIO_GetPortInputDisable(const GPIO_Type * const base)\r\n{\r\n    return (pins_channel_type_t)base->PIDR;\r\n}\r\n#endif /* FEATURE_PORT_HAS_INPUT_DISABLE */\r\n\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n/* Reverse bit order in each halfword independently */\r\nstatic inline uint16_t REV_BIT_16(uint16_t value)\r\n{\r\n    uint8_t i;\r\n    uint16_t ret = 0U;\r\n\r\n    for (i = 0U; i < 8U; i++)\r\n    {\r\n        ret |= (uint16_t)((((value >> i) & 1U) << (15U - i)) | (((value << i) & 0x8000U) >> (15U - i)));\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n\r\n/*!\r\n * @brief Write a pin of a port with a given value\r\n *\r\n * This function writes the given pin from a port, with the given value\r\n * ('0' represents LOW, '1' represents HIGH).\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pin pin number to be written\r\n * @param value pin value to be written\r\n *        - 0: corresponding pin is set to LOW\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nstatic inline void PINS_GPIO_WritePin(GPIO_Type * const base,\r\n                                      pins_channel_type_t pin,\r\n                                      pins_level_type_t value)\r\n{\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    pins_channel_type_t pinsValues = (pins_channel_type_t)base->PDOR;\r\n    pinsValues &= (pins_channel_type_t)(~((pins_channel_type_t)1U << pin));\r\n    pinsValues |= (pins_channel_type_t)((pins_channel_type_t)value << pin);\r\n    base->PDOR = GPIO_PDOR_PDO(pinsValues);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    pins_channel_type_t pinsValues = (pins_channel_type_t)base->PGPDO;\r\n    pinsValues &= (pins_channel_type_t)(~((pins_channel_type_t)1U << (15U - pin)));\r\n    pinsValues |= (pins_channel_type_t)((pins_channel_type_t)value << (15U - pin));\r\n    base->PGPDO = pinsValues;\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n}\r\n\r\n/*!\r\n * @brief Write all pins of a port\r\n *\r\n * This function writes all pins configured as output with the values given in\r\n * the parameter pins. '0' represents LOW, '1' represents HIGH.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pins pin mask to be written\r\n *        - 0: corresponding pin is set to LOW\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nstatic inline void PINS_GPIO_WritePins(GPIO_Type * const base,\r\n                                       pins_channel_type_t pins)\r\n{\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    base->PDOR = GPIO_PDOR_PDO(pins);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    base->PGPDO = REV_BIT_16(pins);\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n}\r\n\r\n/*!\r\n * @brief Get the current output from a port\r\n *\r\n * This function returns the current output that is written to a port. Only pins\r\n * that are configured as output will have meaningful values.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO outputs. Each bit represents one pin (LSB is pin 0, MSB is pin\r\n * 31). For each bit:\r\n *        - 0: corresponding pin is set to LOW\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nstatic inline pins_channel_type_t PINS_GPIO_GetPinsOutput(const GPIO_Type * const base)\r\n{\r\n    pins_channel_type_t returnValue = 0U;\r\n\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    returnValue = (pins_channel_type_t)(base->PDOR);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    returnValue = (pins_channel_type_t)REV_BIT_16(base->PGPDO);\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n\r\n    return returnValue;\r\n}\r\n\r\n/*!\r\n * @brief Write pins with 'Set' value\r\n *\r\n * This function configures output pins listed in parameter pins (bits that are\r\n * '1') to have a value of 'set' (HIGH). Pins corresponding to '0' will be\r\n * unaffected.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pins pin mask of bits to be set.  Each bit represents one pin (LSB is\r\n * pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is unaffected\r\n *        - 1: corresponding pin is set to HIGH\r\n */\r\nstatic inline void PINS_GPIO_SetPins(GPIO_Type * const base,\r\n                                     pins_channel_type_t pins)\r\n{\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    base->PSOR = GPIO_PSOR_PTSO(pins);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    base->PGPDO |= REV_BIT_16(pins);\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n}\r\n\r\n/*!\r\n * @brief Write pins to 'Clear' value\r\n *\r\n * This function configures output pins listed in parameter pins (bits that are\r\n * '1') to have a 'cleared' value (LOW). Pins corresponding to '0' will be\r\n * unaffected.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pins pin mask of bits to be cleared.  Each bit represents one pin (LSB\r\n * is pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is unaffected\r\n *        - 1: corresponding pin is cleared(set to LOW)\r\n */\r\nstatic inline void PINS_GPIO_ClearPins(GPIO_Type * const base,\r\n                                       pins_channel_type_t pins)\r\n{\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    base->PCOR = GPIO_PCOR_PTCO(pins);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    base->PGPDO &= (pins_channel_type_t)(~REV_BIT_16(pins));\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n}\r\n\r\n/*!\r\n * @brief Toggle pins value\r\n *\r\n * This function toggles output pins listed in parameter pins (bits that are\r\n * '1'). Pins corresponding to '0' will be unaffected.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @param pins pin mask of bits to be toggled.  Each bit represents one pin (LSB\r\n * is pin 0, MSB is pin 31). For each bit:\r\n *        - 0: corresponding pin is unaffected\r\n *        - 1: corresponding pin is toggled\r\n */\r\nstatic inline void PINS_GPIO_TogglePins(GPIO_Type * const base,\r\n                                        pins_channel_type_t pins)\r\n{\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    base->PTOR = GPIO_PTOR_PTTO(pins);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    base->PGPDO ^= REV_BIT_16(pins);\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n}\r\n\r\n/*!\r\n * @brief Read input pins\r\n *\r\n * This function returns the current input values from a port. Only pins\r\n * configured as input will have meaningful values.\r\n *\r\n * @param base  GPIO base pointer (PTA, PTB, PTC, etc.)\r\n * @return GPIO inputs. Each bit represents one pin (LSB is pin 0, MSB is pin\r\n * 31). For each bit:\r\n *        - 0: corresponding pin is read as LOW\r\n *        - 1: corresponding pin is read as HIGH\r\n */\r\nstatic inline pins_channel_type_t PINS_GPIO_ReadPins(const GPIO_Type * const base)\r\n{\r\n    pins_channel_type_t returnValue = 0U;\r\n\r\n#if defined(FEATURE_PINS_DRIVER_USING_PORT)\r\n    returnValue = (pins_channel_type_t)(base->PDIR);\r\n#elif defined(FEATURE_PINS_DRIVER_USING_SIUL2)\r\n    returnValue = (pins_channel_type_t)REV_BIT_16(base->PGPDI);\r\n#endif /* if defined(FEATURE_PINS_DRIVER_USING_PORT) */\r\n\r\n    return returnValue;\r\n}\r\n\r\n/*! @} */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n#endif /* PINS_GPIO_HW_ACCESS_H*/\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"pins_port_hw_access.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright 2017-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#include \"pins_port_hw_access.h\"\r\n#include \"pins_gpio_hw_access.h\"\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from 'essentially Boolean'\r\n * to 'essentially unsigned'. This is required by the conversion of a bool into a bit.\r\n * Impermissible cast; cannot cast from 'essentially unsigned' to 'essentially enum<i>'.\r\n * This is required by the conversion of a bitfield of a register into a enum.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, Global typedef not referenced.\r\n * The enumeration structure is used by user to enable or disable adc interleved channel.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, Conversion between a pointer and\r\n * integer type.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, Cast from unsigned int to pointer.\r\n * The cast is required to initialize a pointer with an unsigned long define,\r\n * representing an address.\r\n *\r\n */\r\n\r\n#if FEATURE_SOC_PORT_COUNT > 0\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n#if FEATURE_PINS_HAS_ADC_INTERLEAVE_EN\r\n/*!\r\n * @brief ADC Interleave muxing selection\r\n */\r\ntypedef enum\r\n{\r\n    PIN_ADC_INTERLEAVE_DISABLE0    = 0xEu,   /*!< xxx0b ADC1_SE14 channel is connected to PTB15 */\r\n    PIN_ADC_INTERLEAVE_DISABLE1    = 0xDu,   /*!< xx0xb ADC1_SE15 channel is connected to PTB16 */\r\n    PIN_ADC_INTERLEAVE_DISABLE2    = 0xBu,   /*!< x0xxb ADC0_SE8  channel is connected to PTC0  */\r\n    PIN_ADC_INTERLEAVE_DISABLE3    = 0x7u,   /*!< 0xxxb ADC0_SE9  channel is connected to PTC1  */\r\n    PIN_ADC_INTERLEAVE_ENABLE0     = 0x1u,   /*!< xxx1b ADC1_SE14 channel is connected to PTB0  */\r\n    PIN_ADC_INTERLEAVE_ENABLE1     = 0x2u,   /*!< xx1xb ADC1_SE15 channel is connected to PTB1  */\r\n    PIN_ADC_INTERLEAVE_ENABLE2     = 0x4u,   /*!< x1xxb ADC0_SE8  channel is connected to PTB13 */\r\n    PIN_ADC_INTERLEAVE_ENABLE3     = 0x8u,   /*!< 1xxxb ADC0_SE9  channel is connected to PTB14 */\r\n    PIN_ADC_INTERLEAVE_INVALID     = 0xFFu   /*!< ADC interleave is invalid                     */\r\n} pin_adc_interleave_mux_t;\r\n\r\nstatic uint32_t PINS_GetAdcInterleaveVal(const PORT_Type * base,\r\n                                         const uint32_t pinPortIdx,\r\n                                         const uint32_t currentVal)\r\n{\r\n    uint32_t adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_INVALID;\r\n    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */\r\n    if ((uint32_t)base == (uint32_t)PORTB)\r\n    {\r\n        switch (pinPortIdx)\r\n        {\r\n            case 0:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE0 | currentVal;\r\n                break;\r\n            case 1:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE1 | currentVal;\r\n                break;\r\n            case 13:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE2 | currentVal;\r\n                break;\r\n            case 14:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE3 | currentVal;\r\n                break;\r\n            case 15:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE0 & currentVal;\r\n                break;\r\n            case 16:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE1 & currentVal;\r\n                break;\r\n            default:\r\n                /* invalid command */\r\n                break;\r\n        }\r\n    }\r\n    else if ((uint32_t)base == (uint32_t)PORTC)\r\n    {\r\n        switch (pinPortIdx)\r\n        {\r\n            case 0:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE2 & currentVal;\r\n                break;\r\n            case 1:\r\n                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE3 & currentVal;\r\n                break;\r\n            default:\r\n                /* invalid command */\r\n                break;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /* invalid command */\r\n    }\r\n    return adcInterleaveVal;\r\n}\r\n#endif /* FEATURE_PINS_HAS_ADC_INTERLEAVE_EN */\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_Init\r\n * Description   : This function configures the pins with the options provided\r\n * in the provided structure.\r\n *\r\n *END**************************************************************************/\r\nvoid PINS_Init(const pin_settings_config_t * config)\r\n{\r\n    DEV_ASSERT(config->base != NULL);\r\n    DEV_ASSERT((PORT_MUX_AS_GPIO != config->mux) || (config->gpioBase != NULL));\r\n    DEV_ASSERT(config->pinPortIdx < PORT_PCR_COUNT);\r\n    uint32_t regValue = config->base->PCR[config->pinPortIdx];\r\n    uint32_t directions;\r\n    uint32_t digitalFilters;\r\n    port_mux_t muxing;\r\n\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n    switch (config->pullConfig)\r\n    {\r\n        case PORT_INTERNAL_PULL_NOT_ENABLED:\r\n            {\r\n                regValue &= ~(PORT_PCR_PE_MASK);\r\n            }\r\n            break;\r\n        case PORT_INTERNAL_PULL_DOWN_ENABLED:\r\n            {\r\n                regValue &= ~(PORT_PCR_PS_MASK);\r\n                regValue |= PORT_PCR_PE(1U);\r\n            }\r\n            break;\r\n        case PORT_INTERNAL_PULL_UP_ENABLED:\r\n            {\r\n                regValue |= PORT_PCR_PE(1U);\r\n                regValue |= PORT_PCR_PS(1U);\r\n            }\r\n            break;\r\n        default:\r\n            /* invalid command */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n#endif /* FEATURE_PINS_HAS_PULL_SELECTION */\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n    switch (config->overCurConfig)\r\n    {\r\n        case PORT_OVER_CURRENT_DISABLED:\r\n            {\r\n                regValue &= ~(PORT_PCR_OCE_MASK);\r\n            }\r\n            break;\r\n        case PORT_OVER_CURRENT_INT_DISABLED:\r\n            {\r\n                regValue &= ~(PORT_PCR_OCIE_MASK);\r\n                regValue |= PORT_PCR_OCE_MASK;\r\n            }\r\n            break;\r\n        case PORT_OVER_CURRENT_INT_ENABLED:\r\n            {\r\n                regValue |= PORT_PCR_OCIE_MASK;\r\n                regValue |= PORT_PCR_OCE_MASK;\r\n            }\r\n            break;\r\n        default:\r\n            /* invalid command */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n    if (config->clearOCurFlag)\r\n    {\r\n        regValue &= ~(PORT_PCR_OCF_MASK);\r\n        regValue |= PORT_PCR_OCF(1U);\r\n    }\r\n#endif /* FEATURE_PINS_HAS_OVER_CURRENT */\r\n#if FEATURE_PINS_HAS_SLEW_RATE\r\n    regValue &= ~(PORT_PCR_SRE_MASK);\r\n    regValue |= PORT_PCR_SRE(config->rateSelect);\r\n#endif\r\n#if FEATURE_PORT_HAS_PASSIVE_FILTER\r\n    regValue &= ~(PORT_PCR_PFE_MASK);\r\n    regValue |= PORT_PCR_PFE(config->passiveFilter);\r\n#endif\r\n#if FEATURE_PINS_HAS_OPEN_DRAIN\r\n    regValue &= ~(PORT_PCR_ODE_MASK);\r\n    regValue |= PORT_PCR_ODE(config->openDrain);\r\n#endif\r\n#if FEATURE_PINS_HAS_DRIVE_STRENGTH\r\n    regValue &= ~(PORT_PCR_DSE_MASK);\r\n    regValue |= PORT_PCR_DSE(config->driveSelect);\r\n#endif\r\n    regValue &= ~(PORT_PCR_MUX_MASK);\r\n    muxing = config->mux;\r\n#if FEATURE_PINS_HAS_ADC_INTERLEAVE_EN\r\n    if (muxing == PORT_MUX_ADC_INTERLEAVE)\r\n    {\r\n        /* Get ADC Interleave from SIM and enable/disable desired bit */\r\n        uint32_t chipCtlReg = (SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;\r\n        uint32_t interleaveVal = PINS_GetAdcInterleaveVal(config->base, config->pinPortIdx, chipCtlReg);\r\n        if (interleaveVal != (uint32_t)PIN_ADC_INTERLEAVE_INVALID)\r\n        {\r\n            SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);\r\n            SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);\r\n        }\r\n        /* return real muxing for pin */\r\n        muxing = PORT_PIN_DISABLED;\r\n    }\r\n#endif\r\n    regValue |= PORT_PCR_MUX(muxing);\r\n#if FEATURE_PORT_HAS_PIN_CONTROL_LOCK\r\n    regValue &= ~(PORT_PCR_LK_MASK);\r\n    regValue |= PORT_PCR_LK(config->pinLock);\r\n#endif\r\n    regValue &= ~(PORT_PCR_IRQC_MASK);\r\n    regValue |= PORT_PCR_IRQC(config->intConfig);\r\n    if (config->clearIntFlag)\r\n    {\r\n        regValue &= ~(PORT_PCR_ISF_MASK);\r\n        regValue |= PORT_PCR_ISF(1U);\r\n    }\r\n\r\n    config->base->PCR[config->pinPortIdx] = regValue;\r\n\r\n    /* Read current digital filter of port */\r\n    digitalFilters = (uint32_t)(config->base->DFER);\r\n    digitalFilters &= ~(1UL << (config->pinPortIdx));\r\n    digitalFilters |= (((uint32_t)(config->digitalFilter)) << (config->pinPortIdx));\r\n    /* Write to digital filter enable register */\r\n    config->base->DFER = digitalFilters;\r\n\r\n    /* If gpioBase address not null setup the direction of pin */\r\n    if (PORT_MUX_AS_GPIO == config->mux)\r\n    {\r\n        /* Read current direction */\r\n        directions = (uint32_t)(config->gpioBase->PDDR);\r\n        switch (config->direction)\r\n        {\r\n            case GPIO_INPUT_DIRECTION:\r\n                directions &= ~(1UL << config->pinPortIdx);\r\n                break;\r\n            case GPIO_OUTPUT_DIRECTION:\r\n                directions |= (1UL << config->pinPortIdx);\r\n                break;\r\n            case GPIO_UNSPECIFIED_DIRECTION:\r\n            /* pass-through */\r\n            default:\r\n                /* nothing to configure */\r\n                DEV_ASSERT(false);\r\n                break;\r\n        }\r\n\r\n        /* Configure initial value for output */\r\n        if (config->direction == GPIO_OUTPUT_DIRECTION)\r\n        {\r\n            PINS_GPIO_WritePin(config->gpioBase, config->pinPortIdx, config->initValue);\r\n        }\r\n\r\n        /* Configure direction */\r\n        config->gpioBase->PDDR = GPIO_PDDR_PDD(directions);\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_SetMuxModeSel\r\n * Description   : This function configures the pin muxing and support configuring\r\n * for the pins that have ADC interleaved channel as well.\r\n *\r\n *END**************************************************************************/\r\nvoid PINS_SetMuxModeSel(PORT_Type * const base,\r\n                        uint32_t pin,\r\n                        port_mux_t mux)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    uint32_t regValue = base->PCR[pin];\r\n    port_mux_t muxing = mux;\r\n\r\n#if FEATURE_PINS_HAS_ADC_INTERLEAVE_EN\r\n    if (muxing == PORT_MUX_ADC_INTERLEAVE)\r\n    {\r\n        /* Get ADC Interleave from SIM and enable/disable desired bit */\r\n        uint32_t chipCtlReg = (SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;\r\n        uint32_t interleaveVal = PINS_GetAdcInterleaveVal(base, pin, chipCtlReg);\r\n        if (interleaveVal != (uint32_t)PIN_ADC_INTERLEAVE_INVALID)\r\n        {\r\n            SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);\r\n            SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);\r\n        }\r\n        /* return real muxing for pin */\r\n        muxing = PORT_PIN_DISABLED;\r\n    }\r\n#endif\r\n    regValue &= ~(PORT_PCR_MUX_MASK);\r\n    regValue |= PORT_PCR_MUX(muxing);\r\n    base->PCR[pin] = regValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_SetGlobalPinControl\r\n * Description   : Quickly configures multiple pins with the same pin configuration.\r\n *\r\n *END**************************************************************************/\r\nvoid PINS_SetGlobalPinControl(PORT_Type * const base,\r\n                              uint16_t pins,\r\n                              uint16_t value,\r\n                              port_global_control_pins_t halfPort)\r\n{\r\n    uint16_t mask = 0;\r\n    /* keep only available fields */\r\n    mask |= PORT_PCR_PS_MASK;\r\n    mask |= PORT_PCR_PE_MASK;\r\n#if FEATURE_PINS_HAS_SLEW_RATE\r\n    mask |= PORT_PCR_SRE_MASK;\r\n#endif /* FEATURE_PINS_HAS_OPEN_DRAIN */\r\n    mask |= PORT_PCR_PFE_MASK;\r\n#if FEATURE_PINS_HAS_OPEN_DRAIN\r\n    mask |= PORT_PCR_ODE_MASK;\r\n#endif /* FEATURE_PINS_HAS_OPEN_DRAIN */\r\n    mask |= PORT_PCR_DSE_MASK;\r\n    mask |= PORT_PCR_MUX_MASK;\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n    mask |= PORT_PCR_OCE_MASK;\r\n#endif /* FEATURE_PINS_HAS_OVER_CURRENT */\r\n    mask |= PORT_PCR_LK_MASK;\r\n    mask &= value;\r\n\r\n    switch (halfPort)\r\n    {\r\n        case PORT_GLOBAL_CONTROL_LOWER_HALF_PINS:\r\n            base->GPCLR = (((uint32_t)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32_t)mask;\r\n            break;\r\n        case PORT_GLOBAL_CONTROL_UPPER_HALF_PINS:\r\n            base->GPCHR = (((uint32_t)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32_t)mask;\r\n            break;\r\n        default:\r\n            /* nothing to configure */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : PINS_SetGlobalIntControl\r\n * Description   : Quickly configures multiple pins with the same interrupt configuration.\r\n *\r\n *END**************************************************************************/\r\nvoid PINS_SetGlobalIntControl(PORT_Type * const base,\r\n                              uint16_t pins,\r\n                              uint16_t value,\r\n                              port_global_control_pins_t halfPort)\r\n{\r\n    uint32_t mask;\r\n    mask = (((uint32_t)value) << PORT_GICLR_GIWD_SHIFT) & PORT_PCR_IRQC_MASK;\r\n\r\n    switch (halfPort)\r\n    {\r\n        case PORT_GLOBAL_CONTROL_LOWER_HALF_PINS:\r\n            base->GICLR = ((uint32_t)pins) | mask;\r\n            break;\r\n        case PORT_GLOBAL_CONTROL_UPPER_HALF_PINS:\r\n            base->GICHR = ((uint32_t)pins) | mask;\r\n            break;\r\n        default:\r\n            /* nothing to configure */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n}\r\n\r\n#endif /* FEATURE_SOC_PORT_COUNT */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"pins_port_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright 2017-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef PINS_PORT_HW_ACCESS_H\r\n#define PINS_PORT_HW_ACCESS_H\r\n\r\n#include \"pins_driver.h\"\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.3, The value of an expression\r\n * shall not be assigned to an object with a narrower essential type or of a\r\n * different essential type category.\r\n * The cast is required to perform a conversion between an unsigned integer\r\n * and an enum type with many values.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from\r\n * 'essentially unsigned' type to 'essentially enum<i>'.\r\n * This is required by the conversion of a bit-field of a register into a enum type.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 10.5, Impermissible cast; cannot cast from\r\n * 'essentially unsigned' type to 'essentially Boolean'.\r\n * This is required by the conversion of a bit into a bool type.\r\n *\r\n */\r\n\r\n/*!\r\n * @defgroup port_hal Port Control and Interrupts (PORT)\r\n * @ingroup pins_driver\r\n * @brief This module covers the functionality of the PORT peripheral.\r\n * <p>\r\n *  PORT HAL provides the API for reading and writing register bit-fields belonging to the PORT module.\r\n * </p>\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @name Configuration\r\n * @{\r\n */\r\n\r\n/*!\r\n * @brief Initializes the pins with the given configuration structure\r\n *\r\n * This function configures the pins with the options provided in the\r\n * given structure.\r\n *\r\n * @param[in] config the configuration structure\r\n */\r\nvoid PINS_Init(const pin_settings_config_t * config);\r\n\r\n#if FEATURE_PINS_HAS_PULL_SELECTION\r\n/*!\r\n * @brief Configures the internal resistor.\r\n *\r\n * Pull configuration is valid in all digital pin muxing modes.\r\n *\r\n * @param[in] base        port base pointer.\r\n * @param[in] pin         port pin number\r\n * @param[in] pullConfig  internal resistor pull feature selection\r\n *        - PORT_PULL_NOT_ENABLED: internal pull-down or pull-up resistor is not enabled.\r\n *        - PORT_PULL_DOWN_ENABLED: internal pull-down resistor is enabled.\r\n *        - PORT_PULL_UP_ENABLED: internal pull-up resistor is enabled.\r\n */\r\nstatic inline void PINS_SetPullSel(PORT_Type * const base,\r\n                                   uint32_t pin,\r\n                                   port_pull_config_t pullConfig)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    switch (pullConfig)\r\n    {\r\n        case PORT_INTERNAL_PULL_NOT_ENABLED:\r\n            {\r\n                base->PCR[pin] &= ~(PORT_PCR_PE_MASK);\r\n            }\r\n            break;\r\n        case PORT_INTERNAL_PULL_DOWN_ENABLED:\r\n            {\r\n                uint32_t regValue = base->PCR[pin];\r\n                regValue &= ~(PORT_PCR_PS_MASK);\r\n                regValue |= PORT_PCR_PE(1U);\r\n                base->PCR[pin] = regValue;\r\n            }\r\n            break;\r\n        case PORT_INTERNAL_PULL_UP_ENABLED:\r\n            {\r\n                uint32_t regValue = base->PCR[pin];\r\n                regValue |= PORT_PCR_PE(1U);\r\n                regValue |= PORT_PCR_PS(1U);\r\n                base->PCR[pin] = regValue;\r\n            }\r\n            break;\r\n        default:\r\n            /* invalid command */\r\n            DEV_ASSERT(false);\r\n            break;\r\n    }\r\n}\r\n\r\n#endif /* if FEATURE_PINS_HAS_PULL_SELECTION */\r\n\r\n/*!\r\n * @brief Configures the pin muxing.\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pin  port pin number\r\n * @param[in] mux  pin muxing slot selection\r\n *        - PORT_PIN_DISABLED: Pin disabled.\r\n *        - PORT_MUX_AS_GPIO : Set as GPIO.\r\n *        - PORT_MUX_ADC_INTERLEAVE : For ADC interleaved\r\n *        - others           : chip-specific.\r\n */\r\nvoid PINS_SetMuxModeSel(PORT_Type * const base,\r\n                        uint32_t pin,\r\n                        port_mux_t mux);\r\n\r\n/*!\r\n * @brief Configures the port pin interrupt/DMA request.\r\n *\r\n * @param[in] base       port base pointer.\r\n * @param[in] pin        port pin number\r\n * @param[in] intConfig  interrupt configuration\r\n *        - PORT_INT_DISABLED     : Interrupt/DMA request disabled.\r\n *        - PORT_DMA_RISING_EDGE  : DMA request on rising edge.\r\n *        - PORT_DMA_FALLING_EDGE : DMA request on falling edge.\r\n *        - PORT_DMA_EITHER_EDGE  : DMA request on either edge.\r\n *        - PORT_FLAG_RISING_EDGE : Flag sets on rising edge only.\r\n *        - PORT_FLAG_FALLING_EDGE: Flag sets on falling edge only.\r\n *        - PORT_FLAG_EITHER_EDGE : Flag sets on either edge only.\r\n *        - PORT_INT_LOGIC_ZERO   : Interrupt when logic zero.\r\n *        - PORT_INT_RISING_EDGE  : Interrupt on rising edge.\r\n *        - PORT_INT_FALLING_EDGE : Interrupt on falling edge.\r\n *        - PORT_INT_EITHER_EDGE  : Interrupt on either edge.\r\n *        - PORT_INT_LOGIC_ONE    : Interrupt when logic one.\r\n *        - PORT_HIGH_TRIGGER_OUT : Enable active high trigger output, flag is disabled.\r\n *        - PORT_LOW_TRIGGER_OUT  : Enable active low trigger output, flag is disabled.\r\n */\r\nstatic inline void PINS_SetPinIntSel(PORT_Type * const base,\r\n                                     uint32_t pin,\r\n                                     port_interrupt_config_t intConfig)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    uint32_t regValue = base->PCR[pin];\r\n    regValue &= ~(PORT_PCR_IRQC_MASK);\r\n    regValue |= PORT_PCR_IRQC(intConfig);\r\n    base->PCR[pin] = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Gets the current port pin interrupt/DMA request configuration.\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pin   port pin number\r\n * @return  interrupt configuration\r\n *        - PORT_INT_DISABLED     : Interrupt/DMA request disabled.\r\n *        - PORT_DMA_RISING_EDGE  : DMA request on rising edge.\r\n *        - PORT_DMA_FALLING_EDGE : DMA request on falling edge.\r\n *        - PORT_DMA_EITHER_EDGE  : DMA request on either edge.\r\n *        - PORT_FLAG_RISING_EDGE : Flag sets on rising edge only.\r\n *        - PORT_FLAG_FALLING_EDGE: Flag sets on falling edge only.\r\n *        - PORT_FLAG_EITHER_EDGE : Flag sets on either edge only.\r\n *        - PORT_INT_LOGIC_ZERO   : Interrupt when logic zero.\r\n *        - PORT_INT_RISING_EDGE  : Interrupt on rising edge.\r\n *        - PORT_INT_FALLING_EDGE : Interrupt on falling edge.\r\n *        - PORT_INT_EITHER_EDGE  : Interrupt on either edge.\r\n *        - PORT_INT_LOGIC_ONE    : Interrupt when logic one.\r\n *        - PORT_HIGH_TRIGGER_OUT : Enable active high trigger output, flag is disabled.\r\n *        - PORT_LOW_TRIGGER_OUT  : Enable active low trigger output, flag is disabled.\r\n */\r\nstatic inline port_interrupt_config_t PINS_GetPinIntSel(const PORT_Type * const base,\r\n                                                        uint32_t pin)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    uint32_t regValue = base->PCR[pin];\r\n    regValue = (regValue & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT;\r\n\r\n    return (port_interrupt_config_t)regValue;\r\n}\r\n\r\n/*!\r\n * @brief Clears the individual pin-interrupt status flag.\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pin   port pin number\r\n */\r\nstatic inline void PINS_ClearPinIntFlagCmd(PORT_Type * const base,\r\n                                           uint32_t pin)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    uint32_t regValue = base->PCR[pin];\r\n    regValue &= ~(PORT_PCR_ISF_MASK);\r\n    regValue |= PORT_PCR_ISF(1U);\r\n    base->PCR[pin] = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Enables digital filter for digital pin muxing\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pin   port pin number\r\n */\r\nstatic inline void PINS_EnableDigitalFilter(PORT_Type * const base,\r\n                                            uint32_t pin)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    base->DFER |= (uint32_t)1U << pin;\r\n}\r\n\r\n/*!\r\n * @brief Disables digital filter for digital pin muxing\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pin   port pin number\r\n */\r\nstatic inline void PINS_DisableDigitalFilter(PORT_Type * const base,\r\n                                             uint32_t pin)\r\n{\r\n    DEV_ASSERT(pin < PORT_PCR_COUNT);\r\n    base->DFER &= ~((uint32_t)1U << pin);\r\n}\r\n\r\n/*!\r\n * @brief Configures digital filter clock for port with given configuration\r\n *\r\n * @param[in] base   port base pointer\r\n * @param[in] config configuration struct\r\n */\r\nstatic inline void PINS_ConfigDigitalFilter(PORT_Type * const base,\r\n                                            const port_digital_filter_config_t * const config)\r\n{\r\n    DEV_ASSERT(config->width <= PORT_DFWR_FILT_MASK);\r\n    base->DFCR = PORT_DFCR_CS(config->clock);\r\n    base->DFWR = PORT_DFWR_FILT(config->width);\r\n}\r\n\r\n/*!\r\n * @brief Reads the entire port interrupt status flag.\r\n *\r\n * @param[in] base  port base pointer\r\n * @return all 32 pin interrupt status flags. For specific bit:\r\n *         - 0: interrupt is not detected.\r\n *         - 1: interrupt is detected.\r\n */\r\nstatic inline uint32_t PINS_GetPortIntFlag(const PORT_Type * const base)\r\n{\r\n    uint32_t regValue = base->ISFR;\r\n\r\n    return regValue;\r\n}\r\n\r\n/*!\r\n * @brief Clears the entire port interrupt status flag.\r\n *\r\n * @param[in] base  port base pointer\r\n */\r\nstatic inline void PINS_ClearPortIntFlagCmd(PORT_Type * const base)\r\n{\r\n    base->ISFR = PORT_ISFR_ISF_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Quickly configures multiple pins with the same pin configuration.\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pins  pin mask where each bit represents one pin\r\n * @param[in] value the config value will be updated for the pins are set to '1'\r\n * @param[in] halfPort the lower or upper half of pin registers at the same port\r\n */\r\nvoid PINS_SetGlobalPinControl(PORT_Type * const base,\r\n                              uint16_t pins,\r\n                              uint16_t value,\r\n                              port_global_control_pins_t halfPort);\r\n\r\n/*!\r\n * @brief Quickly configures multiple pins with the same interrupt configuration.\r\n *\r\n * @param[in] base  port base pointer\r\n * @param[in] pins  pin mask where each bit represents one pin\r\n * @param[in] value the config value will be updated for the pins are set to '1'\r\n * @param[in] halfPort the lower or upper half of pin registers at the same port\r\n */\r\nvoid PINS_SetGlobalIntControl(PORT_Type * const base,\r\n                              uint16_t pins,\r\n                              uint16_t value,\r\n                              port_global_control_pins_t halfPort);\r\n\r\n\r\n#if FEATURE_PINS_HAS_OVER_CURRENT\r\n/*!\r\n * @brief Reads the entire over current port interrupt status flag.\r\n *\r\n * @param[in] base  port base pointer\r\n * @return all 32 pin interrupt status flags. For specific bit:\r\n *         - 0: interrupt is not detected.\r\n *         - 1: interrupt is detected.\r\n */\r\nstatic inline uint32_t PINS_GetOverCurPortIntFlag(const PORT_Type * const base)\r\n{\r\n    return ((uint32_t)(base->OCFR));\r\n}\r\n\r\n/*!\r\n * @brief Clears the entire over current port interrupt status flag.\r\n *\r\n * @param[in] base  port base pointer\r\n */\r\nstatic inline void PINS_ClearOverCurPortIntFlag(PORT_Type * const base)\r\n{\r\n    base->ISFR = PORT_OCFR_OCF_MASK;\r\n}\r\n#endif /* FEATURE_PINS_HAS_OVER_CURRENT */\r\n\r\n/*! @} */\r\n\r\n/*! @} */\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @} */\r\n\r\n#endif /* PINS_PORT_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"pmc_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\clock\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef PMC_HW_ACCESS_H\r\n#define PMC_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n\r\n/*!\r\n * @file pmc_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to implement enumeration entries as macro.\r\n * Enumeration entries (macros) are referenced from application code.\r\n */\r\n\r\n/*!\r\n * @ingroup pmc_hw_access\r\n * @defgroup pmc_hw_access\r\n * @{\r\n */\r\n\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*!\r\n * @brief Enables/Disables the Low Power Oscillator.\r\n *\r\n * This function  enables/disables the Low Power Oscillator.\r\n *\r\n * @param[in] baseAddr  Base address for current PMC instance.\r\n * @param[in] enable    enable/disable the Low Power Oscillator.\r\n */\r\nstatic inline void PMC_SetLpoMode(PMC_Type* const baseAddr, const bool enable)\r\n{\r\n    uint8_t regValue = baseAddr->REGSC;\r\n    regValue &= (uint8_t)(~(PMC_REGSC_LPODIS_MASK));\r\n    regValue |= (uint8_t)PMC_REGSC_LPODIS(enable?0U:1U);\r\n    baseAddr->REGSC = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Gets the Low Power Oscillator status.\r\n *\r\n * This function gets the Low Power Oscillator status.\r\n *\r\n * @param[in] baseAddr  Base address for current PMC instance.\r\n * @return value LPO status\r\n *               false - LPO is disabled\r\n *               true - LPO is enabled\r\n */\r\nstatic inline bool PMC_GetLpoMode(const PMC_Type * const baseAddr)\r\n{\r\n    uint8_t regValue = baseAddr->REGSC;\r\n    regValue = (uint8_t)((regValue & PMC_REGSC_LPODIS_MASK) >> PMC_REGSC_LPODIS_SHIFT);\r\n    return (regValue == 0U) ? true : false;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Low Power Oscillator Trimming Value\r\n *\r\n * This function sets the trimming value for the low power oscillator\r\n *\r\n * @param[in] baseAddr  Base address for current PMC instance.\r\n * @param[in] value     Trimming value\r\n */\r\nstatic inline void PMC_SetLpoTrimValue(PMC_Type* const baseAddr, const int8_t decimalValue)\r\n{\r\n    int8_t decValue = decimalValue;\r\n    uint8_t lpotrim, trimval, regValue;\r\n\r\n    if (decValue < 0)\r\n    {\r\n        lpotrim = ((uint8_t)1U) << (PMC_LPOTRIM_LPOTRIM_WIDTH);\r\n        decValue = (int8_t)(decValue + (int8_t)(lpotrim));\r\n    }\r\n    trimval = (uint8_t)decValue;\r\n\r\n    DEV_ASSERT(trimval <= (1U << PMC_LPOTRIM_LPOTRIM_WIDTH));\r\n\r\n    regValue = baseAddr->LPOTRIM;\r\n    regValue &= (uint8_t)(~(PMC_LPOTRIM_LPOTRIM_MASK));\r\n    regValue |= (uint8_t)PMC_LPOTRIM_LPOTRIM(trimval);\r\n    baseAddr->LPOTRIM = regValue;\r\n}\r\n\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*! @}*/\r\n\r\n#endif /* PMC_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_manager.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file power_manager.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, There shall be no occurrence of\r\n * undefined or critical unspecified behaviour.\r\n * The addresses of the stack variables are only used at local scope.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.4, external symbol defined without a prior\r\n * declaration.\r\n * The gPowerManagerState symbol is not a part of the public API.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 8.5, object/function previously declared.\r\n * This requirement is fulfilled since the functions are declared as external only in one file\r\n * included for each SoC.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n */\r\n\r\n#include <stddef.h>\r\n#include \"power_manager.h\"\r\n\r\n/*******************************************************************************\r\n * INTERNAL FUNCTIONS\r\n ******************************************************************************/\r\n\r\nstatic status_t POWER_SYS_CallbacksManagement(power_manager_notify_struct_t * notifyStruct,\r\n                                              uint8_t * currentStaticCallback,\r\n                                              power_manager_policy_t policy);\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_Init\r\n * Description   : Initializes the Power manager for operation.\r\n * This function initializes the Power manager and its run-time state structure.\r\n * Reference to an array of Power mode configuration structures has to be passed\r\n * as parameter along with parameter specifying its size. At least one power mode\r\n * configuration is required. Optionally, reference to array of predefined\r\n * call-backs can be passed with its size parameter.\r\n * For details about call-backs refer to the power_manager_callback_user_config_t.\r\n * As Power manager stores only references to array of these structures they have\r\n * to exist while Power manager is used.\r\n *\r\n * Implements POWER_SYS_Init_Activity\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_Init(power_manager_user_config_t * (*powerConfigsPtr)[],\r\n                        uint8_t configsNumber,\r\n                        power_manager_callback_user_config_t * (*callbacksPtr)[],\r\n                        uint8_t callbacksNumber)\r\n{\r\n    DEV_ASSERT(powerConfigsPtr != NULL);                  /* Reference to the power configurations is valid. */\r\n    DEV_ASSERT(configsNumber != 0U);                      /* Power configuration index is valid. */\r\n    DEV_ASSERT(gPowerManagerState.configs == NULL);       /* Driver is not initialized, reference to configuration is not valid. */\r\n    DEV_ASSERT(gPowerManagerState.configsNumber == 0U);   /* Driver is not initialized, number of configurations is zero. */\r\n\r\n    /* Store references to user-defined power mode configurations */\r\n    gPowerManagerState.configs = (power_manager_user_config_t * (*)[])powerConfigsPtr;\r\n    gPowerManagerState.configsNumber = configsNumber;\r\n    gPowerManagerState.currentConfig = 0U;\r\n\r\n    /* Store references to user-defined callback configurations and increment call-back handle counter */\r\n    if (callbacksPtr != NULL)\r\n    {\r\n        gPowerManagerState.staticCallbacks = (power_manager_callback_user_config_t * (*)[])callbacksPtr;\r\n        gPowerManagerState.staticCallbacksNumber = callbacksNumber;\r\n        /* Default value of handle of last call-back that returned error */\r\n        gPowerManagerState.errorCallbackIndex = callbacksNumber;\r\n    }\r\n    else\r\n    {\r\n        gPowerManagerState.staticCallbacks = NULL;\r\n        gPowerManagerState.staticCallbacksNumber = 0U;\r\n        gPowerManagerState.errorCallbackIndex = 0U;\r\n    }\r\n\r\n    return POWER_SYS_DoInit();\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_Deinit\r\n * Description   : De-initializes the Power manager.\r\n *\r\n * Implements POWER_SYS_Deinit_Activity\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_Deinit(void)\r\n{\r\n    gPowerManagerState.configs = NULL;\r\n    gPowerManagerState.configsNumber = 0U;\r\n    gPowerManagerState.staticCallbacks = NULL;\r\n    gPowerManagerState.staticCallbacksNumber = 0U;\r\n\r\n    return POWER_SYS_DoDeinit();\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetLastMode\r\n * Description   : This function returns power mode set as the last one.\r\n *\r\n * This function returns index of power mode which was set using POWER_SYS_SetMode() as the last one.\r\n * If the power mode was entered although some of the registered call-back denied the mode change\r\n * or if any of the call-backs invoked after the entering/restoring run mode failed then the return\r\n * code of this function has STATUS_ERROR value.\r\n * value.\r\n *\r\n * Implements POWER_SYS_GetLastMode_Activity\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_GetLastMode(uint8_t * powerModeIndexPtr)\r\n{\r\n    status_t returnCode; /* Function return */\r\n\r\n    /* Pass index of user-defined configuration structure of currently running power mode */\r\n    *powerModeIndexPtr = gPowerManagerState.currentConfig;\r\n\r\n    /* Return whether all call-backs executed without error */\r\n    if (gPowerManagerState.errorCallbackIndex == gPowerManagerState.staticCallbacksNumber)\r\n    {\r\n        returnCode = STATUS_SUCCESS;\r\n    }\r\n    else\r\n    {\r\n        returnCode = STATUS_ERROR;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetLastModeConfig\r\n * Description   : This function returns user configuration structure of power mode set as the last one.\r\n *\r\n * This function returns reference to configuration structure which was set using POWER_SYS_SetMode()\r\n * as the last one. If the current power mode was entered although some of the registered call-back denied\r\n * the mode change or if any of the call-backs invoked after the entering/restoring run mode failed then\r\n * the return code of this function has STATUS_ERROR value.\r\n *\r\n * Implements POWER_SYS_GetLastModeConfig_Activity\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_GetLastModeConfig(power_manager_user_config_t ** powerModePtr)\r\n{\r\n    status_t returnCode; /* Function return */\r\n    /* Pass reference to user-defined configuration structure of currently running power mode */\r\n    *powerModePtr = (*gPowerManagerState.configs)[gPowerManagerState.currentConfig];\r\n\r\n    /* Return whether all call-backs executed without error */\r\n    if (gPowerManagerState.errorCallbackIndex == gPowerManagerState.staticCallbacksNumber)\r\n    {\r\n        returnCode = STATUS_SUCCESS;\r\n    }\r\n    else\r\n    {\r\n        returnCode = STATUS_ERROR;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetErrorCallbackIndex\r\n * Description   : Returns the last failed notification callback.\r\n *\r\n * This function returns index of the last call-back that failed during the power mode switch while\r\n * the last POWER_SYS_SetMode() was called. If the last POWER_SYS_SetMode() call ended successfully\r\n * value equal to callbacks number is returned. Returned value represents index in the array of\r\n * static call-backs.\r\n *\r\n * Implements POWER_SYS_GetErrorCallbackIndex_Activity\r\n *END**************************************************************************/\r\nuint8_t POWER_SYS_GetErrorCallbackIndex(void)\r\n{\r\n    return gPowerManagerState.errorCallbackIndex;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetErrorCallback\r\n * Description   : Get the callback which returns error in last mode switch.\r\n *\r\n * Implements POWER_SYS_GetErrorCallback_Activity\r\n *END**************************************************************************/\r\npower_manager_callback_user_config_t * POWER_SYS_GetErrorCallback(void)\r\n{\r\n\r\n    /* If all callbacks return success. */\r\n    return (gPowerManagerState.errorCallbackIndex >=\r\n            gPowerManagerState.staticCallbacksNumber) ? NULL : (*gPowerManagerState.staticCallbacks)[gPowerManagerState.errorCallbackIndex];\r\n}\r\n\r\n/*FUNCTION**********************************************************************************************\r\n* Function Name : POWER_SYS_CallbacksManagement\r\n* Description   : Internal function used by POWER_SYS_SetMode function for callback management\r\n* notifyStruct            callback notification structure\r\n* currentStaticCallback   index to array of statically registered call-backs\r\n* policy                  transaction policy\r\n*\r\n*END***************************************************************************************************/\r\nstatic status_t POWER_SYS_CallbacksManagement(power_manager_notify_struct_t * notifyStruct,\r\n                                              uint8_t * currentStaticCallback,\r\n                                              power_manager_policy_t policy)\r\n{\r\n    uint8_t callbacksNumber;                                   /* The total number of callbacks */\r\n    status_t returnCode = STATUS_SUCCESS;                      /* Function return */\r\n    status_t errorCode = STATUS_SUCCESS;                       /* Error code to be returned(error case) */\r\n    status_t callbackStatusCode;                               /* Status code returned by callback function */\r\n    power_manager_callback_type_t callbackTypeFilter;          /* Callback types to be excluded */\r\n\r\n    switch (notifyStruct->notifyType)\r\n    {\r\n        /* notify before */\r\n        case POWER_MANAGER_NOTIFY_BEFORE:\r\n            callbacksNumber = gPowerManagerState.staticCallbacksNumber;\r\n            callbackTypeFilter = POWER_MANAGER_CALLBACK_AFTER;\r\n            errorCode = STATUS_MCU_NOTIFY_BEFORE_ERROR;\r\n            break;\r\n        /* notify after */\r\n        case POWER_MANAGER_NOTIFY_AFTER:\r\n            callbacksNumber = gPowerManagerState.staticCallbacksNumber;\r\n            callbackTypeFilter = POWER_MANAGER_CALLBACK_BEFORE;\r\n            errorCode = STATUS_MCU_NOTIFY_AFTER_ERROR;\r\n            break;\r\n        /* notify recover */\r\n        case POWER_MANAGER_NOTIFY_RECOVER:\r\n            callbacksNumber = gPowerManagerState.staticCallbacksNumber;\r\n            callbackTypeFilter = POWER_MANAGER_CALLBACK_AFTER;\r\n            errorCode = STATUS_MCU_NOTIFY_BEFORE_ERROR;\r\n            break;\r\n        default:\r\n            /* invalid value for notifyType */\r\n            DEV_ASSERT(false);\r\n            callbacksNumber = 0U;\r\n            callbackTypeFilter = POWER_MANAGER_CALLBACK_BEFORE;\r\n            break;\r\n    }\r\n\r\n    /* From all statically registered call-backs... */\r\n    for ((*currentStaticCallback) = 0U; (*currentStaticCallback) < callbacksNumber; (*currentStaticCallback)++)\r\n    {\r\n        /* Pointer to callback configuration */\r\n        const power_manager_callback_user_config_t * const callbackConfig = ((*gPowerManagerState.staticCallbacks)[*currentStaticCallback]);\r\n\r\n        /* Check pointer to static callback configuration */\r\n        if ((callbackConfig != NULL) && (callbackTypeFilter != callbackConfig->callbackType))\r\n        {\r\n            /* In case that call-back returned error code mark it, store the call-back handle and eventually cancel the mode switch */\r\n\r\n            callbackStatusCode = callbackConfig->callbackFunction(notifyStruct, callbackConfig->callbackData);\r\n            if (STATUS_SUCCESS != callbackStatusCode)\r\n            {\r\n                returnCode = errorCode;\r\n                gPowerManagerState.errorCallbackIndex = *currentStaticCallback;\r\n                /* If not forcing power mode switch, call all already notified call-backs to revert their state as the mode change is canceled */\r\n                if (policy != POWER_MANAGER_POLICY_FORCIBLE)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_SetMode\r\n * Description   : Configures the power mode.\r\n *\r\n * This function switches to one of the defined power modes. Requested mode number is passed\r\n * as an input parameter. This function notifies all registered callback functions before\r\n * the mode change (using  POWER_MANAGER_CALLBACK_BEFORE set as callback type parameter),\r\n * sets specific power options defined in the power mode configuration and enters the specified\r\n * mode. In case of success switch, this function also invokes all registered callbacks after\r\n * the mode change (using POWER_MANAGER_CALLBACK_AFTER).\r\n * The actual mode switch is performed by POWER_SYS_DoSetMode in the specific implementation.\r\n * Callbacks are invoked in the following order: All registered callbacks are notified\r\n * ordered by index in the callbacks array (see callbacksPtr parameter of POWER_SYS_Init()).\r\n * The same order is used for before and after switch notifications.\r\n * The notifications before the power mode switch can be used to obtain confirmation about\r\n * the change from registered callbacks. If any registered callback denies the power\r\n * mode change, further execution of this function depends on mode change policy: the mode\r\n * change is either forced(POWER_MANAGER_POLICY_FORCIBLE) or exited(POWER_MANAGER_POLICY_AGREEMENT).\r\n * When mode change is forced, the result of the before switch notifications are ignored. If\r\n * agreement is required, if any callback returns an error code then further notifications\r\n * before switch notifications are cancelled and all already notified callbacks are re-invoked\r\n * with POWER_MANAGER_CALLBACK_AFTER set as callback type parameter. The index of the callback\r\n * which returned error code during pre-switch notifications is stored(any error codes during\r\n * callbacks re-invocation are ignored) and POWER_SYS_GetErrorCallback() can be used to get it.\r\n * Regardless of the policies, if any callback returned an error code, an error code denoting in which phase\r\n * the error occurred is returned when POWER_SYS_SetMode() exits.\r\n * It is possible to enter any mode supported by the processor. Refer to the chip reference manual\r\n * for list of available power modes. If it is necessary to switch into intermediate power mode prior to\r\n * entering requested mode, then the intermediate mode is entered without invoking the callback mechanism.\r\n *\r\n * Implements POWER_SYS_SetMode_Activity\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_SetMode(uint8_t powerModeIndex,\r\n                           power_manager_policy_t policy)\r\n{\r\n    power_manager_user_config_t * configPtr; /* Local pointer to the requested user-defined power mode configuration */\r\n    status_t returnCode; /* Function return */\r\n    status_t errorCode;\r\n    bool successfulSwitch;                                 /* Power mode switch is successful or not */\r\n    uint8_t currentStaticCallback = 0U;                    /* Index to array of statically registered call-backs */\r\n    power_manager_notify_struct_t notifyStruct;            /* Callback notification structure */\r\n\r\n    /* Driver is already initialized. */\r\n    DEV_ASSERT(gPowerManagerState.configs != NULL);\r\n    DEV_ASSERT(gPowerManagerState.configsNumber != 0U);\r\n\r\n    /* Power mode index is valid. */\r\n    DEV_ASSERT(powerModeIndex < gPowerManagerState.configsNumber);\r\n\r\n    /* Initialization of local pointer to the requested user-defined power mode configuration */\r\n    configPtr = (*gPowerManagerState.configs)[powerModeIndex];\r\n\r\n    /* Reference to the requested user-defined power mode configuration is valid. */\r\n    DEV_ASSERT(configPtr != NULL);\r\n\r\n    /* Default value of handle of last call-back that returned error */\r\n    gPowerManagerState.errorCallbackIndex = gPowerManagerState.staticCallbacksNumber;\r\n\r\n    /* Set the transaction policy in the notification structure */\r\n    notifyStruct.policy = policy;\r\n\r\n    /* Set the target power mode configuration in the notification structure */\r\n    notifyStruct.targetPowerConfigIndex = powerModeIndex;\r\n    notifyStruct.targetPowerConfigPtr = configPtr;\r\n\r\n    /* Notify those which asked to be called before the power mode change */\r\n    notifyStruct.notifyType = POWER_MANAGER_NOTIFY_BEFORE;\r\n    returnCode = POWER_SYS_CallbacksManagement(&notifyStruct, &currentStaticCallback, policy);\r\n\r\n    /* Power mode switch */\r\n    /* In case that any call-back returned error code and  policy doesn't force the mode switch go to after switch call-backs */\r\n    if ((policy == POWER_MANAGER_POLICY_FORCIBLE) || (returnCode == STATUS_SUCCESS))\r\n    {\r\n        returnCode = POWER_SYS_DoSetMode(configPtr);\r\n        successfulSwitch = (STATUS_SUCCESS == returnCode);\r\n    }\r\n    else\r\n    {\r\n        /* Unsuccessful switch */\r\n        successfulSwitch = false;\r\n    }\r\n\r\n    if (successfulSwitch)\r\n    {\r\n        /* End of successful switch */\r\n\r\n        /* Update current configuration index */\r\n        gPowerManagerState.currentConfig = powerModeIndex;\r\n\r\n        /* Notify those which asked to be called after the power mode change */\r\n        notifyStruct.notifyType = POWER_MANAGER_NOTIFY_AFTER;\r\n        returnCode = POWER_SYS_CallbacksManagement(&notifyStruct, &currentStaticCallback, POWER_MANAGER_POLICY_FORCIBLE);\r\n    }\r\n    else\r\n    {\r\n        /* End of unsuccessful switch */\r\n\r\n        /* Notify those which have been called before the power mode change */\r\n        notifyStruct.notifyType = POWER_MANAGER_NOTIFY_RECOVER;\r\n        errorCode = POWER_SYS_CallbacksManagement(&notifyStruct, &currentStaticCallback, POWER_MANAGER_POLICY_FORCIBLE);\r\n        (void)(errorCode);\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetDefaultConfig\r\n * Description   : Initializes the power_manager configuration structure.\r\n * This function returns a pointer of the power_manager configuration structure.\r\n * All structure members have default value when CPU is default power mode.\r\n *\r\n * Implements    : POWER_SYS_GetDefaultConfig_Activity\r\n *END**************************************************************************/\r\nvoid POWER_SYS_GetDefaultConfig(power_manager_user_config_t * const config)\r\n{\r\n    POWER_SYS_DoGetDefaultConfig(config);\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_manager.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\inc","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014-2016 Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef POWER_MANAGER_H_\r\n#define POWER_MANAGER_H_\r\n\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n\r\n/*\r\n * Include the cpu API header files.\r\n */\r\n#if ((defined(S32K14x_SERIES)) || (defined(S32MTV_SERIES)) || (defined(S32K11x_SERIES)))\r\n/* S32K144 power management API header file */\r\n#include \"../src/power/S32K1xx/power_manager_S32K1xx.h\"\r\n#elif (defined(S32V234_SERIES))\r\n/* S32V234 Power Management Level API header file */\r\n#include \"../src/power/S32V234/power_manager_S32V234.h\"\r\n#elif (defined(MPC574x_SERIES) || defined(S32R_SERIES))\r\n/* MPC5748G Power Management Level API header file */\r\n#include \"../src/power/MPC57xx/power_manager_MPC57xx.h\"\r\n#else\r\n#error \"No valid CPU defined!\"\r\n#endif\r\n\r\n/*!\r\n * @file power_manager.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, Global typedef not referenced.\r\n * Although all symbols from power_manager.h are referenced in power_manager.c,\r\n * these symbols are not referenced in other drivers;\r\n */\r\n\r\n/*!\r\n * @addtogroup power_manager\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief Power manager policies.\r\n *\r\n * Defines whether the mode switch initiated by the POWER_SYS_SetMode() is agreed upon\r\n * (depending on the result of notification callbacks), or forced.\r\n * For POWER_MANAGER_POLICY_FORCIBLE the power mode is changed\r\n * regardless of the callback results, while for POWER_MANAGER_POLICY_AGREEMENT policy\r\n * any error code returned by one of the callbacks aborts the mode change.\r\n * See also POWER_SYS_SetMode() description.\r\n * Implements power_manager_policy_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    POWER_MANAGER_POLICY_AGREEMENT,      /*!< Power mode is changed if all of the callbacks return success. */\r\n    POWER_MANAGER_POLICY_FORCIBLE        /*!< Power mode is changed regardless of the result of callbacks. */\r\n} power_manager_policy_t;\r\n\r\n/*!\r\n * @brief The PM notification type. Used to notify registered callbacks.\r\n * Callback notifications can be invoked in following situations:\r\n *  - before a power mode change (Callback return value can affect POWER_SYS_SetMode()\r\n *    execution. Refer to the  POWER_SYS_SetMode() and power_manager_policy_t documentation).\r\n *  - after a successful change of the power mode.\r\n *  - after an unsuccessful attempt to switch power mode, in order to recover to a working state.\r\n * Implements power_manager_notify_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    POWER_MANAGER_NOTIFY_RECOVER = 0x00U,  /*!< Notify IP to recover to previous work state.      */\r\n    POWER_MANAGER_NOTIFY_BEFORE  = 0x01U,  /*!< Notify IP that the system will change the power setting.  */\r\n    POWER_MANAGER_NOTIFY_AFTER   = 0x02U   /*!< Notify IP that the system has changed to a new power setting. */\r\n} power_manager_notify_t;\r\n\r\n/*!\r\n * @brief The callback type indicates when a callback will be invoked.\r\n *\r\n * Used in the callback configuration structures (power_manager_callback_user_config_t)\r\n * to specify when the registered callback will be called during power mode change initiated by\r\n * POWER_SYS_SetMode().\r\n *\r\n * Implements power_manager_callback_type_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    POWER_MANAGER_CALLBACK_BEFORE       = 0x01U, /*!< Before callback. */\r\n    POWER_MANAGER_CALLBACK_AFTER        = 0x02U, /*!< After callback. */\r\n    POWER_MANAGER_CALLBACK_BEFORE_AFTER = 0x03U  /*!< Before-After callback. */\r\n} power_manager_callback_type_t;\r\n\r\n/*!\r\n * @brief Callback-specific data.\r\n *\r\n * Pointer to data of this type is passed during callback registration. The pointer is\r\n * part of the power_manager_callback_user_config_t structure and is passed to the callback during\r\n * power mode change notifications.\r\n * Implements power_manager_callback_data_t_Class\r\n */\r\ntypedef void power_manager_callback_data_t;\r\n\r\n/*!\r\n * @brief Power mode user configuration structure.\r\n *\r\n * This structure defines power mode with additional power options.\r\n * This structure is implementation-defiend. Please refer to actual definition based on the\r\n * underlying HAL (SMC, MC_ME etc). Applications may define multiple power modes and\r\n * switch between them. A list of all defined power modes is passed to the Power manager during\r\n * initialization as an array of references to structures of this type (see POWER_SYS_Init()).\r\n * Power modes can be switched by calling POWER_SYS_SetMode(), which takes as argument the index\r\n * of the reqested power mode in the list passed during manager initialization.\r\n * The power mode currently in use can be retrieved by calling POWER_SYS_GetLastMode(), which provides\r\n * the index of the current power mode, or by calling POWER_SYS_GetLastModeConfig(), which provides a\r\n * pointer to the configuration structure of the current power mode.\r\n * The members of the power mode configuration structure depend on power options available\r\n * for a specific chip, and includes at least the power mode. The available power modes are chip-specific.\r\n * See power_manager_modes_t defined in the underlying HAL for a list of all supported modes.\r\n */\r\n\r\n/*!\r\n * @brief Power notification structure passed to registered callback function\r\n *\r\n * Implements power_manager_notify_struct_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    power_manager_user_config_t * targetPowerConfigPtr; /*!< Pointer to target power configuration */\r\n    uint8_t targetPowerConfigIndex;    /*!< Target power configuration index. */\r\n    power_manager_policy_t policy;     /*!< Power mode transition policy.          */\r\n    power_manager_notify_t notifyType; /*!< Power mode notification type.          */\r\n} power_manager_notify_struct_t;\r\n\r\n/*!\r\n * @brief Callback prototype.\r\n *\r\n * Declaration of callback. It is common for all registered callbacks.\r\n * Function pointer of this type is part of power_manager_callback_user_config_t callback\r\n * configuration structure.\r\n * Depending on the callback type, the callback function is invoked during power mode change\r\n * (see POWER_SYS_SetMode()) before the mode change, after it, or in both cases to notify about\r\n * the change progress (see power_manager_callback_type_t). When called, the type of the notification\r\n * is passed as parameter along with a pointer to power mode configuration structure\r\n * (see power_manager_notify_struct_t) and any data passed during the callback registration (see\r\n * power_manager_callback_data_t).\r\n * When notified before a mode change, depending on the power mode change policy (see\r\n * power_manager_policy_t) the callback may deny the mode change by returning any error code other\r\n * than STATUS_SUCCESS (see POWER_SYS_SetMode()).\r\n * @param notify Notification structure.\r\n * @param dataPtr Callback data. Pointer to the data passed during callback registration. Intended to\r\n *  pass any driver or application data such as internal state information.\r\n * @return An error code or STATUS_SUCCESS.\r\n * Implements power_manager_callback_t_Class\r\n */\r\ntypedef status_t (* power_manager_callback_t)(power_manager_notify_struct_t * notify,\r\n                                              power_manager_callback_data_t * dataPtr);\r\n\r\n/*!\r\n * @brief callback configuration structure\r\n *\r\n * This structure holds configuration of callbacks passed\r\n * to the Power manager during its initialization.\r\n * Structures of this type are expected to be statically\r\n * allocated.\r\n * This structure contains following application-defined data:\r\n *  callback - pointer to the callback function\r\n *  callbackType - specifies when the callback is called\r\n *  callbackData - pointer to the data passed to the callback\r\n * Implements power_manager_callback_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    power_manager_callback_t callbackFunction;\r\n    power_manager_callback_type_t callbackType;\r\n    power_manager_callback_data_t * callbackData;\r\n} power_manager_callback_user_config_t;\r\n\r\n/*!\r\n * @brief Power manager internal state structure.\r\n *\r\n * Power manager internal structure. Contains data necessary for Power manager proper\r\n * functionality. Stores references to registered power mode configurations,\r\n * callbacks, and other internal data.\r\n * This structure is statically allocated and initialized by POWER_SYS_Init().\r\n * Implements power_manager_state_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    power_manager_user_config_t * (*configs)[];             /*!< Pointer to power configure table.*/\r\n    uint8_t configsNumber;                                  /*!< Number of power configurations */\r\n    power_manager_callback_user_config_t * (*staticCallbacks)[]; /*!< Pointer to callback table. */\r\n    uint8_t staticCallbacksNumber;                          /*!< Max. number of callback configurations */\r\n    uint8_t errorCallbackIndex;                             /*!< Index of callback returns error. */\r\n    uint8_t currentConfig;                                  /*!< Index of current configuration.  */\r\n} power_manager_state_t;\r\n\r\n/*! @brief Power manager internal structure. */\r\nextern power_manager_state_t gPowerManagerState;\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief Power manager initialization for operation.\r\n *\r\n * This function initializes the Power manager and its run-time state structure.\r\n * Pointer to an array of Power mode configuration structures needs to be passed\r\n * as a parameter along with a parameter specifying its size. At least one power mode\r\n * configuration is required. Optionally, pointer to the array of predefined\r\n * callbacks can be passed with its corresponding size parameter.\r\n * For details about callbacks, refer to the power_manager_callback_user_config_t.\r\n * As Power manager stores only pointers to arrays of these structures, they need\r\n * to exist and be valid for the entire life cycle of Power manager.\r\n *\r\n * @param[in] powerConfigsPtr A pointer to an array of pointers to all power\r\n *  configurations which will be handled by Power manager.\r\n * @param[in] configsNumber Number of power configurations. Size of powerConfigsPtr\r\n *  array.\r\n * @param[in] callbacksPtr A pointer to an array of pointers to callback configurations.\r\n *  If there are no callbacks to register during Power manager initialization, use NULL value.\r\n * @param[in] callbacksNumber Number of registered callbacks. Size of callbacksPtr\r\n *  array.\r\n * @return An error code or STATUS_SUCCESS.\r\n */\r\nstatus_t POWER_SYS_Init(power_manager_user_config_t * (*powerConfigsPtr)[],\r\n                        uint8_t configsNumber,\r\n                        power_manager_callback_user_config_t * (*callbacksPtr)[],\r\n                        uint8_t callbacksNumber);\r\n\r\n/*!\r\n * @brief This function deinitializes the Power manager.\r\n *\r\n * @return An error code or STATUS_SUCCESS.\r\n */\r\nstatus_t POWER_SYS_Deinit(void);\r\n\r\n/*!\r\n * @brief This function configures the power mode.\r\n *\r\n * This function switches to one of the defined power modes. Requested mode number is passed\r\n * as an input parameter. This function notifies all registered callback functions before\r\n * the mode change (using  POWER_MANAGER_CALLBACK_BEFORE set as callback type parameter),\r\n * sets specific power options defined in the power mode configuration and enters the specified\r\n * mode. In case of run modes (for example, Run, Very low power run, or High speed run), this function\r\n * also invokes all registered callbacks after the mode change (using POWER_MANAGER_CALLBACK_AFTER).\r\n * In case of sleep or deep sleep modes, if the requested mode is not exited through\r\n * a reset, these notifications are sent after the core wakes up.\r\n * Callbacks are invoked in the following order: All registered callbacks are notified\r\n * ordered by index in the callbacks array (see callbacksPtr parameter of POWER_SYS_Init()).\r\n * The same order is used for before and after switch notifications.\r\n * The notifications before the power mode switch can be used to obtain confirmation about\r\n * the change from registered callbacks. If any registered callback denies the power\r\n * mode change, further execution of this function depends on mode change policy: the mode\r\n * change is either forced(POWER_MANAGER_POLICY_FORCIBLE) or aborted(POWER_MANAGER_POLICY_AGREEMENT).\r\n * When mode change is forced, the results of the before switch notifications are ignored. If\r\n * agreement is requested, in case any callback returns an error code then further\r\n * before switch notifications are cancelled and all already notified callbacks are re-invoked\r\n * with POWER_MANAGER_CALLBACK_AFTER set as callback type parameter. The index of the callback\r\n * which returned error code during pre-switch notifications is stored and can be obtained by using\r\n * POWER_SYS_GetErrorCallback(). Any error codes during callbacks re-invocation (recover phase) are ignored.\r\n * POWER_SYS_SetMode() returns an error code denoting the phase in which a callback failed.\r\n * It is possible to enter any mode supported by the processor. Refer to the chip reference manual\r\n * for the list of available power modes. If it is necessary to switch into an intermediate power mode prior to\r\n * entering the requested mode (for example, when switching from Run into Very low power wait through Very low\r\n * power run mode), then the intermediate mode is entered without invoking the callback mechanism.\r\n *\r\n * @param[in] powerModeIndex Requested power mode represented as an index into\r\n * array of user-defined power mode configurations passed to the POWER_SYS_Init().\r\n * @param[in] policy Transaction policy\r\n * @return An error code or STATUS_SUCCESS.\r\n */\r\nstatus_t POWER_SYS_SetMode(uint8_t powerModeIndex,\r\n                           power_manager_policy_t policy);\r\n\r\n/*!\r\n * @brief This function returns the last successfully set power mode.\r\n *\r\n * This function returns index of power mode which was last set using POWER_SYS_SetMode().\r\n * If the power mode was entered even though some of the registered callbacks denied the mode change,\r\n * or if any of the callbacks invoked after the entering/restoring run mode failed, then the return\r\n * code of this function has STATUS_ERROR value.\r\n *\r\n * @param[out] powerModeIndexPtr Power mode which has been set represented as an index into array of power mode\r\n * configurations passed to the POWER_SYS_Init().\r\n * @return An error code or STATUS_SUCCESS.\r\n */\r\nstatus_t POWER_SYS_GetLastMode(uint8_t * powerModeIndexPtr);\r\n\r\n/*!\r\n * @brief This function returns the user configuration structure of the last successfully set power mode.\r\n *\r\n * This function returns a pointer to configuration structure which was last set using POWER_SYS_SetMode().\r\n * If the current power mode was entered even though some of the registered callbacks denied\r\n * the mode change, or if any of the callbacks invoked after the entering/restoring run mode failed, then\r\n * the return code of this function has STATUS_ERROR value.\r\n *\r\n * @param[out] powerModePtr Pointer to power mode configuration structure of the last set power mode.\r\n * @return An error code or STATUS_SUCCESS.\r\n */\r\nstatus_t POWER_SYS_GetLastModeConfig(power_manager_user_config_t ** powerModePtr);\r\n\r\n/*!\r\n * @brief This function returns currently running power mode.\r\n *\r\n * This function reads hardware settings and returns currently running power mode.\r\n *\r\n * @return Currently used run power mode.\r\n */\r\npower_manager_modes_t POWER_SYS_GetCurrentMode(void);\r\n\r\n/*!\r\n * @brief This function returns the last failed notification callback.\r\n *\r\n * This function returns the index of the last callback that failed during the power mode switch when\r\n * POWER_SYS_SetMode() was called. The returned value represents the index in the array of registered callbacks.\r\n * If the last POWER_SYS_SetMode() call ended successfully, a value equal to the number of registered callbacks\r\n * is returned.\r\n *\r\n * @return Callback index of last failed callback or value equal to callbacks count.\r\n */\r\nuint8_t POWER_SYS_GetErrorCallbackIndex(void);\r\n\r\n/*!\r\n * @brief This function returns the callback configuration structure for the last failed notification.\r\n *\r\n * This function returns a pointer to configuration structure of the last callback that failed during\r\n * the power mode switch when POWER_SYS_SetMode() was called.\r\n * If the last POWER_SYS_SetMode() call ended successfully, a NULL value is returned.\r\n *\r\n * @return Pointer to the callback configuration which returns error.\r\n */\r\npower_manager_callback_user_config_t * POWER_SYS_GetErrorCallback(void);\r\n\r\n/*!\r\n * @brief This function returns the default power_manager configuration structure.\r\n *\r\n * This function returns a pointer of the power_manager configuration structure.\r\n * All structure members have default value when CPU is default power mode.\r\n *\r\n */\r\nvoid POWER_SYS_GetDefaultConfig(power_manager_user_config_t * const config);\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* POWER_MANAGER_H_ */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_manager_S32K1xx.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file power_manager_S32K1xx.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 1.3, There shall be no occurrence of\r\n * undefined or critical unspecified behaviour.\r\n * The addresses of the stack variables are only used at local scope.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The base address parameter from HAL functions is provided as integer so\r\n * it needs to be cast to pointer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The base address parameter from HAL functions is provided as integer so\r\n * a conversion between a pointer and an integer has to be performed\r\n *\r\n */\r\n\r\n#include <stddef.h>\r\n#include \"power_manager.h\"\r\n#include \"power_smc_hw_access.h\"\r\n#include \"power_rcm_hw_access.h\"\r\n#include \"power_scg_hw_access.h\"\r\n#include \"clock_manager.h\"\r\n\r\n\r\n/*! @brief Power manager internal structure. */\r\npower_manager_state_t gPowerManagerState;\r\n\r\n/* Save system clock configure */\r\nstatic sys_clk_config_t sysClkConfig;\r\n/* Confirm change clock when switch very low power run mode */\r\nstatic bool changeClkVlp = false;\r\n#if FEATURE_HAS_SPLL_CLK\r\n/* Confirm clock source SPLL config enabled or disable */\r\nstatic bool enableSPLL = false;\r\n#endif /* #if FEATURE_HAS_SPLL_CLK */\r\n/* Confirm clock source FIRC config enabled or disable */\r\nstatic bool enableFIRC = false;\r\n/* Confirm clock source SOSC config enabled or disable */\r\nstatic bool enableSOSC = false;\r\n/*******************************************************************************\r\n * INTERNAL FUNCTIONS\r\n ******************************************************************************/\r\nstatic status_t POWER_SYS_SwitchToSleepingPowerMode(const power_manager_user_config_t * const configPtr);\r\n\r\nstatic status_t POWER_SYS_SwitchToRunningPowerMode(const power_manager_user_config_t * const configPtr);\r\n\r\nstatic status_t POWER_DRV_SwitchVlprClk(const sys_clk_config_t * const sysClock);\r\n\r\nstatic status_t POWER_DRV_UpdateInitClk(const sys_clk_config_t * const sysClk);\r\n\r\nstatic void POWER_DRV_EnableVlpClockSrc(void);\r\n\r\nstatic void POWER_DRV_DisableVlpClockSrc(void);\r\n\r\nstatic void POWER_DRV_GetEnableClockSrc(void);\r\n\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\nstatic status_t POWER_SYS_EnterHsrunMode(void);\r\n#endif\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n *\r\n * It is expected that prior to the POWER_SYS_Init() call the write-once protection\r\n * register was configured appropriately allowing entry to all required low power\r\n * modes.\r\n * The following is an example of how to set up two power modes and one\r\n * callback, and initialize the Power manager with structures containing their settings.\r\n * The example shows two possible ways the configuration structures can be stored\r\n * (ROM or RAM), although it is expected that they will be placed in the read-only\r\n * memory to save the RAM space. (Note: In the example it is assumed that the programmed chip\r\n * doesn't support any optional power options described in the power_manager_user_config_t)\r\n * :\r\n * @code\r\n *\r\n *  power_manager_user_config_t vlprConfig = {   vlprConfig power mode configuration\r\n *     .powerMode = POWER_MANAGER_VLPR,\r\n *     .sleepOnExitValue = false,\r\n *  };\r\n *\r\n *  power_manager_user_config_t stopConfig = {   stopConfig power mode configuration\r\n *     .powerMode = POWER_MANAGER_STOP,\r\n *     .sleepOnExitValue = false,\r\n *  };\r\n *\r\n *  power_manager_user_config_t const * powerConfigsArr[] = {    Power mode configurations array\r\n *     &vlprConfig,\r\n *     &stopConfig\r\n *  };\r\n *\r\n *  power_manager_callback_user_config_t callbackCfg0 = {  Callback configuration structure callbackCfg0\r\n *     .callbackFunction                     = &callback0,\r\n *     .callbackType                         = POWER_MANAGER_CALLBACK_BEFORE_AFTER,\r\n *     .callbackData                         = (void *)0,\r\n *  };\r\n *\r\n *  power_manager_callback_user_config_t const * callbacksConfigsArr[] = {  Callback configuration structures array\r\n *     &callbackCfg0\r\n *  };\r\n *\r\n *  status_t callback0(power_manager_notify_struct_t * notify,   Definition of power manager callback\r\n *                                      power_manager_callback_data_t * dataPtr)\r\n *  {\r\n *   status_t ret = STATUS_SUCCESS;\r\n *   ...\r\n *   return ret;\r\n *  }\r\n *\r\n *  int main(void) Main function\r\n *  {\r\n *   status_t ret = STATUS_SUCCESS;\r\n *\r\n *   Calling of init method\r\n *   POWER_SYS_Init(&powerConfigsArr, 2U, &powerStaticCallbacksConfigsArr, 1U);\r\n *\r\n *   Switch to VLPR mode\r\n *   ret = POWER_SYS_SetMode(MODE_VLPR,POWER_MANAGER_POLICY_AGREEMENT);\r\n *\r\n *   if (ret != STATUS_SUCCESS)\r\n *   {\r\n *     return -1;\r\n *   }\r\n *   return 0;\r\n *  }\r\n *\r\n * @endcode\r\n *\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_DoInit(void)\r\n{\r\n    uint8_t k = 0U;\r\n\r\n    smc_power_mode_protection_config_t powerModeProtConfig;\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n    powerModeProtConfig.hsrunProt = false;\r\n#endif /* #if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */\r\n    powerModeProtConfig.vlpProt = false;\r\n\r\n    for (k = 0;k < gPowerManagerState.configsNumber;k++)\r\n    {\r\n        const power_manager_user_config_t * const config = (*gPowerManagerState.configs)[k];\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n        if (config->powerMode == POWER_MANAGER_HSRUN)\r\n        {\r\n            powerModeProtConfig.hsrunProt  =   true;  /* High speed mode is allowed. */\r\n        }\r\n#endif /* #if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */\r\n        if ((config->powerMode == POWER_MANAGER_VLPR) || (config->powerMode == POWER_MANAGER_VLPS))\r\n        {\r\n            powerModeProtConfig.vlpProt    =   true; /* Very low power mode is allowed. */\r\n        }\r\n    }\r\n\r\n    /* Biasing disabled, core logic can run in full performance */\r\n    PMC_DisableBiasen(PMC);\r\n\r\n    /* Very low power modes and high speed mode are not protected. */\r\n    SMC_SetProtectionMode(SMC, &powerModeProtConfig);\r\n    /* Get all clock source were enabled. This one was used for update initialize clock when CPU\r\n    came back RUN mode from very low power mode */\r\n    POWER_DRV_GetEnableClockSrc();\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_DoDeinit\r\n * Description   : This function performs the actual implementation-specific de-initialization.\r\n *\r\n *\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_DoDeinit(void)\r\n{\r\n\r\n    /* Biasing disabled, core logic can run in full performance */\r\n    PMC_DisableBiasen(PMC);\r\n\r\n    return STATUS_SUCCESS;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_DoSetMode\r\n * Description   : This function performs the actual implementation-specific logic to switch\r\n * to one of the defined power modes.\r\n *\r\n *\r\n *END**************************************************************************/\r\nstatus_t POWER_SYS_DoSetMode(const power_manager_user_config_t * const configPtr)\r\n{\r\n    status_t returnCode; /* Function return */\r\n\r\n    /* Check whether the power mode is a sleeping or a running power mode */\r\n    if (configPtr->powerMode <= POWER_MANAGER_VLPR)\r\n    {\r\n        /* Switch to a running power mode */\r\n        returnCode = POWER_SYS_SwitchToRunningPowerMode(configPtr);\r\n    }\r\n    else\r\n    {\r\n        /* Switch to a sleeping power mode */\r\n        returnCode = POWER_SYS_SwitchToSleepingPowerMode(configPtr);\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetCurrentMode\r\n * Description   : Returns currently running power mode.\r\n *\r\n * Implements POWER_SYS_GetCurrentMode_Activity\r\n *\r\n *END**************************************************************************/\r\npower_manager_modes_t POWER_SYS_GetCurrentMode(void)\r\n{\r\n    power_manager_modes_t retVal;\r\n\r\n    switch (SMC_GetPowerModeStatus(SMC))\r\n    {\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n        /* High speed run mode */\r\n        case STAT_HSRUN:\r\n            retVal = POWER_MANAGER_HSRUN;\r\n            break;\r\n#endif\r\n        /* Run mode */\r\n        case STAT_RUN:\r\n            retVal = POWER_MANAGER_RUN;\r\n            break;\r\n        /* Very low power run mode */\r\n        case STAT_VLPR:\r\n            retVal = POWER_MANAGER_VLPR;\r\n            break;\r\n        /* This should never happen - core has to be in some run mode to execute code */\r\n        default:\r\n            retVal = POWER_MANAGER_MAX;\r\n            break;\r\n    }\r\n\r\n    return retVal;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_SwitchToRunningPowerMode\r\n * Description   :Internal function used by POWER_SYS_SetMode function to switch to a running power mode\r\n * configPtr   pointer to the requested user-defined power mode configuration.\r\n * System clock source must be SIRC or SOSC in Run mode before transition very low power run  mode.\r\n * Update initialization  or default clock source in run mode when came back from very low power run mode.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t POWER_SYS_SwitchToRunningPowerMode(const power_manager_user_config_t * const configPtr)\r\n{\r\n    smc_power_mode_config_t modeConfig; /* SMC hardware layer configuration structure */\r\n    power_mode_stat_t currentMode = SMC_GetPowerModeStatus(SMC);\r\n    status_t returnCode = STATUS_SUCCESS;\r\n\r\n    /* Configure the running mode */\r\n    switch (configPtr->powerMode)\r\n    {\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n        /* High speed run mode */\r\n        case POWER_MANAGER_HSRUN:\r\n            /* High speed run mode can be entered only from Run mode */\r\n            if (currentMode != STAT_HSRUN)\r\n            {\r\n                if (currentMode != STAT_RUN)\r\n                {\r\n                    modeConfig.powerModeName = POWER_MANAGER_RUN;\r\n                    /* Switch the mode */\r\n                    returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n                }\r\n                if (returnCode == STATUS_SUCCESS)\r\n                {\r\n                    returnCode = POWER_SYS_EnterHsrunMode();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                returnCode = STATUS_SUCCESS;\r\n            }\r\n            break;\r\n#endif /* if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */\r\n        /* Run mode */\r\n        case POWER_MANAGER_RUN:\r\n            if (currentMode != STAT_RUN)\r\n            {\r\n                modeConfig.powerModeName = POWER_MANAGER_RUN;\r\n                /* Switch the mode */\r\n                returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n            }\r\n            if ((returnCode == STATUS_SUCCESS) && changeClkVlp)\r\n            {\r\n                /* Enable all clock source */\r\n                POWER_DRV_EnableVlpClockSrc();\r\n                /* Update initialize clock configuration */\r\n                returnCode = POWER_DRV_UpdateInitClk(&sysClkConfig);\r\n                if (returnCode == STATUS_SUCCESS)\r\n                {\r\n                    changeClkVlp = false;\r\n                }\r\n            }\r\n\r\n            break;\r\n        /* Very low power run mode */\r\n        case POWER_MANAGER_VLPR:\r\n\r\n            if (currentMode != STAT_VLPR)\r\n            {\r\n                /* Very low power run mode can be entered only from Run mode */\r\n                if (SMC_GetPowerModeStatus(SMC) != STAT_RUN)\r\n                {\r\n                    modeConfig.powerModeName = POWER_MANAGER_RUN;\r\n                    /* Switch the mode */\r\n                    returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n                }\r\n                if (STATUS_SUCCESS == returnCode)\r\n                {\r\n                    if (!changeClkVlp)\r\n                    {\r\n                        CLOCK_DRV_GetSystemClockSource(&sysClkConfig);\r\n                    }\r\n                    returnCode = POWER_DRV_SwitchVlprClk(&sysClkConfig);\r\n                    if (STATUS_SUCCESS == returnCode)\r\n                    {\r\n                        changeClkVlp = true;\r\n                        modeConfig.powerModeName = POWER_MANAGER_VLPR;\r\n                        /* Disable all clock source except SIRC */\r\n                        POWER_DRV_DisableVlpClockSrc();\r\n                        /* Switch the mode */\r\n                        returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                returnCode = STATUS_SUCCESS;\r\n            }\r\n\r\n            break;\r\n        /* Wait mode */\r\n        default:\r\n            /* invalid power mode */\r\n            returnCode = STATUS_UNSUPPORTED;\r\n            modeConfig.powerModeName = POWER_MANAGER_MAX;\r\n            break;\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_SwitchToSleepingPowerMode\r\n * Description   :Internal function used by POWER_SYS_SetMode function to switch to a sleeping power mode\r\n * configPtr   pointer to the requested user-defined power mode configuration\r\n *\r\n *END**************************************************************************/\r\nstatic status_t POWER_SYS_SwitchToSleepingPowerMode(const power_manager_user_config_t * const configPtr)\r\n{\r\n    smc_power_mode_config_t modeConfig; /* SMC hardware layer configuration structure */\r\n    status_t returnCode = STATUS_SUCCESS; /* return value */\r\n    power_mode_stat_t pwrModeStat = SMC_GetPowerModeStatus(SMC);         /* power mode stat */\r\n\r\n    /* Configure the hardware layer */\r\n    switch (configPtr->powerMode)\r\n    {\r\n#if FEATURE_SMC_HAS_WAIT_VLPW\r\n        /* Wait mode */\r\n        case POWER_MANAGER_WAIT:\r\n            /* Wait mode can be entered only from Run mode */\r\n            if (pwrModeStat != STAT_RUN)\r\n            {\r\n                modeConfig.powerModeName = POWER_MANAGER_RUN;\r\n                /* Switch the mode */\r\n                returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n            }\r\n\r\n            modeConfig.powerModeName = POWER_MANAGER_WAIT;\r\n            break;\r\n        /* Very low power wait mode */\r\n        case POWER_MANAGER_VLPW:\r\n            /* Very low power wait mode can be entered only from Very low power run mode */\r\n            if (pwrModeStat != STAT_VLPR)\r\n            {\r\n                modeConfig.powerModeName = POWER_MANAGER_VLPR;\r\n                /* Switch the mode */\r\n                returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n            }\r\n\r\n            modeConfig.powerModeName = POWER_MANAGER_VLPW;\r\n            break;\r\n#endif /* if FEATURE_SMC_HAS_WAIT_VLPW */\r\n#if FEATURE_SMC_HAS_PSTOPO\r\n        /* Partial stop modes */\r\n        case POWER_MANAGER_PSTOP1:\r\n        /* fall-through */\r\n        case POWER_MANAGER_PSTOP2:\r\n            /* fall-through */\r\n#endif\r\n#if FEATURE_SMC_HAS_STOPO\r\n        /* Stop modes */\r\n        case POWER_MANAGER_STOP1:\r\n        /* fall-through */\r\n        case POWER_MANAGER_STOP2:\r\n            /* Stop1 and Stop2 mode can be entered only from Run mode */\r\n            if (pwrModeStat != STAT_RUN)\r\n            {\r\n                modeConfig.powerModeName = POWER_MANAGER_RUN;\r\n                /* Switch the mode */\r\n                returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n            }\r\n\r\n            modeConfig.powerModeName = configPtr->powerMode;\r\n#endif /* #if FEATURE_SMC_HAS_STOPO */\r\n#if FEATURE_SMC_HAS_PSTOPO\r\n            modeConfig.pstopOption = true;\r\n            /* Set the partial stop option value */\r\n            if (POWER_MANAGER_PSTOP1 == configPtr->powerMode)\r\n            {\r\n                modeConfig.pstopOptionValue = SMC_PSTOP_STOP1;\r\n            }\r\n            else if (POWER_MANAGER_PSTOP2 == configPtr->powerMode)\r\n            {\r\n                modeConfig.pstopOptionValue = SMC_PSTOP_STOP2;\r\n            }\r\n            else\r\n            {\r\n                modeConfig.pstopOptionValue = SMC_PSTOP_STOP;\r\n            }\r\n\r\n#endif /* if FEATURE_SMC_HAS_PSTOPO */\r\n#if FEATURE_SMC_HAS_STOPO\r\n            /* Set the stop option value */\r\n            if (POWER_MANAGER_STOP1 == configPtr->powerMode)\r\n            {\r\n                modeConfig.stopOptionValue = SMC_STOP1;\r\n            }\r\n            else\r\n            {\r\n                modeConfig.stopOptionValue = SMC_STOP2;\r\n            }\r\n#endif /* if FEATURE_SMC_HAS_STOPO */\r\n            break;\r\n        /* Very low power stop mode */\r\n        case POWER_MANAGER_VLPS:\r\n            /* Very low power stop mode can be entered only from Run mode or Very low power run mode*/\r\n            if ((pwrModeStat != STAT_RUN) && (pwrModeStat != STAT_VLPR))\r\n            {\r\n                modeConfig.powerModeName = POWER_MANAGER_RUN;\r\n                returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n            }\r\n\r\n            if (returnCode == STATUS_SUCCESS)\r\n            {\r\n                if (POWER_SYS_GetCurrentMode() == POWER_MANAGER_RUN)\r\n                {\r\n                    /* Get current source clock */\r\n                    if (!changeClkVlp)\r\n                    {\r\n                        CLOCK_DRV_GetSystemClockSource(&sysClkConfig);\r\n                    }\r\n                    returnCode = POWER_DRV_SwitchVlprClk(&sysClkConfig);\r\n                    if (STATUS_SUCCESS == returnCode)\r\n                    {\r\n                        changeClkVlp = true;\r\n                        modeConfig.powerModeName = POWER_MANAGER_VLPS;\r\n                        /* Disable all clock source except SIRC */\r\n                        POWER_DRV_DisableVlpClockSrc();\r\n                    }\r\n                }\r\n            }\r\n            modeConfig.powerModeName = POWER_MANAGER_VLPS;\r\n            break;\r\n        default:\r\n            /* invalid power mode */\r\n            returnCode = STATUS_UNSUPPORTED;\r\n            modeConfig.powerModeName = POWER_MANAGER_MAX;\r\n            break;\r\n    }\r\n\r\n    if (STATUS_SUCCESS == returnCode)\r\n    {\r\n        /* Configure ARM core what to do after interrupt invoked in (deep) sleep state */\r\n            if (configPtr->sleepOnExitValue)\r\n            {\r\n                /* Go back to (deep) sleep state on ISR exit */\r\n                S32_SCB->SCR |= S32_SCB_SCR_SLEEPONEXIT_MASK;\r\n            }\r\n            else\r\n            {\r\n                /* Do not re-enter (deep) sleep state on ISR exit */\r\n                S32_SCB->SCR &= ~(S32_SCB_SCR_SLEEPONEXIT_MASK);\r\n            }\r\n\r\n        /* Switch the mode */\r\n        if (SMC_SetPowerMode(SMC, &modeConfig) != STATUS_SUCCESS)\r\n        {\r\n            returnCode = STATUS_MCU_TRANSITION_FAILED;\r\n        }\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_DRV_SwitchVlprClk\r\n * Description   : This function will change system clock in run mode before MCU enter very low power run mode.\r\n *\r\n *\r\n *END**************************************************************************/\r\nstatic status_t POWER_DRV_SwitchVlprClk(const sys_clk_config_t * const sysClock)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n    sys_clk_config_t sysClkVlprConfig;\r\n    clock_names_t currentSystemClockSource = sysClock->src;\r\n\r\n    if (currentSystemClockSource != SIRC_CLK)\r\n    {\r\n        /* Set SIRC the system clock source */\r\n        sysClkVlprConfig.src = SIRC_CLK;\r\n        sysClkVlprConfig.dividers[0U] = (uint16_t)(SCG_Get_VCCR_DIVCORE(SCG) + 1U);  /* Core clock divider, do not divide */\r\n        sysClkVlprConfig.dividers[1U] = (uint16_t)(SCG_Get_VCCR_DIVBUS(SCG) + 1U);    /* Bus clock divider, do not divide */\r\n        sysClkVlprConfig.dividers[2U] = (uint16_t)(SCG_Get_VCCR_DIVSLOW(SCG) + 1U);  /* Bus clock divider, do not divide */\r\n\r\n        retCode = CLOCK_DRV_SetSystemClock(NULL,&sysClkVlprConfig);\r\n    }\r\n\r\n    return retCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_DRV_UpdateInitClk\r\n * Description   : This function will  update initialization or default clock source of run mode when MCU come back run mode.\r\n *\r\n *\r\n *END**************************************************************************/\r\nstatic status_t POWER_DRV_UpdateInitClk(const sys_clk_config_t * const sysClk)\r\n{\r\n    status_t retCode = STATUS_SUCCESS;\r\n\r\n    retCode = CLOCK_DRV_SetSystemClock(NULL,sysClk);\r\n\r\n    return retCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_DRV_EnableVlpClockSrc\r\n * Description   : This function will enable SPLL, FIRC, SOSC\r\n *\r\n *END**************************************************************************/\r\nstatic void POWER_DRV_EnableVlpClockSrc(void)\r\n{\r\n#if FEATURE_HAS_SPLL_CLK\r\n    SCG_SetEnableSPLL(enableSPLL);\r\n#endif /* #if FEATURE_HAS_SPLL_CLK */\r\n    SCG_SetEnableFIRC(enableFIRC);\r\n    SCG_SetEnableSOSC(enableSOSC);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_DRV_DisableVlpClockSrc\r\n * Description   : This function will disable SPLL, FIRC, SOSC\r\n * before enter the very low power mode.\r\n *\r\n *\r\n *END**************************************************************************/\r\nstatic void POWER_DRV_DisableVlpClockSrc(void)\r\n{\r\n#if FEATURE_HAS_SPLL_CLK\r\n    SCG_SetEnableSPLL(false);\r\n#endif /* #if FEATURE_HAS_SPLL_CLK */\r\n    SCG_SetEnableSOSC(false);\r\n    SCG_SetEnableFIRC(false);\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_DRV_GetEnableClockSrc\r\n * Description   : This function will get status of clock source enable or not.\r\n *\r\n *END**************************************************************************/\r\nstatic void POWER_DRV_GetEnableClockSrc(void)\r\n{\r\n#if FEATURE_HAS_SPLL_CLK\r\n    enableSPLL = SCG_GetEnableSPLL();\r\n#endif /* #if FEATURE_HAS_SPLL_CLK */\r\n    enableFIRC = SCG_GetEnableFIRC();\r\n    enableSOSC = SCG_GetEnableSOSC();\r\n}\r\n\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_EnterHsrunMode\r\n * Description   :Internal function used by POWER_SYS_SwitchToRunningPowerMode function to enter configuration\r\n * to a Hsrun power mode.\r\n * configPtr   pointer to the requested user-defined Hsrun mode power mode configuration.\r\n * System clock source must be FIRC or SPLL in HSRun mode before transition very low power run  mode.\r\n * Update initialization when came back from very low power run mode.\r\n *\r\n *END**************************************************************************/\r\nstatic status_t POWER_SYS_EnterHsrunMode(void)\r\n{\r\n    status_t returnCode = STATUS_SUCCESS;\r\n    smc_power_mode_config_t modeConfig; /* SMC hardware layer configuration structure */\r\n #if FEATURE_HAS_SPLL_CLK\r\n    bool checkEnableSPLL = SCG_GetHsrunSelectSPLL();\r\n\r\n    if ((!enableSPLL) && (!enableFIRC))\r\n    {\r\n        returnCode = STATUS_ERROR;\r\n    }\r\n    else if ((checkEnableSPLL && !enableSPLL) || (!checkEnableSPLL && !enableFIRC))\r\n    {\r\n        returnCode = STATUS_ERROR;\r\n    }\r\n    else\r\n#endif\r\n    {\r\n        if (changeClkVlp)\r\n        {\r\n            POWER_DRV_EnableVlpClockSrc();\r\n            /* Update initialize clock configuration */\r\n            returnCode = POWER_DRV_UpdateInitClk(&sysClkConfig);\r\n            if (returnCode == STATUS_SUCCESS)\r\n            {\r\n                changeClkVlp = false;\r\n                modeConfig.powerModeName = POWER_MANAGER_HSRUN;\r\n                /* Switch the mode */\r\n                returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            modeConfig.powerModeName = POWER_MANAGER_HSRUN;\r\n            /* Switch the mode */\r\n            returnCode = SMC_SetPowerMode(SMC, &modeConfig);\r\n        }\r\n    }\r\n\r\n    return returnCode;\r\n}\r\n#endif\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : POWER_SYS_GetResetSrcStatusCmd\r\n * Description   : This function will get the current reset source status for specified source\r\n *\r\n * Implements POWER_SYS_GetResetSrcStatusCmd_Activity\r\n *\r\n *END**************************************************************************/\r\nbool POWER_SYS_GetResetSrcStatusCmd(const RCM_Type * const baseAddr , const rcm_source_names_t srcName)\r\n{\r\n    return RCM_GetSrcStatusCmd(baseAddr , srcName);\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_manager_S32K1xx.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\power\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2014-2016 Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef POWER_MANAGER_S32K1XX_H\r\n#define POWER_MANAGER_S32K1XX_H\r\n\r\n/*!\r\n * @file clock_manager_S32K1xx.h\r\n */\r\n\r\n#include \"device_registers.h\"\r\n#include \"status.h\"\r\n\r\n/*!\r\n * @ingroup power_manager\r\n * @defgroup power_s32k1xx\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n/*!\r\n * @brief Power modes enumeration.\r\n *\r\n * Defines power modes. Used in the power mode configuration structure\r\n * (power_manager_user_config_t). From ARM core perspective, Power modes\r\n * can be generally divided into run modes (High speed run, Run and\r\n * Very low power run), sleep (Wait and Very low power wait) and deep sleep modes\r\n * (all Stop modes).\r\n * List of power modes supported by specific chip along with requirements for entering\r\n * and exiting of these modes can be found in chip documentation.\r\n * List of all supported power modes:\\n\r\n *  \\li POWER_MANAGER_HSRUN - High speed run mode.\r\n *  \\li POWER_MANAGER_RUN - Run mode.\r\n *  \\li POWER_MANAGER_VLPR - Very low power run mode.\r\n *  \\li POWER_MANAGER_WAIT - Wait mode.\r\n *  \\li POWER_MANAGER_VLPW - Very low power wait mode.\r\n *  \\li POWER_MANAGER_PSTOP1 - Partial stop 1 mode.\r\n *  \\li POWER_MANAGER_PSTOP2 - Partial stop 2 mode.\r\n *  \\li POWER_MANAGER_PSTOP1 - Stop 1 mode.\r\n *  \\li POWER_MANAGER_PSTOP2 - Stop 2 mode.\r\n *  \\li POWER_MANAGER_VLPS - Very low power stop mode.\r\n * Implements power_manager_modes_t_Class\r\n */\r\ntypedef enum\r\n{\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n    POWER_MANAGER_HSRUN,            /*!< High speed run mode.  */\r\n#endif\r\n    POWER_MANAGER_RUN,              /*!< Run mode. */\r\n    POWER_MANAGER_VLPR,             /*!< Very low power run mode.  */\r\n#if FEATURE_SMC_HAS_WAIT_VLPW\r\n    POWER_MANAGER_WAIT,             /*!< Wait mode.  */\r\n    POWER_MANAGER_VLPW,             /*!< Very low power wait mode.  */\r\n#endif\r\n#if FEATURE_SMC_HAS_PSTOPO\r\n    POWER_MANAGER_PSTOP1,           /*!< Partial stop 1 mode. */\r\n    POWER_MANAGER_PSTOP2,           /*!< Partial stop 2 mode. */\r\n#endif\r\n#if FEATURE_SMC_HAS_STOPO\r\n    POWER_MANAGER_STOP1,           /*!< Stop 1 mode. */\r\n    POWER_MANAGER_STOP2,           /*!< Stop 2 mode. */\r\n#endif\r\n    POWER_MANAGER_VLPS,             /*!< Very low power stop mode.  */\r\n    POWER_MANAGER_MAX\r\n} power_manager_modes_t;\r\n\r\n/*!\r\n * @brief Power mode user configuration structure.\r\n *\r\n * List of power mode configuration structure members depends on power options available\r\n * for the specific chip. Complete list contains:\r\n * mode - S32K power mode. List of available modes is chip-specific. See power_manager_modes_t\r\n * list of modes.\r\n * sleepOnExitOption - Controls whether the sleep-on-exit option value is used(when set to true)\r\n * or ignored(when set to false). See sleepOnExitValue.\r\n * sleepOnExitValue - When set to true, ARM core returns to sleep (S32K wait modes) or deep sleep\r\n * state (S32K stop modes) after interrupt service finishes. When set to false, core stays\r\n * woken-up.\r\n * Implements power_manager_user_config_t_Class\r\n */\r\ntypedef struct\r\n{\r\n    power_manager_modes_t powerMode;\r\n    bool sleepOnExitValue;\r\n} power_manager_user_config_t;\r\n\r\n/*!\r\n * @brief Power Modes in PMSTAT\r\n *\r\n */\r\ntypedef enum\r\n{\r\n    STAT_RUN     = 0x01,              /*!< 0000_0001 - Current power mode is RUN*/\r\n    STAT_STOP    = 0x02,              /*!< 0000_0010 - Current power mode is STOP*/\r\n    STAT_VLPR    = 0x04,              /*!< 0000_0100 - Current power mode is VLPR*/\r\n    STAT_VLPW    = 0x08,              /*!< 0000_1000 - Current power mode is VLPW*/\r\n    STAT_VLPS    = 0x10,              /*!< 0001_0000 - Current power mode is VLPS*/\r\n    STAT_HSRUN   = 0x80,              /*!< 1000_0000 - Current power mode is HSRUN*/\r\n    STAT_INVALID = 0xFF               /*!< 1111_1111 - Non-existing power mode*/\r\n} power_mode_stat_t;\r\n\r\n/*!\r\n * @brief Run mode definition\r\n *\r\n */\r\ntypedef enum\r\n{\r\n    SMC_RUN,                                /*!< normal RUN mode*/\r\n    SMC_RESERVED_RUN, SMC_VLPR,             /*!< Very-Low-Power RUN mode*/\r\n    SMC_HSRUN                               /*!< High Speed Run mode (HSRUN)*/\r\n} smc_run_mode_t;\r\n\r\n/*!\r\n * @brief Stop mode definition\r\n *\r\n */\r\ntypedef enum\r\n{\r\n    SMC_STOP            = 0U,    /*!< Normal STOP mode*/\r\n    SMC_RESERVED_STOP1  = 1U,    /*!< Reserved*/\r\n    SMC_VLPS            = 2U     /*!< Very-Low-Power STOP mode*/\r\n} smc_stop_mode_t;\r\n\r\n/*!\r\n * @brief STOP option\r\n *\r\n */\r\ntypedef enum\r\n{\r\n    SMC_STOP_RESERVED = 0x00,               /*!< Reserved stop mode */\r\n    SMC_STOP1         = 0x01,               /*!< Stop with both system and bus clocks disabled */\r\n    SMC_STOP2         = 0x02                /*!< Stop with system clock disabled and bus clock enabled */\r\n} smc_stop_option_t;\r\n\r\n/*!\r\n * @brief Power mode protection configuration\r\n *\r\n */\r\ntypedef struct\r\n{\r\n    bool vlpProt;            /*!< VLP protect*/\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n    bool hsrunProt;          /*!< HSRUN protect */\r\n#endif\r\n} smc_power_mode_protection_config_t;\r\n\r\n/*!\r\n * @brief Power mode control configuration used for calling the SMC_SYS_SetPowerMode API\r\n *\r\n */\r\ntypedef struct\r\n{\r\n    power_manager_modes_t powerModeName;    /*!< Power mode(enum), see power_manager_modes_t */\r\n#if FEATURE_SMC_HAS_STOPO\r\n    smc_stop_option_t stopOptionValue;      /*!< STOPO option(enum), see smc_stop_option_t */\r\n#endif\r\n#if FEATURE_SMC_HAS_PSTOPO\r\n    bool pStopOption;                       /*!< If PSTOPO option is needed */\r\n    smc_stop_option_t pStopOptionValue;     /*!< PSTOPO option(enum), see smc_stop_option_t */\r\n#endif\r\n} smc_power_mode_config_t;\r\n\r\n/*!\r\n * @brief System Reset Source Name definitions\r\n * Implements rcm_source_names_t_Class\r\n */\r\ntypedef enum\r\n{\r\n    RCM_LOW_VOLT_DETECT      = 1U,             /*!< Low voltage detect reset */\r\n    RCM_LOSS_OF_CLK          = 2U,       /*!< Loss of clock reset */\r\n    RCM_LOSS_OF_LOCK         = 3U,       /*!< Loss of lock reset */\r\n#if FEATURE_RCM_HAS_CMU_LOSS_OF_CLOCK\r\n    RCM_CMU_LOC              = 4U,        /*!< CMU Loss of lock reset */\r\n#endif\r\n    RCM_WATCH_DOG            = 5U,        /*!< Watch dog reset */\r\n    RCM_EXTERNAL_PIN         = 6U,       /*!< External pin reset */\r\n    RCM_POWER_ON             = 7U,       /*!< Power on reset */\r\n    RCM_SJTAG                = 8U,       /*!< JTAG generated reset */\r\n    RCM_CORE_LOCKUP          = 9U,       /*!< core lockup reset */\r\n    RCM_SOFTWARE             = 10U,       /*!< Software reset */\r\n    RCM_SMDM_AP              = 11U,       /*!< MDM-AP system reset */\r\n    RCM_STOP_MODE_ACK_ERR    = 13U,       /*!< Stop mode ack error reset */\r\n    RCM_SRC_NAME_MAX\r\n} rcm_source_names_t;\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\n\r\n/*!\r\n * @brief This function implementation-specific configuration of power modes.\r\n *\r\n * This function performs the actual implementation-specific initialization based on the provided power mode configurations.\r\n * In addition, This function get all clock source were enabled. This one was used for update init clock when CPU \r\n    jump from very low power mode to run or high speed run mode.\r\n *\r\n * @return Operation status\r\n *        - STATUS_SUCCESS: Operation was successful.\r\n *        - STATUS_ERROR: Operation failed.\r\n */\r\nstatus_t POWER_SYS_DoInit(void);\r\n\r\n/*!\r\n * @brief This function implementation-specific de-initialization of power manager.\r\n *\r\n * This function performs the actual implementation-specific de-initialization.\r\n *\r\n * @return Operation status\r\n *        - STATUS_SUCCESS: Operation was successful.\r\n *        - STATUS_ERROR: Operation failed.\r\n */\r\nstatus_t POWER_SYS_DoDeinit(void);\r\n\r\n/*!\r\n * @brief This function configures the power mode.\r\n *\r\n * This function performs the actual implementation-specific logic to switch to one of the defined power modes.\r\n *\r\n * @param configPtr: Pointer to user configuration structure\r\n * @return Operation status\r\n *        - STATUS_SUCCESS: Operation was successful.\r\n *        - STATUS_MCU_TRANSITION_FAILED: Operation failed.\r\n */\r\nstatus_t POWER_SYS_DoSetMode(const power_manager_user_config_t * const configPtr);\r\n\r\n/*!\r\n * @brief Gets the reset source status\r\n *\r\n * This function gets the current reset source status for a specified source.\r\n *\r\n * @param[in] baseAddr     Register base address of RCM\r\n * @param[in] srcName      reset source name\r\n * @return status          True or false for specified reset source\r\n */\r\nbool POWER_SYS_GetResetSrcStatusCmd(const RCM_Type * const baseAddr , const rcm_source_names_t srcName);\r\n\r\n/*!\r\n * @brief Gets the default power_manager configuration structure.\r\n *\r\n * This function gets the power_manager configuration structure of the default power mode.\r\n *\r\n * @param[out] defaultConfig : Pointer to power mode configuration structure of the default power mode.\r\n */\r\nstatic inline void POWER_SYS_DoGetDefaultConfig(power_manager_user_config_t * const defaultConfig)\r\n{\r\n    defaultConfig->powerMode = POWER_MANAGER_RUN;    /*!< Power manager mode  */\r\n    defaultConfig->sleepOnExitValue = false;         /*!< Sleep on exit value */\r\n}\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n\r\n#endif /* POWER_MANAGER_S32K1XX_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_rcm_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\power\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef POWER_RCM_HW_ACCESS_H\r\n#define POWER_RCM_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n#include \"power_manager_S32K1xx.h\"\r\n\r\n/*! @file power_rcm_hw_access.h */\r\n\r\n/*!\r\n * @ingroup power_rcm_hw_access\r\n * @defgroup power_rcm_hw_access\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n/*! @name Reset Control Module APIs*/\r\n/*@{*/\r\n\r\nstatic inline bool RCM_GetSrcStatusCmd(const RCM_Type * const baseAddr,\r\n                         const rcm_source_names_t srcName)\r\n{\r\n    bool retValue;\r\n    uint32_t regValue = (uint32_t)baseAddr->SRS;\r\n\r\n    DEV_ASSERT(srcName < RCM_SRC_NAME_MAX);\r\n\r\n    switch (srcName)\r\n    {\r\n        case RCM_LOW_VOLT_DETECT:              /* low voltage detect reset */\r\n            regValue = (regValue & RCM_SRS_LVD_MASK) >> RCM_SRS_LVD_SHIFT;\r\n            break;\r\n        case RCM_LOSS_OF_CLK:                  /* loss of clock reset */\r\n            regValue = (regValue & RCM_SRS_LOC_MASK) >> RCM_SRS_LOC_SHIFT;\r\n            break;\r\n        case RCM_LOSS_OF_LOCK:                 /* loss of lock reset */\r\n            regValue = (regValue & RCM_SRS_LOL_MASK) >> RCM_SRS_LOL_SHIFT;\r\n            break;\r\n#if FEATURE_RCM_HAS_CMU_LOSS_OF_CLOCK          /*!< CMU Loss of lock reset */\r\n        case RCM_CMU_LOC:\r\n            regValue = (regValue & RCM_SRS_CMU_LOC_MASK) >> RCM_SRS_CMU_LOC_SHIFT;\r\n            break;     \r\n#endif\r\n        case RCM_WATCH_DOG:                    /* watch dog reset */\r\n            regValue = (regValue & RCM_SRS_WDOG_MASK) >> RCM_SRS_WDOG_SHIFT;\r\n            break;\r\n        case RCM_EXTERNAL_PIN:                 /* external pin reset */\r\n            regValue = (regValue & RCM_SRS_PIN_MASK) >> RCM_SRS_PIN_SHIFT;\r\n            break;\r\n        case RCM_POWER_ON:                     /* power on reset */\r\n            regValue = (regValue & RCM_SRS_POR_MASK) >> RCM_SRS_POR_SHIFT;\r\n            break;\r\n        case RCM_SJTAG:                        /* JTAG generated reset */\r\n            regValue = (regValue & RCM_SSRS_SJTAG_MASK) >> RCM_SSRS_SJTAG_SHIFT;\r\n            break;\r\n        case RCM_CORE_LOCKUP:                  /* core lockup reset */\r\n            regValue = (regValue & RCM_SRS_LOCKUP_MASK) >> RCM_SRS_LOCKUP_SHIFT;\r\n            break;\r\n        case RCM_SOFTWARE:                     /* software reset */\r\n            regValue = (regValue & RCM_SRS_SW_MASK) >> RCM_SRS_SW_SHIFT;\r\n            break;\r\n        case RCM_SMDM_AP:                      /* MDM-AP system reset */\r\n            regValue = (regValue & RCM_SSRS_SMDM_AP_MASK) >> RCM_SSRS_SMDM_AP_SHIFT;\r\n            break;\r\n        case RCM_STOP_MODE_ACK_ERR:            /* stop mode ack error reset */\r\n            regValue = (regValue & RCM_SRS_SACKERR_MASK) >> RCM_SRS_SACKERR_SHIFT;\r\n            break;\r\n        default:\r\n            /* invalid command */\r\n            regValue = 0U;\r\n            break;\r\n    }\r\n\r\n    retValue = (regValue == 0UL) ? false : true;\r\n\r\n    return retValue;\r\n}\r\n\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n/*! @}*/\r\n\r\n#endif /* POWER_RCM_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_scg_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright 2018-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef POWER_SCG_HW_ACCESS_H\r\n#define POWER_SCG_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n\r\n/*!\r\n * @file power_scg_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The address of hardware modules is provided as integer so\r\n * it needs to be cast to pointer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The address of hardware modules is provided as integer so\r\n * a conversion between a pointer and an integer has to be performed\r\n */\r\n\r\n/*!\r\n * power_scg_hw_access\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n/*!\r\n * @brief Set the SPLL clock source was enabled or disabled\r\n *\r\n * This function sets SPLL clock source enable or disabled.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @param[in] enable This variable select the SPLL available or not.\r\n */\r\nstatic inline void SCG_SetEnableSPLL(bool enable)\r\n{\r\n    uint32_t regValue = SCG->SPLLCSR;\r\n    regValue &= ~SCG_SPLLCSR_SPLLEN_MASK;\r\n    if (enable == true)\r\n    {\r\n        regValue |= SCG_SPLLCSR_SPLLEN(1U);\r\n    }\r\n    else\r\n    {\r\n        regValue |= SCG_SPLLCSR_SPLLEN(0U);\r\n    }\r\n    SCG->SPLLCSR = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Get status of SPLL clock source was enabled or disabled\r\n *\r\n * This function gets SPLL clock source enable or disabled.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @return true  : SPLL enabled\r\n           false : SPLL disable\r\n */\r\nstatic inline bool SCG_GetEnableSPLL(void)\r\n{\r\n    uint32_t regValue = SCG->SPLLCSR;\r\n    regValue = (regValue & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;\r\n\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n/*!\r\n * @brief Check clock source in HSRUN mode\r\n *\r\n * This function checks SPLL as source in HSRUN mode.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @return true  : SPLL is clock source in HSRUN.\r\n           false : SPLL is not clock source in HSRUN.\r\n */\r\nstatic inline bool SCG_GetHsrunSelectSPLL(void)\r\n{\r\n    uint32_t regValue = SCG->HCCR;\r\n    regValue = (regValue & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT;\r\n\r\n    return (regValue == FEATURE_SCG_SPLL_VALUE) ? true : false;\r\n}\r\n#endif\r\n\r\n#endif\r\n\r\n/*!\r\n * @brief Set the FIRC clock source was enabled or disabled\r\n *\r\n * This function sets FIRC clock source enable or disabled.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @param[in] enable This variable select the FIRC available or not.\r\n */\r\nstatic inline void SCG_SetEnableFIRC(bool enable)\r\n{\r\n    uint32_t regValue = SCG->FIRCCSR;\r\n    regValue &= ~SCG_FIRCCSR_FIRCEN_MASK;\r\n    if (enable == true)\r\n    {\r\n        regValue |= SCG_FIRCCSR_FIRCEN(1U);\r\n    }\r\n    else\r\n    {\r\n        regValue |= SCG_FIRCCSR_FIRCEN(0U);\r\n    }\r\n    SCG->FIRCCSR = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Get status of FIRC clock source was enabled or disabled\r\n *\r\n * This function gets FIRC clock source enable or disabled.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @return true  : FIRC enabled\r\n           false : FIRC disable\r\n */\r\nstatic inline bool SCG_GetEnableFIRC(void)\r\n{\r\n    uint32_t regValue = SCG->FIRCCSR;\r\n    regValue = (regValue & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;\r\n\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n * @brief Set the SOSC clock source was enabled or disabled\r\n *\r\n * This function sets SOSC clock source enable or disabled.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @param[in] enable This variable select the SOSC available or not.\r\n */\r\nstatic inline void SCG_SetEnableSOSC(bool enable)\r\n{\r\n    uint32_t regValue = SCG->SOSCCSR;\r\n    regValue &= ~SCG_SOSCCSR_SOSCEN_MASK;\r\n    if (enable == true)\r\n    {\r\n        regValue |= SCG_SOSCCSR_SOSCEN(1U);\r\n    }\r\n    else\r\n    {\r\n        regValue |= SCG_SOSCCSR_SOSCEN(0U);\r\n    }\r\n    SCG->SOSCCSR = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Get status of SOSC clock source was enabled or disabled\r\n *\r\n * This function gets SOSC clock source enable or disabled.\r\n * This one is used in the switching very low power mode sequence.\r\n *\r\n * @return true  : SOSC enabled\r\n           false : SOSC disable\r\n */\r\nstatic inline bool SCG_GetEnableSOSC(void)\r\n{\r\n    uint32_t regValue = SCG->SOSCCSR;\r\n    regValue = (regValue & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;\r\n\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n/*! @}*/\r\n\r\n#endif /* POWER_SCG_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_smc_hw_access.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n/*!\r\n * @file power_smc_hw_access.c\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The address of hardware modules is provided as integer so\r\n * it needs to be cast to pointer.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The address of hardware modules is provided as integer so\r\n * a conversion between a pointer and an integer has to be performed\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application or driver code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 10.3, Expression assigned to a narrower or different essential type.\r\n * The cast is required to perform a conversion between an unsigned integer and an enum type with many values.\r\n */\r\n\r\n#include <stddef.h>\r\n#include \"power_smc_hw_access.h\"\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n\r\n/*******************************************************************************\r\n * INTERNAL FUNCTIONS\r\n ******************************************************************************/\r\nstatic bool SMC_WaitForStatChange(const SMC_Type * const baseAddr,\r\n                                  const power_mode_stat_t mode,\r\n                                  const uint32_t timeout);\r\n\r\n/*! Timeout used for waiting to set new mode */\r\n#define SMC_TIMEOUT 1000U\r\n\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SMC_SetPowerMode\r\n * Description   : Configure the power mode\r\n * This function will configure the power mode control for any run, stop and\r\n * stop submode if needed. It will also configure the power options for specific\r\n * power mode. Application should follow the proper procedure to configure and\r\n * switch power mode between the different run and stop mode. Refer to reference\r\n * manual for the proper procedure and supported power mode that can be configured\r\n * and switch between each other. Refer to smc_power_mode_config_t for required\r\n * parameters to configure the power mode and the supported options. Other options\r\n * may need to configure through the hal driver individaully. Refer to hal driver\r\n * header for details.\r\n *\r\n *END**************************************************************************/\r\nstatus_t SMC_SetPowerMode(SMC_Type * const baseAddr,\r\n                          const smc_power_mode_config_t * const powerModeConfig)\r\n{\r\n    status_t retCode;\r\n    smc_stop_mode_t stopMode;\r\n    power_manager_modes_t powerModeName = powerModeConfig->powerModeName;\r\n    /* Branch based on power mode name*/\r\n    switch (powerModeName)\r\n    {\r\n        case POWER_MANAGER_RUN:\r\n            /* Biasing disabled, core logic can run in full performance */\r\n            PMC_DisableBiasen(PMC);\r\n            /* Set to RUN mode. */\r\n            SMC_SetRunModeControl(baseAddr, SMC_RUN);\r\n            /* Wait for stat change */\r\n            if (!SMC_WaitForStatChange(baseAddr, STAT_RUN, SMC_TIMEOUT))\r\n            {\r\n                /* Timeout for power mode change expired. */\r\n                retCode = STATUS_MCU_TRANSITION_FAILED;\r\n            }\r\n            else\r\n            {\r\n                retCode = STATUS_SUCCESS;\r\n            }\r\n            break;\r\n\r\n        case POWER_MANAGER_VLPR:\r\n            /* Biasing enable before entering VLP* mode to educe MCU power consumption in low power mode*/\r\n            PMC_EnableBiasen(PMC);\r\n\r\n            /* Set power mode to VLPR*/\r\n            SMC_SetRunModeControl(baseAddr, SMC_VLPR);\r\n            /* Wait for stat change */\r\n            if (!SMC_WaitForStatChange(baseAddr, STAT_VLPR, SMC_TIMEOUT))\r\n            {\r\n                /* Timeout for power mode change expired. */\r\n                retCode = STATUS_MCU_TRANSITION_FAILED;\r\n            }\r\n            else\r\n            {\r\n                retCode = STATUS_SUCCESS;\r\n            }\r\n            break;\r\n\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n        case POWER_MANAGER_HSRUN:\r\n            /* Biasing disabled, core logic can run in full performance */\r\n            PMC_DisableBiasen(PMC);\r\n            /* Set power mode to HSRUN */\r\n            SMC_SetRunModeControl(baseAddr, SMC_HSRUN);\r\n            /* Wait for stat change */\r\n            if (!SMC_WaitForStatChange(baseAddr, STAT_HSRUN, SMC_TIMEOUT))\r\n            {\r\n                /* Timeout for power mode change expired. */\r\n                retCode = STATUS_MCU_TRANSITION_FAILED;\r\n            }\r\n            else\r\n            {\r\n                retCode = STATUS_SUCCESS;\r\n            }\r\n\r\n            break;\r\n#endif /* if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */\r\n#if FEATURE_SMC_HAS_WAIT_VLPW\r\n        case POWER_MANAGER_WAIT:\r\n        /* Fall-through */\r\n        case POWER_MANAGER_VLPW:\r\n            /* Clear the SLEEPDEEP bit to disable deep sleep mode - WAIT */\r\n            S32_SCB->SCR &= ~S32_SCB_SCR_SLEEPDEEP_MASK;\r\n\r\n            /* Cpu is going into sleep state */\r\n            STANDBY();\r\n\r\n            retCode = STATUS_SUCCESS;\r\n            break;\r\n#endif /* if FEATURE_SMC_HAS_WAIT_VLPW */\r\n        case POWER_MANAGER_STOP1:\r\n        /* Fall-through */\r\n        case POWER_MANAGER_STOP2:\r\n        /* Fall-through */\r\n        case POWER_MANAGER_VLPS:\r\n            if ((powerModeName == POWER_MANAGER_STOP1) || (powerModeName == POWER_MANAGER_STOP2))\r\n            {\r\n                stopMode = SMC_STOP;\r\n#if FEATURE_SMC_HAS_STOPO\r\n                SMC_SetStopOption(baseAddr, powerModeConfig->stopOptionValue);\r\n#endif\r\n#if FEATURE_SMC_HAS_PSTOPO\r\n                SMC_SetPStopOption(baseAddr, powerModeConfig->pStopOptionValue);\r\n#endif\r\n            }\r\n            else\r\n            {\r\n                /* Biasing enable before entering VLP* mode to educe MCU power consumption in low power mode*/\r\n                PMC_EnableBiasen(PMC);\r\n                stopMode = SMC_VLPS;\r\n            }\r\n\r\n            /* Set power mode to specified STOP mode*/\r\n            SMC_SetStopModeControl(baseAddr, stopMode);\r\n\r\n            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP)*/\r\n            S32_SCB->SCR |= S32_SCB_SCR_SLEEPDEEP_MASK;\r\n\r\n            /* Cpu is going into deep sleep state */\r\n            STANDBY();\r\n\r\n            /* check the current mode to control bias bit */\r\n            if (SMC_GetPowerModeStatus(baseAddr) == STAT_RUN)\r\n            {\r\n                PMC_DisableBiasen(PMC);\r\n            }\r\n            else\r\n            {\r\n                PMC_EnableBiasen(PMC);\r\n            }\r\n\r\n            retCode = STATUS_SUCCESS;\r\n            break;\r\n        default:\r\n            retCode = STATUS_UNSUPPORTED;\r\n            break;\r\n    }\r\n\r\n    return retCode;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SMC_SetProtectionMode\r\n * Description   : Configure all power mode protection settings\r\n * This function will configure the power mode protection settings for\r\n * supported power mode on the specified chip family. The available power modes\r\n * are defined in smc_power_mode_protection_config_t. Application should provide\r\n * the protect settings for all supported power mode on the chip and also this\r\n * should be done at early system level initialize stage. Refer to reference manual\r\n * for details. This register can only write once after power reset. So either\r\n * use this function or use the individual set function if you only have single\r\n * option to set.\r\n *\r\n *END**************************************************************************/\r\nvoid SMC_SetProtectionMode(SMC_Type * const baseAddr,\r\n                           const smc_power_mode_protection_config_t * const protectConfig)\r\n{\r\n    /* Initialize the setting */\r\n    uint32_t regValue = 0U;\r\n\r\n    /* Check configurations for each mode and combine the setting together */\r\n    if (protectConfig->vlpProt)\r\n    {\r\n        regValue |= SMC_PMPROT_AVLP(1);\r\n    }\r\n\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n    if (protectConfig->hsrunProt)\r\n    {\r\n        regValue |= SMC_PMPROT_AHSRUN(1);\r\n    }\r\n\r\n#endif\r\n\r\n    /* Write once into PMPROT register*/\r\n    baseAddr->PMPROT = regValue;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n * Function Name : SMC_WaitForStatChange\r\n * Description   : Internal function used by SMC_SetPowerMode function\r\n * to wait until the state is changed or timeout expires\r\n *\r\n * return power mode status change\r\n *                - true: power mode has been changed successfully\r\n *                - false: timeout expired, power mode has not been changed\r\n *END**************************************************************************/\r\nstatic bool SMC_WaitForStatChange(const SMC_Type * const baseAddr,\r\n                                  const power_mode_stat_t mode,\r\n                                  const uint32_t timeout)\r\n{\r\n    uint32_t i;\r\n    bool retValue;\r\n\r\n    /* Waiting for register read access. It's no longer apply when bus clock has very low frequency in HSRUN mode */\r\n    if (mode == STAT_HSRUN)\r\n    {\r\n        for (i = 0U; i < 100U; i++)\r\n        {\r\n            /* Do nothing */\r\n        }\r\n    }\r\n\r\n    for (i = 0U; i < timeout; i++)\r\n    {\r\n        if (mode == SMC_GetPowerModeStatus(baseAddr))\r\n        {\r\n            /* Power mode has been changed successfully */\r\n            break;\r\n        }\r\n    }\r\n\r\n    /* If i greater or equal to timeout, then timeout expired(the power mode has not been changed)*/\r\n    retValue = (i < timeout);\r\n\r\n    return retValue;\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"power_smc_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\power\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef POWER_SMC_HW_ACCESS_H\r\n#define POWER_SMC_HW_ACCESS_H\r\n\r\n#include \"status.h\"\r\n#include \"device_registers.h\"\r\n#include \"power_manager_S32K1xx.h\"\r\n\r\n/*!\r\n * @file power_smc_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, Global typedef not referenced.\r\n * User configuration structure is defined in Hal and is referenced from Driver.\r\n */\r\n\r\n/*!\r\n * power_smc_hw_access\r\n * @{\r\n */\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n/*! @name System mode controller APIs*/\r\n/*@{*/\r\n\r\n/*!\r\n * @brief Configures the power mode.\r\n *\r\n * This function configures the power mode control for both run, stop, and\r\n * stop sub mode if needed. Also it configures the power options for a specific\r\n * power mode. An application should follow the proper procedure to configure and\r\n * switch power modes between  different run and stop modes. For proper procedures\r\n * and supported power modes, see an appropriate chip reference\r\n * manual. See the smc_power_mode_config_t for required\r\n * parameters to configure the power mode and the supported options. Other options\r\n * may need to be individually configured through the HAL driver. See the HAL driver\r\n * header file for details.\r\n *\r\n * @param baseAddr  Base address for current SMC instance.\r\n * @param powerModeConfig Power mode configuration structure smc_power_mode_config_t\r\n * @return errorCode SMC error code\r\n */\r\nstatus_t SMC_SetPowerMode(SMC_Type * const baseAddr,\r\n                          const smc_power_mode_config_t * const powerModeConfig);\r\n\r\n/*!\r\n * @brief Configures all power mode protection settings.\r\n *\r\n * This function configures the power mode protection settings for\r\n * supported power modes in the specified chip family. The available power modes\r\n * are defined in the smc_power_mode_protection_config_t. An application should provide\r\n * the protect settings for all supported power modes on the chip. This\r\n * should be done at an early system level initialization stage. See the reference manual\r\n * for details. This register can only write once after the power reset. If the user has\r\n * only a single option to set,\r\n * either use this function or use the individual set function.\r\n *\r\n *\r\n * @param[in] baseAddr  Base address for current SMC instance.\r\n * @param[in] protectConfig Configurations for the supported power mode protect settings\r\n *                      - See smc_power_mode_protection_config_t for details.\r\n */\r\nvoid SMC_SetProtectionMode(SMC_Type * const baseAddr,\r\n                           const smc_power_mode_protection_config_t * const protectConfig);\r\n\r\n/*!\r\n * @brief Configures the the RUN mode control setting.\r\n *\r\n * This function sets the run mode settings, for example, normal run mode,\r\n * very lower power run mode, etc. See the smc_run_mode_t for supported run\r\n * mode on the chip family and the reference manual for details about the\r\n * run mode.\r\n *\r\n * @param[in] baseAddr  Base address for current SMC instance.\r\n * @param[in] runMode   Run mode setting defined in smc_run_mode_t\r\n */\r\nstatic inline void SMC_SetRunModeControl(SMC_Type * const baseAddr,\r\n                                         const smc_run_mode_t runMode)\r\n{\r\n    uint32_t regValue = baseAddr->PMCTRL;\r\n    regValue &= ~(SMC_PMCTRL_RUNM_MASK);\r\n    regValue |= SMC_PMCTRL_RUNM(runMode);\r\n    baseAddr->PMCTRL = regValue;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Enable the BIASEN bit.\r\n *\r\n* This bit enables source and well biasing for the core logic in low power mode\r\n *\r\n * @param[in] baseAddr  Base address for current PMC instance.\r\n */\r\nstatic inline void PMC_EnableBiasen(PMC_Type * const baseAddr )\r\n{\r\n    uint8_t regValue = baseAddr->REGSC;\r\n    regValue &= ~(PMC_REGSC_BIASEN_MASK);\r\n\r\n    regValue |= ((uint8_t)(PMC_REGSC_BIASEN(1U)));\r\n    baseAddr->REGSC = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Disable the BIASEN bit.\r\n *\r\n * Biasing disabled, core logic can run in full performance\r\n *\r\n * @param[in] baseAddr  Base address for current PMC instance.\r\n */\r\nstatic inline void PMC_DisableBiasen(PMC_Type * const baseAddr )\r\n{\r\n    uint8_t regValue = baseAddr->REGSC;\r\n    regValue &= ~(PMC_REGSC_BIASEN_MASK);\r\n    baseAddr->REGSC = regValue;\r\n}\r\n\r\n/*!\r\n * @brief  Get core clock divide ratio value.\r\n *\r\n * @param[in] baseAddr  Base address for current SCG instance.\r\n */\r\nstatic inline uint32_t SCG_Get_VCCR_DIVCORE(const SCG_Type * const baseAddr )\r\n{\r\n    uint32_t regValue = baseAddr->VCCR;\r\n    regValue = (regValue & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT;\r\n    return regValue;\r\n\r\n}\r\n\r\n/*!\r\n * @brief  Get bus clock divide ratio value.\r\n *\r\n * @param[in] baseAddr  Base address for current SCG instance.\r\n */\r\nstatic inline uint32_t SCG_Get_VCCR_DIVBUS(const SCG_Type * const baseAddr )\r\n{\r\n    uint32_t regValue = baseAddr->VCCR;\r\n    regValue = (regValue & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT;\r\n    return regValue;\r\n\r\n}\r\n\r\n/*!\r\n * @brief Get slow clock divide ratio value.\r\n *\r\n * @param[in] baseAddr  Base address for current SCG instance.\r\n */\r\nstatic inline uint32_t SCG_Get_VCCR_DIVSLOW(const SCG_Type * const baseAddr )\r\n{\r\n    uint32_t regValue = baseAddr->VCCR;\r\n    regValue = (regValue & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT;\r\n    return regValue;\r\n\r\n}\r\n\r\n\r\n/*!\r\n * @brief Configures  the STOP mode control setting.\r\n *\r\n * This function sets the stop mode settings, for example, normal stop mode,\r\n * very lower power stop mode, etc. See the smc_stop_mode_t for supported stop\r\n * mode on the chip family and the reference manual for details about the\r\n * stop mode.\r\n *\r\n * @param[in] baseAddr  Base address for current SMC instance.\r\n * @param[in] stopMode  Stop mode defined in smc_stop_mode_t\r\n */\r\nstatic inline void SMC_SetStopModeControl(SMC_Type * const baseAddr,\r\n                                          const smc_stop_mode_t stopMode)\r\n{\r\n    uint32_t regValue = baseAddr->PMCTRL;\r\n    regValue &= ~(SMC_PMCTRL_STOPM_MASK);\r\n    regValue |= SMC_PMCTRL_STOPM(stopMode);\r\n    baseAddr->PMCTRL = regValue;\r\n}\r\n\r\n#if FEATURE_SMC_HAS_STOPO\r\n/*!\r\n * @brief Configures the STOPO (Stop Option).\r\n *\r\n * It controls the type of the stop operation when STOPM=STOP. When entering Stop mode\r\n * from RUN mode, the PMC, SCG and flash remain fully powered, allowing the device to\r\n * wakeup almost instantaneously at the expense of higher power consumption. In STOP2,\r\n * only system clocks are gated allowing peripherals running on bus clock to remain fully\r\n * functional. In STOP1, both system and bus clocks are gated.\r\n *\r\n * @param[in] baseAddr  Base address for current SMC instance.\r\n * @param[in] option STOPO option setting defined in smc_stop_option_t\r\n */\r\nstatic inline void SMC_SetStopOption(SMC_Type * const baseAddr,\r\n                                     const smc_stop_option_t option)\r\n{\r\n    uint32_t regValue = baseAddr->STOPCTRL;\r\n    regValue &= ~(SMC_STOPCTRL_STOPO_MASK);\r\n    regValue |= SMC_STOPCTRL_STOPO(option);\r\n    baseAddr->STOPCTRL = regValue;\r\n}\r\n\r\n#endif /* if FEATURE_SMC_HAS_STOPO */\r\n\r\n#if FEATURE_SMC_HAS_PSTOPO\r\n\r\n#error \"Unimplemented\"\r\n\r\n#endif\r\n\r\n/*!\r\n * @brief Gets the current power mode stat.\r\n *\r\n * This function returns the current power mode stat. Once application\r\n * switches the power mode, it should always check the stat to check whether it\r\n * runs into the specified mode or not. An application should check\r\n * this mode before switching to a different mode. The system requires that\r\n * only certain modes can switch to other specific modes. See the\r\n * reference manual for details and the power_mode_stat for information about\r\n * the power stat.\r\n *\r\n * @param[in] baseAddr  Base address for current SMC instance.\r\n * @return stat  Current power mode stat\r\n */\r\nstatic inline power_mode_stat_t SMC_GetPowerModeStatus(const SMC_Type * const baseAddr)\r\n{\r\n    power_mode_stat_t retValue;\r\n    uint32_t regValue = baseAddr->PMSTAT;\r\n    regValue = (regValue & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT;\r\n\r\n    switch (regValue)\r\n    {\r\n        case 1UL:\r\n            retValue = STAT_RUN;\r\n            break;\r\n        case 2UL:\r\n            retValue = STAT_STOP;\r\n            break;\r\n        case 4UL:\r\n            retValue = STAT_VLPR;\r\n            break;\r\n#if FEATURE_SMC_HAS_WAIT_VLPW\r\n        case 8UL:\r\n            retValue = STAT_VLPW;\r\n            break;\r\n#endif\r\n        case 16UL:\r\n            retValue = STAT_VLPS;\r\n            break;\r\n#if FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE\r\n        case 128UL:\r\n            retValue = STAT_HSRUN;\r\n            break;\r\n#endif\r\n        case 255UL:\r\n        default:\r\n            retValue = STAT_INVALID;\r\n            break;\r\n    }\r\n\r\n    return retValue;\r\n}\r\n\r\n/*@}*/\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n/*! @}*/\r\n\r\n#endif /* POWER_SMC_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"rtw_continuous.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1990-2022 The MathWorks, Inc. */\n\n/*\n * File: rtw_continuous.h\n *\n * Abstract:\n *   Type definitions for continuous-time support.\n *\n */\n\n#ifndef RTW_CONTINUOUS_H__\n#define RTW_CONTINUOUS_H__\n\n#ifdef MATLAB_MEX_FILE\n#include \"tmwtypes.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\n/* For models registering MassMatrix */\ntypedef enum {\n    SS_MATRIX_NONE,\n    SS_MATRIX_CONSTANT,\n    SS_MATRIX_TIMEDEP,\n    SS_MATRIX_STATEDEP\n} ssMatrixType;\n\ntypedef enum {\n    SOLVER_MODE_AUTO, /* only occurs in\n                         mdlInitializeSizes/mdlInitializeSampleTimes */\n    SOLVER_MODE_SINGLETASKING,\n    SOLVER_MODE_MULTITASKING\n} SolverMode;\n\ntypedef enum { MINOR_TIME_STEP, MAJOR_TIME_STEP } SimTimeStep;\n\n/* =============================================================================\n * Model methods object\n * =============================================================================\n */\ntypedef void (*rtMdlInitializeSizesFcn)(void* rtModel);\ntypedef void (*rtMdlInitializeSampleTimesFcn)(void* rtModel);\ntypedef void (*rtMdlStartFcn)(void* rtModel);\ntypedef void (*rtMdlOutputsFcn)(void* rtModel, int_T tid);\ntypedef void (*rtMdlUpdateFcn)(void* rtModel, int_T tid);\ntypedef void (*rtMdlDerivativesFcn)(void* rtModel);\ntypedef void (*rtMdlProjectionFcn)(void* rtModel);\ntypedef void (*rtMdlMassMatrixFcn)(void* rtModel);\ntypedef void (*rtMdlForcingFunctionFcn)(void* rtModel);\ntypedef void (*rtMdlTerminateFcn)(void* rtModel);\n#ifdef RT_MALLOC\ntypedef real_T (*rtMdlDiscreteEventsFcn)(void* pModel,\n                                         int_T rtmNumSampTimes,\n                                         void* rtmTimingData,\n                                         int_T* rtmSampleHitPtr,\n                                         int_T* rtmPerTaskSampleHits);\n#endif\n\ntypedef struct _RTWRTModelMethodsInfo_tag {\n    void* rtModelPtr;\n    rtMdlInitializeSizesFcn rtmInitSizesFcn;\n    rtMdlInitializeSampleTimesFcn rtmInitSampTimesFcn;\n    rtMdlStartFcn rtmStartFcn;\n    rtMdlOutputsFcn rtmOutputsFcn;\n    rtMdlUpdateFcn rtmUpdateFcn;\n    rtMdlDerivativesFcn rtmDervisFcn;\n    rtMdlProjectionFcn rtmProjectionFcn;\n    rtMdlMassMatrixFcn rtmMassMatrixFcn;\n    rtMdlForcingFunctionFcn rtmForcingFunctionFcn;\n    rtMdlTerminateFcn rtmTerminateFcn;\n#ifdef RT_MALLOC\n    rtMdlDiscreteEventsFcn rtmDiscreteEventsFcn;\n#endif\n} RTWRTModelMethodsInfo;\n\n#define rtmiSetRTModelPtr(M, rtmp) ((M).rtModelPtr = (rtmp))\n#define rtmiGetRTModelPtr(M) (M).rtModelPtr\n\n#define rtmiSetInitSizesFcn(M, fp) ((M).rtmInitSizesFcn = ((rtMdlInitializeSizesFcn)(fp)))\n#define rtmiSetInitSampTimesFcn(M, fp) \\\n    ((M).rtmInitSampTimesFcn = ((rtMdlInitializeSampleTimesFcn)(fp)))\n#define rtmiSetStartFcn(M, fp) ((M).rtmStartFcn = ((rtMdlStartFcn)(fp)))\n#define rtmiSetOutputsFcn(M, fp) ((M).rtmOutputsFcn = ((rtMdlOutputsFcn)(fp)))\n#define rtmiSetUpdateFcn(M, fp) ((M).rtmUpdateFcn = ((rtMdlUpdateFcn)(fp)))\n#define rtmiSetDervisFcn(M, fp) ((M).rtmDervisFcn = ((rtMdlDerivativesFcn)(fp)))\n#define rtmiSetProjectionFcn(M, fp) ((M).rtmProjectionFcn = ((rtMdlProjectionFcn)(fp)))\n#define rtmiSetMassMatrixFcn(M, fp) ((M).rtmMassMatrixFcn = ((rtMdlMassMatrixFcn)(fp)))\n#define rtmiSetForcingFunctionFcn(M, fp) \\\n    ((M).rtmForcingFunctionFcn = ((rtMdlForcingFunctionFcn)(fp)))\n#define rtmiSetTerminateFcn(M, fp) ((M).rtmTerminateFcn = ((rtMdlTerminateFcn)(fp)))\n#ifdef RT_MALLOC\n#define rtmiSetDiscreteEventsFcn(M, fp) ((M).rtmDiscreteEventsFcn = ((rtMdlDiscreteEventsFcn)(fp)))\n#endif\n\n#define rtmiInitializeSizes(M) ((*(M).rtmInitSizesFcn)((M).rtModelPtr))\n#define rtmiInitializeSampleTimes(M) ((*(M).rtmInitSampTimesFcn)((M).rtModelPtr))\n#define rtmiStart(M) ((*(M).rtmStartFcn)((M).rtModelPtr))\n#define rtmiOutputs(M, tid) ((*(M).rtmOutputsFcn)((M).rtModelPtr, tid))\n#define rtmiUpdate(M, tid) ((*(M).rtmUpdateFcn)((M).rtModelPtr, tid))\n#define rtmiDerivatives(M) ((*(M).rtmDervisFcn)((M).rtModelPtr))\n#define rtmiProjection(M) ((*(M).rtmProjectionFcn)((M).rtModelPtr))\n#define rtmiMassMatrix(M) ((*(M).rtmMassMatrixFcn)((M).rtModelPtr))\n#define rtmiForcingFunction(M) ((*(M).rtmForcingFunctionFcn)((M).rtModelPtr))\n#define rtmiTerminate(M) ((*(M).rtmTerminateFcn)((M).rtModelPtr))\n#ifdef RT_MALLOC\n#define rtmiDiscreteEvents(M, x1, x2, x3, x4) \\\n    ((*(M).rtmDiscreteEventsFcn)((M).rtModelPtr, (x1), (x2), (x3), (x4)))\n#endif\n#endif /* __RTW_CONTINUOUS_H__ */\n"},{"name":"rtw_solver.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\n * File: rtw_solver.h\n *\n * Abstract:\n *   Type definitions for continuous-time solver support.\n *\n */\n\n/* Copyright 1990-2021 The MathWorks, Inc. */\n\n#ifndef RTW_SOLVER_H__\n#define RTW_SOLVER_H__\n\n#include \"rtw_continuous.h\"\n\n/* =============================================================================\n * Solver object\n * =============================================================================\n */\n#ifndef NO_FLOATS /* ERT integer-only */\n/*\n * Enum for solver tolerance\n */\ntypedef enum {\n    SL_SOLVER_TOLERANCE_AUTO = 0,       /* Set Automatically by Solver */\n    SL_SOLVER_TOLERANCE_LOCAL = 1,      /* Set Locally, e.g., by Blocks */\n    SL_SOLVER_TOLERANCE_GLOBAL = 2,     /* Set Globally, e.g., by Block Diagram */\n    SL_SOLVER_TOLERANCE_UNDEFINED = 255 /* Signal uninitialized */\n} SL_SolverToleranceControlFlag_T;\n\n\n/*\n * Enum for jacobian method control\n */\ntypedef enum {\n    SL_JM_BD_AUTO = 0,\n    SL_JM_BD_SPARSE_PERTURBATION,\n    SL_JM_BD_FULL_PERTURBATION,\n    SL_JM_BD_SPARSE_ANALYTICAL,\n    SL_JM_BD_FULL_ANALYTICAL\n} slJmBdControl;\n\n\ntypedef struct _ssSolverInfo_tag {\n    void* rtModelPtr;\n\n    SimTimeStep* simTimeStepPtr;\n    void* solverData;\n    const char_T* solverName;\n    boolean_T isVariableStepSolver;\n    boolean_T solverNeedsReset;\n    SolverMode solverMode;\n\n    time_T solverStopTime;\n    time_T* stepSizePtr;\n    time_T minStepSize;\n    time_T maxStepSize;\n    time_T fixedStepSize;\n\n    int_T solverShapePreserveControl;\n    int_T solverMaxConsecutiveMinStep;\n    int_T maxNumMinSteps;\n    int_T solverMaxOrder;\n    real_T solverConsecutiveZCsStepRelTol;\n    int_T solverMaxConsecutiveZCs;\n\n    int_T solverExtrapolationOrder;\n    int_T solverNumberNewtonIterations;\n\n    int_T solverRefineFactor;\n    real_T solverRelTol;\n    real_T unused_real_T_1;\n\n    real_T** dXPtr;\n    time_T** tPtr;\n\n    int_T* numContStatesPtr;\n    real_T** contStatesPtr;\n\n    int_T* numPeriodicContStatesPtr;\n    int_T** periodicContStateIndicesPtr;\n    real_T** periodicContStateRangesPtr;\n\n    real_T* zcSignalVector;\n    uint8_T* zcEventsVector;\n    uint8_T* zcSignalAttrib;\n    int_T zcSignalVectorLength;\n    uint8_T* reserved;\n\n    boolean_T foundContZcEvents;\n    boolean_T isAtLeftPostOfContZcEvent;\n    boolean_T isAtRightPostOfContZcEvent;\n    boolean_T adaptiveZcDetection;\n\n    int_T numZcSignals;\n\n    boolean_T stateProjection;\n    boolean_T robustResetMethod;     /* user's preference */\n    boolean_T updateJacobianAtReset; /* S-Fcn request (sticky) */\n    boolean_T consistencyChecking;\n\n    ssMatrixType massMatrixType;\n    int_T massMatrixNzMax;\n    int_T* massMatrixIr;\n    int_T* massMatrixJc;\n    real_T* massMatrixPr;\n\n    const char_T** errStatusPtr;\n\n    RTWRTModelMethodsInfo* modelMethodsPtr;\n    real_T zcThreshold;\n    int_T reserved_1;\n    int_T consecutiveZCsError;\n    boolean_T CTOutputIncnstWithState;\n    boolean_T isComputingJacobian;\n    slJmBdControl solverJacobianMethodControl;\n    int_T ignoredZcDiagnostic;\n    int_T maskedZcDiagnostic;\n    boolean_T isOutputMethodComputed;\n    int_T maxZcBracketingIterations;\n    boolean_T isMinorTimeStepWithModeChange;\n    int_T maxZcPerStep;\n    real_T** zcSignalPtr;\n} ssSolverInfo;\n\n/* Support old name RTWSolverInfo */\ntypedef ssSolverInfo RTWSolverInfo;\n\n#define rtsiSetRTModelPtr(S, rtmp) ((S)->rtModelPtr = (rtmp))\n#define rtsiGetRTModelPtr(S) (S)->rtModelPtr\n\n#define rtsiSetSimTimeStepPtr(S, stp) ((S)->simTimeStepPtr = (stp))\n#define rtsiGetSimTimeStepPtr(S) ((S)->simTimeStepPtr)\n#define rtsiGetSimTimeStep(S) *((S)->simTimeStepPtr)\n#define rtsiSetSimTimeStep(S, st) (*((S)->simTimeStepPtr) = (st))\n\n#define rtsiSetSolverData(S, sd) ((S)->solverData = (sd))\n#define rtsiGetSolverData(S) (S)->solverData\n\n#define rtsiSetSolverName(S, sn) ((S)->solverName = (sn))\n#define rtsiGetSolverName(S) (S)->solverName\n\n#define rtsiSetVariableStepSolver(S, vs) ((S)->isVariableStepSolver = (vs))\n#define rtsiIsVariableStepSolver(S) (S)->isVariableStepSolver\n\n#define rtsiSetSolverNeedsReset(S, sn) ((S)->solverNeedsReset = (sn))\n#define rtsiGetSolverNeedsReset(S) (S)->solverNeedsReset\n\n#define rtsiSetContTimeOutputInconsistentWithStateAtMajorStep(S, sn) \\\n    ((S)->CTOutputIncnstWithState = (sn))\n#define rtsiGetContTimeOutputInconsistentWithStateAtMajorStep(S) (S)->CTOutputIncnstWithState\n\n#define rtsiSetBlkStateChange(S, sn) ((S)->CTOutputIncnstWithState = (sn))\n#define rtsiGetBlkStateChange(S) (S)->CTOutputIncnstWithState\n\n#define rtsiSetBlockStateForSolverChangedAtMajorStep(S, sn) ((S)->solverNeedsReset = (sn))\n#define rtsiGetBlockStateForSolverChangedAtMajorStep(S) (S)->solverNeedsReset\n\n#define rtsiSetSolverMode(S, sm) ((S)->solverMode = (sm))\n#define rtsiGetSolverMode(S) (S)->solverMode\n\n#define rtsiSetSolverStopTime(S, st) ((S)->solverStopTime = (st))\n#define rtsiGetSolverStopTime(S) (S)->solverStopTime\n\n#define rtsiSetStepSizePtr(S, ssp) ((S)->stepSizePtr = (ssp))\n#define rtsiSetStepSize(S, ss) (*((S)->stepSizePtr) = (ss))\n#define rtsiGetStepSize(S) *((S)->stepSizePtr)\n\n#define rtsiSetMinStepSize(S, ss) (((S)->minStepSize = (ss)))\n#define rtsiGetMinStepSize(S) (S)->minStepSize\n\n#define rtsiSetMaxStepSize(S, ss) ((S)->maxStepSize = (ss))\n#define rtsiGetMaxStepSize(S) (S)->maxStepSize\n\n#define rtsiSetFixedStepSize(S, ss) ((S)->fixedStepSize = (ss))\n#define rtsiGetFixedStepSize(S) (S)->fixedStepSize\n\n#define rtsiSetMaxNumMinSteps(S, mns) ((S)->maxNumMinSteps = (mns))\n#define rtsiGetMaxNumMinSteps(S) (S)->maxNumMinSteps\n\n#define rtsiSetSolverMaxOrder(S, smo) ((S)->solverMaxOrder = (smo))\n#define rtsiGetSolverMaxOrder(S) (S)->solverMaxOrder\n\n#define rtsiSetSolverJacobianMethodControl(S, smcm) \\\n    (ssGetSolverInfo(S)->solverJacobianMethodControl = (smcm))\n#define rtsiGetSolverJacobianMethodControl(S) ssGetSolverInfo(S)->solverJacobianMethodControl\n\n#define rtsiSetSolverShapePreserveControl(S, smcm) \\\n    (ssGetSolverInfo(S)->solverShapePreserveControl = (smcm))\n#define rtsiGetSolverShapePreserveControl(S) ssGetSolverInfo(S)->solverShapePreserveControl\n\n#define rtsiSetSolverConsecutiveZCsStepRelTol(S, scr) \\\n    (ssGetSolverInfo(S)->solverConsecutiveZCsStepRelTol = (scr))\n#define rtsiGetSolverConsecutiveZCsStepRelTol(S) ssGetSolverInfo(S)->solverConsecutiveZCsStepRelTol\n\n#define rtsiSetSolverMaxConsecutiveZCs(S, smcz) \\\n    (ssGetSolverInfo(S)->solverMaxConsecutiveZCs = (smcz))\n#define rtsiGetSolverMaxConsecutiveZCs(S) ssGetSolverInfo(S)->solverMaxConsecutiveZCs\n\n#define rtsiSetSolverMaxConsecutiveMinStep(S, smcm) \\\n    (ssGetSolverInfo(S)->solverMaxConsecutiveMinStep = (smcm))\n#define rtsiGetSolverMaxConsecutiveMinStep(S) ssGetSolverInfo(S)->solverMaxConsecutiveMinStep\n\n#define rtsiSetSolverExtrapolationOrder(S, seo) ((S)->solverExtrapolationOrder = (seo))\n#define rtsiGetSolverExtrapolationOrder(S) (S)->solverExtrapolationOrder\n\n#define rtsiSetSolverNumberNewtonIterations(S, nni) ((S)->solverNumberNewtonIterations = (nni))\n#define rtsiGetSolverNumberNewtonIterations(S) (S)->solverNumberNewtonIterations\n\n#define rtsiSetSolverRefineFactor(S, smo) ((S)->solverRefineFactor = (smo))\n#define rtsiGetSolverRefineFactor(S) (S)->solverRefineFactor\n\n#define rtsiSetSolverRelTol(S, smo) ((S)->solverRelTol = (smo))\n#define rtsiGetSolverRelTol(S) (S)->solverRelTol\n\n#define rtsiSetSolverMassMatrixType(S, type) ((S)->massMatrixType = (type))\n#define rtsiGetSolverMassMatrixType(S) (S)->massMatrixType\n\n#define rtsiSetSolverMassMatrixNzMax(S, nzMax) ((S)->massMatrixNzMax = (nzMax))\n#define rtsiGetSolverMassMatrixNzMax(S) (S)->massMatrixNzMax\n\n#define rtsiSetSolverMassMatrixIr(S, ir) ((S)->massMatrixIr = (ir))\n#define rtsiGetSolverMassMatrixIr(S) (S)->massMatrixIr\n\n#define rtsiSetSolverMassMatrixJc(S, jc) ((S)->massMatrixJc = (jc))\n#define rtsiGetSolverMassMatrixJc(S) (S)->massMatrixJc\n\n#define rtsiSetSolverMassMatrixPr(S, pr) ((S)->massMatrixPr = (pr))\n#define rtsiGetSolverMassMatrixPr(S) (S)->massMatrixPr\n\n#define rtsiSetdXPtr(S, dxp) ((S)->dXPtr = (dxp))\n#define rtsiSetdX(S, dx) (*((S)->dXPtr) = (dx))\n#define rtsiGetdX(S) *((S)->dXPtr)\n\n#define rtsiSetTPtr(S, tp) ((S)->tPtr = (tp))\n#define rtsiSetT(S, t) ((*((S)->tPtr))[0] = (t))\n#define rtsiGetT(S) (*((S)->tPtr))[0]\n\n#define rtsiSetContStatesPtr(S, cp) ((S)->contStatesPtr = (cp))\n#define rtsiGetContStates(S) *((S)->contStatesPtr)\n\n#define rtsiSetNumContStatesPtr(S, cp) ((S)->numContStatesPtr = (cp))\n#define rtsiGetNumContStates(S) *((S)->numContStatesPtr)\n\n#define rtsiSetNumPeriodicContStatesPtr(S, cp) ((S)->numPeriodicContStatesPtr = (cp))\n#define rtsiGetNumPeriodicContStates(S) *((S)->numPeriodicContStatesPtr)\n\n#define rtsiSetPeriodicContStateIndicesPtr(S, cp) ((S)->periodicContStateIndicesPtr = (cp))\n#define rtsiGetPeriodicContStateIndices(S) *((S)->periodicContStateIndicesPtr)\n\n#define rtsiSetPeriodicContStateRangesPtr(S, cp) ((S)->periodicContStateRangesPtr = (cp))\n#define rtsiGetPeriodicContStateRanges(S) *((S)->periodicContStateRangesPtr)\n\n#define rtsiSetErrorStatusPtr(S, esp) ((S)->errStatusPtr = (esp))\n#define rtsiSetErrorStatus(S, es) (*((S)->errStatusPtr) = (es))\n#define rtsiGetErrorStatus(S) *((S)->errStatusPtr)\n\n#define rtsiSetModelMethodsPtr(S, mmp) ((S)->modelMethodsPtr = (mmp))\n#define rtsiGetModelMethodsPtr(S) (S)->modelMethodsPtr\n\n#define rtsiSetSolverComputingJacobian(S, val) ((S)->isComputingJacobian = (val))\n#define rtsiIsSolverComputingJacobian(S) (S)->isComputingJacobian\n\n#define rtsiSetSolverOutputComputed(S, val) ((S)->isOutputMethodComputed = (val))\n#define rtsiIsSolverOutputComputed(S) (S)->isOutputMethodComputed\n\n#define rtsiSetIsMinorTimeStepWithModeChange(S, sn) ((S)->isMinorTimeStepWithModeChange = (sn))\n#define rtsiGetIsMinorTimeStepWithModeChange(S) (S)->isMinorTimeStepWithModeChange\n\n#define rtsiIsModeUpdateTimeStep(S) \\\n    (rtsiGetSimTimeStep(S) == MAJOR_TIME_STEP || rtsiGetIsMinorTimeStepWithModeChange(S))\n\n#define rtsiSetSolverZcSignalPtr(S, zcp) ((S)->zcSignalPtr = (zcp))\n#define rtsiSetSolverZcSignalVector(S, zcp) (*((S)->zcSignalPtr) = (zcp))\n#define rtsiGetSolverZcSignalVector(S) *((S)->zcSignalPtr)\n\n\n#define rtsiSetSolverZcEventsVector(S, ptr) ((S)->zcEventsVector = (ptr))\n#define rtsiGetSolverZcEventsVector(S) ((S)->zcEventsVector)\n\n#define rtsiSetSolverZcSignalAttrib(S, ptr) ((S)->zcSignalAttrib = (ptr))\n#define rtsiGetSolverZcSignalAttrib(S) ((S)->zcSignalAttrib)\n\n#define rtsiSetSolverZcSignalVectorLength(S, n) ((S)->zcSignalVectorLength = (n))\n#define rtsiGetSolverZcSignalVectorLength(S) ((S)->zcSignalVectorLength)\n\n#define rtsiSetSolverFoundContZcEvents(S, val) ((S)->foundContZcEvents = (val))\n#define rtsiGetSolverFoundContZcEvents(S) ((S)->foundContZcEvents)\n\n#endif /* !NO_FLOATS */\n\n#endif /* RTW_SOLVER_H__ */\n"},{"name":"s32k_clock_init.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2017 - 2020 NXP.\r\n * All rights reserved.\r\n */\r\n#include \"s32k_clock_init.h\"\r\n#include \"clock_manager.h\"\r\n#include \"lpit_driver.h\"\r\n#include \"pcc_hw_access.h\"\r\n#include \"power_manager.h\"\r\n\r\n#if XTAL_FREQ == 8000000\r\n#define MBDT_PLLPREDIV                 SCG_SPLL_CLOCK_PREDIV_BY_1\r\n#define MBDT_SOSCDIV                   SCG_ASYNC_CLOCK_DIV_BY_1\r\n#elif XTAL_FREQ == 16000000\r\n#define MBDT_PLLPREDIV                 SCG_SPLL_CLOCK_PREDIV_BY_2\r\n#define MBDT_SOSCDIV                   SCG_ASYNC_CLOCK_DIV_BY_1\r\n#elif XTAL_FREQ == 24000000\r\n#define MBDT_PLLPREDIV                 SCG_SPLL_CLOCK_PREDIV_BY_3\r\n#define MBDT_SOSCDIV                   SCG_ASYNC_CLOCK_DIV_BY_1\r\n#elif XTAL_FREQ == 32000000\r\n#define MBDT_PLLPREDIV                 SCG_SPLL_CLOCK_PREDIV_BY_4\r\n#define MBDT_SOSCDIV                   SCG_ASYNC_CLOCK_DIV_BY_1\r\n#elif XTAL_FREQ == 40000000\r\n#define MBDT_PLLPREDIV                 SCG_SPLL_CLOCK_PREDIV_BY_5\r\n#define MBDT_SOSCDIV                   SCG_ASYNC_CLOCK_DIV_BY_1\r\n#endif\r\n\r\n#if CORE_CLK_FREQ == 80000000\r\n#define PLL_MULT                       4U                        // mult = 20\r\n#define POWER_MODE                     POWER_MANAGER_RUN\r\n#define PLL_ASYNC_DIV2                 SCG_ASYNC_CLOCK_DIV_BY_4\r\n#elif CORE_CLK_FREQ == 112000000\r\n#define PLL_MULT                       12U                       // mult = 28\r\n#define POWER_MODE                     POWER_MANAGER_HSRUN\r\n#define PLL_ASYNC_DIV2                 SCG_ASYNC_CLOCK_DIV_BY_4\r\n#endif\r\n\r\nvoid Clock_Setup(void)\r\n{\r\n  /* Configuration structure for Clock Configuration */\r\n  clock_manager_user_config_t clockMan1_InitConfig0 = {\r\n    /* Configuration of SIRC */\r\n    .scgConfig =\r\n    {\r\n      .sircConfig =\r\n      {\r\n        .initialize = true,            /* Initialize */\r\n\r\n        /* SIRCCSR */\r\n        .enableInStop = false,         /* SIRCSTEN  */\r\n        .enableInLowPower = true,      /* SIRCLPEN  */\r\n        .locked = false,               /* LK        */\r\n\r\n        /* SIRCCFG */\r\n        .range = SCG_SIRC_RANGE_HIGH,  /* RANGE - High range (8 MHz) */\r\n\r\n        /* SIRCDIV */\r\n        .div1 = SCG_ASYNC_CLOCK_DIV_BY_1,/* SIRCDIV1  */\r\n        .div2 = SCG_ASYNC_CLOCK_DIV_BY_1,/* SIRCDIV2  */\r\n      },\r\n      .fircConfig =\r\n      {\r\n        .initialize = true,            /* Initialize */\r\n\r\n        /* FIRCCSR */\r\n        .regulator = true,             /* FIRCREGOFF */\r\n        .locked = false,               /* LK         */\r\n\r\n        /* FIRCCFG */\r\n        .range = SCG_FIRC_RANGE_48M,   /* RANGE      */\r\n\r\n        /* FIRCDIV */\r\n        .div1 = SCG_ASYNC_CLOCK_DIV_BY_1,/* FIRCDIV1   */\r\n        .div2 = SCG_ASYNC_CLOCK_DIV_BY_1,/* FIRCDIV2   */\r\n      },\r\n      .rtcConfig =\r\n      {\r\n        .initialize = true,            /* Initialize  */\r\n        .rtcClkInFreq = 0U,            /* RTC_CLKIN   */\r\n      },\r\n      .soscConfig =\r\n      {\r\n        .initialize = true,            /* Initialize */\r\n        .freq = XTAL_FREQ,             /* Frequency  */\r\n\r\n        /* SOSCCSR */\r\n        .monitorMode = SCG_SOSC_MONITOR_DISABLE,/* SOSCCM      */\r\n        .locked = false,               /* LK          */\r\n\r\n        /* SOSCCFG */\r\n        .extRef = SCG_SOSC_REF_OSC,    /* EREFS       */\r\n        .gain = SCG_SOSC_GAIN_LOW,     /* HGO         */\r\n        .range = SCG_SOSC_RANGE_HIGH,  /* RANGE       */\r\n\r\n        /* SOSCDIV */\r\n        .div1 = MBDT_SOSCDIV,/* SOSCDIV1    */\r\n        .div2 = MBDT_SOSCDIV,/* SOSCDIV2    */\r\n      },\r\n      .spllConfig =\r\n      {\r\n        .initialize = true,            /* Initialize */\r\n\r\n        /* SPLLCSR */\r\n        .monitorMode = SCG_SPLL_MONITOR_DISABLE,/* SPLLCM     */\r\n        .locked = false,               /* LK         */\r\n\r\n        /* SPLLCFG */\r\n        .prediv = MBDT_PLLPREDIV,          /* PREDIV     */\r\n        .mult = PLL_MULT,              /* MULT       */\r\n        .src = 0U,                     /* SOURCE     */\r\n\r\n        /* SPLLDIV */\r\n        .div1 = SCG_ASYNC_CLOCK_DIV_BY_1,/* SPLLDIV1   */\r\n        .div2 = PLL_ASYNC_DIV2,        /* SPLLDIV2   */\r\n      },\r\n      .clockOutConfig =\r\n      {\r\n        .initialize = true,            /* Initialize    */\r\n        .source = SCG_CLOCKOUT_SRC_FIRC,/* SCG CLKOUTSEL     */\r\n      },\r\n      .clockModeConfig =\r\n      {\r\n        .initialize = true,            /* Initialize */\r\n        .rccrConfig =                  /* RCCR - Run Clock Control Register          */\r\n        {\r\n#if CORE_CLK_FREQ == 80000000\r\n          .src          = SCG_SYSTEM_CLOCK_SRC_SYS_PLL,        /* SCS        */\r\n          .divCore      = SCG_SYSTEM_CLOCK_DIV_BY_1,           /* DIVCORE    */\r\n          .divBus       = SCG_SYSTEM_CLOCK_DIV_BY_2,           /* DIVBUS     */\r\n          .divSlow      = SCG_SYSTEM_CLOCK_DIV_BY_4,           /* DIVSLOW    */\r\n#elif CORE_CLK_FREQ == 112000000\r\n          .src          = SCG_SYSTEM_CLOCK_SRC_FIRC,           /* SCS        */\r\n          .divCore      = SCG_SYSTEM_CLOCK_DIV_BY_1,           /* DIVCORE    */\r\n          .divBus       = SCG_SYSTEM_CLOCK_DIV_BY_2,           /* DIVBUS     */\r\n          .divSlow      = SCG_SYSTEM_CLOCK_DIV_BY_2,           /* DIVSLOW    */\r\n#endif\r\n        },\r\n        .vccrConfig =                  /* VCCR - VLPR Clock Control Register         */\r\n        {\r\n          .src = SCG_SYSTEM_CLOCK_SRC_SIRC,/* SCS        */\r\n          .divCore = SCG_SYSTEM_CLOCK_DIV_BY_2,/* DIVCORE    */\r\n          .divBus = SCG_SYSTEM_CLOCK_DIV_BY_1,/* DIVBUS     */\r\n          .divSlow = SCG_SYSTEM_CLOCK_DIV_BY_4,/* DIVSLOW    */\r\n        },\r\n        .hccrConfig =                  /* HCCR - HSRUN Clock Control Register        */\r\n        {\r\n          .src = SCG_SYSTEM_CLOCK_SRC_SYS_PLL,/* SCS        */\r\n          .divCore = SCG_SYSTEM_CLOCK_DIV_BY_1,/* DIVCORE    */\r\n          .divBus = SCG_SYSTEM_CLOCK_DIV_BY_2,/* DIVBUS     */\r\n          .divSlow = SCG_SYSTEM_CLOCK_DIV_BY_4,/* DIVSLOW    */\r\n        },\r\n      },\r\n    },\r\n    .pccConfig =\r\n    {\r\n      .peripheralClocks = (void*)0,    /* Peripheral clock control configurations  */\r\n      .count = 0,                      /* Number of the peripheral clock control configurations  */\r\n    },\r\n    .simConfig =\r\n    {\r\n      .clockOutConfig =                /* Clock Out configuration.           */\r\n      {\r\n        .initialize = true,            /* Initialize    */\r\n        .enable = false,               /* CLKOUTEN      */\r\n        .source = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT,/* CLKOUTSEL     */\r\n        .divider = SIM_CLKOUT_DIV_BY_1,/* CLKOUTDIV     */\r\n      },\r\n      .lpoClockConfig =                /* Low Power Clock configuration.     */\r\n      {\r\n        .initialize = true,            /* Initialize    */\r\n        .enableLpo1k = true,           /* LPO1KCLKEN    */\r\n        .enableLpo32k = true,          /* LPO32KCLKEN   */\r\n        .sourceLpoClk = SIM_LPO_CLK_SEL_LPO_128K,/* LPOCLKSEL     */\r\n        .sourceRtcClk = SIM_RTCCLK_SEL_LPO_32K,/* RTCCLKSEL     */\r\n      },\r\n      .platGateConfig =                /* Platform Gate Clock configuration. */\r\n      {\r\n        .initialize = false,           /* Initialize    */\r\n        .enableMscm = false,           /* CGCMSCM       */\r\n        .enableMpu = false,            /* CGCMPU        */\r\n        .enableDma = false,            /* CGCDMA        */\r\n        .enableErm = false,            /* CGCERM        */\r\n        .enableEim = false,            /* CGCEIM        */\r\n      },\r\n      .qspiRefClkGating =              /* Quad Spi Internal Reference Clock Gating. */\r\n      {\r\n        .enableQspiRefClk = false,     /* Qspi reference clock gating    */\r\n      },\r\n      .tclkConfig =                    /* TCLK CLOCK configuration. */\r\n      {\r\n        .initialize = false,           /* Initialize    */\r\n        .tclkFreq[0] = 0U,             /* TCLK0         */\r\n        .tclkFreq[1] = 0U,             /* TCLK1         */\r\n        .tclkFreq[2] = 0U,             /* TCLK2         */\r\n      },\r\n      .traceClockConfig =              /* Debug trace Clock Configuration. */\r\n      {\r\n        .initialize = false,           /* Initialize    */\r\n        .divEnable = false,            /* TRACEDIVEN    */\r\n        .source = CLOCK_TRACE_SRC_CORE_CLK,/* TRACECLK_SEL  */\r\n        .divider = 0U,                 /* TRACEDIV      */\r\n        .divFraction = false,          /* TRACEFRAC     */\r\n      },\r\n    },\r\n    .pmcConfig =\r\n    {\r\n      .lpoClockConfig =                /* Low Power Clock configuration.     */\r\n      {\r\n        .initialize = true,            /* Initialize             */\r\n        .enable = true,                /* Enable/disable LPO     */\r\n        .trimValue = 0,                /* Trimming value for LPO */\r\n      },\r\n    },\r\n  };\r\n\r\n  /* Array of pointers to User configuration structures */\r\n  clock_manager_user_config_t const * g_clockManConfigsArr[] = {\r\n    &clockMan1_InitConfig0\r\n  };\r\n\r\n  /* Array of pointers to User defined Callbacks configuration structures */\r\n  clock_manager_callback_user_config_t * g_clockManCallbacksArr[] = { (void*)0 };\r\n\r\n  CLOCK_SYS_Init(g_clockManConfigsArr, 1,\r\n                 g_clockManCallbacksArr, 0);\r\n  CLOCK_SYS_UpdateConfiguration(0U, CLOCK_MANAGER_POLICY_AGREEMENT);\r\n\r\n  /* Power mode configuration */\r\n  power_manager_user_config_t powerConfig = {\r\n    .powerMode = POWER_MODE,\r\n    .sleepOnExitValue = false,\r\n  };\r\n\r\n  /* Power mode configurations array */\r\n  power_manager_user_config_t * powerConfigsArr[] = {\r\n    &powerConfig,\r\n  };\r\n\r\n  /* Callback configuration structures array */\r\n  power_manager_callback_user_config_t * powerCallbacksConfigsArr[] = { (void*)0 };\r\n  \r\n  POWER_SYS_Init(&powerConfigsArr, 1U,\r\n                 &powerCallbacksConfigsArr, 0U);\r\n  POWER_SYS_SetMode(0,POWER_MANAGER_POLICY_AGREEMENT);\r\n}\r\n\r\nvoid UpdateSystickConfig(uint32_t ticks)\r\n{\r\n  S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(ticks - 1);\r\n  S32_SysTick->CVR = 0;\r\n  S32_SysTick->CSR = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(1u) | \r\n      S32_SysTick_CSR_CLKSOURCE(1u);\r\n}\r\n\r\nvoid lpit0_clock_init(void)\r\n{\r\n  static uint8_t MBDT_PIT_0_ENABLED = 1;\r\n  if (MBDT_PIT_0_ENABLED)\r\n  {\r\n    MBDT_PIT_0_ENABLED = 0;\r\n    /* Un-gate PIT clock*/\r\n    PCC_SetPeripheralClockControl(PCC, PCC_LPIT0_CLOCK, true, CLK_SRC_SPLL, 0, 0);\r\n\r\n    /* Initialize PIT, enable module clock, disable run in debug. */\r\n    static const lpit_user_config_t lpitInit = {\r\n      .enableRunInDebug = false,\r\n      .enableRunInDoze = true\r\n    };\r\n    LPIT_DRV_Init(0, &lpitInit);\r\n  }\r\n}\r\n"},{"name":"s32k_clock_init.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _S32K_CLOCK_INIT_H\r\n#define _S32K_CLOCK_INIT_H\r\n#include <stdint.h>\r\n#define XTAL_FREQ                      8000000UL\r\n#define CORE_CLK_FREQ                  80000000UL\r\n\r\nvoid Clock_Setup(void);\r\nvoid UpdateSystickConfig(uint32_t ticks);\r\nvoid lpit0_clock_init(void);\r\n\r\n#endif\r\n"},{"name":"scg_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\clock\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef SCG_HW_ACCESS_H\r\n#define SCG_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n\r\n/*!\r\n * @file scg_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to implement enumeration entries as macro.\r\n * Enumeration entries (macros) are referenced from application code.\r\n */\r\n\r\n/*!\r\n * @ingroup scg_hw_access\r\n * @defgroup scg_hw_access\r\n * @{\r\n */\r\n\r\n\r\n\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*!\r\n * @brief Get SCG ClockOut source select\r\n *\r\n * This function gets the SCG clockOut source\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return ClockOut source.\r\n */\r\nstatic inline uint32_t SCG_GetClockoutSourceSel(const SCG_Type * base)\r\n{\r\n    return (base->CLKOUTCNFG & SCG_CLKOUTCNFG_CLKOUTSEL_MASK) >> SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Gets SCG current system clock source\r\n *\r\n * This function gets the current system clock source.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return Current system clock source.\r\n */\r\nstatic inline uint32_t SCG_GetCurrentSystemClockSource(const SCG_Type * base)\r\n{\r\n    return ((base->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Gets SCG Current Core Clock Divide Ratio\r\n *\r\n * This function gets the Current Core Clock Divide Ratio.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return Current Core Clock Divide Ratio.\r\n */\r\nstatic inline uint32_t SCG_GetCurrentCoreClockDividerRatio(const SCG_Type * base)\r\n{\r\n    return ((base->CSR & SCG_CSR_DIVCORE_MASK) >> SCG_CSR_DIVCORE_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Gets SCG Current Bus Clock Divide Ratio\r\n *\r\n * This function gets the Current Bus Clock Divide Ratio.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return Current Bus Clock Divide Ratio.\r\n */\r\nstatic inline uint32_t SCG_GetCurrentBusClockDividerRatio(const SCG_Type * base)\r\n{\r\n    return ((base->CSR & SCG_CSR_DIVBUS_MASK) >> SCG_CSR_DIVBUS_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Gets SCG Current Slow Clock Divide Ratio\r\n *\r\n * This function gets the Current Slow Clock Divide Ratio.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return Current Slow Clock Divide Ratio.\r\n */\r\nstatic inline uint32_t SCG_GetCurrentSlowClockDividerRatio(const SCG_Type * base)\r\n{\r\n    return ((base->CSR & SCG_CSR_DIVSLOW_MASK) >> SCG_CSR_DIVSLOW_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Sets SCG run system clock\r\n *\r\n * This function sets the RUN clock control (system clock source, bus, core and slow dividers).\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base System clock configuration address.\r\n */\r\nstatic inline void SCG_SetRunClockControl(SCG_Type * base, uint32_t source, uint32_t coreDivider, uint32_t busDivider, uint32_t slowDivider)\r\n{\r\n    uint32_t value = (uint32_t)(((source      << SCG_RCCR_SCS_SHIFT)     & SCG_RCCR_SCS_MASK)     |\r\n                                ((coreDivider << SCG_RCCR_DIVCORE_SHIFT) & SCG_RCCR_DIVCORE_MASK) |\r\n                                ((busDivider  << SCG_RCCR_DIVBUS_SHIFT)  & SCG_RCCR_DIVBUS_MASK)  |\r\n                                ((slowDivider << SCG_RCCR_DIVSLOW_SHIFT) & SCG_RCCR_DIVSLOW_MASK) );\r\n    base->RCCR = value;\r\n}\r\n\r\n/*!\r\n * @brief Sets SCG vlpr system clock\r\n *\r\n * This function sets the VLPR clock control (system clock source, bus, core and slow dividers).\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base System clock configuration address.\r\n */\r\nstatic inline void SCG_SetVlprClockControl(SCG_Type * base, uint32_t source, uint32_t coreDivider, uint32_t busDivider, uint32_t slowDivider)\r\n{\r\n    uint32_t value = (uint32_t)(((source      << SCG_VCCR_SCS_SHIFT)     & SCG_VCCR_SCS_MASK)     |\r\n                                ((coreDivider << SCG_VCCR_DIVCORE_SHIFT) & SCG_VCCR_DIVCORE_MASK) |\r\n                                ((busDivider  << SCG_VCCR_DIVBUS_SHIFT)  & SCG_VCCR_DIVBUS_MASK)  |\r\n                                ((slowDivider << SCG_VCCR_DIVSLOW_SHIFT) & SCG_VCCR_DIVSLOW_MASK) );\r\n\r\n    base->VCCR = value;\r\n}\r\n\r\n#if FEATURE_HAS_HIGH_SPEED_RUN_MODE\r\n/*!\r\n * @brief Sets SCG hsrun system clock\r\n *\r\n * This function sets the HSRUN clock control (system clock source, bus, core and slow dividers).\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base System clock configuration address.\r\n */\r\nstatic inline void SCG_SetHsrunClockControl(SCG_Type * base, uint32_t source, uint32_t coreDivider, uint32_t busDivider, uint32_t slowDivider)\r\n{\r\n    uint32_t value = (uint32_t)(((source      << SCG_HCCR_SCS_SHIFT)     & SCG_HCCR_SCS_MASK)     |\r\n                                ((coreDivider << SCG_HCCR_DIVCORE_SHIFT) & SCG_HCCR_DIVCORE_MASK) |\r\n                                ((busDivider  << SCG_HCCR_DIVBUS_SHIFT)  & SCG_HCCR_DIVBUS_MASK)  |\r\n                                ((slowDivider << SCG_HCCR_DIVSLOW_SHIFT) & SCG_HCCR_DIVSLOW_MASK) );\r\n\r\n    base->HCCR = value;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Gets the first asynchronous divider for FIRC.\r\n *\r\n * This function gets the first asynchronous divider for FIRC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return FIRC first asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetFircFirstAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->FIRCDIV & SCG_FIRCDIV_FIRCDIV1_MASK) >> SCG_FIRCDIV_FIRCDIV1_SHIFT;\r\n}\r\n\r\n/*!\r\n * @brief Gets the second asynchronous divider for FIRC.\r\n *\r\n * This function gets the second asynchronous divider for FIRC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return FIRC second asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetFircSecondAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->FIRCDIV & SCG_FIRCDIV_FIRCDIV2_MASK) >> SCG_FIRCDIV_FIRCDIV2_SHIFT;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Sets SCG asynchronous dividers for FIRC.\r\n *\r\n * This function sets SCG asynchronous dividers for FIRC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base Asynchronous first divider\r\n * @param[in] base Asynchronous second divider\r\n */\r\nstatic inline void SCG_SetFircAsyncConfig(SCG_Type * base, uint32_t div1, uint32_t div2)\r\n{\r\n    uint32_t value = (uint32_t)(((div1 << SCG_FIRCDIV_FIRCDIV1_SHIFT) & SCG_FIRCDIV_FIRCDIV1_MASK)     |\r\n                                ((div2 << SCG_FIRCDIV_FIRCDIV2_SHIFT) & SCG_FIRCDIV_FIRCDIV2_MASK) );\r\n    base->FIRCDIV = value;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Gets the first asynchronous divider for SIRC.\r\n *\r\n * This function gets the first asynchronous divider for SIRC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SIRC first asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetSircFirstAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->SIRCDIV & SCG_SIRCDIV_SIRCDIV1_MASK) >> SCG_SIRCDIV_SIRCDIV1_SHIFT;\r\n}\r\n\r\n/*!\r\n * @brief Gets the second asynchronous divider for SIRC.\r\n *\r\n * This function gets the second asynchronous divider for SIRC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SIRC second asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetSircSecondAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->SIRCDIV & SCG_SIRCDIV_SIRCDIV2_MASK) >> SCG_SIRCDIV_SIRCDIV2_SHIFT;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Sets SCG asynchronous dividers for SIRC.\r\n *\r\n * This function sets SCG asynchronous dividers for SIRC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base Asynchronous first divider\r\n * @param[in] base Asynchronous second divider\r\n */\r\nstatic inline void SCG_SetSircAsyncConfig(SCG_Type * base, uint32_t div1, uint32_t div2)\r\n{\r\n    uint32_t value = (uint32_t)(((div1 << SCG_SIRCDIV_SIRCDIV1_SHIFT) & SCG_SIRCDIV_SIRCDIV1_MASK)     |\r\n                                ((div2 << SCG_SIRCDIV_SIRCDIV2_SHIFT) & SCG_SIRCDIV_SIRCDIV2_MASK) );\r\n    base->SIRCDIV = value;\r\n}\r\n\r\n\r\n\r\n/*!\r\n * @brief Gets the first asynchronous divider for SOSC.\r\n *\r\n * This function gets the first asynchronous divider for SOSC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SOSC first asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetSoscFirstAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->SOSCDIV & SCG_SOSCDIV_SOSCDIV1_MASK) >> SCG_SOSCDIV_SOSCDIV1_SHIFT;\r\n}\r\n\r\n/*!\r\n * @brief Gets the second asynchronous divider for SOSC.\r\n *\r\n * This function gets the second asynchronous divider for SOSC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SOSC second asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetSoscSecondAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->SOSCDIV & SCG_SOSCDIV_SOSCDIV2_MASK) >> SCG_SOSCDIV_SOSCDIV2_SHIFT;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Sets SCG asynchronous dividers for SOSC.\r\n *\r\n * This function sets SCG asynchronous dividers for SOSC.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base Asynchronous first divider\r\n * @param[in] base Asynchronous second divider\r\n */\r\nstatic inline void SCG_SetSoscAsyncConfig(SCG_Type * base, uint32_t div1, uint32_t div2)\r\n{\r\n    uint32_t value = (uint32_t)(((div1 << SCG_SOSCDIV_SOSCDIV1_SHIFT) & SCG_SOSCDIV_SOSCDIV1_MASK)     |\r\n                                ((div2 << SCG_SOSCDIV_SOSCDIV2_SHIFT) & SCG_SOSCDIV_SOSCDIV2_MASK) );\r\n    base->SOSCDIV = value;\r\n}\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n#ifdef SCG_SPLLCFG_SOURCE_MASK\r\n/*!\r\n * @brief Gets the source clock for SPLL.\r\n *\r\n * This function gets the source clock for SPLL.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SPLL source\r\n */\r\nstatic inline uint32_t SCG_GetSourcSpll(const SCG_Type * base)\r\n{\r\n    return (base->SPLLCFG & SCG_SPLLCFG_SOURCE_MASK) >> SCG_SPLLCFG_SOURCE_SHIFT;\r\n}\r\n/*!\r\n * @brief Sets SCG source clock for SPLL.\r\n *\r\n * This function sets source clock for SPLL.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] source for spll\r\n */\r\nstatic inline void SCG_SetSourceSpll(SCG_Type * base, uint32_t source)\r\n{\r\n    uint32_t value = base->SPLLCFG;\r\n\r\n    value &= ~SCG_SPLLCFG_SOURCE_MASK;\r\n    value |= SCG_SPLLCFG_SOURCE(source);\r\n    base->SPLLCFG = value;\r\n}\r\n#endif\r\n/*!\r\n * @brief Gets the first asynchronous divider for SPLL.\r\n *\r\n * This function gets the first asynchronous divider for SPLL.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SPLL first asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetSpllFirstAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->SPLLDIV & SCG_SPLLDIV_SPLLDIV1_MASK) >> SCG_SPLLDIV_SPLLDIV1_SHIFT;\r\n}\r\n\r\n/*!\r\n * @brief Gets the second asynchronous divider for SPLL.\r\n *\r\n * This function gets the second asynchronous divider for SPLL.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @return SPLL second asynchronous divider\r\n */\r\nstatic inline uint32_t SCG_GetSpllSecondAsyncDivider(const SCG_Type * base)\r\n{\r\n    return (base->SPLLDIV & SCG_SPLLDIV_SPLLDIV2_MASK) >> SCG_SPLLDIV_SPLLDIV2_SHIFT;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Sets SCG asynchronous dividers for SPLL.\r\n *\r\n * This function sets SCG asynchronous dividers for SPLL.\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] base Asynchronous first divider\r\n * @param[in] base Asynchronous second divider\r\n */\r\nstatic inline void SCG_SetSpllAsyncConfig(SCG_Type * base, uint32_t div1, uint32_t div2)\r\n{\r\n    uint32_t value = (uint32_t)(((div1 << SCG_SPLLDIV_SPLLDIV1_SHIFT) & SCG_SPLLDIV_SPLLDIV1_MASK)     |\r\n                                ((div2 << SCG_SPLLDIV_SPLLDIV2_SHIFT) & SCG_SPLLDIV_SPLLDIV2_MASK) );\r\n    base->SPLLDIV = value;\r\n}\r\n#endif\r\n\r\n/*!\r\n * @brief Set SCG ClockOut source select\r\n *\r\n * This function sets the SCG ClockOut source\r\n *\r\n * @param[in] base Register base address for the SCG instance.\r\n * @param[in] source used for ClockOut\r\n */\r\nstatic inline void SCG_SetClockoutSourceSel(SCG_Type * base, uint32_t source)\r\n{\r\n    uint32_t regValue;\r\n\r\n    regValue = base->CLKOUTCNFG;\r\n    regValue &= ~(SCG_CLKOUTCNFG_CLKOUTSEL_MASK);\r\n    regValue |= SCG_CLKOUTCNFG_CLKOUTSEL(source);\r\n    base->CLKOUTCNFG = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Gets sirc system clock mode status\r\n *\r\n * This function checks whether SIRC is used as system clock source.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  sirc system clock mode status\r\n *        - false : SIRC is not the system clock source\r\n *        - true : SIRC is the system clock source\r\n */\r\nstatic inline bool SCG_GetSircSystemClockMode(const SCG_Type* const base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->SIRCCSR;\r\n    regValue = (regValue & SCG_SIRCCSR_SIRCSEL_MASK) >> SCG_SIRCCSR_SIRCSEL_SHIFT;\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n * @brief Gets sirc clock status\r\n * This function checks whether SIRC is enabled and output clock is valid.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  sirc  clock status\r\n *        - false : SIRC is not enabled or clock is not valid\r\n *        - true  : SIRC is enabled and clock is valid\r\n */\r\nstatic inline bool SCG_GetSircStatus(const SCG_Type* const base)\r\n{\r\n    return (((base->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT) != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Gets sirc clock range\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  sirc  range value\r\n */\r\nstatic inline uint32_t SCG_GetSircRange(const SCG_Type* const base)\r\n{\r\n    return ((base->SIRCCFG & SCG_SIRCCFG_RANGE_MASK) >> SCG_SIRCCFG_RANGE_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears SIRC lock register\r\n *\r\n * @param[in] base        scg base pointer\r\n */\r\nstatic inline void SCG_ClearSircLock(SCG_Type*  base)\r\n{\r\n    /* Clear LK bit field */\r\n    base->SIRCCSR &= (uint32_t)(~(SCG_SIRCCSR_LK_MASK));\r\n}\r\n\r\n\r\n/*!\r\n * @brief Clears SIRC control register\r\n *\r\n * @param[in] base        scg base pointer\r\n */\r\nstatic inline void SCG_ClearSircControl(SCG_Type* base)\r\n{\r\n    /* Clear configuration. */\r\n    base->SIRCCSR = 0U;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Sets SIRC configuration register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] range       sirc range value\r\n */\r\nstatic inline void SCG_SetSircConfiguration(SCG_Type* base, uint8_t range)\r\n{\r\n    /* Set PLL configuration: frequency range */\r\n    base->SIRCCFG = SCG_SIRCCFG_RANGE(range);\r\n}\r\n\r\n/*!\r\n * @brief Sets SIRC control register\r\n *\r\n * @param[in] base                scg base pointer\r\n * @param[in] enableInStop        enable in stop modes\r\n * @param[in] enableInLowPower    enable in very low power modes\r\n * @param[in] lockMode            control register can be written or not\r\n */\r\nstatic inline void SCG_SetSircControl(SCG_Type* base, bool enableInStop, bool enableInLowPower, bool lockMode)\r\n{\r\n    uint32_t value = SCG_SIRCCSR_SIRCEN(1U)                                  |\r\n                     SCG_SIRCCSR_SIRCSTEN(((enableInStop)     ? 1UL : 0UL )) |\r\n                     SCG_SIRCCSR_SIRCLPEN(((enableInLowPower) ? 1UL : 0UL )) |\r\n                     SCG_SIRCCSR_LK((lockMode) ? 1UL : 0UL);\r\n\r\n    base->SIRCCSR = value;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Gets firc system clock mode status\r\n *\r\n * This function checks whether FIRC is used as system clock source.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  firc system clock mode status\r\n *        - false : FIRC is not the system clock source\r\n *        - true : FIRC is the system clock source\r\n */\r\nstatic inline bool SCG_GetFircSystemClockMode(const SCG_Type* const base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->FIRCCSR;\r\n    regValue = (regValue & SCG_FIRCCSR_FIRCSEL_MASK) >> SCG_FIRCCSR_FIRCSEL_SHIFT;\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n * @brief Gets firc clock status\r\n * This function checks whether FIRC is enabled and output clock is valid.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  firc  clock status\r\n *        - false : FIRC is not enabled or clock is not valid\r\n *        - true  : FIRC is enabled and clock is valid\r\n */\r\nstatic inline bool SCG_GetFircStatus(const SCG_Type* const base)\r\n{\r\n    return (((base->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT) != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Gets firc clock range\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  firc  frequency range value\r\n */\r\nstatic inline uint32_t SCG_GetFircRange(const SCG_Type* const base)\r\n{\r\n    return ((base->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears FIRC lock register\r\n *\r\n * This function clears FIRC lock.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n */\r\nstatic inline void SCG_ClearFircLock(SCG_Type*  base)\r\n{\r\n    /* Clear LK bit field */\r\n    base->FIRCCSR &= (uint32_t)(~(SCG_FIRCCSR_LK_MASK));\r\n}\r\n\r\n\r\n/*!\r\n * @brief Clears FIRC control register\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n */\r\nstatic inline void SCG_ClearFircControl(SCG_Type* base)\r\n{\r\n    /* Disable monitor, disable clock and clear error. */\r\n    base->FIRCCSR = SCG_FIRCCSR_FIRCERR_MASK;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Sets FIRC configuration register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] range       firc range value\r\n */\r\nstatic inline void SCG_SetFircConfiguration(SCG_Type* base, uint8_t range)\r\n{\r\n    /* Set PLL configuration: frequency range */\r\n    base->FIRCCFG = SCG_FIRCCFG_RANGE(range);\r\n}\r\n\r\n/*!\r\n * @brief Sets FIRC control register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] monitorMode clock monitor enablement\r\n * @param[in] lockMode    control register can be written or not\r\n */\r\nstatic inline void SCG_SetFircControl(SCG_Type* base, bool regulator, bool lockMode)\r\n{\r\n    uint32_t value = SCG_FIRCCSR_FIRCEN(1U)                             |\r\n                     SCG_FIRCCSR_FIRCREGOFF((regulator) ? 0UL : 1UL)    |\r\n                     SCG_FIRCCSR_LK((lockMode) ? 1UL : 0UL);\r\n\r\n    base->FIRCCSR = value;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Gets sosc system clock mode status\r\n *\r\n * This function checks whether SOSC is used as system clock source.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  sosc system clock mode status\r\n *        - false : SOSC is not the system clock source\r\n *        - true : SOSC is the system clock source\r\n */\r\nstatic inline bool SCG_GetSoscSystemClockMode(const SCG_Type* const base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->SOSCCSR;\r\n    regValue = (regValue & SCG_SOSCCSR_SOSCSEL_MASK) >> SCG_SOSCCSR_SOSCSEL_SHIFT;\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n * @brief Gets sosc clock status\r\n * This function checks whether SOSC is enabled and output clock is valid.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  sosc  clock status\r\n *        - false : SOSC is not enabled or clock is not valid\r\n *        - true  : SOSC is enabled and clock is valid\r\n */\r\nstatic inline bool SCG_GetSoscStatus(const SCG_Type* const base)\r\n{\r\n    return (((base->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT) != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Clears SOSC lock register\r\n *\r\n * @param[in] base        scg base pointer\r\n */\r\nstatic inline void SCG_ClearSoscLock(SCG_Type*  base)\r\n{\r\n    /* Clear LK bit field */\r\n    base->SOSCCSR &= (uint32_t)(~(SCG_SOSCCSR_LK_MASK));\r\n}\r\n\r\n\r\n/*!\r\n * @brief Clears SOSC control register\r\n *\r\n * @param[in] base        scg base pointer\r\n */\r\nstatic inline void SCG_ClearSoscControl(SCG_Type* base)\r\n{\r\n    /* Disable monitor, disable clock and clear error. */\r\n    base->SOSCCSR = SCG_SOSCCSR_SOSCERR_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Sets SOSC configuration register\r\n *\r\n * @param[in] base        scg base pointer\r\n */\r\n\r\n\r\n/*!\r\n * @brief Sets SOSC configuration register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] range       sosc range\r\n * @param[in] gain        sosc gain\r\n * @param[in] extRef      external reference\r\n */\r\nstatic inline void SCG_SetSoscConfiguration(SCG_Type* base, uint32_t range, uint32_t gain, uint32_t extRef)\r\n{\r\n    /* Set SOSC configuration. */\r\n    base->SOSCCFG = SCG_SOSCCFG_RANGE(range)        |\r\n                    SCG_SOSCCFG_HGO(gain)           |\r\n                    SCG_SOSCCFG_EREFS(extRef);\r\n}\r\n\r\n/*!\r\n * @brief Sets SOSC control register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] monitorMode clock monitor enablement\r\n * @param[in] resetMode   clock monitor reset enablement\r\n * @param[in] lockMode    control register can be written or not\r\n */\r\nstatic inline void SCG_SetSoscControl(SCG_Type* base, bool monitorMode, bool resetMode, bool lockMode)\r\n{\r\n    uint32_t value = SCG_SOSCCSR_SOSCEN(1U)                        |\r\n                     SCG_SOSCCSR_SOSCCM((monitorMode) ? 1UL : 0UL) |\r\n                     SCG_SOSCCSR_SOSCCMRE((resetMode) ? 1UL : 0UL) |\r\n                     SCG_SOSCCSR_LK((lockMode) ? 1UL : 0UL);\r\n\r\n    base->SOSCCSR = value;\r\n}\r\n\r\n#if FEATURE_HAS_SPLL_CLK\r\n/*!\r\n * @brief Gets spll system clock mode status\r\n *\r\n * This function checks whether SPLL is used as system clock source.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  spll system clock mode status\r\n *        - false : SPLL is not the system clock source\r\n *        - true : SPLL is the system clock source\r\n */\r\nstatic inline bool SCG_GetSpllSystemClockMode(const SCG_Type* const base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->SPLLCSR;\r\n    regValue = (regValue & SCG_SPLLCSR_SPLLSEL_MASK) >> SCG_SPLLCSR_SPLLSEL_SHIFT;\r\n    return (regValue == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n * @brief Gets spll clock status\r\n * This function checks whether SPLL is enabled and output clock is valid.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  spll  clock status\r\n *        - false : SPLL is not enabled or clock is not valid\r\n *        - true  : SPLL is enabled and clock is valid\r\n */\r\nstatic inline bool SCG_GetSpllStatus(const SCG_Type* const base)\r\n{\r\n    return (((base->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT) != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Gets spll predivider\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  spll predivider value\r\n */\r\nstatic inline uint32_t SCG_GetSpllPredivider(const SCG_Type* const base)\r\n{\r\n    return ((base->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Gets spll multiplier\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n * @return  spll multiplier value\r\n */\r\nstatic inline uint32_t SCG_GetSpllMultiplier(const SCG_Type* const base)\r\n{\r\n    return ((base->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Clears SPLL lock register\r\n *\r\n * This function clears SPLL lock.\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n */\r\nstatic inline void SCG_ClearSpllLock(SCG_Type*  base)\r\n{\r\n    /* Clear LK bit field */\r\n    base->SPLLCSR &= (uint32_t)(~(SCG_SPLLCSR_LK_MASK));\r\n}\r\n\r\n\r\n/*!\r\n * @brief Clears SPLL control register\r\n *\r\n * @param[in] base        scg base pointer\r\n *\r\n */\r\nstatic inline void SCG_ClearSpllControl(SCG_Type* base)\r\n{\r\n    /* Disable monitor, disable clock and clear error. */\r\n    base->SPLLCSR = SCG_SPLLCSR_SPLLERR_MASK;\r\n}\r\n\r\n/*!\r\n * @brief Sets SPLL configuration register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] divider     spll predivider value\r\n * @param[in] multiplier  spll multiplier value\r\n */\r\nstatic inline void SCG_SetSpllConfiguration(SCG_Type* base, uint8_t divider, uint8_t multiplier)\r\n{\r\n    /* Set PLL configuration. */\r\n    base->SPLLCFG = SCG_SPLLCFG_PREDIV(divider)  |\r\n                    SCG_SPLLCFG_MULT(multiplier);\r\n}\r\n\r\n/*!\r\n * @brief Sets SPLL control register\r\n *\r\n * @param[in] base        scg base pointer\r\n * @param[in] monitorMode clock monitor enablement\r\n * @param[in] resetMode   clock monitor reset enablement\r\n * @param[in] lockMode    control register can be written or not\r\n */\r\nstatic inline void SCG_SetSpllControl(SCG_Type* base, bool monitorMode, bool resetMode, bool lockMode)\r\n{\r\n    uint32_t value = SCG_SPLLCSR_SPLLEN(1U)                        |\r\n                     SCG_SPLLCSR_SPLLCM((monitorMode) ? 1UL : 0UL) |\r\n                     SCG_SPLLCSR_SPLLCMRE((resetMode) ? 1UL : 0UL) |\r\n                     SCG_SPLLCSR_LK((lockMode) ? 1UL : 0UL);\r\n\r\n    base->SPLLCSR = value;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*! @}*/\r\n\r\n#endif /* SCG_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"sim_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\clock\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef SIM_HW_ACCESS_H\r\n#define SIM_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n\r\n/*!\r\n * @file sim_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to implement enumeration entries as macro.\r\n * Enumeration entries (macros) are referenced from application code.\r\n */\r\n\r\n/*!\r\n * @ingroup sim_hw_access\r\n * @defgroup sim_hw_access\r\n * @{\r\n */\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n#define CLOCK_QSPI_MCR_SCLKCFG_CLK_MOD       0x40U    /* Quadspi Clocking mode selection  */\r\n#define CLOCK_QSPI_MCR_SCLKCFG_EXT_DQS       0x20U    /* Use external DQS (HyperRAM mode) */\r\n#define CLOCK_QSPI_MCR_SCLKCFG_CLK_SRC       0x10U    /* QuadSPI source clock selection   */\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*!\r\n * @brief Get the clock selection of RTCCLKSEL.\r\n *\r\n * This function gets the clock selection of RTCCLKSEL.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return Current selection.\r\n */\r\nstatic inline uint32_t SIM_GetRtcClkSrc(const SIM_Type * base)\r\n{\r\n    return ((base->LPOCLKS & SIM_LPOCLKS_RTCCLKSEL_MASK) >> SIM_LPOCLKS_RTCCLKSEL_SHIFT);\r\n}\r\n\r\n\r\n/*!\r\n * @brief Set the clock selection of LPOCLKSEL.\r\n *\r\n * This function sets the clock selection of LPOCLKSEL.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] setting The value to set.\r\n * @note This function ignores initialize member\r\n */\r\nstatic inline void SIM_SetLpoClocks(SIM_Type* base, bool enableLpo1k, bool enableLpo32k, uint32_t sourceLpoClk, uint32_t sourceRtcClk)\r\n{\r\n    uint32_t regValue = base->LPOCLKS;\r\n\r\n    regValue &= ~( SIM_LPOCLKS_LPO1KCLKEN_MASK  |\r\n                   SIM_LPOCLKS_LPO32KCLKEN_MASK |\r\n                   SIM_LPOCLKS_LPOCLKSEL_MASK   |\r\n                   SIM_LPOCLKS_RTCCLKSEL_MASK   );\r\n\r\n    regValue |= SIM_LPOCLKS_LPO1KCLKEN(enableLpo1k ? 1UL : 0UL);\r\n    regValue |= SIM_LPOCLKS_LPO32KCLKEN(enableLpo32k ? 1UL : 0UL);\r\n    regValue |= SIM_LPOCLKS_LPOCLKSEL(sourceLpoClk);\r\n    regValue |= SIM_LPOCLKS_RTCCLKSEL(sourceRtcClk);\r\n\r\n    /* Write value to register. */\r\n    base->LPOCLKS = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Set the EIM Clock Gate from the Platform Clock Gating Control Register.\r\n *\r\n * This function configures the EIM Clock Gate in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] EIM clock gate enable setting\r\n */\r\nstatic inline void SIM_SetEimClockGate(SIM_Type* base, bool enable)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCEIM_MASK));\r\n    regValue |= SIM_PLATCGC_CGCEIM(enable ? 1UL : 0UL);\r\n    base->PLATCGC = (uint32_t)regValue;\r\n}\r\n\r\n/*!\r\n * @brief Gets the EIM Clock Gate from the Platform Clock Gating Control Register.\r\n *\r\n * This function gets the EIM Clock Gate in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return EIM Clock Gating\r\n */\r\nstatic inline bool SIM_GetEimClockGate(const SIM_Type * base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue = (regValue & SIM_PLATCGC_CGCEIM_MASK) >> SIM_PLATCGC_CGCEIM_SHIFT;\r\n    return (regValue != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Set the ERM Clock Gate from the Platform Clock Gating Control Register.\r\n *\r\n * This function configures the ERM Clock Gate in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] enable ERM clock gate enable setting\r\n */\r\nstatic inline void SIM_SetErmClockGate(SIM_Type* base, bool enable)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCERM_MASK));\r\n    regValue |= SIM_PLATCGC_CGCERM(enable ? 1UL : 0UL);\r\n    base->PLATCGC = (uint32_t)regValue;\r\n}\r\n\r\n\r\n\r\n/*!\r\n * @brief Gets the ERM Clock Gate from the Platform Clock Gating Control Register.\r\n *\r\n * This function gets the ERM Clock Gate in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return ERM Clock Gating\r\n */\r\nstatic inline bool SIM_GetErmClockGate(const SIM_Type * base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue = (regValue & SIM_PLATCGC_CGCERM_MASK) >> SIM_PLATCGC_CGCERM_SHIFT;\r\n    return (regValue != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Set the DMA Clock Gate from the Platform Clock Gating Control Register.\r\n *\r\n * This function configures the DMA Clock Gate in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] enable DMA clock gate enable setting\r\n */\r\nstatic inline void SIM_SetDmaClockGate(SIM_Type* base, bool enable)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCDMA_MASK));\r\n    regValue |= SIM_PLATCGC_CGCDMA(enable ? 1UL : 0UL);\r\n    base->PLATCGC = (uint32_t)regValue;\r\n}\r\n\r\n\r\n\r\n/*!\r\n * @brief Gets the DMA Clock Gate from the Platform Clock Gating Control Register.\r\n *\r\n * This function gets the DMA Clock Gate in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return DMA Clock Gating\r\n */\r\nstatic inline bool SIM_GetDmaClockGate(const SIM_Type * base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue = (regValue & SIM_PLATCGC_CGCDMA_MASK) >> SIM_PLATCGC_CGCDMA_SHIFT;\r\n    return (regValue != 0U) ? true : false;\r\n}\r\n\r\n\r\n/*!\r\n * @brief Configure the MPU Clock Gating from the Platform Clock Gating Control Register.\r\n *\r\n * This function configures the MPU Clock Gating in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] enable MPU clock gate enable setting\r\n */\r\nstatic inline void SIM_SetMpuClockGate(SIM_Type* base, bool enable)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCMPU_MASK));\r\n    regValue |= SIM_PLATCGC_CGCMPU(enable ? 1UL : 0UL);\r\n    base->PLATCGC = (uint32_t)regValue;\r\n}\r\n\r\n/*!\r\n * @brief Gets the MPU Clock Gating from the Platform Clock Gating Control Register.\r\n *\r\n * This function gets the MPU Clock Gating in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return MPU Clock Gating\r\n */\r\nstatic inline bool SIM_GetMpuClockGate(const SIM_Type * base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue = (regValue & SIM_PLATCGC_CGCMPU_MASK) >> SIM_PLATCGC_CGCMPU_SHIFT;\r\n    return (regValue != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Configure the MSCM Clock Gating from the Platform Clock Gating Control Register.\r\n *\r\n * This function configures the MSCM Clock Gating in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] enable MPU clock gate enable setting\r\n */\r\nstatic inline void SIM_SetMscmClockGate(SIM_Type* base, bool enable)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCMSCM_MASK));\r\n    regValue |= SIM_PLATCGC_CGCMSCM(enable ? 1UL : 0UL);\r\n    base->PLATCGC = (uint32_t)regValue;\r\n}\r\n\r\n/*!\r\n * @brief Gets the MSCM Clock Gating from the Platform Clock Gating Control Register.\r\n *\r\n * This function gets the MSCM Clock Gating in the Platform Clock Gating Control Register.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return MSCM Clock Gating\r\n */\r\nstatic inline bool SIM_GetMscmClockGate(const SIM_Type * base)\r\n{\r\n    uint32_t regValue = (uint32_t)base->PLATCGC;\r\n    regValue = (regValue & SIM_PLATCGC_CGCMSCM_MASK) >> SIM_PLATCGC_CGCMSCM_SHIFT;\r\n    return (regValue != 0U) ? true : false;\r\n}\r\n\r\n#if defined(QuadSPI_INSTANCE_COUNT)\r\n/*!\r\n * @brief Configure the QuadSPI Internal Reference Clock Gating\r\n *\r\n * This function configures the QuadSPI Internal Reference Clock Gating.\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @param[in] configures QuadSPI Internal Reference Clock Gating\r\n */\r\nstatic inline void SIM_SetQspiIntRefClockGate(SIM_Type* base, bool enable)\r\n{\r\n    uint32_t regValue = (uint32_t)base->MISCTRL0;\r\n    regValue &= (uint32_t)(~(SIM_MISCTRL0_QSPI_CLK_SEL_MASK));\r\n    regValue |= SIM_MISCTRL0_QSPI_CLK_SEL(enable ? 1UL : 0UL);\r\n    base->MISCTRL0 = (uint32_t)regValue;\r\n}\r\n\r\n/*\r\n * @brief Get the current QSPI clocking mode selection\r\n *\r\n * This function gets the current QSPI clocking mode selection.\r\n *\r\n * @param[in] baseAddr Base address for current QSPI instance.\r\n * @return clocking mode selection\r\n */\r\nstatic inline bool QSPI_GetClockingModeSelection(const QuadSPI_Type *baseAddr)\r\n{\r\n    return (((baseAddr->MCR & QuadSPI_MCR_SCLKCFG_MASK) >> QuadSPI_MCR_SCLKCFG_SHIFT) & CLOCK_QSPI_MCR_SCLKCFG_CLK_MOD) != 0U;\r\n}\r\n\r\n/*\r\n * @brief Get the current QSPI HyperRam clocking mode selection\r\n *\r\n * This function gets the current QSPI HyperRam clocking mode selection.\r\n *\r\n * @param[in] baseAddr Base address for current QSPI instance.\r\n * @return HyperRam clocking mode selection\r\n */\r\nstatic inline bool QSPI_GetClockingHyperRamMode(const QuadSPI_Type *baseAddr)\r\n{\r\n    return (((baseAddr->MCR & QuadSPI_MCR_SCLKCFG_MASK) >> QuadSPI_MCR_SCLKCFG_SHIFT) & CLOCK_QSPI_MCR_SCLKCFG_EXT_DQS) != 0U;\r\n}\r\n\r\n/*\r\n * @brief Get the current QSPI clocking source selection\r\n *\r\n * This function gets the current QSPI clocking source selection.\r\n *\r\n * @param[in] baseAddr Base address for current QSPI instance.\r\n * @return clocking source selection\r\n */\r\nstatic inline bool QSPI_GetClockingSourceSelection(const QuadSPI_Type *baseAddr)\r\n{\r\n    return (((baseAddr->MCR & QuadSPI_MCR_SCLKCFG_MASK) >> QuadSPI_MCR_SCLKCFG_SHIFT) & CLOCK_QSPI_MCR_SCLKCFG_CLK_SRC) != 0U;\r\n}\r\n\r\n/*\r\n * @brief Get the current SIM clocking mode selection\r\n *\r\n * This function gets the current SIM clocking mode selection.\r\n *\r\n * @param[in] baseAddr Base address for current SIM instance.\r\n * @return clocking mode selection\r\n */\r\nstatic inline bool SIM_GetClockingModeSelection(const SIM_Type *baseAddr)\r\n{\r\n    return ((baseAddr->MISCTRL0 & SIM_MISCTRL0_QSPI_CLK_SEL_MASK) >> SIM_MISCTRL0_QSPI_CLK_SEL_SHIFT) != 0U;\r\n}\r\n\r\n/*\r\n * @brief Get the clocking programmable divider\r\n *\r\n * This function gets the clocking programmable divider.\r\n *\r\n * @param[in] baseAddr Base address for current QSPI instance.\r\n * @return clocking programmable divider\r\n */\r\nstatic inline uint32_t QSPI_GetClockingProgrammableDividerValue(const QuadSPI_Type *baseAddr)\r\n{\r\n    return (baseAddr->SOCCR & QuadSPI_SOCCR_SOCCFG_MASK) >> QuadSPI_SOCCR_SOCCFG_SHIFT;\r\n}\r\n#endif\r\n\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm0ExternalClkPinMode\r\n * Description   : Get FlexTimer 0 external clock pin select setting\r\n * This function will get FlexTimer 0 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm0ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM0CLKSEL_MASK) >> SIM_FTMOPT0_FTM0CLKSEL_SHIFT;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm1ExternalClkPinMode\r\n * Description   : Get FlexTimer 1 external clock pin select setting\r\n * This function will get FlexTimer 1 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm1ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM1CLKSEL_MASK) >> SIM_FTMOPT0_FTM1CLKSEL_SHIFT;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm2ExternalClkPinMode\r\n * Description   : Get FlexTimer 2 external clock pin select setting\r\n * This function will get FlexTimer 2 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm2ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM2CLKSEL_MASK) >> SIM_FTMOPT0_FTM2CLKSEL_SHIFT;\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm3ExternalClkPinMode\r\n * Description   : Get FlexTimer 3 external clock pin select setting\r\n * This function will get FlexTimer 3 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm3ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM3CLKSEL_MASK) >> SIM_FTMOPT0_FTM3CLKSEL_SHIFT;\r\n}\r\n\r\n#if FTM_INSTANCE_COUNT > 4U\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm4ExternalClkPinMode\r\n * Description   : Get FlexTimer 4 external clock pin select setting\r\n * This function will get FlexTimer 4 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm4ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM4CLKSEL_MASK) >> SIM_FTMOPT0_FTM4CLKSEL_SHIFT;\r\n}\r\n#endif\r\n\r\n#if FTM_INSTANCE_COUNT > 5U\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm5ExternalClkPinMode\r\n * Description   : Get FlexTimer 5 external clock pin select setting\r\n * This function will get FlexTimer 5 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm5ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM5CLKSEL_MASK) >> SIM_FTMOPT0_FTM5CLKSEL_SHIFT;\r\n}\r\n#endif\r\n\r\n#if FTM_INSTANCE_COUNT > 6U\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm6ExternalClkPinMode\r\n * Description   : Get FlexTimer 6 external clock pin select setting\r\n * This function will get FlexTimer 6 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm6ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM6CLKSEL_MASK) >> SIM_FTMOPT0_FTM6CLKSEL_SHIFT;\r\n}\r\n#endif\r\n\r\n\r\n#if FTM_INSTANCE_COUNT > 7U\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SIM_GetFtm7ExternalClkPinMode\r\n * Description   : Get FlexTimer 7 external clock pin select setting\r\n * This function will get FlexTimer 7 external clock pin select setting.\r\n *END**************************************************************************/\r\nstatic inline uint32_t SIM_GetFtm7ExternalClkPinMode(const SIM_Type * base)\r\n{\r\n    return (base->FTMOPT0 & SIM_FTMOPT0_FTM7CLKSEL_MASK) >> SIM_FTMOPT0_FTM7CLKSEL_SHIFT;\r\n}\r\n#endif\r\n\r\n/*FUNCTION*********************************************************************\r\n *\r\n * Function Name : SIM_GetLpo32KStatus\r\n * Description   : Get SIM LPO 32KHz clock gating status (LPO_32K_CLOCK).\r\n *END*************************************************************************/\r\nstatic inline bool SIM_GetLpo32KStatus(const SIM_Type * base)\r\n{\r\n    return (((base->LPOCLKS & SIM_LPOCLKS_LPO32KCLKEN_MASK) >> SIM_LPOCLKS_LPO32KCLKEN_SHIFT) != 0U) ? true : false;\r\n}\r\n\r\n/*FUNCTION*********************************************************************\r\n *\r\n * Function Name : SIM_GetLpo1KStatus\r\n * Description   : Get SIM LPO 1KHz clock gating status (LPO_1K_CLOCK).\r\n *END*************************************************************************/\r\nstatic inline bool SIM_GetLpo1KStatus(const SIM_Type * base)\r\n{\r\n    return (((base->LPOCLKS & SIM_LPOCLKS_LPO1KCLKEN_MASK) >> SIM_LPOCLKS_LPO1KCLKEN_SHIFT) != 0U) ? true : false;\r\n}\r\n\r\n/*!\r\n * @brief Gets the LPO selector value\r\n *\r\n * This function gets the LPO selector value\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return clockout status\r\n */\r\nstatic inline uint32_t SIM_GetLpoClkSelectorValue(const SIM_Type * base)\r\n{\r\n    return ((base->LPOCLKS & SIM_LPOCLKS_LPOCLKSEL_MASK) >> SIM_LPOCLKS_LPOCLKSEL_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Gets the clock out status\r\n *\r\n * This function gets the clock out status (enabled or disabled)\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return clockout status\r\n */\r\nstatic inline bool SIM_GetClockoutStatus(const SIM_Type * base)\r\n{\r\n    return (((base->CHIPCTL & SIM_CHIPCTL_CLKOUTEN_MASK) >> SIM_CHIPCTL_CLKOUTEN_SHIFT) == 0U) ? false : true;\r\n}\r\n\r\n/*!\r\n * @brief Gets the clock out divider value\r\n *\r\n * This function gets the clock out divider value\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return clockout divider\r\n */\r\nstatic inline uint32_t SIM_GetClockoutDividerValue(const SIM_Type * base)\r\n{\r\n    return ((base->CHIPCTL & SIM_CHIPCTL_CLKOUTDIV_MASK) >> SIM_CHIPCTL_CLKOUTDIV_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Gets the clock out source\r\n *\r\n * This function gets the clock out source\r\n *\r\n * @param[in] base Base address for current SIM instance.\r\n * @return clockout source\r\n */\r\nstatic inline uint32_t SIM_GetClockoutSelectorValue(const SIM_Type * base)\r\n{\r\n    return ((base->CHIPCTL & SIM_CHIPCTL_CLKOUTSEL_MASK) >> SIM_CHIPCTL_CLKOUTSEL_SHIFT);\r\n}\r\n\r\n/*!\r\n * @brief Sets ext pin clock source for FTM\r\n *\r\n * @param[in] base        sim base pointer\r\n * @param[in] instance    ftm instance\r\n * @param[in] source      clock source\r\n */\r\nstatic inline void SIM_SetExtPinSourceFtm(SIM_Type* base, uint8_t instance, uint32_t source)\r\n{\r\n    uint32_t regValue = base->FTMOPT0;\r\n\r\n    switch (instance)\r\n    {\r\n        case 0U:\r\n            regValue &= ~SIM_FTMOPT0_FTM0CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM0CLKSEL(source);\r\n            break;\r\n        case 1U:\r\n            regValue &= ~SIM_FTMOPT0_FTM1CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM1CLKSEL(source);\r\n            break;\r\n#if FTM_INSTANCE_COUNT > 2U\r\n        case 2U:\r\n            regValue &= ~SIM_FTMOPT0_FTM2CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM2CLKSEL(source);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 3U\r\n        case 3U:\r\n            regValue &= ~SIM_FTMOPT0_FTM3CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM3CLKSEL(source);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 4U\r\n        case 4U:\r\n            regValue &= ~SIM_FTMOPT0_FTM4CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM4CLKSEL(source);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 5U\r\n        case 5U:\r\n            regValue &= ~SIM_FTMOPT0_FTM5CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM5CLKSEL(source);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 6U\r\n        case 6U:\r\n            regValue &= ~SIM_FTMOPT0_FTM6CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM6CLKSEL(source);\r\n            break;\r\n#endif\r\n#if FTM_INSTANCE_COUNT > 7U\r\n        case 7U:\r\n            regValue &= ~SIM_FTMOPT0_FTM7CLKSEL_MASK;\r\n            regValue |= SIM_FTMOPT0_FTM7CLKSEL(source);\r\n            break;\r\n#endif\r\n        default:\r\n            /* Do nothing */\r\n            break;\r\n    }\r\n\r\n    base->FTMOPT0 = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Sets clockout\r\n *\r\n * @param[in] base        sim base pointer\r\n * @param[in] source      clock source\r\n * @param[in] divider     clock divider\r\n */\r\nstatic inline void SIM_SetClockout(SIM_Type* base, bool enable, uint32_t source, uint32_t divider)\r\n{\r\n    uint32_t regValue;\r\n\r\n    /* CLKOUTEN should be first cleared and then execute sequence */\r\n    base->CHIPCTL &= ~SIM_CHIPCTL_CLKOUTEN_MASK;\r\n\r\n    regValue = base->CHIPCTL;\r\n    regValue &= ~( SIM_CHIPCTL_CLKOUTEN_MASK  |\r\n                   SIM_CHIPCTL_CLKOUTDIV_MASK |\r\n                   SIM_CHIPCTL_CLKOUTSEL_MASK );\r\n\r\n    regValue |= SIM_CHIPCTL_CLKOUTEN(enable ? 1UL : 0UL);\r\n    regValue |= SIM_CHIPCTL_CLKOUTSEL(source);\r\n    regValue |= SIM_CHIPCTL_CLKOUTDIV(divider);\r\n\r\n    base->CHIPCTL = regValue;\r\n}\r\n\r\n/*!\r\n * @brief Configure clock trace source\r\n *\r\n * @param[in] base        sim base pointer\r\n * @param[in] source      clock trace source\r\n */\r\nstatic inline void SIM_SetTraceClockSource(SIM_Type* base, uint32_t clTraceSrc)\r\n{\r\n    uint32_t regValue;\r\n\r\n    /* Configure trace source. */\r\n    regValue = (uint32_t)base->CHIPCTL;\r\n    regValue &= (uint32_t)(~(SIM_CHIPCTL_TRACECLK_SEL_MASK));\r\n    regValue |= SIM_CHIPCTL_TRACECLK_SEL(clTraceSrc);\r\n    base->CHIPCTL = (uint32_t)regValue;\r\n}\r\n\r\n/*!\r\n * @brief Clears SIM Debug Trace configuration.\r\n *\r\n * This function disables the SIM Debug Trace clock.\r\n *\r\n * @param[in] base Register base address for the SIM instance.\r\n */\r\nstatic inline void SIM_ClearTraceClockConfig(SIM_Type * base)\r\n{\r\n    /* Disable divider. */\r\n    base->CLKDIV4 &= 0U;\r\n}\r\n\r\n/*!\r\n * @brief Set SIM Debug Trace configuration.\r\n *\r\n * This function disables the SIM Debug Trace clock.\r\n *\r\n * @param[in] base        sim base pointer\r\n * @param[in] source      clock trace source\r\n */\r\nstatic inline void SIM_SetTraceClockConfig(SIM_Type * base, bool enable, uint32_t divider, uint32_t multiplier)\r\n{\r\n    base->CLKDIV4 = SIM_CLKDIV4_TRACEDIVEN(enable ? 1UL : 0UL) |\r\n                    SIM_CLKDIV4_TRACEDIV(divider)              |\r\n                    SIM_CLKDIV4_TRACEFRAC(multiplier);\r\n}\r\n\r\n\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*! @}*/\r\n\r\n#endif /* SIM_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"smc_hw_access.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw\\src\\clock\\S32K1xx","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef SMC_HW_ACCESS_H\r\n#define SMC_HW_ACCESS_H\r\n\r\n#include \"device_registers.h\"\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n\r\n/*!\r\n * @file smc_hw_access.h\r\n *\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\r\n * This is required to implement enumeration entries as macro.\r\n * Enumeration entries (macros) are referenced from application code.\r\n */\r\n\r\n/*!\r\n * @ingroup smc_hw_access\r\n * @defgroup smc_hw_access\r\n * @{\r\n */\r\n\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*!\r\n * @brief Gets the current running power mode.\r\n *\r\n * This function  returns the current running power mode.\r\n *\r\n * @param[in] baseAddr  Base address for current SMC instance.\r\n * @return stat  Current power mode stat\r\n */\r\nstatic inline uint32_t SMC_GetCurrentRunningMode(const SMC_Type* const baseAddr)\r\n{\r\n    return (baseAddr->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT;\r\n}\r\n\r\n\r\n#if defined(__cplusplus)\r\n}\r\n#endif /* __cplusplus*/\r\n\r\n\r\n/*! @}*/\r\n\r\n#endif /* SMC_HW_ACCESS_H */\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"startup.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, An object should be defined at block\r\n * scope if its identifier only appears in a single function.\r\n * All variables with this problem are defined in the linker files.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.11, When an array with external linkage\r\n * is declared, its size should be explicitly specified.\r\n * The size of the arrays can not be explicitly determined.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The cast is required to initialize a pointer with an unsigned int define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The cast is required to initialize a pointer with an unsigned int define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 2.1, A project shall not contain unreachable\r\n * code.\r\n * The condition compares two address defined in linker files that can be different.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Mandatory Rule 17.3, Symbol 'MFSPR' undeclared, assumed\r\n * to return int.\r\n * This is an e200 Power Architecture Assembly instruction used to retrieve\r\n * the core number.\r\n *\r\n */\r\n\r\n#include \"startup.h\"\r\n#include <stdint.h>\r\n\r\n\r\n/*******************************************************************************\r\n * Static Variables\r\n ******************************************************************************/\r\nstatic volatile uint32_t * const s_vectors[NUMBER_OF_CORES] = FEATURE_INTERRUPT_INT_VECTORS;\r\n\r\n/*******************************************************************************\r\n * Code\r\n ******************************************************************************/\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : init_data_bss\r\n * Description   : Make necessary initializations for RAM.\r\n * - Copy the vector table from ROM to RAM.\r\n * - Copy initialized data from ROM to RAM.\r\n * - Copy code that should reside in RAM from ROM\r\n * - Clear the zero-initialized data section.\r\n *\r\n * Tool Chains:\r\n *   __GNUC__           : GNU Compiler Collection\r\n *   __ghs__            : Green Hills ARM Compiler\r\n *   __ICCARM__         : IAR ARM Compiler\r\n *   __DCC__            : Wind River Diab Compiler\r\n *   __ARMCC_VERSION    : ARMC Compiler\r\n *\r\n * Implements    : init_data_bss_Activity\r\n *END**************************************************************************/\r\nvoid init_data_bss(void)\r\n{\r\n    uint32_t n;\r\n    uint8_t coreId;\r\n/* For ARMC we are using the library method of initializing DATA, Custom Section and\r\n * Code RAM sections so the below variables are not needed */\r\n#if !defined(__ARMCC_VERSION)\r\n    /* Declare pointers for various data sections. These pointers\r\n     * are initialized using values pulled in from the linker file */\r\n    uint8_t * data_ram;\r\n    uint8_t * code_ram;\r\n    uint8_t * bss_start;\r\n    uint8_t * custom_ram;\r\n    const uint8_t * data_rom, * data_rom_end;\r\n    const uint8_t * code_rom, * code_rom_end;\r\n    const uint8_t * bss_end;\r\n    const uint8_t * custom_rom, * custom_rom_end;\r\n#endif\r\n    /* Addresses for VECTOR_TABLE and VECTOR_RAM come from the linker file */\r\n\r\n#if defined(__ARMCC_VERSION)\r\n    extern uint32_t __RAM_VECTOR_TABLE_SIZE;\r\n    extern uint32_t __VECTOR_ROM;\r\n    extern uint32_t __VECTOR_RAM;\r\n#else\r\n    extern uint32_t __RAM_VECTOR_TABLE_SIZE[];\r\n    extern uint32_t __VECTOR_TABLE[];\r\n    extern uint32_t __VECTOR_RAM[];\r\n#endif\r\n    /* Get section information from linker files */\r\n#if defined(__ICCARM__)\r\n    /* Data */\r\n    data_ram        = __section_begin(\".data\");\r\n    data_rom        = __section_begin(\".data_init\");\r\n    data_rom_end    = __section_end(\".data_init\");\r\n\r\n    /* CODE RAM */\r\n    #pragma section = \"__CODE_ROM\"\r\n    #pragma section = \"__CODE_RAM\"\r\n    code_ram        = __section_begin(\"__CODE_RAM\");\r\n    code_rom        = __section_begin(\"__CODE_ROM\");\r\n    code_rom_end    = __section_end(\"__CODE_ROM\");\r\n\r\n    /* BSS */\r\n    bss_start       = __section_begin(\".bss\");\r\n    bss_end         = __section_end(\".bss\");\r\n\r\n    custom_ram      = __section_begin(\".customSection\");\r\n    custom_rom      = __section_begin(\".customSection_init\");\r\n    custom_rom_end  = __section_end(\".customSection_init\");\r\n    \r\n#elif defined (__ARMCC_VERSION)\r\n    /* VECTOR TABLE*/\r\n    uint8_t * vector_table_size = (uint8_t *)__RAM_VECTOR_TABLE_SIZE;\r\n    uint32_t * vector_rom    = (uint32_t *)__VECTOR_ROM;\r\n    uint32_t * vector_ram    = (uint32_t *)__VECTOR_RAM;\r\n#else\r\n    extern uint32_t __DATA_ROM[];\r\n    extern uint32_t __DATA_RAM[];\r\n    extern uint32_t __DATA_END[];\r\n\r\n    extern uint32_t __CODE_RAM[];\r\n    extern uint32_t __CODE_ROM[];\r\n    extern uint32_t __CODE_END[];\r\n\r\n    extern uint32_t __BSS_START[];\r\n    extern uint32_t __BSS_END[];\r\n\r\n    extern uint32_t __CUSTOM_ROM[];\r\n    extern uint32_t __CUSTOM_END[];\r\n\r\n    /* Data */\r\n    data_ram        = (uint8_t *)__DATA_RAM;\r\n    data_rom        = (uint8_t *)__DATA_ROM;\r\n    data_rom_end    = (uint8_t *)__DATA_END;\r\n    /* CODE RAM */\r\n    code_ram        = (uint8_t *)__CODE_RAM;\r\n    code_rom        = (uint8_t *)__CODE_ROM;\r\n    code_rom_end    = (uint8_t *)__CODE_END;\r\n    /* BSS */\r\n    bss_start       = (uint8_t *)__BSS_START;\r\n    bss_end         = (uint8_t *)__BSS_END;\r\n\r\n\t/* Custom section */\r\n    custom_ram      = CUSTOMSECTION_SECTION_START;\r\n    custom_rom      = (uint8_t *)__CUSTOM_ROM;\r\n    custom_rom_end  = (uint8_t *)__CUSTOM_END;\r\n\r\n#endif\r\n\r\n#if !defined(__ARMCC_VERSION)\r\n    /* Copy initialized data from ROM to RAM */\r\n    while (data_rom_end != data_rom)\r\n    {\r\n        *data_ram = *data_rom;\r\n        data_ram++;\r\n        data_rom++;\r\n    }\r\n\r\n    /* Copy functions from ROM to RAM */\r\n    while (code_rom_end != code_rom)\r\n    {\r\n        *code_ram = *code_rom;\r\n        code_ram++;\r\n        code_rom++;\r\n    }\r\n\r\n    /* Clear the zero-initialized data section */\r\n    while(bss_end != bss_start)\r\n    {\r\n        *bss_start = 0;\r\n        bss_start++;\r\n    }\r\n\r\n    /* Copy customsection rom to ram */\r\n    while(custom_rom_end != custom_rom)\r\n    {\r\n        *custom_ram = *custom_rom;\r\n        custom_rom++;\r\n        custom_ram++;\r\n    }\r\n#endif\r\n    coreId = (uint8_t)GET_CORE_ID();\r\n#if defined (__ARMCC_VERSION)\r\n        /* Copy the vector table from ROM to RAM */\r\n                /* Workaround */\r\n        for (n = 0; n < (((uint32_t)(vector_table_size))/sizeof(uint32_t)); n++)\r\n        {\r\n            vector_ram[n] = vector_rom[n];\r\n        }\r\n        /* Point the VTOR to the position of vector table */\r\n         *s_vectors[coreId] = (uint32_t) __VECTOR_RAM;\r\n#else\r\n    /* Check if VECTOR_TABLE copy is needed */\r\n    if (__VECTOR_RAM != __VECTOR_TABLE)\r\n    {\r\n        /* Copy the vector table from ROM to RAM */\r\n        for (n = 0; n < (((uint32_t)__RAM_VECTOR_TABLE_SIZE)/sizeof(uint32_t)); n++)\r\n        {\r\n            __VECTOR_RAM[n] = __VECTOR_TABLE[n];\r\n        }\r\n        /* Point the VTOR to the position of vector table */\r\n        *s_vectors[coreId] = (uint32_t)__VECTOR_RAM;\r\n    }\r\n    else\r\n    {\r\n        /* Point the VTOR to the position of vector table */\r\n        *s_vectors[coreId] = (uint32_t)__VECTOR_TABLE;\r\n    }\r\n#endif\r\n\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n\r\n"},{"name":"startup.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef STARTUP_H\r\n#define STARTUP_H\r\n\r\n#include <stdint.h>\r\n#include \"device_registers.h\"\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Local macro not referenced.\r\n * The defined macro is used as include guard.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, An object should be defined at block\r\n * scope if its identifier only appears in a single function.\r\n * All variables with this problem are defined in the linker files.\r\n *\r\n */\r\n\r\n/*******************************************************************************\r\n * API\r\n ******************************************************************************/\r\n\r\n/*!\r\n * @brief define symbols that specific start and end addres of some basic sections. \r\n */\r\n#if (defined(S32K14x_SERIES) || defined(S32K11x_SERIES) || defined(S32V234_SERIES) || defined(MPC574x_SERIES) || defined(S32R_SERIES) || defined(S32MTV_SERIES) || defined(SJA1110_SERIES))\r\n    #if (defined(__ICCARM__))     \r\n        #define INTERRUPTS_SECTION_START               __section_begin(\".intvec\")\r\n        #define INTERRUPTS_SECTION_END                 __section_end(\".intvec\")\r\n        #define BSS_SECTION_START                      __section_begin(\".bss\")\r\n        #define BSS_SECTION_END                        __section_end(\".bss\")\r\n        #define DATA_SECTION_START                     __section_begin(\".data\")\r\n        #define DATA_SECTION_END                       __section_end(\".data\")\r\n        #define CUSTOMSECTION_SECTION_START            __section_begin(\".customSection\")\r\n        #define CUSTOMSECTION_SECTION_END              __section_end(\".customSection\")\r\n        #define CODE_RAM_SECTION_START                 __section_begin(\"__CODE_RAM\")\r\n        #define CODE_RAM_SECTION_END                   __section_end(\"__CODE_RAM\")\r\n        #define DATA_INIT_SECTION_START                __section_begin(\".data_init\")\r\n        #define DATA_INIT_SECTION_END                  __section_end(\".data_init\")\r\n        #define CODE_ROM_SECTION_START                 __section_begin(\"__CODE_ROM\")\r\n        #define CODE_ROM_SECTION_END                   __section_end(\"__CODE_ROM\")\r\n\r\n    #elif (defined(__ARMCC_VERSION))\r\n        #define INTERRUPTS_SECTION_START               (uint8_t *)__VECTOR_ROM_START\r\n        #define INTERRUPTS_SECTION_END                 (uint8_t *)__VECTOR_ROM_END\r\n        #define BSS_SECTION_START                      (uint8_t *)__BSS_START\r\n        #define BSS_SECTION_END                        (uint8_t *)__BSS_END\r\n        #define DATA_SECTION_START                     (uint8_t *)__DATA_RAM_START\r\n        #define DATA_SECTION_END                       (uint8_t *)__DATA_RAM_END\r\n        #define CUSTOMSECTION_SECTION_START            (uint8_t *)__CUSTOM_SECTION_START\r\n        #define CUSTOMSECTION_SECTION_END              (uint8_t *)__CUSTOM_SECTION_END\r\n        #define CODE_RAM_SECTION_START                 (uint8_t *)__CODE_RAM_START\r\n        #define CODE_RAM_SECTION_END                   (uint8_t *)__CODE_RAM_END\r\n        \r\n        extern uint32_t __VECTOR_ROM_START;\r\n        extern uint32_t __VECTOR_ROM_END;\r\n        extern uint32_t __BSS_START;\r\n        extern uint32_t __BSS_END;\r\n        extern uint32_t __DATA_RAM_START;\r\n        extern uint32_t __DATA_RAM_END;\r\n        extern uint32_t __CUSTOM_SECTION_START;\r\n        extern uint32_t __CUSTOM_SECTION_END;\r\n        extern uint32_t __CODE_RAM_START;\r\n        extern uint32_t __CODE_RAM_END;\r\n    #else\r\n        #define INTERRUPTS_SECTION_START               (uint8_t *)&__interrupts_start__\r\n        #define INTERRUPTS_SECTION_END                 (uint8_t *)&__interrupts_end__\r\n        #define BSS_SECTION_START                      (uint8_t *)&__bss_start__\r\n        #define BSS_SECTION_END                        (uint8_t *)&__bss_end__\r\n        #define DATA_SECTION_START                     (uint8_t *)&__data_start__\r\n        #define DATA_SECTION_END                       (uint8_t *)&__data_end__\r\n        #define CUSTOMSECTION_SECTION_START            (uint8_t *)&__customSection_start__\r\n        #define CUSTOMSECTION_SECTION_END              (uint8_t *)&__customSection_end__\r\n        #define CODE_RAM_SECTION_START                 (uint8_t *)&__code_ram_start__\r\n        #define CODE_RAM_SECTION_END                   (uint8_t *)&__code_ram_end__\r\n        \r\n        extern uint32_t __interrupts_start__;\r\n        extern uint32_t __interrupts_end__;\r\n        extern uint32_t __bss_start__;\r\n        extern uint32_t __bss_end__;\r\n        extern uint32_t __data_start__;\r\n        extern uint32_t __data_end__;\r\n        extern uint32_t __customSection_start__;\r\n        extern uint32_t __customSection_end__;\r\n        extern uint32_t __code_ram_start__;\r\n        extern uint32_t __code_ram_end__;\r\n    #endif\r\n#endif\r\n\r\n#if (defined(__ICCARM__))\r\n    #pragma section = \".data\"\r\n    #pragma section = \".data_init\"\r\n    #pragma section = \".bss\"\r\n    #pragma section = \".intvec\"\r\n    #pragma section = \".customSection\"\r\n    #pragma section = \".customSection_init\"\r\n    #pragma section = \"__CODE_RAM\"\r\n    #pragma section = \"__CODE_ROM\"\r\n#endif\r\n\r\n/*!\r\n * @brief Make necessary initializations for RAM.\r\n *\r\n * - Copy initialized data from ROM to RAM.\r\n * - Clear the zero-initialized data section.\r\n * - Copy the vector table from ROM to RAM. This could be an option.  \r\n */\r\nvoid init_data_bss(void);\r\n\r\n#endif /* STARTUP_H*/\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n\r\n"},{"name":"status.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2016, Freescale Semiconductor, Inc.\r\n * Copyright 2016-2020 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n#ifndef STATUS_H\r\n#define STATUS_H\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.3, Global typedef not referenced.\r\n * status_t is referenced from all drivers.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 2.5, Local macro not referenced.\r\n * The defined macro is used as include guard.\r\n *\r\n */\r\n\r\n/*******************************************************************************\r\n * Definitions\r\n ******************************************************************************/\r\n\r\n/*! @brief Status return codes.\r\n * Common error codes will be a unified enumeration (C enum) that will contain all error codes\r\n * (common and specific). There will be separate \"error values spaces\" (or slots), each of 256\r\n * positions, allocated per functionality.\r\n */\r\ntypedef enum\r\n{\r\n    /* Generic error codes */\r\n    STATUS_SUCCESS                         = 0x000U,    /*!< Generic operation success status */\r\n    STATUS_ERROR                           = 0x001U,    /*!< Generic operation failure status */\r\n    STATUS_BUSY                            = 0x002U,    /*!< Generic operation busy status */\r\n    STATUS_TIMEOUT                         = 0x003U,    /*!< Generic operation timeout status */\r\n    STATUS_UNSUPPORTED                     = 0x004U,    /*!< Generic operation unsupported status */\r\n    /* MCU specific error codes */\r\n    STATUS_MCU_GATED_OFF                   = 0x100U,  /*!< Module is gated off */\r\n    STATUS_MCU_TRANSITION_FAILED           = 0x101U,  /*!< Error occurs during transition. */\r\n    STATUS_MCU_INVALID_STATE               = 0x102U,  /*!< Unsupported in current state. */\r\n    STATUS_MCU_NOTIFY_BEFORE_ERROR         = 0x103U,  /*!< Error occurs during send \"BEFORE\" notification. */\r\n    STATUS_MCU_NOTIFY_AFTER_ERROR          = 0x104U,  /*!< Error occurs during send \"AFTER\" notification. */\r\n    /* I2C specific error codes */\r\n    STATUS_I2C_RECEIVED_NACK               = 0x200U,  /*!< NACK signal received  */\r\n    STATUS_I2C_TX_UNDERRUN                 = 0x201U,  /*!< TX underrun error */\r\n    STATUS_I2C_RX_OVERRUN                  = 0x202U,  /*!< RX overrun error */\r\n    STATUS_I2C_ARBITRATION_LOST            = 0x203U,  /*!< Arbitration lost */\r\n    STATUS_I2C_ABORTED                     = 0x204U,  /*!< A transfer was aborted */\r\n    STATUS_I2C_BUS_BUSY                    = 0x205U,  /*!< I2C bus is busy, cannot start transfer */\r\n    /* CAN specific error codes */\r\n    STATUS_CAN_BUFF_OUT_OF_RANGE           = 0x300U,  /*!< The specified MB index is out of the configurable range */\r\n    STATUS_CAN_NO_TRANSFER_IN_PROGRESS     = 0x301U,  /*!< There is no transmission or reception in progress */\r\n    /* Security specific error codes */\r\n    STATUS_SEC_SEQUENCE_ERROR              = 0x402U,  /*!< The sequence of commands or subcommands is out of\r\n                                                            sequence */\r\n    STATUS_SEC_KEY_NOT_AVAILABLE           = 0x403U,  /*!< A key is locked due to failed boot measurement or\r\n                                                            an active debugger */\r\n    STATUS_SEC_KEY_INVALID                 = 0x404U,  /*!< A function is called to perform an operation with\r\n                                                            a key that is not allowed for the given operation */\r\n    STATUS_SEC_KEY_EMPTY                   = 0x405U,  /*!< Attempt to use a key that has not been initialized yet */\r\n    STATUS_SEC_NO_SECURE_BOOT              = 0x406U,  /*!< The conditions for a secure boot process are not met */\r\n    STATUS_SEC_KEY_WRITE_PROTECTED         = 0x407U,  /*!< Request for updating a write protected key slot,\r\n                                                            or activating debugger with write protected key(s) */\r\n    STATUS_SEC_KEY_UPDATE_ERROR            = 0x408U,  /*!< Key update did not succeed due to errors in\r\n                                                            verification of the messages */\r\n    STATUS_SEC_RNG_SEED                    = 0x409U,  /*!< Returned by CMD_RND and CMD_DEBUG if the seed has not\r\n                                                            been initialized before */\r\n    STATUS_SEC_NO_DEBUGGING                = 0x40AU,  /*!< DEBUG command authentication failed */\r\n    STATUS_SEC_MEMORY_FAILURE              = 0x40CU,  /*!< General memory technology failure\r\n                                                            (multibit ECC error, common fault detected) */\r\n    STATUS_SEC_HSM_INTERNAL_MEMORY_ERROR   = 0x410U,  /*!< An internal memory error encountered while\r\n                                                           executing the command */\r\n    STATUS_SEC_INVALID_COMMAND             = 0x411U,  /*!< Command value out of range */\r\n    STATUS_SEC_TRNG_ERROR                  = 0x412U,  /*!< One or more statistical tests run on the TRNG output failed */\r\n    STATUS_SEC_HSM_FLASH_BLOCK_ERROR       = 0x413U,  /*!< Error reading, programming or erasing one of the HSM flash blocks */\r\n    STATUS_SEC_INTERNAL_CMD_ERROR          = 0x414U,  /*!< An internal command processor error while executing a command */\r\n    STATUS_SEC_MAC_LENGTH_ERROR            = 0x415U,  /*!< MAC/Message length out of range */\r\n    STATUS_SEC_INVALID_ARG                 = 0x421U,  /*!< Invalid command argument */\r\n    STATUS_SEC_TRNG_CLOCK_ERROR            = 0x423U,  /*!< TRNG not provided with a stable clock */\r\n    /* SPI specific error codes */\r\n    STATUS_SPI_TX_UNDERRUN                 = 0x500U,  /*!< TX underrun error */\r\n    STATUS_SPI_RX_OVERRUN                  = 0x501U,  /*!< RX overrun error */\r\n    STATUS_SPI_ABORTED                     = 0x502U,  /*!< A transfer was aborted */\r\n    /* UART specific error codes */\r\n    STATUS_UART_TX_UNDERRUN                = 0x600U,  /*!< TX underrun error */\r\n    STATUS_UART_RX_OVERRUN                 = 0x601U,  /*!< RX overrun error */\r\n    STATUS_UART_ABORTED                    = 0x602U,  /*!< A transfer was aborted */\r\n\tSTATUS_UART_FRAMING_ERROR              = 0x603U,  /*!< Framing error */\r\n\tSTATUS_UART_PARITY_ERROR               = 0x604U,  /*!< Parity error */\r\n\tSTATUS_UART_NOISE_ERROR                = 0x605U,  /*!< Noise error */\r\n    /* I2S specific error codes */\r\n    STATUS_I2S_TX_UNDERRUN                 = 0x700U,  /*!< TX underrun error */\r\n    STATUS_I2S_RX_OVERRUN                  = 0x701U,  /*!< RX overrun error */\r\n    STATUS_I2S_ABORTED                     = 0x702U,  /*!< A transfer was aborted */\r\n    /* SBC specific error codes */\r\n    SBC_NVN_ERROR                          = 0x801U, /*!< Unsuccessful attempt writing to non volatile memory\r\n                                                          (0x73 and 0x74). Set device to factory settings. */\r\n    SBC_COMM_ERROR                         = 0x802U, /*!< Data transfer was aborted */\r\n    SBC_CMD_ERROR                          = 0x804U, /*!< Wrong command. */\r\n    SBC_ERR_NA                             = 0x808U, /*!< Feature/device not available */\r\n    SBC_MTPNV_LOCKED                       = 0x810U, /*!< Unable to write MTPNV cells, NVMPS = 0 */\r\n\r\n    /* FLASH specific error codes */\r\n    STATUS_FLASH_ERROR_ENABLE              = 0x901U, /*!< It's impossible to enable an operation */\r\n    STATUS_FLASH_ERROR_NO_BLOCK            = 0x902U, /*!< No blocks have been enabled for Array Integrity check */\r\n    STATUS_FLASH_INPROGRESS                = 0x903U, /*!< InProgress status */\r\n\r\n    /* SAI specific error codes */\r\n    STATUS_SAI_ABORTED                     = 0xA00U, /*!< SAI aborted status */\r\n\r\n    /* ENET specific error codes */\r\n    STATUS_ENET_RX_QUEUE_EMPTY             = 0xA01U, /*!< There is no available frame in the receive queue */\r\n    STATUS_ENET_TX_QUEUE_FULL              = 0xA02U, /*!< There is no available space for the frame in the transmit queue */\r\n    STATUS_ENET_BUFF_NOT_FOUND             = 0xA03U, /*!< The specified buffer was not found in the queue */\r\n\r\n    /* FCCU specific error codes */\r\n    STATUS_FCCU_ERROR_CONFIG_TIMEOUT       = 0xB01U, /*!< FCCU triggers TimeOut when try to enter in Config State */\r\n    STATUS_FCCU_ERROR_INIT_FCCU            = 0xB02U, /*!< FCCU Initializing FCCU Module */\r\n    STATUS_FCCU_ERROR_SET_CONFIG           = 0xB03U, /*!< FCCU Fail to Enter in Config Mode  */\r\n    STATUS_FCCU_ERROR_SET_NORMAL           = 0xB04U, /*!< FCCU Fail to Enter in Normal Mode  */\r\n    STATUS_FCCU_ERROR_APPLY_NCF_CONFIG     = 0xB05U, /*!< FCCU Fail to set NoCritical Faults  */\r\n    STATUS_FCCU_ERROR_UPDATE_FREEZE        = 0xB06U, /*!< FCCU Fail to update Freez Status registers */\r\n    STATUS_FCCU_ERROR_CLEAR_FREEZE         = 0xB07U, /*!< FCCU Fail to Clear Freez Status registers */\r\n    STATUS_FCCU_ERROR_SET_EOUT             = 0xB08U, /*!< FCCU Fail to Set Eout Configuration */\r\n    STATUS_FCCU_ERROR_FAULT_DETECTED       = 0xB09U, /*!< FCCU Faults Detected */\r\n    STATUS_FCCU_ERROR_OTHER                = 0xB0AU, /*!< FCCU other Error */\r\n\r\n    /* EMIOS specific error codes */\r\n    STATUS_EMIOS_WRONG_MODE                = 0xC00U,   /*!< EMIOS unsuccessful attempt selecting wrong mode. */\r\n    STATUS_EMIOS_CNT_BUS_OVERFLOW          = 0xC01U,   /*!< EMIOS counter bus overflow. */\r\n    STATUS_EMIOS_WRONG_CNT_BUS             = 0xC02U,   /*!< EMIOS unsuccessful attempt selecting wrong counter bus. */\r\n    STATUS_EMIOS_ENABLE_GLOBAL_FRZ         = 0xC03U,   /*!< EMIOS must set global allow enter debug mode first. */\r\n\r\n    /* EEE specific error codes */\r\n    STATUS_EEE_ERROR_NO_ENOUGH_SPACE       = 0xD00U, /*!< The data is too big to fit in any of the block */\r\n    STATUS_EEE_ERROR_NO_ENOUGH_BLOCK       = 0xD01U, /*!< The block numbers is not enough for round robin */\r\n    STATUS_EEE_ERROR_DATA_NOT_FOUND        = 0xD02U, /*!< The required data is not found in the EEPROM emulation */\r\n    STATUS_EEE_ERROR_NOT_IN_CACHE          = 0xD03U, /*!< The required data is not in the cache table */\r\n    STATUS_EEE_ERROR_PROGRAM_INDICATOR     = 0xD04U, /*!< Failed to make block indicator to non-blank for several times */\r\n    STATUS_EEE_HVOP_INPROGRESS             = 0xD05U, /*!< The high voltage operation is in progress */\r\n\r\n    /* uSDHC specific error codes */\r\n    STATUS_USDHC_OUT_OF_RANGE              = 0xE00U,    /*!< The size of data to be sent is larger than maximum size of ADMA table */\r\n    STATUS_USDHC_PREPARE_ADMA_FAILED       = 0xE01U,    /*!< Failed to prepare the ADMA table */\r\n\r\n    /* TDM specific error codes */\r\n    STATUS_TDM_DIARY_FULL                  = 0xF01U, /*!< No empty flash left in diary region */\r\n\r\n    /* PHY specific error codes */\r\n    STATUS_PHY_ACCESS_FAILED               = 0x1001U, /*!< Could not access PHY registers */\r\n    STATUS_PHY_INCOMPATIBLE_DEVICE         = 0x1002U  /*!< The selected PHY driver is not compatible with the device */\r\n} status_t;\r\n\r\n#endif /* STATUS_H */\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"system_S32K144.c","type":"source","group":"legacy","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015 Freescale Semiconductor, Inc.\r\n * Copyright 2016-2017 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n/**\r\n * @page misra_violations MISRA-C:2012 violations\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.9, An object should be defined at block\r\n * scope if its identifier only appears in a single function.\r\n * An object with static storage duration declared at block scope cannot be\r\n * accessed directly from outside the block.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 11.4, A conversion should not be performed\r\n * between a pointer to object and an integer type.\r\n * The cast is required to initialize a pointer with an unsigned int define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Required Rule 11.6, A cast shall not be performed\r\n * between pointer to void and an arithmetic type.\r\n * The cast is required to initialize a pointer with an unsigned int define,\r\n * representing an address.\r\n *\r\n * @section [global]\r\n * Violates MISRA 2012 Advisory Rule 8.7, External could be made static.\r\n * Function is defined for usage by application code.\r\n *\r\n */\r\n\r\n#include \"device_registers.h\"\r\n#include \"system_S32K144.h\"\r\n#include \"stdbool.h\"\r\n\r\n/* ----------------------------------------------------------------------------\r\n   -- Core clock\r\n   ---------------------------------------------------------------------------- */\r\n\r\nuint32_t SystemCoreClock = DEFAULT_SYSTEM_CLOCK;\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SystemInit\r\n * Description   : This function disables the watchdog, enables FPU\r\n * and the power mode protection if the corresponding feature macro\r\n * is enabled. SystemInit is called from startup_device file.\r\n *\r\n * Implements    : SystemInit_Activity\r\n *END**************************************************************************/\r\nvoid SystemInit(void)\r\n{\r\n/**************************************************************************/\r\n                      /* FPU ENABLE*/\r\n/**************************************************************************/\r\n#ifdef ENABLE_FPU\r\n  /* Enable CP10 and CP11 coprocessors */\r\n  S32_SCB->CPACR |= (S32_SCB_CPACR_CP10_MASK | S32_SCB_CPACR_CP11_MASK);\r\n#ifdef  ERRATA_E6940\r\n  /* Disable lazy context save of floating point state by clearing LSPEN bit\r\n   * Workaround for errata e6940 */\r\n  S32_SCB->FPCCR &= ~(S32_SCB_FPCCR_LSPEN_MASK);\r\n#endif\r\n#endif /* ENABLE_FPU */\r\n\r\n/**************************************************************************/\r\n                      /* WDOG DISABLE*/\r\n/**************************************************************************/\r\n  \r\n#if (DISABLE_WDOG)\r\n  /* Write of the WDOG unlock key to CNT register, must be done in order to allow any modifications*/\r\n  WDOG->CNT = (uint32_t ) FEATURE_WDOG_UNLOCK_VALUE;\r\n  /* The dummy read is used in order to make sure that the WDOG registers will be configured only \r\n   * after the write of the unlock value was completed. */\r\n  (void)WDOG->CNT;\r\n\r\n  /* Initial write of WDOG configuration register:\r\n   * enables support for 32-bit refresh/unlock command write words,\r\n   * clock select from LPO, update enable, watchdog disabled */\r\n  WDOG->CS  = (uint32_t ) ( (1UL << WDOG_CS_CMD32EN_SHIFT)                       |\r\n                            (FEATURE_WDOG_CLK_FROM_LPO << WDOG_CS_CLK_SHIFT)     |\r\n                            (0U << WDOG_CS_EN_SHIFT)                             |\r\n                            (1U << WDOG_CS_UPDATE_SHIFT)                         );\r\n                            \r\n  /* Configure timeout */\r\n  WDOG->TOVAL = (uint32_t )0xFFFF;\r\n#endif /* (DISABLE_WDOG) */\r\n\r\n/**************************************************************************/\r\n            /* ENABLE CACHE */\r\n/**************************************************************************/\r\n#if defined(I_CACHE) && (ICACHE_ENABLE == 1)\r\n  /* Invalidate and enable code cache */\r\n  LMEM->PCCCR = LMEM_PCCCR_INVW0(1) | LMEM_PCCCR_INVW1(1) | LMEM_PCCCR_GO(1) | LMEM_PCCCR_ENCACHE(1);\r\n#endif /* defined(I_CACHE) && (ICACHE_ENABLE == 1) */\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SystemCoreClockUpdate\r\n * Description   : This function must be called whenever the core clock is changed\r\n * during program execution. It evaluates the clock register settings and calculates\r\n * the current core clock.\r\n *\r\n * Implements    : SystemCoreClockUpdate_Activity\r\n *END**************************************************************************/\r\nvoid SystemCoreClockUpdate(void)\r\n{\r\n  uint32_t SCGOUTClock = 0U;      /* Variable to store output clock frequency of the SCG module */\r\n  uint32_t regValue;              /* Temporary variable */\r\n  uint32_t divider, prediv, multi;\r\n  bool validSystemClockSource = true;\r\n  static const uint32_t fircFreq[] = {\r\n      FEATURE_SCG_FIRC_FREQ0,\r\n  };\r\n  \r\n  divider = ((SCG->CSR & SCG_CSR_DIVCORE_MASK) >> SCG_CSR_DIVCORE_SHIFT) + 1U;\r\n\r\n  switch ((SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) {\r\n    case 0x1:\r\n      /* System OSC */\r\n      SCGOUTClock = CPU_XTAL_CLK_HZ;\r\n      break;\r\n    case 0x2:\r\n      /* Slow IRC */\r\n      regValue = (SCG->SIRCCFG & SCG_SIRCCFG_RANGE_MASK) >> SCG_SIRCCFG_RANGE_SHIFT;\r\n\t  \r\n      if (regValue != 0U)\r\n      {\r\n        SCGOUTClock = FEATURE_SCG_SIRC_HIGH_RANGE_FREQ;\r\n      }\r\n\r\n      break;\r\n    case 0x3:\r\n      /* Fast IRC */\r\n      regValue = (SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;\r\n      SCGOUTClock= fircFreq[regValue];\r\n      break;\r\n    case 0x6:\r\n      /* System PLL */\r\n      SCGOUTClock = CPU_XTAL_CLK_HZ;\r\n      prediv = ((SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT) + 1U;\r\n      multi = ((SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT) + 16U;\r\n      SCGOUTClock = SCGOUTClock * multi / (prediv * 2U);\r\n      break;\r\n    default:\r\n      validSystemClockSource = false;\r\n      break;\r\n  }\r\n\r\n  if (validSystemClockSource == true) {\r\n     SystemCoreClock = (SCGOUTClock / divider);\r\n  }\r\n}\r\n\r\n/*FUNCTION**********************************************************************\r\n *\r\n * Function Name : SystemSoftwareReset\r\n * Description   : This function is used to initiate a system reset\r\n *\r\n * Implements    : SystemSoftwareReset_Activity\r\n *END**************************************************************************/\r\nvoid SystemSoftwareReset(void)\r\n{\r\n    uint32_t regValue;\r\n\r\n    /* Read Application Interrupt and Reset Control Register */\r\n    regValue = S32_SCB->AIRCR;\r\n\r\n    /* Clear register key */\r\n    regValue &= ~( S32_SCB_AIRCR_VECTKEY_MASK);\r\n\r\n    /* Configure System reset request bit and Register Key */\r\n    regValue |= S32_SCB_AIRCR_VECTKEY(FEATURE_SCB_VECTKEY);\r\n    regValue |= S32_SCB_AIRCR_SYSRESETREQ(0x1u);\r\n\r\n    /* Write computed register value */\r\n    S32_SCB->AIRCR = regValue;\r\n}\r\n\r\n/*******************************************************************************\r\n * EOF\r\n ******************************************************************************/\r\n"},{"name":"system_S32K144.h","type":"header","group":"other","path":"N:\\project\\Final_project_template_mbd_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Copyright (c) 2015 Freescale Semiconductor, Inc.\r\n * Copyright 2016-2017 NXP\r\n * All rights reserved.\r\n *\r\n * NXP Confidential. This software is owned or controlled by NXP and may only be\r\n * used strictly in accordance with the applicable license terms. By expressly\r\n * accepting such terms or by downloading, installing, activating and/or otherwise\r\n * using the software, you are agreeing that you have read, and that you agree to\r\n * comply with and are bound by, such license terms. If you do not agree to be\r\n * bound by the applicable license terms, then you may not retain, install,\r\n * activate or otherwise use the software. The production use license in\r\n * Section 2.3 is expressly granted for this software.\r\n */\r\n\r\n\r\n/*! @addtogroup soc_support_S32K144*/\r\n/*! @{*/\r\n\r\n/*!\r\n * @file system_S32K144.h\r\n * @brief Device specific configuration file for S32K144\r\n */\r\n\r\n#ifndef SYSTEM_S32K144_H_\r\n#define SYSTEM_S32K144_H_                        /**< Symbol preventing repeated inclusion */\r\n\r\n#include <stdint.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/******************************************************************************\r\n * CPU Settings.\r\n *****************************************************************************/\r\n\r\n/* Watchdog disable */\r\n#ifndef DISABLE_WDOG\r\n  #define DISABLE_WDOG                 1\r\n#endif\r\n\r\n/* Cache enablement  */\r\n#ifndef ICACHE_ENABLE\r\n#define ICACHE_ENABLE                  0\r\n#endif\r\n\r\n/* Value of the external crystal or oscillator clock frequency in Hz */\r\n#ifndef CPU_XTAL_CLK_HZ\r\n  #define CPU_XTAL_CLK_HZ                8000000u\r\n#endif\r\n\r\n/* Value of the fast internal oscillator clock frequency in Hz  */\r\n#ifndef CPU_INT_FAST_CLK_HZ\r\n  #define CPU_INT_FAST_CLK_HZ            48000000u\r\n#endif\r\n\r\n/* Default System clock value */\r\n#ifndef DEFAULT_SYSTEM_CLOCK\r\n #define DEFAULT_SYSTEM_CLOCK            48000000u\r\n#endif\r\n\r\n/**\r\n * @brief System clock frequency (core clock)\r\n *\r\n * The system clock frequency supplied to the SysTick timer and the processor\r\n * core clock. This variable can be used by the user application to setup the\r\n * SysTick timer or configure other parameters. It may also be used by debugger to\r\n * query the frequency of the debug timer or configure the trace clock speed\r\n * SystemCoreClock is initialized with a correct predefined value.\r\n */\r\nextern uint32_t SystemCoreClock;\r\n\r\n/**\r\n * @brief Setup the SoC.\r\n *\r\n * This function disables the watchdog, enables FPU.\r\n * if the corresponding feature macro is enabled.\r\n * SystemInit is called from startup_device file.\r\n */\r\nvoid SystemInit(void);\r\n\r\n/**\r\n * @brief Updates the SystemCoreClock variable.\r\n *\r\n * It must be called whenever the core clock is changed during program\r\n * execution. SystemCoreClockUpdate() evaluates the clock register settings and calculates\r\n * the current core clock.\r\n * This function must be called when user does not want to use clock manager component.\r\n * If clock manager is used, the CLOCK_SYS_GetFreq function must be used with CORE_CLOCK\r\n * parameter.\r\n *\r\n */\r\nvoid SystemCoreClockUpdate(void);\r\n\r\n/**\r\n * @brief Initiates a system reset.\r\n *\r\n * This function is used to initiate a system reset\r\n */\r\nvoid SystemSoftwareReset(void);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n/*! @}*/\r\n#endif  /* #if !defined(SYSTEM_S32K144_H_) */\r\n"}],"trace":"{\"model\":\"Final_project_template\",\"sources\":[\"Final_project_template.c\",\"Final_project_template.h\",\"fcan0_s32k_rx_isr.c\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\",\"BlockName\"],\"categoricalValues\":[\"InternalData\",\"Default\",\"\\u003cS2\\u003e/s,n,psi,us (Cars 1-6)\",\"Constants\"],\"sidPrefixes\":[\"Final_project_template\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[74,31,74,32],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[75,1,75,2],\"els\":[\"1:2604\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[75,3,75,32],\"els\":[\"1:2604\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[75,32,75,33],\"els\":[\"1:2604\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[78,1,78,8],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[78,9,78,15],\"els\":[\"1:2604\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[79,31,79,32],\"els\":[\"1:2610\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[80,1,80,2],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[80,3,80,32],\"els\":[\"1:2610\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[80,32,80,33],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[83,1,83,8],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[83,9,83,15],\"els\":[\"1:2610\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[85,21,85,22],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[86,3,86,11],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[86,12,86,26],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[86,26,86,27],\"els\":[\"1:2899\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[86,27,86,29],\"els\":[\"1:2899\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[86,29,86,30],\"els\":[\"1:2899\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[86,30,86,31],\"els\":[\"1:14\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[87,3,87,11],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[87,12,87,25],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[87,25,87,26],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[87,26,87,28],\"els\":[\"1:14\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[87,28,87,29],\"els\":[\"1:14\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[87,29,87,30],\"ct\":{\"0\":0,\"1\":1,\"2\":2}},{\"tk\":[88,3,88,11],\"ct\":{\"0\":0,\"1\":1,\"2\":2}},{\"tk\":[88,12,88,43],\"ct\":{\"0\":0,\"1\":1,\"2\":2}},{\"tk\":[88,43,88,44],\"ct\":{\"0\":0,\"1\":1,\"2\":2}},{\"tk\":[88,44,88,46],\"ct\":{\"2\":2,\"1\":1,\"0\":0}},{\"tk\":[88,46,88,47],\"ct\":{\"0\":0,\"1\":1,\"2\":2}},{\"tk\":[88,47,88,48],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[89,3,89,11],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[89,12,89,31],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[89,31,89,32],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[90,3,90,11],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[90,12,90,31],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[90,31,90,32],\"els\":[\"1:3185\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[91,3,91,11],\"els\":[\"1:3185\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[91,12,91,17],\"els\":[\"1:3185\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[91,17,91,18],\"els\":[\"1:3185\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[92,3,92,11],\"els\":[\"1:3185\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[92,12,92,16],\"els\":[\"1:3185\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[92,16,92,17],\"els\":[\"1:3199\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[93,3,93,11],\"els\":[\"1:3199\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[93,12,93,21],\"els\":[\"1:3199\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[93,21,93,22],\"els\":[\"1:62\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[94,3,94,11],\"els\":[\"1:62\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[94,12,94,22],\"els\":[\"1:62\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[94,22,94,23],\"els\":[\"1:3062:44\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[95,3,95,11],\"els\":[\"1:3062:44\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[95,12,95,22],\"els\":[\"1:3062:44\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[95,22,95,23],\"els\":[\"1:3062:28\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[96,3,96,11],\"els\":[\"1:3062:28\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[96,12,96,32],\"els\":[\"1:3062:28\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[96,32,96,33],\"els\":[\"1:3062:28\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[97,3,97,11],\"els\":[\"1:3062:28\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[97,12,97,32],\"els\":[\"1:3062:28\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[97,32,97,33],\"els\":[\"1:3062:29\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[98,3,98,11],\"els\":[\"1:3062:29\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[98,12,98,16],\"els\":[\"1:3062:29\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[98,16,98,17],\"els\":[\"1:3062:29\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[99,3,99,11],\"els\":[\"1:3062:29\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[99,12,99,33],\"els\":[\"1:3062:29\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[99,33,99,34],\"els\":[\"1:3062:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[100,3,100,11],\"els\":[\"1:3062:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[100,12,100,33],\"els\":[\"1:3062:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[100,33,100,34],\"els\":[\"1:1016:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[101,3,101,11],\"els\":[\"1:1016:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[101,12,101,23],\"els\":[\"1:1016:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[101,23,101,24],\"els\":[\"1:1016:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[102,3,102,11],\"els\":[\"1:1016:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[102,12,102,23],\"els\":[\"1:1016:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[102,23,102,24],\"els\":[\"1:1016:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[103,3,103,11],\"els\":[\"1:1016:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[103,12,103,35],\"els\":[\"1:1016:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[103,35,103,36],\"els\":[\"1:1016:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[104,3,104,11],\"els\":[\"1:1016:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[104,12,104,35],\"els\":[\"1:1016:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[104,35,104,36],\"els\":[\"1:977:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[105,3,105,11],\"els\":[\"1:977:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[105,12,105,25],\"els\":[\"1:977:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[105,25,105,26],\"els\":[\"1:977:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[106,3,106,11],\"els\":[\"1:977:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[106,12,106,25],\"els\":[\"1:977:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[106,25,106,26],\"els\":[\"1:977:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[107,3,107,11],\"els\":[\"1:977:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[107,12,107,35],\"els\":[\"1:977:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[107,35,107,36],\"els\":[\"1:977:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[108,3,108,11],\"els\":[\"1:977:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[108,12,108,35],\"els\":[\"1:977:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[108,35,108,36],\"els\":[\"1:983:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[109,3,109,11],\"els\":[\"1:983:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[109,12,109,25],\"els\":[\"1:983:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[109,25,109,26],\"els\":[\"1:983:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[110,3,110,11],\"els\":[\"1:983:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[110,12,110,25],\"els\":[\"1:983:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[110,25,110,26],\"els\":[\"1:983:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[111,3,111,11],\"els\":[\"1:983:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[111,12,111,35],\"els\":[\"1:983:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[111,35,111,36],\"els\":[\"1:983:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[112,3,112,11],\"els\":[\"1:983:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[112,12,112,35],\"els\":[\"1:983:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[112,35,112,36],\"els\":[\"1:990:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[113,3,113,11],\"els\":[\"1:990:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[113,12,113,26],\"els\":[\"1:990:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[113,26,113,27],\"els\":[\"1:990:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[114,3,114,11],\"els\":[\"1:990:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[114,12,114,26],\"els\":[\"1:990:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[114,26,114,27],\"els\":[\"1:990:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[115,3,115,11],\"els\":[\"1:990:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[115,12,115,35],\"els\":[\"1:990:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[115,35,115,36],\"els\":[\"1:990:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[116,3,116,11],\"els\":[\"1:990:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[116,12,116,35],\"els\":[\"1:990:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[116,35,116,36],\"els\":[\"1:997:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[117,3,117,11],\"els\":[\"1:997:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[117,12,117,25],\"els\":[\"1:997:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[117,25,117,26],\"els\":[\"1:997:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[118,3,118,11],\"els\":[\"1:997:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[118,12,118,25],\"els\":[\"1:997:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[118,25,118,26],\"els\":[\"1:997:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[119,3,119,11],\"els\":[\"1:997:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[119,12,119,36],\"els\":[\"1:997:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[119,36,119,37],\"els\":[\"1:997:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[120,3,120,11],\"els\":[\"1:997:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[120,12,120,35],\"els\":[\"1:997:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[120,35,120,36],\"els\":[\"1:1004:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[121,3,121,11],\"els\":[\"1:1004:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[121,12,121,25],\"els\":[\"1:1004:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[121,25,121,26],\"els\":[\"1:1004:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[122,3,122,11],\"els\":[\"1:1004:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[122,12,122,25],\"els\":[\"1:1004:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[122,25,122,26],\"els\":[\"1:1004:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[123,3,123,11],\"els\":[\"1:1004:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[123,12,123,36],\"els\":[\"1:1004:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[123,36,123,37],\"els\":[\"1:1004:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[124,3,124,11],\"els\":[\"1:1004:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[124,12,124,35],\"els\":[\"1:1004:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[124,35,124,36],\"els\":[\"1:1011:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[125,3,125,11],\"els\":[\"1:1011:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[125,12,125,25],\"els\":[\"1:1011:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[125,25,125,26],\"els\":[\"1:1011:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[126,3,126,11],\"els\":[\"1:1011:64\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[126,12,126,25],\"els\":[\"1:1011:64\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[126,25,126,26],\"els\":[\"1:1011:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[127,3,127,11],\"els\":[\"1:1011:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[127,12,127,34],\"els\":[\"1:1011:63\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[127,34,127,35],\"els\":[\"1:1011:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[128,3,128,11],\"els\":[\"1:1011:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[128,12,128,34],\"els\":[\"1:1011:63\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[128,34,128,35],\"els\":[\"1:3063:5\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[129,3,129,11],\"els\":[\"1:3063:5\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[129,12,129,20],\"els\":[\"1:3063:5\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[129,20,129,21],\"els\":[\"1:3063:5\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[130,3,130,11],\"els\":[\"1:3063:5\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[130,12,130,22],\"els\":[\"1:3063:5\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[130,22,130,23],\"els\":[\"1:3103\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[131,3,131,11],\"els\":[\"1:3103\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[131,12,131,34],\"els\":[\"1:3103\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[131,34,131,35],\"els\":[\"1:2909\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[132,3,132,11],\"els\":[\"1:2909\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[132,12,132,35],\"els\":[\"1:2909\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[132,35,132,36],\"els\":[\"1:3062:33\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[133,3,133,11],\"els\":[\"1:3062:33\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[133,12,133,34],\"els\":[\"1:3062:33\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[133,34,133,35],\"els\":[\"1:3062:33\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[134,3,134,11],\"els\":[\"1:3062:33\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[134,12,134,35],\"els\":[\"1:3062:33\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[134,35,134,36],\"els\":[\"1:3035\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[135,3,135,11],\"els\":[\"1:3035\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[135,12,135,33],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[135,33,135,34],\"els\":[\"1:3054\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[136,3,136,11],\"els\":[\"1:3054\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[136,12,136,33],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[136,33,136,34],\"els\":[\"1:3044\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[137,3,137,11],\"els\":[\"1:3044\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[137,12,137,31],\"els\":[\"1:3044\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[137,31,137,32],\"els\":[\"1:3044\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[138,3,138,11],\"els\":[\"1:3044\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[138,12,138,28],\"els\":[\"1:3044\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[138,28,138,29],\"els\":[\"1:3044\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[139,3,139,11],\"els\":[\"1:3044\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[139,12,139,28],\"els\":[\"1:3044\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[139,28,139,29],\"els\":[\"1:2710\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[140,3,140,11],\"els\":[\"1:2710\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[140,12,140,30],\"els\":[\"1:2710\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[140,30,140,31],\"els\":[\"1:2710\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[141,3,141,11],\"els\":[\"1:2710\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[141,12,141,30],\"els\":[\"1:2710\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[141,30,141,31],\"els\":[\"1:2704\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[142,3,142,11],\"els\":[\"1:2704\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[142,12,142,31],\"els\":[\"1:2704\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[142,31,142,32],\"els\":[\"1:2704\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[143,3,143,11],\"els\":[\"1:2704\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[143,12,143,30],\"els\":[\"1:2704\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[143,30,143,31],\"els\":[\"1:2690\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[144,3,144,11],\"els\":[\"1:2690\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[144,12,144,30],\"els\":[\"1:2690\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[144,30,144,31],\"els\":[\"1:2690\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[145,3,145,11],\"els\":[\"1:2690\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[145,12,145,30],\"els\":[\"1:2690\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[145,30,145,31],\"els\":[\"1:2684\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[146,3,146,11],\"els\":[\"1:2684\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[146,12,146,30],\"els\":[\"1:2684\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[146,30,146,31],\"els\":[\"1:2684\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[147,3,147,11],\"els\":[\"1:2684\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[147,12,147,30],\"els\":[\"1:2684\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[147,30,147,31],\"els\":[\"1:2670\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[148,3,148,11],\"els\":[\"1:2670\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[148,12,148,31],\"els\":[\"1:2670\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[148,31,148,32],\"els\":[\"1:2670\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[149,3,149,11],\"els\":[\"1:2670\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[149,12,149,30],\"els\":[\"1:2670\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[149,30,149,31],\"els\":[\"1:2664\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[150,3,150,11],\"els\":[\"1:2664\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[150,12,150,30],\"els\":[\"1:2664\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[150,30,150,31],\"els\":[\"1:2664\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[151,3,151,11],\"els\":[\"1:2664\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[151,12,151,31],\"els\":[\"1:2664\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[151,31,151,32],\"els\":[\"1:2650\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[152,3,152,11],\"els\":[\"1:2650\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[152,12,152,30],\"els\":[\"1:2650\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[152,30,152,31],\"els\":[\"1:2650\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[153,3,153,11],\"els\":[\"1:2650\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[153,12,153,30],\"els\":[\"1:2650\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[153,30,153,31],\"els\":[\"1:2644\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[154,3,154,11],\"els\":[\"1:2644\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[154,12,154,31],\"els\":[\"1:2644\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[154,31,154,32],\"els\":[\"1:2644\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[155,3,155,11],\"els\":[\"1:2644\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[155,12,155,30],\"els\":[\"1:2644\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[155,30,155,31],\"els\":[\"1:2630\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[156,3,156,11],\"els\":[\"1:2630\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[156,12,156,31],\"els\":[\"1:2630\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[156,31,156,32],\"els\":[\"1:2630\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[157,3,157,11],\"els\":[\"1:2630\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[157,12,157,30],\"els\":[\"1:2630\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[157,30,157,31],\"els\":[\"1:2624\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[158,3,158,11],\"els\":[\"1:2624\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[158,12,158,30],\"els\":[\"1:2624\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[158,30,158,31],\"els\":[\"1:2624\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[159,3,159,11],\"els\":[\"1:2624\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[159,12,159,31],\"els\":[\"1:2624\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[159,31,159,32],\"els\":[\"1:2610\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[160,3,160,11],\"els\":[\"1:2610\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[160,12,160,30],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[160,30,160,31],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[161,3,161,11],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[161,12,161,30],\"els\":[\"1:2610\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[161,30,161,31],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[162,3,162,11],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[162,12,162,23],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[162,23,162,24],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[163,3,163,11],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[163,12,163,33],\"els\":[\"1:2604\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[163,33,163,34],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[164,3,164,10],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[164,11,164,14],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[164,14,164,15],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[164,15,164,17],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[164,17,164,18],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[164,18,164,19],\"els\":[\"1:2752\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[165,3,165,10],\"els\":[\"1:2752\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[165,11,165,22],\"els\":[\"1:2752\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[165,22,165,23],\"els\":[\"1:2752\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[166,3,166,10],\"els\":[\"1:2752\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[166,11,166,22],\"els\":[\"1:2752\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[166,22,166,23],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[166,23,166,24],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[166,24,166,25],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[166,25,166,26],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[167,3,167,10],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[167,11,167,22],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[167,22,167,23],\"els\":[\"1:2717\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[168,3,168,10],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[168,11,168,22],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[168,22,168,23],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[169,3,169,10],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[169,11,169,22],\"els\":[\"1:2717\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[169,22,169,23],\"els\":[\"1:2768\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[169,23,169,25],\"els\":[\"1:2768\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[169,25,169,26],\"els\":[\"1:2768\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[169,26,169,27],\"els\":[\"1:2756\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[170,3,170,10],\"els\":[\"1:2756\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[170,11,170,20],\"els\":[\"1:2756\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[170,20,170,21],\"els\":[\"1:2756\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[170,21,170,22],\"els\":[\"1:2756\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[170,22,170,23],\"els\":[\"1:2756\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[170,23,170,24],\"els\":[\"1:3107\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[171,3,171,10],\"els\":[\"1:3107\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[171,11,171,19],\"els\":[\"1:3107\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[171,19,171,20],\"els\":[\"1:3107\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[171,20,171,21],\"els\":[\"1:3107\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[171,21,171,22],\"els\":[\"1:3107\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[171,22,171,23],\"els\":[\"1:3106\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[172,3,172,12],\"els\":[\"1:3106\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[172,13,172,17],\"els\":[\"1:3106\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[172,17,172,18],\"els\":[\"1:3106\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[173,3,173,12],\"els\":[\"1:3106\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[173,13,173,26],\"els\":[\"1:3106\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[173,26,173,27],\"els\":[\"1:2751\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[174,3,174,12],\"els\":[\"1:2751\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[174,13,174,28],\"els\":[\"1:2751\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[174,28,174,29],\"els\":[\"1:2777\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[175,3,175,12],\"els\":[\"1:2777\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[175,13,175,27],\"els\":[\"1:2777\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[175,27,175,28],\"els\":[\"1:2781\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[176,3,176,12],\"els\":[\"1:2781\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[176,13,176,27],\"els\":[\"1:2781\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[176,27,176,28],\"els\":[\"1:2782\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[177,3,177,12],\"els\":[\"1:2782\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[177,13,177,27],\"els\":[\"1:2782\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[177,27,177,28],\"els\":[\"1:2783\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[178,3,178,12],\"els\":[\"1:2783\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[178,13,178,27],\"els\":[\"1:2783\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[178,27,178,28],\"els\":[\"1:2784\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[179,3,179,12],\"els\":[\"1:2784\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[179,13,179,27],\"els\":[\"1:2784\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[179,27,179,28],\"els\":[\"1:2785\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[180,3,180,12],\"els\":[\"1:2785\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[180,13,180,27],\"els\":[\"1:2785\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[180,27,180,28],\"els\":[\"1:2786\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[181,3,181,12],\"els\":[\"1:2786\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[181,13,181,27],\"els\":[\"1:2786\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[181,27,181,28],\"els\":[\"1:2787\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[182,3,182,12],\"els\":[\"1:2787\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[182,13,182,34],\"els\":[\"1:2787\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[182,34,182,35],\"els\":[\"1:2788\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[183,3,183,12],\"els\":[\"1:2788\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[183,13,183,34],\"els\":[\"1:2788\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[183,34,183,35],\"els\":[\"1:2883\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[184,3,184,12],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[184,13,184,34],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[184,34,184,35],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[185,3,185,12],\"els\":[\"1:2883\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[185,13,185,29],\"els\":[\"1:2883\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[185,29,185,30],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[186,3,186,12],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[186,13,186,16],\"els\":[\"1:2883\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[186,16,186,17],\"els\":[\"1:2778\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[187,3,187,12],\"els\":[\"1:2778\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[187,13,187,16],\"els\":[\"1:2778\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[187,16,187,17],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[188,3,188,12],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[188,13,188,16],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[188,16,188,17],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[189,1,189,2],\"els\":[\"1:3179\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[189,3,189,4],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[189,4,189,5],\"els\":[\"1:3179\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[192,1,192,8],\"els\":[\"1:3179\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[192,9,192,15],\"els\":[\"1:3179\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[194,27,194,28],\"els\":[\"1:2773\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[195,3,195,11],\"els\":[\"1:2773\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[195,12,195,28],\"els\":[\"1:2773\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[195,28,195,29],\"els\":[\"1:3062:25\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[195,29,195,30],\"els\":[\"1:3062:25\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[195,30,195,31],\"els\":[\"1:3062:25\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[195,31,195,32],\"els\":[\"1:3224\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[196,3,196,11],\"els\":[\"1:3224\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[196,12,196,29],\"els\":[\"1:3224\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[196,29,196,30],\"els\":[\"1:3224\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[197,3,197,11],\"els\":[\"1:3224\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[197,12,197,30],\"els\":[\"1:3224\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[197,30,197,31],\"els\":[\"1:2893\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[198,3,198,11],\"els\":[\"1:2893\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[198,12,198,41],\"els\":[\"1:2893\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[198,41,198,42],\"els\":[\"1:3062:44\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[199,3,199,11],\"els\":[\"1:3062:44\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[199,12,199,42],\"els\":[\"1:3062:44\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[199,42,199,43],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[200,3,200,11],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[200,12,200,43],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[200,43,200,44],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[201,3,201,11],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[201,12,201,42],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[201,42,201,43],\"els\":[\"1:3052\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[202,3,202,11],\"els\":[\"1:3052\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[202,12,202,30],\"els\":[\"1:3052\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[202,30,202,31],\"els\":[\"1:3053\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[203,3,203,11],\"els\":[\"1:3053\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[203,12,203,33],\"els\":[\"1:3053\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[203,33,203,34],\"els\":[\"1:3151\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[203,34,203,36],\"els\":[\"1:3151\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[203,36,203,37],\"els\":[\"1:3151\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[203,37,203,38],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[204,3,204,11],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[204,12,204,41],\"els\":[\"1:14\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[204,41,204,42],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[205,3,205,11],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[205,12,205,42],\"els\":[\"1:14\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[205,42,205,43],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[206,3,206,11],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[206,12,206,43],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[206,43,206,44],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[207,3,207,11],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[207,12,207,42],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[207,42,207,43],\"els\":[\"1:3052\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[208,3,208,11],\"els\":[\"1:3052\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[208,12,208,34],\"els\":[\"1:3052\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[208,34,208,35],\"els\":[\"1:3053\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[209,3,209,8],\"els\":[\"1:3053\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[209,9,209,26],\"els\":[\"1:3053\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[209,26,209,27],\"els\":[\"1:3\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[209,27,209,28],\"els\":[\"1:3\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[209,28,209,29],\"els\":[\"1:3\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[209,29,209,30],\"els\":[\"1:2756\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[210,3,210,11],\"els\":[\"1:2756\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[210,12,210,30],\"els\":[\"1:2756\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[210,30,210,31],\"els\":[\"1:2756\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[211,3,211,12],\"els\":[\"1:2756\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[211,13,211,27],\"els\":[\"1:2756\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[211,27,211,28],\"els\":[\"1:2892\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[212,3,212,10],\"els\":[\"1:2892\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[212,11,212,22],\"els\":[\"1:2892\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[212,22,212,23],\"els\":[\"1:2759\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[212,23,212,25],\"els\":[\"1:2759\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[212,25,212,26],\"els\":[\"1:2759\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[212,26,212,27],\"els\":[\"1:2752\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[213,3,213,10],\"els\":[\"1:2752\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[213,11,213,42],\"els\":[\"1:2752\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[213,42,213,43],\"els\":[\"1:2752\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[214,3,214,10],\"els\":[\"1:2752\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[214,11,214,42],\"els\":[\"1:2752\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[214,42,214,43],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[215,3,215,10],\"els\":[\"1:3035\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[215,11,215,42],\"els\":[\"1:3035\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[215,42,215,43],\"els\":[\"1:3054\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[216,3,216,10],\"els\":[\"1:3054\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[216,11,216,42],\"els\":[\"1:3054\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[216,42,216,43],\"els\":[\"1:3052\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[217,3,217,10],\"els\":[\"1:3052\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[217,11,217,39],\"els\":[\"1:3052\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[217,39,217,40],\"els\":[\"1:3053\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[218,3,218,10],\"els\":[\"1:3053\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[218,11,218,42],\"els\":[\"1:3053\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[218,42,218,43],\"els\":[\"1:3179\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[219,3,219,12],\"els\":[\"1:3179\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[219,13,219,23],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[219,23,219,24],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[220,3,220,12],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[220,13,220,42],\"els\":[\"1:3179\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[220,42,220,43],\"els\":[\"1:2751\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[221,3,221,32],\"els\":[\"1:2751\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[221,33,221,61],\"els\":[\"1:2751\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[221,61,221,62],\"els\":[\"1:3\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[223,3,223,32],\"els\":[\"1:3\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[223,33,223,61],\"els\":[\"1:3\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[223,61,223,62],\"els\":[\"1:2707\"],\"ct\":{\"1\":1}},{\"tk\":[225,3,225,32],\"els\":[\"1:2707\"],\"ct\":{\"1\":1}},{\"tk\":[225,33,225,61],\"els\":[\"1:2707\"],\"ct\":{\"1\":1}},{\"tk\":[225,61,225,62],\"els\":[\"1:2701\"],\"ct\":{\"1\":1}},{\"tk\":[227,3,227,32],\"els\":[\"1:2701\"],\"ct\":{\"1\":1}},{\"tk\":[227,33,227,62],\"els\":[\"1:2701\"],\"ct\":{\"1\":1}},{\"tk\":[227,62,227,63],\"els\":[\"1:2687\"],\"ct\":{\"1\":1}},{\"tk\":[229,3,229,32],\"els\":[\"1:2687\"],\"ct\":{\"1\":1}},{\"tk\":[229,33,229,61],\"els\":[\"1:2687\"],\"ct\":{\"1\":1}},{\"tk\":[229,61,229,62],\"els\":[\"1:2681\"],\"ct\":{\"1\":1}},{\"tk\":[231,3,231,32],\"els\":[\"1:2681\"],\"ct\":{\"1\":1}},{\"tk\":[231,33,231,61],\"els\":[\"1:2681\"],\"ct\":{\"1\":1}},{\"tk\":[231,61,231,62],\"els\":[\"1:2667\"],\"ct\":{\"1\":1}},{\"tk\":[233,3,233,32],\"els\":[\"1:2667\"],\"ct\":{\"1\":1}},{\"tk\":[233,33,233,61],\"els\":[\"1:2667\"],\"ct\":{\"1\":1}},{\"tk\":[233,61,233,62],\"els\":[\"1:2661\"],\"ct\":{\"1\":1}},{\"tk\":[235,3,235,32],\"els\":[\"1:2661\"],\"ct\":{\"1\":1}},{\"tk\":[235,33,235,61],\"els\":[\"1:2661\"],\"ct\":{\"1\":1}},{\"tk\":[235,61,235,62],\"els\":[\"1:2647\"],\"ct\":{\"1\":1}},{\"tk\":[237,3,237,32],\"els\":[\"1:2647\"],\"ct\":{\"1\":1}},{\"tk\":[237,33,237,61],\"els\":[\"1:2647\"],\"ct\":{\"1\":1}},{\"tk\":[237,61,237,62],\"els\":[\"1:2641\"],\"ct\":{\"1\":1}},{\"tk\":[239,3,239,32],\"els\":[\"1:2641\"],\"ct\":{\"1\":1}},{\"tk\":[239,33,239,61],\"els\":[\"1:2641\"],\"ct\":{\"1\":1}},{\"tk\":[239,61,239,62],\"els\":[\"1:2627\"],\"ct\":{\"1\":1}},{\"tk\":[241,3,241,32],\"els\":[\"1:2627\"],\"ct\":{\"1\":1}},{\"tk\":[241,33,241,61],\"els\":[\"1:2627\"],\"ct\":{\"1\":1}},{\"tk\":[241,61,241,62],\"els\":[\"1:2621\"],\"ct\":{\"1\":1}},{\"tk\":[243,3,243,32],\"els\":[\"1:2621\"],\"ct\":{\"1\":1}},{\"tk\":[243,33,243,61],\"els\":[\"1:2621\"],\"ct\":{\"1\":1}},{\"tk\":[243,61,243,62],\"els\":[\"1:2607\"],\"ct\":{\"1\":1}},{\"tk\":[245,1,245,2],\"els\":[\"1:2607\"],\"ct\":{\"1\":1}},{\"tk\":[245,3,245,5],\"els\":[\"1:2607\"],\"ct\":{\"1\":1}},{\"tk\":[245,5,245,6],\"els\":[\"1:2601\"],\"ct\":{\"1\":1}},{\"tk\":[248,1,248,8],\"els\":[\"1:2601\"],\"ct\":{\"1\":1}},{\"tk\":[248,9,248,15],\"els\":[\"1:2601\"],\"ct\":{\"1\":1}},{\"tk\":[250,10,250,11],\"els\":[\"1:2770\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[253,1,253,8],\"els\":[\"1:2770\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[253,9,253,15],\"els\":[\"1:2770\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[258,9,258,10],\"els\":[\"1:3044\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[261,1,261,7],\"els\":[\"1:3044\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[261,8,261,15],\"els\":[\"1:3044\"],\"ct\":{\"0\":3,\"1\":1}}]},\"2\":{\"records\":[{\"tk\":[32,5,32,8],\"els\":[\"2:2717\"]},{\"tk\":[32,9,32,20],\"els\":[\"2:2717\"]},{\"tk\":[33,5,33,8],\"els\":[\"2:2717\"]},{\"tk\":[33,9,33,20],\"els\":[\"2:2717\"]},{\"tk\":[34,5,34,8],\"els\":[\"2:2717\"]},{\"tk\":[34,9,34,20],\"els\":[\"2:2717\"]},{\"tk\":[36,8,36,9],\"els\":[\"2:2717\"]},{\"tk\":[36,9,36,12],\"els\":[\"2:2717\"]},{\"tk\":[36,13,36,24],\"els\":[\"2:2717\"]},{\"tk\":[39,5,39,8],\"els\":[\"2:2717\"]},{\"tk\":[39,9,39,20],\"els\":[\"2:2717\"]},{\"tk\":[48,5,48,7],\"els\":[\"2:2598\"]},{\"tk\":[48,9,48,10],\"els\":[\"2:2600\"]},{\"tk\":[48,17,48,20],\"els\":[\"2:2600\"]},{\"tk\":[48,21,48,32],\"els\":[\"2:2600\"]},{\"tk\":[48,33,48,34],\"els\":[\"2:2600\"]},{\"tk\":[48,35,48,39],\"els\":[\"2:2600\",\"2:2588\"]},{\"tk\":[48,40,48,42],\"els\":[\"2:2598\"]},{\"tk\":[48,43,48,46],\"els\":[\"2:2598\"]},{\"tk\":[52,7,52,33],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,33,52,34],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,34,52,37],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,37,52,38],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,38,52,49],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,49,52,50],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,51,52,52],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,52,52,55],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,55,52,56],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,56,52,74],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[52,74,52,75],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[53,9,53,10],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[53,10,53,13],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[53,13,53,14],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[53,14,53,32],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[53,32,53,33],\"els\":[\"2:2601\",\"2:2598\",\"2:2603\"]},{\"tk\":[56,12,56,14],\"els\":[\"2:2598\"]},{\"tk\":[56,16,56,17],\"els\":[\"2:2600\"]},{\"tk\":[56,24,56,27],\"els\":[\"2:2600\"]},{\"tk\":[56,28,56,39],\"els\":[\"2:2600\"]},{\"tk\":[56,40,56,41],\"els\":[\"2:2600\"]},{\"tk\":[56,42,56,46],\"els\":[\"2:2600\",\"2:2588\"]},{\"tk\":[56,47,56,49],\"els\":[\"2:2598\"]},{\"tk\":[56,50,56,53],\"els\":[\"2:2598\"]},{\"tk\":[60,7,60,33],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,33,60,34],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,34,60,37],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,37,60,38],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,38,60,49],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,49,60,50],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,51,60,52],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,52,60,55],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,55,60,56],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,56,60,74],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[60,74,60,75],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[61,9,61,10],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[61,10,61,13],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[61,13,61,14],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[61,14,61,33],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[61,33,61,34],\"els\":[\"2:2607\",\"2:2598\",\"2:2609\"]},{\"tk\":[72,5,72,7],\"els\":[\"2:2618\"]},{\"tk\":[72,9,72,10],\"els\":[\"2:2620\"]},{\"tk\":[72,17,72,20],\"els\":[\"2:2620\"]},{\"tk\":[72,21,72,32],\"els\":[\"2:2620\"]},{\"tk\":[72,33,72,34],\"els\":[\"2:2620\"]},{\"tk\":[72,35,72,39],\"els\":[\"2:2620\",\"2:2588\"]},{\"tk\":[72,40,72,42],\"els\":[\"2:2618\"]},{\"tk\":[72,43,72,46],\"els\":[\"2:2618\"]},{\"tk\":[76,7,76,33],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,33,76,34],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,34,76,37],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,37,76,38],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,38,76,49],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,49,76,50],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,51,76,52],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,52,76,55],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,55,76,56],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,56,76,75],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[76,75,76,76],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[77,9,77,10],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[77,10,77,13],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[77,13,77,14],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[77,14,77,32],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[77,32,77,33],\"els\":[\"2:2621\",\"2:2618\",\"2:2623\"]},{\"tk\":[80,12,80,14],\"els\":[\"2:2618\"]},{\"tk\":[80,16,80,17],\"els\":[\"2:2620\"]},{\"tk\":[80,24,80,27],\"els\":[\"2:2620\"]},{\"tk\":[80,28,80,39],\"els\":[\"2:2620\"]},{\"tk\":[80,40,80,41],\"els\":[\"2:2620\"]},{\"tk\":[80,42,80,46],\"els\":[\"2:2620\",\"2:2588\"]},{\"tk\":[80,47,80,49],\"els\":[\"2:2618\"]},{\"tk\":[80,50,80,53],\"els\":[\"2:2618\"]},{\"tk\":[84,7,84,33],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,33,84,34],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,34,84,37],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,37,84,38],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,38,84,49],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,49,84,50],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,51,84,52],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,52,84,55],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,55,84,56],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,56,84,75],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[84,75,84,76],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[85,9,85,10],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[85,10,85,13],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[85,13,85,14],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[85,14,85,32],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[85,32,85,33],\"els\":[\"2:2627\",\"2:2618\",\"2:2629\"]},{\"tk\":[96,5,96,7],\"els\":[\"2:2638\"]},{\"tk\":[96,9,96,10],\"els\":[\"2:2640\"]},{\"tk\":[96,17,96,20],\"els\":[\"2:2640\"]},{\"tk\":[96,21,96,32],\"els\":[\"2:2640\"]},{\"tk\":[96,33,96,34],\"els\":[\"2:2640\"]},{\"tk\":[96,35,96,39],\"els\":[\"2:2640\",\"2:2588\"]},{\"tk\":[96,40,96,42],\"els\":[\"2:2638\"]},{\"tk\":[96,43,96,46],\"els\":[\"2:2638\"]},{\"tk\":[100,7,100,33],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,33,100,34],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,34,100,37],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,37,100,38],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,38,100,49],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,49,100,50],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,51,100,52],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,52,100,55],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,55,100,56],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,56,100,74],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[100,74,100,75],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[101,9,101,10],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[101,10,101,13],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[101,13,101,14],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[101,14,101,32],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[101,32,101,33],\"els\":[\"2:2641\",\"2:2638\",\"2:2643\"]},{\"tk\":[104,12,104,14],\"els\":[\"2:2638\"]},{\"tk\":[104,16,104,17],\"els\":[\"2:2640\"]},{\"tk\":[104,24,104,27],\"els\":[\"2:2640\"]},{\"tk\":[104,28,104,39],\"els\":[\"2:2640\"]},{\"tk\":[104,40,104,41],\"els\":[\"2:2640\"]},{\"tk\":[104,42,104,46],\"els\":[\"2:2640\",\"2:2588\"]},{\"tk\":[104,47,104,49],\"els\":[\"2:2638\"]},{\"tk\":[104,50,104,53],\"els\":[\"2:2638\"]},{\"tk\":[108,7,108,33],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,33,108,34],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,34,108,37],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,37,108,38],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,38,108,49],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,49,108,50],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,51,108,52],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,52,108,55],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,55,108,56],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,56,108,74],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[108,74,108,75],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[109,9,109,10],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[109,10,109,13],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[109,13,109,14],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[109,14,109,33],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[109,33,109,34],\"els\":[\"2:2647\",\"2:2638\",\"2:2649\"]},{\"tk\":[120,5,120,7],\"els\":[\"2:2658\"]},{\"tk\":[120,9,120,10],\"els\":[\"2:2660\"]},{\"tk\":[120,17,120,20],\"els\":[\"2:2660\"]},{\"tk\":[120,21,120,32],\"els\":[\"2:2660\"]},{\"tk\":[120,33,120,34],\"els\":[\"2:2660\"]},{\"tk\":[120,35,120,39],\"els\":[\"2:2660\",\"2:2588\"]},{\"tk\":[120,40,120,42],\"els\":[\"2:2658\"]},{\"tk\":[120,43,120,46],\"els\":[\"2:2658\"]},{\"tk\":[124,7,124,33],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,33,124,34],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,34,124,37],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,37,124,38],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,38,124,49],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,49,124,50],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,51,124,52],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,52,124,55],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,55,124,56],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,56,124,75],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[124,75,124,76],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[125,9,125,10],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[125,10,125,13],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[125,13,125,14],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[125,14,125,32],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[125,32,125,33],\"els\":[\"2:2661\",\"2:2658\",\"2:2663\"]},{\"tk\":[128,12,128,14],\"els\":[\"2:2658\"]},{\"tk\":[128,16,128,17],\"els\":[\"2:2660\"]},{\"tk\":[128,24,128,27],\"els\":[\"2:2660\"]},{\"tk\":[128,28,128,39],\"els\":[\"2:2660\"]},{\"tk\":[128,40,128,41],\"els\":[\"2:2660\"]},{\"tk\":[128,42,128,46],\"els\":[\"2:2660\",\"2:2588\"]},{\"tk\":[128,47,128,49],\"els\":[\"2:2658\"]},{\"tk\":[128,50,128,53],\"els\":[\"2:2658\"]},{\"tk\":[132,7,132,33],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,33,132,34],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,34,132,37],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,37,132,38],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,38,132,49],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,49,132,50],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,51,132,52],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,52,132,55],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,55,132,56],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,56,132,74],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[132,74,132,75],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[133,9,133,10],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[133,10,133,13],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[133,13,133,14],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[133,14,133,32],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[133,32,133,33],\"els\":[\"2:2667\",\"2:2658\",\"2:2669\"]},{\"tk\":[144,5,144,7],\"els\":[\"2:2678\"]},{\"tk\":[144,9,144,10],\"els\":[\"2:2680\"]},{\"tk\":[144,17,144,20],\"els\":[\"2:2680\"]},{\"tk\":[144,21,144,32],\"els\":[\"2:2680\"]},{\"tk\":[144,33,144,34],\"els\":[\"2:2680\"]},{\"tk\":[144,35,144,39],\"els\":[\"2:2680\",\"2:2588\"]},{\"tk\":[144,40,144,42],\"els\":[\"2:2678\"]},{\"tk\":[144,43,144,46],\"els\":[\"2:2678\"]},{\"tk\":[148,7,148,33],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,33,148,34],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,34,148,37],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,37,148,38],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,38,148,49],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,49,148,50],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,51,148,52],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,52,148,55],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,55,148,56],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,56,148,74],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[148,74,148,75],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[149,9,149,10],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[149,10,149,13],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[149,13,149,14],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[149,14,149,32],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[149,32,149,33],\"els\":[\"2:2681\",\"2:2678\",\"2:2683\"]},{\"tk\":[152,12,152,14],\"els\":[\"2:2678\"]},{\"tk\":[152,16,152,17],\"els\":[\"2:2680\"]},{\"tk\":[152,24,152,27],\"els\":[\"2:2680\"]},{\"tk\":[152,28,152,39],\"els\":[\"2:2680\"]},{\"tk\":[152,40,152,41],\"els\":[\"2:2680\"]},{\"tk\":[152,42,152,46],\"els\":[\"2:2680\",\"2:2588\"]},{\"tk\":[152,47,152,49],\"els\":[\"2:2678\"]},{\"tk\":[152,50,152,53],\"els\":[\"2:2678\"]},{\"tk\":[156,7,156,33],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,33,156,34],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,34,156,37],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,37,156,38],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,38,156,49],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,49,156,50],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,51,156,52],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,52,156,55],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,55,156,56],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,56,156,75],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[156,75,156,76],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[157,9,157,10],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[157,10,157,13],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[157,13,157,14],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[157,14,157,32],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[157,32,157,33],\"els\":[\"2:2687\",\"2:2678\",\"2:2689\"]},{\"tk\":[168,5,168,7],\"els\":[\"2:2698\"]},{\"tk\":[168,9,168,10],\"els\":[\"2:2700\"]},{\"tk\":[168,17,168,20],\"els\":[\"2:2700\"]},{\"tk\":[168,21,168,32],\"els\":[\"2:2700\"]},{\"tk\":[168,33,168,34],\"els\":[\"2:2700\"]},{\"tk\":[168,35,168,39],\"els\":[\"2:2700\",\"2:2588\"]},{\"tk\":[168,40,168,42],\"els\":[\"2:2698\"]},{\"tk\":[168,43,168,46],\"els\":[\"2:2698\"]},{\"tk\":[172,7,172,33],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,33,172,34],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,34,172,37],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,37,172,38],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,38,172,49],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,49,172,50],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,51,172,52],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,52,172,55],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,55,172,56],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,56,172,74],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[172,74,172,75],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[173,9,173,10],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[173,10,173,13],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[173,13,173,14],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[173,14,173,32],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[173,32,173,33],\"els\":[\"2:2701\",\"2:2698\",\"2:2703\"]},{\"tk\":[176,12,176,14],\"els\":[\"2:2698\"]},{\"tk\":[176,16,176,17],\"els\":[\"2:2700\"]},{\"tk\":[176,24,176,27],\"els\":[\"2:2700\"]},{\"tk\":[176,28,176,39],\"els\":[\"2:2700\"]},{\"tk\":[176,40,176,41],\"els\":[\"2:2700\"]},{\"tk\":[176,42,176,46],\"els\":[\"2:2700\",\"2:2588\"]},{\"tk\":[176,47,176,49],\"els\":[\"2:2698\"]},{\"tk\":[176,50,176,53],\"els\":[\"2:2698\"]},{\"tk\":[180,7,180,33],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,33,180,34],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,34,180,37],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,37,180,38],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,38,180,49],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,49,180,50],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,51,180,52],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,52,180,55],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,55,180,56],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,56,180,72],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[180,72,180,73],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[181,9,181,10],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[181,10,181,13],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[181,13,181,14],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[181,14,181,30],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]},{\"tk\":[181,30,181,31],\"els\":[\"2:2707\",\"2:2698\",\"2:2709\"]}]},\"0\":{\"records\":[{\"tk\":[132,3,132,4],\"els\":[\"0:2604\"]},{\"tk\":[132,4,132,8],\"els\":[\"0:2604\"]},{\"tk\":[132,8,132,9],\"els\":[\"0:2604\"]},{\"tk\":[132,9,132,15],\"els\":[\"0:2604\"]},{\"tk\":[132,15,132,16],\"els\":[\"0:2604\"]},{\"tk\":[132,16,132,17],\"els\":[\"0:2604\"]},{\"tk\":[132,17,132,24],\"els\":[\"0:2604\"]},{\"tk\":[132,24,132,25],\"els\":[\"0:2604\"]},{\"tk\":[132,25,132,26],\"els\":[\"0:2604\"]},{\"tk\":[132,26,132,31],\"els\":[\"0:2604\"]},{\"tk\":[132,31,132,32],\"els\":[\"0:2604\"]},{\"tk\":[132,33,132,34],\"els\":[\"0:2604\"]},{\"tk\":[132,34,132,41],\"els\":[\"0:2604\"]},{\"tk\":[132,41,132,42],\"els\":[\"0:2604\"]},{\"tk\":[132,42,132,43],\"els\":[\"0:2604\"]},{\"tk\":[132,43,132,44],\"els\":[\"0:2604\"]},{\"tk\":[132,44,132,50],\"els\":[\"0:2604\"]},{\"tk\":[132,50,132,51],\"els\":[\"0:2604\"]},{\"tk\":[132,51,132,52],\"els\":[\"0:2604\"]},{\"tk\":[132,52,132,53],\"els\":[\"0:2604\"]},{\"tk\":[132,54,132,55],\"els\":[\"0:2604\"]},{\"tk\":[132,56,132,57],\"els\":[\"0:2604\"]},{\"tk\":[132,57,132,58],\"els\":[\"0:2604\"]},{\"tk\":[132,59,132,60],\"els\":[\"0:2604\"]},{\"tk\":[132,60,132,61],\"els\":[\"0:2604\"]},{\"tk\":[132,61,132,62],\"els\":[\"0:2604\"]},{\"tk\":[133,3,133,4],\"els\":[\"0:2604\"]},{\"tk\":[133,4,133,8],\"els\":[\"0:2604\"]},{\"tk\":[133,8,133,9],\"els\":[\"0:2604\"]},{\"tk\":[133,9,133,15],\"els\":[\"0:2604\"]},{\"tk\":[133,15,133,16],\"els\":[\"0:2604\"]},{\"tk\":[133,16,133,17],\"els\":[\"0:2604\"]},{\"tk\":[133,17,133,24],\"els\":[\"0:2604\"]},{\"tk\":[133,24,133,25],\"els\":[\"0:2604\"]},{\"tk\":[133,25,133,26],\"els\":[\"0:2604\"]},{\"tk\":[133,26,133,31],\"els\":[\"0:2604\"]},{\"tk\":[133,31,133,32],\"els\":[\"0:2604\"]},{\"tk\":[133,33,133,34],\"els\":[\"0:2604\"]},{\"tk\":[133,34,133,41],\"els\":[\"0:2604\"]},{\"tk\":[133,41,133,42],\"els\":[\"0:2604\"]},{\"tk\":[133,42,133,43],\"els\":[\"0:2604\"]},{\"tk\":[133,43,133,44],\"els\":[\"0:2604\"]},{\"tk\":[133,44,133,50],\"els\":[\"0:2604\"]},{\"tk\":[133,50,133,51],\"els\":[\"0:2604\"]},{\"tk\":[133,51,133,52],\"els\":[\"0:2604\"]},{\"tk\":[133,52,133,53],\"els\":[\"0:2604\"]},{\"tk\":[133,54,133,55],\"els\":[\"0:2604\"]},{\"tk\":[133,56,133,57],\"els\":[\"0:2604\"]},{\"tk\":[133,57,133,58],\"els\":[\"0:2604\"]},{\"tk\":[133,59,133,60],\"els\":[\"0:2604\"]},{\"tk\":[133,60,133,61],\"els\":[\"0:2604\"]},{\"tk\":[133,61,133,62],\"els\":[\"0:2604\"]},{\"tk\":[151,3,151,4],\"els\":[\"0:2610\"]},{\"tk\":[151,4,151,8],\"els\":[\"0:2610\"]},{\"tk\":[151,8,151,9],\"els\":[\"0:2610\"]},{\"tk\":[151,9,151,15],\"els\":[\"0:2610\"]},{\"tk\":[151,15,151,16],\"els\":[\"0:2610\"]},{\"tk\":[151,16,151,17],\"els\":[\"0:2610\"]},{\"tk\":[151,17,151,24],\"els\":[\"0:2610\"]},{\"tk\":[151,24,151,25],\"els\":[\"0:2610\"]},{\"tk\":[151,25,151,26],\"els\":[\"0:2610\"]},{\"tk\":[151,26,151,33],\"els\":[\"0:2610\"]},{\"tk\":[151,33,151,34],\"els\":[\"0:2610\"]},{\"tk\":[151,35,151,36],\"els\":[\"0:2610\"]},{\"tk\":[151,36,151,43],\"els\":[\"0:2610\"]},{\"tk\":[151,43,151,44],\"els\":[\"0:2610\"]},{\"tk\":[151,44,151,45],\"els\":[\"0:2610\"]},{\"tk\":[151,45,151,46],\"els\":[\"0:2610\"]},{\"tk\":[151,46,151,55],\"els\":[\"0:2610\"]},{\"tk\":[151,55,151,56],\"els\":[\"0:2610\"]},{\"tk\":[151,56,151,57],\"els\":[\"0:2610\"]},{\"tk\":[151,57,151,58],\"els\":[\"0:2610\"]},{\"tk\":[151,59,151,60],\"els\":[\"0:2610\"]},{\"tk\":[151,61,151,62],\"els\":[\"0:2610\"]},{\"tk\":[151,62,151,63],\"els\":[\"0:2610\"]},{\"tk\":[151,64,151,65],\"els\":[\"0:2610\"]},{\"tk\":[151,65,151,66],\"els\":[\"0:2610\"]},{\"tk\":[151,66,151,67],\"els\":[\"0:2610\"]},{\"tk\":[152,3,152,4],\"els\":[\"0:2610\"]},{\"tk\":[152,4,152,8],\"els\":[\"0:2610\"]},{\"tk\":[152,8,152,9],\"els\":[\"0:2610\"]},{\"tk\":[152,9,152,15],\"els\":[\"0:2610\"]},{\"tk\":[152,15,152,16],\"els\":[\"0:2610\"]},{\"tk\":[152,16,152,17],\"els\":[\"0:2610\"]},{\"tk\":[152,17,152,24],\"els\":[\"0:2610\"]},{\"tk\":[152,24,152,25],\"els\":[\"0:2610\"]},{\"tk\":[152,25,152,26],\"els\":[\"0:2610\"]},{\"tk\":[152,26,152,32],\"els\":[\"0:2610\"]},{\"tk\":[152,32,152,33],\"els\":[\"0:2610\"]},{\"tk\":[152,34,152,35],\"els\":[\"0:2610\"]},{\"tk\":[152,35,152,42],\"els\":[\"0:2610\"]},{\"tk\":[152,42,152,43],\"els\":[\"0:2610\"]},{\"tk\":[152,43,152,44],\"els\":[\"0:2610\"]},{\"tk\":[152,44,152,45],\"els\":[\"0:2610\"]},{\"tk\":[152,45,152,54],\"els\":[\"0:2610\"]},{\"tk\":[152,54,152,55],\"els\":[\"0:2610\"]},{\"tk\":[152,55,152,56],\"els\":[\"0:2610\"]},{\"tk\":[152,56,152,57],\"els\":[\"0:2610\"]},{\"tk\":[152,58,152,59],\"els\":[\"0:2610\"]},{\"tk\":[152,60,152,61],\"els\":[\"0:2610\"]},{\"tk\":[152,61,152,62],\"els\":[\"0:2610\"]},{\"tk\":[152,63,152,64],\"els\":[\"0:2610\"]},{\"tk\":[152,64,152,65],\"els\":[\"0:2610\"]},{\"tk\":[152,65,152,66],\"els\":[\"0:2610\"]},{\"tk\":[163,3,163,5],\"els\":[\"0:2751\"]},{\"tk\":[163,7,163,10],\"els\":[\"0:2751\"]},{\"tk\":[163,10,163,12],\"els\":[\"0:2751\"]},{\"tk\":[163,12,163,18],\"els\":[\"0:2751\"]},{\"tk\":[163,18,163,19],\"els\":[\"0:2751\"]},{\"tk\":[163,19,163,34],\"els\":[\"0:2751\"]},{\"tk\":[163,34,163,35],\"els\":[\"0:2751\"]},{\"tk\":[163,35,163,41],\"els\":[\"0:2751\"]},{\"tk\":[165,5,165,8],\"els\":[\"0:2751#out:1\"]},{\"tk\":[165,9,165,13],\"els\":[\"0:2751#out:1\"]},{\"tk\":[165,14,165,15],\"els\":[\"0:2751#out:1\",\"0:2751\"]},{\"tk\":[165,16,165,20],\"els\":[\"0:2751\"]},{\"tk\":[165,21,165,31],\"els\":[\"0:2751\"]},{\"tk\":[168,5,168,11],\"els\":[\"0:2752#out:1\",\"0:2752\"]},{\"tk\":[168,13,168,16],\"els\":[\"0:2752#out:1\"]},{\"tk\":[168,17,168,20],\"els\":[\"0:2752#out:1\"]},{\"tk\":[168,20,168,21],\"els\":[\"0:2752#out:1\"]},{\"tk\":[168,21,168,22],\"els\":[\"0:2752#out:1\"]},{\"tk\":[168,26,168,30],\"els\":[\"0:2752\"]},{\"tk\":[168,31,168,42],\"els\":[\"0:2752\"]},{\"tk\":[168,42,168,43],\"els\":[\"0:2752\"]},{\"tk\":[168,43,168,44],\"els\":[\"0:2752\"]},{\"tk\":[168,47,168,50],\"els\":[\"0:2752#out:1\",\"0:2752\"]},{\"tk\":[168,51,168,52],\"els\":[\"0:2752#out:1\",\"0:2752\"]},{\"tk\":[168,53,168,59],\"els\":[\"0:2752#out:1\",\"0:2752\"]},{\"tk\":[179,3,179,5],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[179,9,179,18],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[179,19,179,48],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[179,49,179,51],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[179,52,179,61],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[179,63,179,65],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[180,8,180,11],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[180,12,180,16],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[180,18,180,20],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[180,22,180,31],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[180,32,180,61],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[180,62,180,64],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[181,22,181,41],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[183,5,183,9],\"els\":[\"0:2773\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[183,10,183,22],\"els\":[\"0:2773\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[183,23,183,24],\"els\":[\"0:2773\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[183,25,183,28],\"els\":[\"0:2773\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[186,3,186,12],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[186,13,186,42],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[186,43,186,44],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[186,45,186,48],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[186,49,186,53],\"els\":[\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\"]},{\"tk\":[192,3,192,7],\"els\":[\"0:2774\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\",\"0:2773\"]},{\"tk\":[192,8,192,20],\"els\":[\"0:2774\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\",\"0:2773\"]},{\"tk\":[192,20,192,22],\"els\":[\"0:2774\",\"0:2771\",\"0:2770\",\"0:2764\",\"0:2750\",\"0:2772\"]},{\"tk\":[199,3,199,6],\"els\":[\"0:2768#out:1\"]},{\"tk\":[199,7,199,18],\"els\":[\"0:2768#out:1\"]},{\"tk\":[199,19,199,20],\"els\":[\"0:2768#out:1\",\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[199,21,199,24],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[199,25,199,28],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[199,28,199,29],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[199,29,199,30],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[199,38,199,42],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\",\"0:2773\"]},{\"tk\":[199,43,199,55],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\",\"0:2773\"]},{\"tk\":[199,56,199,57],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[199,58,199,59],\"els\":[\"0:2768\",\"0:2764\",\"0:2750\"]},{\"tk\":[202,3,202,4],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,5,203,24],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,24,203,25],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,25,203,26],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,26,203,27],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,28,203,29],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,29,203,32],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,32,203,33],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,33,203,44],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,44,203,45],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,46,203,47],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,47,203,48],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[203,48,203,49],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[204,3,204,4],\"els\":[\"0:2769\",\"0:2764\",\"0:2750\"]},{\"tk\":[209,3,209,22],\"els\":[\"0:2723\"]},{\"tk\":[209,22,209,23],\"els\":[\"0:2723\"]},{\"tk\":[209,23,209,24],\"els\":[\"0:2723\"]},{\"tk\":[209,24,209,25],\"els\":[\"0:2723\"]},{\"tk\":[209,26,209,28],\"els\":[\"0:2723\"]},{\"tk\":[209,28,209,29],\"els\":[\"0:2723\"]},{\"tk\":[209,30,209,31],\"els\":[\"0:2723\"]},{\"tk\":[209,31,209,49],\"els\":[\"0:2723\"]},{\"tk\":[209,49,209,50],\"els\":[\"0:2723\"]},{\"tk\":[209,50,209,51],\"els\":[\"0:2723\"]},{\"tk\":[212,3,212,22],\"els\":[\"0:2724\"]},{\"tk\":[212,22,212,23],\"els\":[\"0:2724\"]},{\"tk\":[212,23,212,24],\"els\":[\"0:2724\"]},{\"tk\":[212,24,212,25],\"els\":[\"0:2724\"]},{\"tk\":[212,26,212,28],\"els\":[\"0:2724\"]},{\"tk\":[212,28,212,29],\"els\":[\"0:2724\"]},{\"tk\":[212,30,212,31],\"els\":[\"0:2724\"]},{\"tk\":[212,31,212,49],\"els\":[\"0:2724\"]},{\"tk\":[212,49,212,50],\"els\":[\"0:2724\"]},{\"tk\":[212,50,212,51],\"els\":[\"0:2724\"]},{\"tk\":[215,3,215,22],\"els\":[\"0:2725\"]},{\"tk\":[215,22,215,23],\"els\":[\"0:2725\"]},{\"tk\":[215,23,215,24],\"els\":[\"0:2725\"]},{\"tk\":[215,24,215,25],\"els\":[\"0:2725\"]},{\"tk\":[215,26,215,28],\"els\":[\"0:2725\"]},{\"tk\":[215,28,215,29],\"els\":[\"0:2725\"]},{\"tk\":[215,30,215,31],\"els\":[\"0:2725\"]},{\"tk\":[215,31,215,49],\"els\":[\"0:2725\"]},{\"tk\":[215,49,215,50],\"els\":[\"0:2725\"]},{\"tk\":[215,50,215,51],\"els\":[\"0:2725\"]},{\"tk\":[218,3,218,22],\"els\":[\"0:2726\"]},{\"tk\":[218,22,218,23],\"els\":[\"0:2726\"]},{\"tk\":[218,23,218,24],\"els\":[\"0:2726\"]},{\"tk\":[218,24,218,25],\"els\":[\"0:2726\"]},{\"tk\":[218,26,218,28],\"els\":[\"0:2726\"]},{\"tk\":[218,28,218,29],\"els\":[\"0:2726\"]},{\"tk\":[218,30,218,31],\"els\":[\"0:2726\"]},{\"tk\":[218,31,218,49],\"els\":[\"0:2726\"]},{\"tk\":[218,49,218,50],\"els\":[\"0:2726\"]},{\"tk\":[218,50,218,51],\"els\":[\"0:2726\"]},{\"tk\":[221,3,221,22],\"els\":[\"0:2727\"]},{\"tk\":[221,22,221,23],\"els\":[\"0:2727\"]},{\"tk\":[221,23,221,24],\"els\":[\"0:2727\"]},{\"tk\":[221,24,221,25],\"els\":[\"0:2727\"]},{\"tk\":[221,26,221,27],\"els\":[\"0:2727\"]},{\"tk\":[221,27,221,28],\"els\":[\"0:2727\"]},{\"tk\":[221,29,221,30],\"els\":[\"0:2727\"]},{\"tk\":[221,30,221,47],\"els\":[\"0:2727\"]},{\"tk\":[221,47,221,48],\"els\":[\"0:2727\"]},{\"tk\":[221,48,221,49],\"els\":[\"0:2727\"]},{\"tk\":[224,3,224,22],\"els\":[\"0:2728\"]},{\"tk\":[224,22,224,23],\"els\":[\"0:2728\"]},{\"tk\":[224,23,224,24],\"els\":[\"0:2728\"]},{\"tk\":[224,24,224,25],\"els\":[\"0:2728\"]},{\"tk\":[224,26,224,27],\"els\":[\"0:2728\"]},{\"tk\":[224,27,224,28],\"els\":[\"0:2728\"]},{\"tk\":[224,29,224,30],\"els\":[\"0:2728\"]},{\"tk\":[224,30,224,47],\"els\":[\"0:2728\"]},{\"tk\":[224,47,224,48],\"els\":[\"0:2728\"]},{\"tk\":[224,48,224,49],\"els\":[\"0:2728\"]},{\"tk\":[227,3,227,22],\"els\":[\"0:2729\"]},{\"tk\":[227,22,227,23],\"els\":[\"0:2729\"]},{\"tk\":[227,23,227,24],\"els\":[\"0:2729\"]},{\"tk\":[227,24,227,25],\"els\":[\"0:2729\"]},{\"tk\":[227,26,227,28],\"els\":[\"0:2729\"]},{\"tk\":[227,28,227,29],\"els\":[\"0:2729\"]},{\"tk\":[227,30,227,31],\"els\":[\"0:2729\"]},{\"tk\":[227,31,227,49],\"els\":[\"0:2729\"]},{\"tk\":[227,49,227,50],\"els\":[\"0:2729\"]},{\"tk\":[227,50,227,51],\"els\":[\"0:2729\"]},{\"tk\":[230,3,230,22],\"els\":[\"0:2730\"]},{\"tk\":[230,22,230,23],\"els\":[\"0:2730\"]},{\"tk\":[230,23,230,24],\"els\":[\"0:2730\"]},{\"tk\":[230,24,230,25],\"els\":[\"0:2730\"]},{\"tk\":[230,26,230,28],\"els\":[\"0:2730\"]},{\"tk\":[230,28,230,29],\"els\":[\"0:2730\"]},{\"tk\":[230,30,230,31],\"els\":[\"0:2730\"]},{\"tk\":[230,31,230,49],\"els\":[\"0:2730\"]},{\"tk\":[230,49,230,50],\"els\":[\"0:2730\"]},{\"tk\":[230,50,230,51],\"els\":[\"0:2730\"]},{\"tk\":[233,3,233,22],\"els\":[\"0:2731\"]},{\"tk\":[233,22,233,23],\"els\":[\"0:2731\"]},{\"tk\":[233,23,233,24],\"els\":[\"0:2731\"]},{\"tk\":[233,24,233,25],\"els\":[\"0:2731\"]},{\"tk\":[233,26,233,27],\"els\":[\"0:2731\"]},{\"tk\":[233,27,233,28],\"els\":[\"0:2731\"]},{\"tk\":[233,29,233,30],\"els\":[\"0:2731\"]},{\"tk\":[233,30,233,47],\"els\":[\"0:2731\"]},{\"tk\":[233,47,233,48],\"els\":[\"0:2731\"]},{\"tk\":[233,48,233,49],\"els\":[\"0:2731\"]},{\"tk\":[236,3,236,22],\"els\":[\"0:2732\"]},{\"tk\":[236,22,236,23],\"els\":[\"0:2732\"]},{\"tk\":[236,23,236,24],\"els\":[\"0:2732\"]},{\"tk\":[236,24,236,25],\"els\":[\"0:2732\"]},{\"tk\":[236,26,236,27],\"els\":[\"0:2732\"]},{\"tk\":[236,27,236,28],\"els\":[\"0:2732\"]},{\"tk\":[236,29,236,30],\"els\":[\"0:2732\"]},{\"tk\":[236,30,236,47],\"els\":[\"0:2732\"]},{\"tk\":[236,47,236,48],\"els\":[\"0:2732\"]},{\"tk\":[236,48,236,49],\"els\":[\"0:2732\"]},{\"tk\":[239,3,239,22],\"els\":[\"0:2733\"]},{\"tk\":[239,22,239,23],\"els\":[\"0:2733\"]},{\"tk\":[239,23,239,24],\"els\":[\"0:2733\"]},{\"tk\":[239,24,239,25],\"els\":[\"0:2733\"]},{\"tk\":[239,26,239,27],\"els\":[\"0:2733\"]},{\"tk\":[239,27,239,28],\"els\":[\"0:2733\"]},{\"tk\":[239,29,239,30],\"els\":[\"0:2733\"]},{\"tk\":[239,30,239,47],\"els\":[\"0:2733\"]},{\"tk\":[239,47,239,48],\"els\":[\"0:2733\"]},{\"tk\":[239,48,239,49],\"els\":[\"0:2733\"]},{\"tk\":[242,3,242,22],\"els\":[\"0:2734\"]},{\"tk\":[242,22,242,23],\"els\":[\"0:2734\"]},{\"tk\":[242,23,242,24],\"els\":[\"0:2734\"]},{\"tk\":[242,24,242,25],\"els\":[\"0:2734\"]},{\"tk\":[242,26,242,27],\"els\":[\"0:2734\"]},{\"tk\":[242,27,242,28],\"els\":[\"0:2734\"]},{\"tk\":[242,29,242,30],\"els\":[\"0:2734\"]},{\"tk\":[242,30,242,47],\"els\":[\"0:2734\"]},{\"tk\":[242,47,242,48],\"els\":[\"0:2734\"]},{\"tk\":[242,48,242,49],\"els\":[\"0:2734\"]},{\"tk\":[245,3,245,22],\"els\":[\"0:2735\"]},{\"tk\":[245,22,245,23],\"els\":[\"0:2735\"]},{\"tk\":[245,23,245,24],\"els\":[\"0:2735\"]},{\"tk\":[245,24,245,25],\"els\":[\"0:2735\"]},{\"tk\":[245,26,245,27],\"els\":[\"0:2735\"]},{\"tk\":[245,27,245,28],\"els\":[\"0:2735\"]},{\"tk\":[245,29,245,30],\"els\":[\"0:2735\"]},{\"tk\":[245,30,245,47],\"els\":[\"0:2735\"]},{\"tk\":[245,47,245,48],\"els\":[\"0:2735\"]},{\"tk\":[245,48,245,49],\"els\":[\"0:2735\"]},{\"tk\":[248,3,248,22],\"els\":[\"0:2736\"]},{\"tk\":[248,22,248,23],\"els\":[\"0:2736\"]},{\"tk\":[248,23,248,24],\"els\":[\"0:2736\"]},{\"tk\":[248,24,248,25],\"els\":[\"0:2736\"]},{\"tk\":[248,26,248,27],\"els\":[\"0:2736\"]},{\"tk\":[248,27,248,28],\"els\":[\"0:2736\"]},{\"tk\":[248,29,248,30],\"els\":[\"0:2736\"]},{\"tk\":[248,30,248,47],\"els\":[\"0:2736\"]},{\"tk\":[248,47,248,48],\"els\":[\"0:2736\"]},{\"tk\":[248,48,248,49],\"els\":[\"0:2736\"]},{\"tk\":[251,3,251,22],\"els\":[\"0:2737\"]},{\"tk\":[251,22,251,23],\"els\":[\"0:2737\"]},{\"tk\":[251,23,251,24],\"els\":[\"0:2737\"]},{\"tk\":[251,24,251,25],\"els\":[\"0:2737\"]},{\"tk\":[251,26,251,28],\"els\":[\"0:2737\"]},{\"tk\":[251,28,251,29],\"els\":[\"0:2737\"]},{\"tk\":[251,30,251,31],\"els\":[\"0:2737\"]},{\"tk\":[251,31,251,49],\"els\":[\"0:2737\"]},{\"tk\":[251,49,251,50],\"els\":[\"0:2737\"]},{\"tk\":[251,50,251,51],\"els\":[\"0:2737\"]},{\"tk\":[254,3,254,22],\"els\":[\"0:2738\"]},{\"tk\":[254,22,254,23],\"els\":[\"0:2738\"]},{\"tk\":[254,23,254,24],\"els\":[\"0:2738\"]},{\"tk\":[254,24,254,25],\"els\":[\"0:2738\"]},{\"tk\":[254,26,254,28],\"els\":[\"0:2738\"]},{\"tk\":[254,28,254,29],\"els\":[\"0:2738\"]},{\"tk\":[254,30,254,31],\"els\":[\"0:2738\"]},{\"tk\":[254,31,254,49],\"els\":[\"0:2738\"]},{\"tk\":[254,49,254,50],\"els\":[\"0:2738\"]},{\"tk\":[254,50,254,51],\"els\":[\"0:2738\"]},{\"tk\":[260,3,260,4],\"els\":[\"0:2815\"]},{\"tk\":[261,5,261,13],\"els\":[\"0:2815\"]},{\"tk\":[261,14,261,19],\"els\":[\"0:2815\"]},{\"tk\":[261,20,261,21],\"els\":[\"0:2815\"]},{\"tk\":[261,22,261,40],\"els\":[\"0:2815\"]},{\"tk\":[261,41,261,42],\"els\":[\"0:2815\"]},{\"tk\":[261,43,261,47],\"els\":[\"0:2815\"]},{\"tk\":[261,47,261,48],\"els\":[\"0:2815\"]},{\"tk\":[262,5,262,29],\"els\":[\"0:2815\"]},{\"tk\":[262,29,262,30],\"els\":[\"0:2815\"]},{\"tk\":[262,30,262,38],\"els\":[\"0:2815\"]},{\"tk\":[262,38,262,39],\"els\":[\"0:2815\"]},{\"tk\":[262,40,262,42],\"els\":[\"0:2815\"]},{\"tk\":[262,42,262,43],\"els\":[\"0:2815\"]},{\"tk\":[262,44,262,72],\"els\":[\"0:2815\"]},{\"tk\":[262,72,262,73],\"els\":[\"0:2815\"]},{\"tk\":[262,74,262,79],\"els\":[\"0:2815\"]},{\"tk\":[262,79,262,80],\"els\":[\"0:2815\"]},{\"tk\":[263,7,263,8],\"els\":[\"0:2815\"]},{\"tk\":[263,8,263,9],\"els\":[\"0:2815\"]},{\"tk\":[263,10,263,14],\"els\":[\"0:2815\"]},{\"tk\":[263,14,263,15],\"els\":[\"0:2815\"]},{\"tk\":[263,15,263,16],\"els\":[\"0:2815\"]},{\"tk\":[264,3,264,4],\"els\":[\"0:2815\"]},{\"tk\":[283,3,283,5],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[283,7,283,11],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[283,12,283,41],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[284,5,284,28],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[284,29,284,30],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[284,31,284,33],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,5,286,28],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,29,286,30],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,31,286,34],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,34,286,36],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,36,286,42],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,42,286,43],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,43,286,53],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[286,54,286,55],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[287,7,287,11],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[287,12,287,34],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,3,290,7],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,8,290,30],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,31,290,32],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,33,290,36],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,36,290,38],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,38,290,44],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,44,290,45],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[290,45,290,55],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[291,3,291,7],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[291,8,291,37],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[291,38,291,39],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[291,40,291,45],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[296,3,296,6],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,6,296,7],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,7,296,20],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,21,296,22],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,23,296,24],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,24,296,41],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,41,296,42],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,42,296,45],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,45,296,46],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,47,296,49],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,50,296,52],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,52,296,53],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,54,296,55],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,56,296,60],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[296,60,296,61],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[299,3,299,6],\"els\":[\"0:1819\"]},{\"tk\":[299,7,299,20],\"els\":[\"0:1819\"]},{\"tk\":[299,20,299,21],\"els\":[\"0:1819\"]},{\"tk\":[299,21,299,22],\"els\":[\"0:1819\"]},{\"tk\":[299,24,299,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[299,26,299,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[299,30,299,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[300,3,300,6],\"els\":[\"0:1819\"]},{\"tk\":[300,7,300,20],\"els\":[\"0:1819\"]},{\"tk\":[300,20,300,21],\"els\":[\"0:1819\"]},{\"tk\":[300,21,300,22],\"els\":[\"0:1819\"]},{\"tk\":[300,24,300,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[300,26,300,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[300,30,300,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[301,3,301,6],\"els\":[\"0:1819\"]},{\"tk\":[301,7,301,20],\"els\":[\"0:1819\"]},{\"tk\":[301,20,301,21],\"els\":[\"0:1819\"]},{\"tk\":[301,21,301,22],\"els\":[\"0:1819\"]},{\"tk\":[301,24,301,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[301,26,301,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[301,30,301,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[302,3,302,6],\"els\":[\"0:1819\"]},{\"tk\":[302,7,302,20],\"els\":[\"0:1819\"]},{\"tk\":[302,20,302,21],\"els\":[\"0:1819\"]},{\"tk\":[302,21,302,22],\"els\":[\"0:1819\"]},{\"tk\":[302,24,302,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[302,26,302,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[302,30,302,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[303,3,303,6],\"els\":[\"0:1819\"]},{\"tk\":[303,7,303,20],\"els\":[\"0:1819\"]},{\"tk\":[303,20,303,21],\"els\":[\"0:1819\"]},{\"tk\":[303,21,303,22],\"els\":[\"0:1819\"]},{\"tk\":[303,24,303,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[303,26,303,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[303,30,303,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[304,3,304,6],\"els\":[\"0:1819\"]},{\"tk\":[304,7,304,20],\"els\":[\"0:1819\"]},{\"tk\":[304,20,304,21],\"els\":[\"0:1819\"]},{\"tk\":[304,21,304,22],\"els\":[\"0:1819\"]},{\"tk\":[304,24,304,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[304,26,304,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[304,30,304,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[305,3,305,6],\"els\":[\"0:1819\"]},{\"tk\":[305,7,305,20],\"els\":[\"0:1819\"]},{\"tk\":[305,20,305,21],\"els\":[\"0:1819\"]},{\"tk\":[305,21,305,22],\"els\":[\"0:1819\"]},{\"tk\":[305,24,305,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[305,26,305,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[305,30,305,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[306,3,306,6],\"els\":[\"0:1819\"]},{\"tk\":[306,7,306,20],\"els\":[\"0:1819\"]},{\"tk\":[306,20,306,21],\"els\":[\"0:1819\"]},{\"tk\":[306,21,306,22],\"els\":[\"0:1819\"]},{\"tk\":[306,24,306,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[306,26,306,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[306,30,306,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[307,3,307,6],\"els\":[\"0:1819\"]},{\"tk\":[307,7,307,20],\"els\":[\"0:1819\"]},{\"tk\":[307,20,307,21],\"els\":[\"0:1819\"]},{\"tk\":[307,21,307,22],\"els\":[\"0:1819\"]},{\"tk\":[307,24,307,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[307,26,307,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[307,30,307,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[308,3,308,6],\"els\":[\"0:1819\"]},{\"tk\":[308,7,308,20],\"els\":[\"0:1819\"]},{\"tk\":[308,20,308,21],\"els\":[\"0:1819\"]},{\"tk\":[308,21,308,22],\"els\":[\"0:1819\"]},{\"tk\":[308,24,308,25],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[308,26,308,29],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[308,30,308,48],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[309,3,309,6],\"els\":[\"0:1819\"]},{\"tk\":[309,7,309,20],\"els\":[\"0:1819\"]},{\"tk\":[309,20,309,21],\"els\":[\"0:1819\"]},{\"tk\":[309,21,309,23],\"els\":[\"0:1819\"]},{\"tk\":[309,25,309,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[309,27,309,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[309,31,309,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[310,3,310,6],\"els\":[\"0:1819\"]},{\"tk\":[310,7,310,20],\"els\":[\"0:1819\"]},{\"tk\":[310,20,310,21],\"els\":[\"0:1819\"]},{\"tk\":[310,21,310,23],\"els\":[\"0:1819\"]},{\"tk\":[310,25,310,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[310,27,310,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[310,31,310,50],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[311,3,311,6],\"els\":[\"0:1819\"]},{\"tk\":[311,7,311,20],\"els\":[\"0:1819\"]},{\"tk\":[311,20,311,21],\"els\":[\"0:1819\"]},{\"tk\":[311,21,311,23],\"els\":[\"0:1819\"]},{\"tk\":[311,25,311,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[311,27,311,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[311,31,311,50],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[312,3,312,6],\"els\":[\"0:1819\"]},{\"tk\":[312,7,312,20],\"els\":[\"0:1819\"]},{\"tk\":[312,20,312,21],\"els\":[\"0:1819\"]},{\"tk\":[312,21,312,23],\"els\":[\"0:1819\"]},{\"tk\":[312,25,312,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[312,27,312,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[312,31,312,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[313,3,313,6],\"els\":[\"0:1819\"]},{\"tk\":[313,7,313,20],\"els\":[\"0:1819\"]},{\"tk\":[313,20,313,21],\"els\":[\"0:1819\"]},{\"tk\":[313,21,313,23],\"els\":[\"0:1819\"]},{\"tk\":[313,25,313,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[313,27,313,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[313,31,313,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[314,3,314,6],\"els\":[\"0:1819\"]},{\"tk\":[314,7,314,20],\"els\":[\"0:1819\"]},{\"tk\":[314,20,314,21],\"els\":[\"0:1819\"]},{\"tk\":[314,21,314,23],\"els\":[\"0:1819\"]},{\"tk\":[314,25,314,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[314,27,314,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[314,31,314,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[315,3,315,6],\"els\":[\"0:1819\"]},{\"tk\":[315,7,315,20],\"els\":[\"0:1819\"]},{\"tk\":[315,20,315,21],\"els\":[\"0:1819\"]},{\"tk\":[315,21,315,23],\"els\":[\"0:1819\"]},{\"tk\":[315,25,315,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[315,27,315,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[315,31,315,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[316,3,316,6],\"els\":[\"0:1819\"]},{\"tk\":[316,7,316,20],\"els\":[\"0:1819\"]},{\"tk\":[316,20,316,21],\"els\":[\"0:1819\"]},{\"tk\":[316,21,316,23],\"els\":[\"0:1819\"]},{\"tk\":[316,25,316,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[316,27,316,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[316,31,316,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[317,3,317,6],\"els\":[\"0:1819\"]},{\"tk\":[317,7,317,20],\"els\":[\"0:1819\"]},{\"tk\":[317,20,317,21],\"els\":[\"0:1819\"]},{\"tk\":[317,21,317,23],\"els\":[\"0:1819\"]},{\"tk\":[317,25,317,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[317,27,317,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[317,31,317,50],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[318,3,318,6],\"els\":[\"0:1819\"]},{\"tk\":[318,7,318,20],\"els\":[\"0:1819\"]},{\"tk\":[318,20,318,21],\"els\":[\"0:1819\"]},{\"tk\":[318,21,318,23],\"els\":[\"0:1819\"]},{\"tk\":[318,25,318,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[318,27,318,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[318,31,318,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[319,3,319,6],\"els\":[\"0:1819\"]},{\"tk\":[319,7,319,20],\"els\":[\"0:1819\"]},{\"tk\":[319,20,319,21],\"els\":[\"0:1819\"]},{\"tk\":[319,21,319,23],\"els\":[\"0:1819\"]},{\"tk\":[319,25,319,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[319,27,319,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[319,31,319,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[320,3,320,6],\"els\":[\"0:1819\"]},{\"tk\":[320,7,320,20],\"els\":[\"0:1819\"]},{\"tk\":[320,20,320,21],\"els\":[\"0:1819\"]},{\"tk\":[320,21,320,23],\"els\":[\"0:1819\"]},{\"tk\":[320,25,320,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[320,27,320,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[320,31,320,49],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[321,3,321,6],\"els\":[\"0:1819\"]},{\"tk\":[321,7,321,20],\"els\":[\"0:1819\"]},{\"tk\":[321,20,321,21],\"els\":[\"0:1819\"]},{\"tk\":[321,21,321,23],\"els\":[\"0:1819\"]},{\"tk\":[321,25,321,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[321,27,321,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[321,31,321,47],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[322,3,322,6],\"els\":[\"0:1819\"]},{\"tk\":[322,7,322,20],\"els\":[\"0:1819\"]},{\"tk\":[322,20,322,21],\"els\":[\"0:1819\"]},{\"tk\":[322,21,322,23],\"els\":[\"0:1819\"]},{\"tk\":[322,25,322,26],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[322,27,322,30],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[322,31,322,47],\"els\":[\"0:1819\",\"0:3\",\"0:1\"]},{\"tk\":[327,3,327,6],\"els\":[\"0:3185\"]},{\"tk\":[327,7,327,38],\"els\":[\"0:3185\"]},{\"tk\":[327,38,327,39],\"els\":[\"0:3185\"]},{\"tk\":[327,39,327,40],\"els\":[\"0:3185\"]},{\"tk\":[327,42,327,43],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[327,44,327,48],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[327,49,327,65],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[327,65,327,66],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[327,66,327,67],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[328,3,328,6],\"els\":[\"0:3185\"]},{\"tk\":[328,7,328,38],\"els\":[\"0:3185\"]},{\"tk\":[328,38,328,39],\"els\":[\"0:3185\"]},{\"tk\":[328,39,328,40],\"els\":[\"0:3185\"]},{\"tk\":[328,42,328,43],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[328,44,328,48],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[328,49,328,65],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[328,65,328,66],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[328,66,328,67],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[329,3,329,6],\"els\":[\"0:3185\"]},{\"tk\":[329,7,329,38],\"els\":[\"0:3185\"]},{\"tk\":[329,38,329,39],\"els\":[\"0:3185\"]},{\"tk\":[329,39,329,40],\"els\":[\"0:3185\"]},{\"tk\":[329,42,329,43],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[329,44,329,48],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[329,49,329,65],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[329,65,329,66],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[329,66,329,67],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[330,3,330,6],\"els\":[\"0:3185\"]},{\"tk\":[330,7,330,38],\"els\":[\"0:3185\"]},{\"tk\":[330,38,330,39],\"els\":[\"0:3185\"]},{\"tk\":[330,39,330,40],\"els\":[\"0:3185\"]},{\"tk\":[330,42,330,43],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[330,44,330,48],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[330,49,330,65],\"els\":[\"0:3185\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[330,65,330,66],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[330,66,330,67],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,3,331,9],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,11,331,14],\"els\":[\"0:3185\"]},{\"tk\":[331,15,331,46],\"els\":[\"0:3185\"]},{\"tk\":[331,46,331,47],\"els\":[\"0:3185\"]},{\"tk\":[331,47,331,48],\"els\":[\"0:3185\"]},{\"tk\":[331,52,331,55],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,56,331,69],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,69,331,70],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,70,331,71],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,74,331,77],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[331,78,331,79],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[332,10,332,16],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,3,335,30],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,30,335,31],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,31,335,32],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,32,335,35],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,35,335,36],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,36,335,67],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,67,335,68],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,68,335,69],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,69,335,70],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[335,70,335,71],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,5,336,6],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,6,336,9],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,9,336,10],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,10,336,29],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,29,336,30],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,31,336,32],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,32,336,35],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,35,336,36],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,36,336,55],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,55,336,56],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[336,56,336,57],\"els\":[\"0:3185\",\"0:3\",\"0:1\"]},{\"tk\":[341,3,341,5],\"els\":[\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[341,7,341,11],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[341,12,341,43],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[341,44,341,46],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[341,47,341,49],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[342,5,342,9],\"els\":[\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[342,10,342,41],\"els\":[\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[342,42,342,43],\"els\":[\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[342,44,342,46],\"els\":[\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[343,5,343,9],\"els\":[\"0:3179:1\",\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[343,10,343,38],\"els\":[\"0:3179:1\",\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[343,39,343,40],\"els\":[\"0:3179:1\",\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[343,41,343,50],\"els\":[\"0:3179:1\",\"0:3179\",\"0:3179::117\",\"0:3\",\"0:1\"]},{\"tk\":[345,5,345,11],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[345,13,345,17],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[345,18,345,46],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[346,11,346,20],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[347,7,347,18],\"els\":[\"0:58#out:1\"]},{\"tk\":[347,19,347,20],\"els\":[\"0:3179:5:131-137\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3179:7:132-138\"]},{\"tk\":[347,21,347,24],\"els\":[\"0:3179:5:131-133\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[347,25,347,44],\"els\":[\"0:3179:5:131-133\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[347,45,347,46],\"els\":[\"0:3179:5:131-137\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[347,47,347,51],\"els\":[\"0:3179:5:136-137\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[347,52,347,68],\"els\":[\"0:3179:5:136-137\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[347,68,347,69],\"els\":[\"0:3179:5:136-137\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[347,69,347,70],\"els\":[\"0:3179:5:136-137\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,7,348,9],\"els\":[\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,11,348,14],\"els\":[\"0:3179:5:105-111\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,15,348,28],\"els\":[\"0:3179:5:105-111\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,29,348,31],\"els\":[\"0:3179:5:116-126\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,33,348,36],\"els\":[\"0:3179:5:116-120\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,37,348,56],\"els\":[\"0:3179:5:116-120\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,57,348,58],\"els\":[\"0:3179:5:116-126\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[348,59,348,63],\"els\":[\"0:3179:5:123-126\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[348,64,348,80],\"els\":[\"0:3179:5:123-126\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[349,12,349,13],\"els\":[\"0:3179:5:123-126\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[349,13,349,14],\"els\":[\"0:3179:5:123-126\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[349,17,349,19],\"els\":[\"0:3179:5:130-143\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[349,21,349,32],\"els\":[\"0:58#out:1\"]},{\"tk\":[349,33,349,35],\"els\":[\"0:3179:5:130-143\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[349,36,349,41],\"els\":[\"0:3179:5:142-143\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[350,9,350,13],\"els\":[\"0:3179:3\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[350,14,350,42],\"els\":[\"0:3179:3\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[350,43,350,44],\"els\":[\"0:3179:3\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[350,45,350,55],\"els\":[\"0:3179:3\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,14,351,16],\"els\":[\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,18,351,21],\"els\":[\"0:3179:7:105-111\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,22,351,35],\"els\":[\"0:3179:7:105-111\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,36,351,38],\"els\":[\"0:3179:7:164-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,41,351,44],\"els\":[\"0:3179:7:117-121\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,45,351,64],\"els\":[\"0:3179:7:117-121\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[351,65,351,66],\"els\":[\"0:3179:7:117-127\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[352,20,352,24],\"els\":[\"0:3179:7:124-127\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[352,25,352,41],\"els\":[\"0:3179:7:124-127\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[352,41,352,42],\"els\":[\"0:3179:7:124-127\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[352,42,352,43],\"els\":[\"0:3179:7:124-127\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[352,46,352,48],\"els\":[\"0:3179:7:131-143\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[352,62,352,63],\"els\":[\"0:3179:7:131-143\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[352,64,352,69],\"els\":[\"0:3179:7:142-143\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[352,71,352,73],\"els\":[\"0:3179:7:164-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[353,21,353,24],\"els\":[\"0:3179:7:149-153\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[353,25,353,44],\"els\":[\"0:3179:7:149-153\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[353,45,353,47],\"els\":[\"0:3179:7:149-160\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[353,48,353,52],\"els\":[\"0:3179:7:157-160\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[353,53,353,69],\"els\":[\"0:3179:7:157-160\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[353,69,353,70],\"els\":[\"0:3179:7:157-160\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[353,70,353,71],\"els\":[\"0:3179:7:157-160\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[353,74,353,76],\"els\":[\"0:3179:7:164-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[354,21,354,24],\"els\":[\"0:3179:7:164-166\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[354,25,354,44],\"els\":[\"0:3179:7:164-166\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[354,45,354,47],\"els\":[\"0:3179:7:164-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[354,48,354,52],\"els\":[\"0:3179:7:170-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[354,53,354,69],\"els\":[\"0:3179:7:170-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[354,69,354,70],\"els\":[\"0:3179:7:170-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[354,70,354,71],\"els\":[\"0:3179:7:170-171\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[355,9,355,13],\"els\":[\"0:3179:4\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[355,14,355,42],\"els\":[\"0:3179:4\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[355,43,355,44],\"els\":[\"0:3179:4\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[355,45,355,55],\"els\":[\"0:3179:4\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[357,9,357,12],\"els\":[\"0:3179::117#out:2\"]},{\"tk\":[357,13,357,16],\"els\":[\"0:3179::117#out:2\"]},{\"tk\":[357,17,357,18],\"els\":[\"0:3179::117#out:2\",\"0:3179:1:49-59\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[357,19,357,23],\"els\":[\"0:3179:1:49-59\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[358,9,358,12],\"els\":[\"0:3179::117#out:3\"]},{\"tk\":[358,13,358,16],\"els\":[\"0:3179::117#out:3\"]},{\"tk\":[358,17,358,18],\"els\":[\"0:3179::117#out:3\",\"0:3179:1:61-72\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[358,19,358,24],\"els\":[\"0:3179:1:61-72\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[359,9,359,12],\"els\":[\"0:3179::117#out:4\"]},{\"tk\":[359,13,359,16],\"els\":[\"0:3179::117#out:4\"]},{\"tk\":[359,17,359,18],\"els\":[\"0:3179::117#out:4\",\"0:3179:1:74-85\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[359,19,359,24],\"els\":[\"0:3179:1:74-85\",\"0:3179:1\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[363,11,363,21],\"els\":[\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[364,7,364,9],\"els\":[\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[364,11,364,12],\"els\":[\"0:3179:6:105-112\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[364,12,364,15],\"els\":[\"0:3179:6:106-112\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[364,16,364,29],\"els\":[\"0:3179:6:106-112\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[365,9,365,13],\"els\":[\"0:3179:1\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[365,14,365,42],\"els\":[\"0:3179:1\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[365,43,365,44],\"els\":[\"0:3179:1\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[365,45,365,54],\"els\":[\"0:3179:1\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,14,366,16],\"els\":[\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,18,366,21],\"els\":[\"0:3179:10:106-112\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,22,366,35],\"els\":[\"0:3179:10:106-112\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,36,366,38],\"els\":[\"0:3179:10:165-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,41,366,44],\"els\":[\"0:3179:10:118-122\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,45,366,64],\"els\":[\"0:3179:10:118-122\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[366,65,366,66],\"els\":[\"0:3179:10:118-128\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[367,20,367,24],\"els\":[\"0:3179:10:125-128\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[367,25,367,41],\"els\":[\"0:3179:10:125-128\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[367,41,367,42],\"els\":[\"0:3179:10:125-128\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[367,42,367,43],\"els\":[\"0:3179:10:125-128\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[367,46,367,48],\"els\":[\"0:3179:10:132-144\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[367,50,367,53],\"els\":[\"0:3179:10:133-135\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[367,54,367,73],\"els\":[\"0:3179:10:133-135\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[367,74,367,75],\"els\":[\"0:3179:10:133-139\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[368,20,368,24],\"els\":[\"0:3179:10:138-139\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[368,25,368,41],\"els\":[\"0:3179:10:138-139\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[368,41,368,42],\"els\":[\"0:3179:10:138-139\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[368,42,368,43],\"els\":[\"0:3179:10:138-139\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[368,45,368,46],\"els\":[\"0:3179:10:132-144\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[368,47,368,52],\"els\":[\"0:3179:10:143-144\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[368,54,368,56],\"els\":[\"0:3179:10:165-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[369,21,369,24],\"els\":[\"0:3179:10:150-154\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[369,25,369,44],\"els\":[\"0:3179:10:150-154\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[369,45,369,47],\"els\":[\"0:3179:10:150-161\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[369,48,369,52],\"els\":[\"0:3179:10:158-161\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[369,53,369,69],\"els\":[\"0:3179:10:158-161\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[369,69,369,70],\"els\":[\"0:3179:10:158-161\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[369,70,369,71],\"els\":[\"0:3179:10:158-161\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[369,74,369,76],\"els\":[\"0:3179:10:165-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[370,21,370,24],\"els\":[\"0:3179:10:165-167\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[370,25,370,44],\"els\":[\"0:3179:10:165-167\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[370,45,370,47],\"els\":[\"0:3179:10:165-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[370,48,370,52],\"els\":[\"0:3179:10:171-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[370,53,370,69],\"els\":[\"0:3179:10:171-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[370,69,370,70],\"els\":[\"0:3179:10:171-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[370,70,370,71],\"els\":[\"0:3179:10:171-172\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[371,9,371,13],\"els\":[\"0:3179:4\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[371,14,371,42],\"els\":[\"0:3179:4\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[371,43,371,44],\"els\":[\"0:3179:4\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[371,45,371,55],\"els\":[\"0:3179:4\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[373,9,373,12],\"els\":[\"0:3179::117#out:2\"]},{\"tk\":[373,13,373,16],\"els\":[\"0:3179::117#out:2\"]},{\"tk\":[373,17,373,18],\"els\":[\"0:3179::117#out:2\",\"0:3179:3:50-61\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[373,19,373,24],\"els\":[\"0:3179:3:50-61\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[374,9,374,12],\"els\":[\"0:3179::117#out:3\"]},{\"tk\":[374,13,374,16],\"els\":[\"0:3179::117#out:3\"]},{\"tk\":[374,17,374,18],\"els\":[\"0:3179::117#out:3\",\"0:3179:3:63-74\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[374,19,374,24],\"els\":[\"0:3179:3:63-74\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[375,9,375,12],\"els\":[\"0:3179::117#out:4\"]},{\"tk\":[375,13,375,16],\"els\":[\"0:3179::117#out:4\"]},{\"tk\":[375,17,375,18],\"els\":[\"0:3179::117#out:4\",\"0:3179:3:76-86\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[375,19,375,23],\"els\":[\"0:3179:3:76-86\",\"0:3179:3\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[381,7,381,9],\"els\":[\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[381,11,381,12],\"els\":[\"0:3179:8:105-112\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[381,12,381,15],\"els\":[\"0:3179:8:106-112\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[381,16,381,29],\"els\":[\"0:3179:8:106-112\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[382,9,382,13],\"els\":[\"0:3179:1\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[382,14,382,42],\"els\":[\"0:3179:1\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[382,43,382,44],\"els\":[\"0:3179:1\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[382,45,382,54],\"els\":[\"0:3179:1\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,14,383,16],\"els\":[\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,18,383,21],\"els\":[\"0:3179:9:105-111\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,22,383,35],\"els\":[\"0:3179:9:105-111\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,36,383,38],\"els\":[\"0:3179:9:116-126\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,40,383,43],\"els\":[\"0:3179:9:116-120\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,44,383,63],\"els\":[\"0:3179:9:116-120\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[383,64,383,65],\"els\":[\"0:3179:9:116-126\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[384,19,384,23],\"els\":[\"0:3179:9:123-126\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[384,24,384,40],\"els\":[\"0:3179:9:123-126\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[384,40,384,41],\"els\":[\"0:3179:9:123-126\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[384,41,384,42],\"els\":[\"0:3179:9:123-126\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[384,45,384,47],\"els\":[\"0:3179:9:130-143\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[384,49,384,52],\"els\":[\"0:3179:9:131-133\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[384,53,384,72],\"els\":[\"0:3179:9:131-133\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[384,73,384,74],\"els\":[\"0:3179:9:131-137\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[385,19,385,23],\"els\":[\"0:3179:9:136-137\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[385,24,385,40],\"els\":[\"0:3179:9:136-137\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[385,40,385,41],\"els\":[\"0:3179:9:136-137\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[385,41,385,42],\"els\":[\"0:3179:9:136-137\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[385,44,385,46],\"els\":[\"0:3179:9:130-143\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[385,47,385,52],\"els\":[\"0:3179:9:142-143\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[386,9,386,13],\"els\":[\"0:3179:3\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[386,14,386,42],\"els\":[\"0:3179:3\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[386,43,386,44],\"els\":[\"0:3179:3\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[386,45,386,55],\"els\":[\"0:3179:3\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[388,9,388,12],\"els\":[\"0:3179::117#out:2\"]},{\"tk\":[388,13,388,16],\"els\":[\"0:3179::117#out:2\"]},{\"tk\":[388,17,388,18],\"els\":[\"0:3179::117#out:2\",\"0:3179:4:50-61\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[388,19,388,24],\"els\":[\"0:3179:4:50-61\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[389,9,389,12],\"els\":[\"0:3179::117#out:3\"]},{\"tk\":[389,13,389,16],\"els\":[\"0:3179::117#out:3\"]},{\"tk\":[389,17,389,18],\"els\":[\"0:3179::117#out:3\",\"0:3179:4:63-73\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[389,19,389,23],\"els\":[\"0:3179:4:63-73\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[390,9,390,12],\"els\":[\"0:3179::117#out:4\"]},{\"tk\":[390,13,390,16],\"els\":[\"0:3179::117#out:4\"]},{\"tk\":[390,17,390,18],\"els\":[\"0:3179::117#out:4\",\"0:3179:4:75-86\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[390,19,390,24],\"els\":[\"0:3179:4:75-86\",\"0:3179:4\",\"0:3179::117\",\"0:3179\",\"0:3\",\"0:1\"]},{\"tk\":[401,3,401,5],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[401,6,401,7],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[401,7,401,10],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[401,10,401,11],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[401,11,401,14],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[401,14,401,15],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[401,16,401,17],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,5,402,21],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,21,402,22],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,22,402,25],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,25,402,26],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,27,402,30],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,30,402,32],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,32,402,33],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,33,402,34],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[402,34,402,35],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[403,3,403,4],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[403,5,403,9],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[403,10,403,11],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,5,404,23],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,23,404,24],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,24,404,27],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,27,404,28],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,29,404,32],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,32,404,34],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,34,404,35],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,35,404,36],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[404,36,404,37],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[405,3,405,4],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[410,3,410,5],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[410,6,410,7],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[410,7,410,10],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[410,10,410,11],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[410,11,410,14],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[410,14,410,15],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[410,16,410,17],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,5,411,21],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,21,411,22],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,22,411,25],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,25,411,26],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,27,411,30],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,30,411,32],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,32,411,33],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,33,411,34],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[411,34,411,35],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[412,3,412,4],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[412,5,412,9],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[412,10,412,11],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,5,413,23],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,23,413,24],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,24,413,27],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,27,413,28],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,29,413,32],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,32,413,34],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,34,413,35],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,35,413,36],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[413,36,413,37],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[414,3,414,4],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[419,3,419,5],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[419,6,419,7],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[419,7,419,10],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[419,10,419,11],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[419,11,419,14],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[419,14,419,15],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[419,16,419,17],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,5,420,21],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,21,420,22],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,22,420,25],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,25,420,26],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,27,420,30],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,30,420,32],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,32,420,34],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,34,420,35],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[420,35,420,36],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[421,3,421,4],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[421,5,421,9],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[421,10,421,11],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,5,422,23],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,23,422,24],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,24,422,27],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,27,422,28],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,29,422,32],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,32,422,34],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,34,422,36],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,36,422,37],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[422,37,422,38],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[423,3,423,4],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[426,3,426,4],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[427,5,427,22],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[427,23,427,36],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[427,37,427,38],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[427,39,427,40],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[428,7,428,8],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[428,8,428,23],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[428,24,428,25],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[428,26,428,31],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[428,31,428,32],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[429,7,429,8],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[429,8,429,15],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[429,16,429,17],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[429,18,429,36],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[430,5,430,6],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[430,6,430,7],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,5,433,23],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,23,433,24],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,24,433,25],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,25,433,26],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,27,433,28],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,28,433,29],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,30,433,31],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,31,433,44],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,44,433,45],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[433,45,433,46],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[434,5,434,13],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[434,14,434,20],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[434,20,434,21],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[437,5,437,25],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[437,25,437,26],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[437,26,437,27],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[437,27,437,28],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[437,28,437,29],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,5,438,26],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,26,438,27],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,27,438,28],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,28,438,29],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,30,438,31],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,31,438,32],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,33,438,34],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,34,438,40],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,40,438,41],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[438,41,438,42],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[439,5,439,8],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[439,8,439,9],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[439,9,439,18],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[439,19,439,20],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[439,21,439,27],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[439,27,439,28],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[440,3,440,4],\"els\":[\"0:2899\",\"0:3\",\"0:1\"]},{\"tk\":[445,3,445,5],\"els\":[\"0:3222\",\"0:3220\",\"0:3\",\"0:1\"]},{\"tk\":[445,7,445,10],\"els\":[\"0:3222\",\"0:3220\",\"0:3\",\"0:1\"]},{\"tk\":[445,11,445,14],\"els\":[\"0:3222\",\"0:3220\",\"0:3\",\"0:1\"]},{\"tk\":[452,5,452,8],\"els\":[\"0:3199#out:1\"]},{\"tk\":[452,9,452,14],\"els\":[\"0:3199#out:1\"]},{\"tk\":[452,15,452,16],\"els\":[\"0:3199#out:1\",\"0:3221\",\"0:3222\",\"0:3220\",\"0:3\",\"0:1\"]},{\"tk\":[452,18,452,19],\"els\":[\"0:2901\",\"0:3\",\"0:1\"]},{\"tk\":[452,28,452,31],\"els\":[\"0:2901\",\"0:3\",\"0:1\"]},{\"tk\":[452,32,452,41],\"els\":[\"0:2901\",\"0:3\",\"0:1\"]},{\"tk\":[452,42,452,43],\"els\":[\"0:2901\",\"0:3\",\"0:1\"]},{\"tk\":[452,44,452,50],\"els\":[\"0:2901\",\"0:3\",\"0:1\",\"0:2900\"]},{\"tk\":[452,52,452,53],\"els\":[\"0:2902\",\"0:3\",\"0:1\"]},{\"tk\":[452,54,452,59],\"els\":[\"0:2902\",\"0:3\",\"0:1\"]},{\"tk\":[460,3,460,5],\"els\":[\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[460,7,460,10],\"els\":[\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[460,11,460,14],\"els\":[\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,5,473,8],\"els\":[\"0:3199#out:1\"]},{\"tk\":[473,9,473,14],\"els\":[\"0:3199#out:1\"]},{\"tk\":[473,15,473,16],\"els\":[\"0:3199#out:1\",\"0:3172\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,19,473,24],\"els\":[\"0:3169\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\",\"0:3194\"]},{\"tk\":[473,25,473,26],\"els\":[\"0:3169\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,28,473,31],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,32,473,51],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,52,473,53],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,54,473,58],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[473,59,473,75],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[473,75,473,76],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,76,473,77],\"els\":[\"0:3170\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[473,81,473,82],\"els\":[\"0:3167\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,18,474,19],\"els\":[\"0:3167\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,27,474,28],\"els\":[\"0:3168\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,30,474,33],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,34,474,53],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,54,474,55],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,56,474,60],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[474,61,474,77],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[474,77,474,78],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[474,78,474,79],\"els\":[\"0:3171\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,18,475,19],\"els\":[\"0:3165\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,20,475,27],\"els\":[\"0:3165\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,29,475,30],\"els\":[\"0:3172\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,31,475,37],\"els\":[\"0:3166\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,38,475,39],\"els\":[\"0:3166\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,40,475,43],\"els\":[\"0:3166\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[475,44,475,63],\"els\":[\"0:3166\",\"0:3164\",\"0:3158\",\"0:3\",\"0:1\"]},{\"tk\":[483,3,483,6],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,6,483,7],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,7,483,22],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,23,483,24],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,25,483,26],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,26,483,43],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,43,483,44],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,44,483,47],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,47,483,48],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,49,483,51],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,52,483,53],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,53,483,54],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,55,483,56],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,57,483,61],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[483,61,483,62],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[488,3,488,6],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,6,488,7],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,7,488,21],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,22,488,23],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,24,488,25],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,25,488,42],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,42,488,43],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,43,488,46],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,46,488,47],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,48,488,50],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,51,488,52],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,52,488,53],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,54,488,55],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,56,488,60],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[488,60,488,61],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[493,3,493,6],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,6,493,7],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,7,493,21],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,22,493,23],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,24,493,25],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,25,493,42],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,42,493,43],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,43,493,46],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,46,493,47],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,48,493,50],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,51,493,52],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,52,493,53],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,54,493,55],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,56,493,60],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[493,60,493,61],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[498,3,498,6],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,6,498,7],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,7,498,21],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,22,498,23],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,24,498,25],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,25,498,42],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,42,498,43],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,43,498,46],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,46,498,47],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,48,498,50],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,51,498,52],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,52,498,53],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,54,498,55],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,56,498,60],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[498,60,498,61],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[503,3,503,6],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,6,503,7],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,7,503,21],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,22,503,23],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,24,503,25],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,25,503,42],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,42,503,43],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,43,503,46],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,46,503,47],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,48,503,50],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,51,503,53],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,53,503,54],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,55,503,56],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,57,503,61],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[503,61,503,62],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[508,3,508,6],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,6,508,7],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,7,508,21],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,22,508,23],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,24,508,25],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,25,508,42],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,42,508,43],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,43,508,46],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,46,508,47],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,48,508,50],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,51,508,53],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,53,508,54],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,55,508,56],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,57,508,61],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[508,61,508,62],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[513,3,513,6],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,6,513,7],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,7,513,21],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,22,513,23],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,24,513,25],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,25,513,42],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,42,513,43],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,43,513,46],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,46,513,47],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,48,513,50],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,51,513,53],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,53,513,54],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,55,513,56],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,57,513,61],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[513,61,513,62],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[518,3,518,6],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,6,518,7],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,7,518,21],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,22,518,23],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,24,518,25],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,25,518,42],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,42,518,43],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,43,518,46],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,46,518,47],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,48,518,50],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,51,518,53],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,53,518,54],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,55,518,56],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,57,518,61],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[518,61,518,62],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[539,3,539,14],\"els\":[\"0:58#out:1\"]},{\"tk\":[539,15,539,16],\"els\":[\"0:58\",\"0:3\",\"0:1\"]},{\"tk\":[539,17,539,18],\"els\":[\"0:57\",\"0:3\",\"0:1\",\"0:56\"]},{\"tk\":[539,28,539,29],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[539,43,539,44],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[539,54,539,57],\"els\":[\"0:2868\",\"0:3\",\"0:1\"]},{\"tk\":[539,58,539,72],\"els\":[\"0:2868\",\"0:3\",\"0:1\"]},{\"tk\":[539,73,539,75],\"els\":[\"0:2872\",\"0:3\",\"0:1\"]},{\"tk\":[539,76,539,77],\"els\":[\"0:2872\",\"0:3\",\"0:1\"]},{\"tk\":[539,79,539,80],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[540,5,540,8],\"els\":[\"0:2867\",\"0:3\",\"0:1\"]},{\"tk\":[540,9,540,24],\"els\":[\"0:2867\",\"0:3\",\"0:1\"]},{\"tk\":[540,26,540,27],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[540,28,540,29],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[540,39,540,42],\"els\":[\"0:2869\",\"0:3\",\"0:1\"]},{\"tk\":[540,43,540,57],\"els\":[\"0:2869\",\"0:3\",\"0:1\"]},{\"tk\":[540,58,540,60],\"els\":[\"0:2873\",\"0:3\",\"0:1\"]},{\"tk\":[540,61,540,62],\"els\":[\"0:2873\",\"0:3\",\"0:1\"]},{\"tk\":[540,65,540,66],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[540,67,540,68],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[541,6,541,9],\"els\":[\"0:2870\",\"0:3\",\"0:1\"]},{\"tk\":[541,10,541,24],\"els\":[\"0:2870\",\"0:3\",\"0:1\"]},{\"tk\":[541,25,541,27],\"els\":[\"0:2874\",\"0:3\",\"0:1\"]},{\"tk\":[541,28,541,29],\"els\":[\"0:2874\",\"0:3\",\"0:1\"]},{\"tk\":[541,32,541,33],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[541,34,541,35],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[541,45,541,48],\"els\":[\"0:2875\",\"0:3\",\"0:1\"]},{\"tk\":[541,49,541,63],\"els\":[\"0:2875\",\"0:3\",\"0:1\"]},{\"tk\":[541,64,541,66],\"els\":[\"0:2879\",\"0:3\",\"0:1\"]},{\"tk\":[541,67,541,68],\"els\":[\"0:2879\",\"0:3\",\"0:1\"]},{\"tk\":[541,71,541,72],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[542,5,542,6],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[542,16,542,19],\"els\":[\"0:2876\",\"0:3\",\"0:1\"]},{\"tk\":[542,20,542,34],\"els\":[\"0:2876\",\"0:3\",\"0:1\"]},{\"tk\":[542,35,542,37],\"els\":[\"0:2880\",\"0:3\",\"0:1\"]},{\"tk\":[542,38,542,39],\"els\":[\"0:2880\",\"0:3\",\"0:1\"]},{\"tk\":[542,42,542,43],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[542,44,542,45],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[542,55,542,58],\"els\":[\"0:2877\",\"0:3\",\"0:1\"]},{\"tk\":[542,59,542,73],\"els\":[\"0:2877\",\"0:3\",\"0:1\"]},{\"tk\":[542,74,542,76],\"els\":[\"0:2881\",\"0:3\",\"0:1\"]},{\"tk\":[542,77,542,78],\"els\":[\"0:2881\",\"0:3\",\"0:1\"]},{\"tk\":[543,5,543,6],\"els\":[\"0:56\",\"0:3\",\"0:1\"]},{\"tk\":[543,8,543,11],\"els\":[\"0:2878\",\"0:3\",\"0:1\"]},{\"tk\":[543,12,543,26],\"els\":[\"0:2878\",\"0:3\",\"0:1\"]},{\"tk\":[543,27,543,29],\"els\":[\"0:2882\",\"0:3\",\"0:1\"]},{\"tk\":[543,30,543,31],\"els\":[\"0:2882\",\"0:3\",\"0:1\"]},{\"tk\":[543,34,543,35],\"els\":[\"0:58\",\"0:3\",\"0:1\"]},{\"tk\":[543,36,543,41],\"els\":[\"0:58\",\"0:3\",\"0:1\"]},{\"tk\":[548,3,548,5],\"els\":[\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[548,7,548,10],\"els\":[\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[548,11,548,14],\"els\":[\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[552,5,552,15],\"els\":[\"0:3156#out:1\"]},{\"tk\":[552,16,552,17],\"els\":[\"0:3156\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[552,18,552,29],\"els\":[\"0:58#out:1\"]},{\"tk\":[552,30,552,31],\"els\":[\"0:3156\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[552,32,552,36],\"els\":[\"0:3156\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[552,37,552,53],\"els\":[\"0:3156\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\",\"0:3224\"]},{\"tk\":[552,53,552,54],\"els\":[\"0:3156\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[552,54,552,55],\"els\":[\"0:3156\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,5,561,8],\"els\":[\"0:3199#out:1\"]},{\"tk\":[561,9,561,14],\"els\":[\"0:3199#out:1\"]},{\"tk\":[561,15,561,16],\"els\":[\"0:3199#out:1\",\"0:3155\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,18,561,25],\"els\":[\"0:3146\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,26,561,27],\"els\":[\"0:3146\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,28,561,38],\"els\":[\"0:3156#out:1\"]},{\"tk\":[561,39,561,40],\"els\":[\"0:3153\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,41,561,45],\"els\":[\"0:3153\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\",\"0:3151\"]},{\"tk\":[561,46,561,64],\"els\":[\"0:3153\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\",\"0:3151\"]},{\"tk\":[561,66,561,67],\"els\":[\"0:3155\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,68,561,74],\"els\":[\"0:3142\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[561,75,561,76],\"els\":[\"0:3142\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[562,7,562,18],\"els\":[\"0:58#out:1\"]},{\"tk\":[569,5,569,9],\"els\":[\"0:3150\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\",\"0:3151\"]},{\"tk\":[569,10,569,28],\"els\":[\"0:3150\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\",\"0:3151\"]},{\"tk\":[569,29,569,31],\"els\":[\"0:3150\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[569,32,569,37],\"els\":[\"0:3145\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[569,38,569,39],\"els\":[\"0:3145\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[569,40,569,50],\"els\":[\"0:3156#out:1\"]},{\"tk\":[569,51,569,52],\"els\":[\"0:3149\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[569,53,569,58],\"els\":[\"0:3149\",\"0:3141\",\"0:3138\",\"0:3\",\"0:1\"]},{\"tk\":[577,3,577,6],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,6,577,7],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,7,577,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,29,577,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,31,577,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,49,577,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,50,577,54],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,54,577,55],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[577,55,577,56],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,3,578,6],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,6,578,7],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,7,578,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,29,578,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,31,578,62],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,62,578,63],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,63,578,67],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,67,578,68],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[578,68,578,69],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,3,579,6],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,6,579,7],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,7,579,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,29,579,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,31,579,57],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,57,579,58],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,58,579,62],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,62,579,63],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[579,63,579,64],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,3,580,6],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,6,580,7],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,7,580,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,29,580,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,31,580,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,49,580,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,50,580,54],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,54,580,55],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[580,55,580,56],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[581,3,581,29],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[581,29,581,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[581,30,581,34],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[581,34,581,35],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[581,35,581,36],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[591,3,591,7],\"els\":[\"0:2891\",\"0:3\",\"0:1\",\"0:2893\"]},{\"tk\":[591,8,591,25],\"els\":[\"0:2891\",\"0:3\",\"0:1\",\"0:2893\"]},{\"tk\":[591,26,591,28],\"els\":[\"0:2891\",\"0:3\",\"0:1\"]},{\"tk\":[591,29,591,30],\"els\":[\"0:2888\",\"0:3\",\"0:1\"]},{\"tk\":[591,39,591,40],\"els\":[\"0:2887\",\"0:3\",\"0:1\"]},{\"tk\":[591,49,591,52],\"els\":[\"0:2890\",\"0:3\",\"0:1\"]},{\"tk\":[591,53,591,74],\"els\":[\"0:2890\",\"0:3\",\"0:1\"]},{\"tk\":[591,75,591,76],\"els\":[\"0:2890\",\"0:3\",\"0:1\"]},{\"tk\":[592,5,592,9],\"els\":[\"0:2890\",\"0:3\",\"0:1\",\"0:2892\"]},{\"tk\":[592,10,592,28],\"els\":[\"0:2890\",\"0:3\",\"0:1\",\"0:2892\"]},{\"tk\":[592,30,592,31],\"els\":[\"0:2889\",\"0:3\",\"0:1\"]},{\"tk\":[592,32,592,37],\"els\":[\"0:2889\",\"0:3\",\"0:1\"]},{\"tk\":[598,3,598,6],\"els\":[\"0:62#out:1\"]},{\"tk\":[598,7,598,11],\"els\":[\"0:62#out:1\"]},{\"tk\":[598,12,598,13],\"els\":[\"0:62#out:1\",\"0:62\",\"0:3\",\"0:1\"]},{\"tk\":[598,14,598,27],\"els\":[\"0:2898\",\"0:3\",\"0:1\"]},{\"tk\":[598,28,598,29],\"els\":[\"0:2898\",\"0:3\",\"0:1\"]},{\"tk\":[598,30,598,34],\"els\":[\"0:2898\",\"0:3\",\"0:1\",\"0:2893\"]},{\"tk\":[598,35,598,52],\"els\":[\"0:2898\",\"0:3\",\"0:1\",\"0:2893\"]},{\"tk\":[598,53,598,54],\"els\":[\"0:62\",\"0:3\",\"0:1\"]},{\"tk\":[598,55,598,56],\"els\":[\"0:62\",\"0:3\",\"0:1\"]},{\"tk\":[603,3,603,6],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,6,603,7],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,7,603,23],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,24,603,25],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,26,603,27],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,27,603,44],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,44,603,45],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,45,603,48],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,48,603,49],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,50,603,52],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,53,603,55],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,55,603,56],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,57,603,58],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,59,603,63],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[603,63,603,64],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[607,3,607,5],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[607,7,607,11],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[607,12,607,43],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[607,44,607,46],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[607,47,607,48],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[609,5,609,8],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\",\"0:3035#out:1\"]},{\"tk\":[609,9,609,31],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\",\"0:3035#out:1\"]},{\"tk\":[609,32,609,33],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\",\"0:3035#out:1\"]},{\"tk\":[609,34,609,38],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[609,39,609,68],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[612,5,612,8],\"els\":[\"0:3035#out:1\"]},{\"tk\":[612,9,612,31],\"els\":[\"0:3035#out:1\"]},{\"tk\":[612,32,612,33],\"els\":[\"0:3035#out:1\",\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[612,34,612,39],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[612,40,612,41],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[612,42,612,43],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[612,52,612,75],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[613,7,613,8],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[613,9,613,13],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[613,14,613,43],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[613,44,613,45],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[613,46,613,50],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[613,51,613,80],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[619,3,619,5],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[619,7,619,11],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[619,12,619,43],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[619,44,619,46],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[619,47,619,48],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[621,5,621,8],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\",\"0:3054#out:1\"]},{\"tk\":[621,9,621,32],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\",\"0:3054#out:1\"]},{\"tk\":[621,33,621,34],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\",\"0:3054#out:1\"]},{\"tk\":[621,35,621,39],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[621,40,621,70],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[624,5,624,8],\"els\":[\"0:3054#out:1\"]},{\"tk\":[624,9,624,32],\"els\":[\"0:3054#out:1\"]},{\"tk\":[624,33,624,34],\"els\":[\"0:3054#out:1\",\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[624,35,624,40],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[624,41,624,42],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[624,43,624,44],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[624,53,624,76],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[625,7,625,8],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[625,9,625,13],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[625,14,625,44],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[625,45,625,46],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[626,7,626,11],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[626,12,626,42],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,3,632,24],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,24,632,25],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,25,632,26],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,26,632,29],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,29,632,30],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,30,632,52],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,52,632,53],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,54,632,55],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,55,632,58],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,58,632,59],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,59,632,63],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[632,63,632,64],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,25,633,26],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,26,633,29],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,29,633,30],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,30,633,53],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,53,633,54],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,55,633,56],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,56,633,59],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,59,633,60],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,60,633,81],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[633,81,633,82],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,25,634,26],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,26,634,29],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,29,634,30],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,30,634,51],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,51,634,52],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,53,634,54],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,54,634,57],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,57,634,58],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,58,634,77],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[634,77,634,78],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,25,635,26],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,26,635,34],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,34,635,35],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,35,635,42],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,42,635,43],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,44,635,45],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,45,635,46],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,47,635,48],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,48,635,56],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,56,635,57],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,57,635,64],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,64,635,65],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,66,635,67],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,67,635,68],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[635,68,635,69],\"els\":[\"0:3044\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[638,3,638,5],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[638,7,638,11],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[638,12,638,43],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[638,44,638,46],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[638,47,638,48],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[640,5,640,9],\"els\":[\"0:3052#out:1\"]},{\"tk\":[640,10,640,41],\"els\":[\"0:3052#out:1\"]},{\"tk\":[640,42,640,44],\"els\":[\"0:3052#out:1\",\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[640,45,640,50],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[640,51,640,52],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[640,53,640,54],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[641,7,641,30],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[641,31,641,32],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[641,33,641,37],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[641,38,641,69],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[647,3,647,5],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[647,7,647,11],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[647,12,647,43],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[647,44,647,46],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[647,47,647,48],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[649,5,649,9],\"els\":[\"0:3053#out:1\"]},{\"tk\":[649,10,649,40],\"els\":[\"0:3053#out:1\"]},{\"tk\":[649,41,649,43],\"els\":[\"0:3053#out:1\",\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[649,44,649,49],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[649,50,649,51],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[649,52,649,53],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[650,7,650,30],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[650,31,650,32],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[650,33,650,37],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[650,38,650,68],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[660,3,660,7],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[660,8,660,39],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[660,40,660,41],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[660,42,660,44],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[661,3,661,7],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[661,8,661,37],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[661,38,661,39],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[661,40,661,43],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[661,44,661,66],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,3,662,7],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,8,662,37],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,38,662,39],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,41,662,44],\"els\":[\"0:3038\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,45,662,50],\"els\":[\"0:3038\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,51,662,52],\"els\":[\"0:3038\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,53,662,59],\"els\":[\"0:3037\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[662,60,662,61],\"els\":[\"0:3037\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[663,5,663,8],\"els\":[\"0:3037\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[663,9,663,31],\"els\":[\"0:3037\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[663,33,663,34],\"els\":[\"0:3036\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[663,35,663,42],\"els\":[\"0:3036\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[666,3,666,7],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[666,8,666,39],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[666,40,666,41],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[666,42,666,44],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[667,3,667,7],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[667,8,667,38],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[667,39,667,40],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[667,41,667,44],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[667,45,667,68],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[668,3,668,7],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[668,8,668,38],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[668,39,668,40],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[668,41,668,44],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[668,45,668,64],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[671,3,671,7],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[671,8,671,39],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[671,40,671,41],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[671,42,671,44],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[672,3,672,7],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[672,8,672,39],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[672,40,672,41],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[672,42,672,45],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[672,46,672,67],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[675,3,675,7],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[675,8,675,39],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[675,40,675,41],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[675,42,675,44],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[676,3,676,7],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[676,8,676,38],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[676,39,676,40],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[676,41,676,44],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[676,45,676,66],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[681,3,681,6],\"els\":[\"0:3062:44#out:1\"]},{\"tk\":[681,7,681,16],\"els\":[\"0:3062:44#out:1\"]},{\"tk\":[681,17,681,18],\"els\":[\"0:3062:44#out:1\",\"0:3062:44\",\"0:3\",\"0:1\"]},{\"tk\":[681,19,681,23],\"els\":[\"0:3062:44\",\"0:3\",\"0:1\"]},{\"tk\":[681,24,681,42],\"els\":[\"0:3062:44\",\"0:3\",\"0:1\"]},{\"tk\":[684,3,684,4],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,5,685,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,12,685,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,19,685,32],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,33,685,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,35,685,36],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,36,685,42],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,42,685,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[685,43,685,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[686,5,686,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[686,12,686,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[686,13,686,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[686,15,686,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[686,20,686,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[687,5,687,8],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[687,9,687,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[687,10,687,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,5,690,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,11,690,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,13,690,17],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,17,690,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,19,690,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,20,690,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,23,690,24],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,24,690,33],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,33,690,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,34,690,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,36,690,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,47,690,48],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[690,48,690,49],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,5,693,8],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,9,693,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,10,693,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,11,693,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,12,693,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,13,693,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,15,693,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,16,693,17],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,17,693,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,23,693,24],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,25,693,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,26,693,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,28,693,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[693,30,693,31],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,7,694,9],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,10,694,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,11,694,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,13,694,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,14,694,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,15,694,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,16,694,17],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,17,694,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,19,694,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,21,694,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,26,694,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[694,28,694,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[695,9,695,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[695,10,695,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[695,12,695,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[696,9,696,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[696,14,696,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[697,7,697,8],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[698,5,698,6],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,5,702,6],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,7,702,8],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,9,702,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,15,702,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,17,702,19],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,19,702,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,20,702,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,21,702,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,22,702,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,23,702,24],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[702,24,702,25],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,5,703,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,12,703,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,14,703,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,16,703,17],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,17,703,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,18,703,19],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,19,703,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,20,703,24],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[703,24,703,25],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[704,5,704,6],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[705,6,705,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[705,11,705,19],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[705,19,705,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,7,707,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,10,707,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,11,707,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,22,707,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,24,707,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,26,707,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,27,707,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,28,707,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,29,707,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,30,707,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,34,707,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,35,707,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,43,707,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,44,707,49],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,49,707,50],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,50,707,51],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,51,707,52],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[707,53,707,54],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,9,708,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,10,708,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,11,708,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,12,708,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,14,708,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,15,708,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,16,708,17],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,17,708,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,18,708,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,22,708,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,23,708,31],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,31,708,32],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,32,708,38],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,38,708,39],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,39,708,40],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,40,708,41],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,41,708,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,43,708,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,44,708,45],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,45,708,46],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,46,708,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,47,708,51],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,51,708,52],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,52,708,60],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,60,708,61],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,61,708,65],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,65,708,66],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,66,708,67],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,67,708,68],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,68,708,69],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,69,708,71],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,71,708,72],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,72,708,73],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,73,708,74],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[708,74,708,75],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,9,709,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,13,709,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,14,709,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,22,709,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,23,709,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,28,709,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,29,709,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,30,709,31],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,31,709,32],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[709,32,709,33],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,7,710,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,10,710,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,11,710,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,22,710,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,24,710,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,26,710,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,27,710,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,28,710,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,29,710,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,30,710,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,34,710,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,35,710,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,43,710,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,44,710,49],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,49,710,50],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,50,710,51],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,51,710,52],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[710,53,710,54],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,9,711,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,10,711,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,11,711,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,12,711,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,14,711,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,15,711,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,16,711,17],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,17,711,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,18,711,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,22,711,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,23,711,31],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,31,711,32],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,32,711,38],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,38,711,39],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,39,711,40],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,40,711,41],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,41,711,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,43,711,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,44,711,45],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,45,711,46],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,46,711,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,47,711,51],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,51,711,52],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,52,711,60],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,60,711,61],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,61,711,65],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,65,711,66],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,66,711,67],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,67,711,68],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,68,711,69],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,69,711,71],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,71,711,72],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,72,711,73],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,73,711,74],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[711,74,711,75],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,9,712,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,13,712,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,14,712,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,22,712,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,23,712,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,28,712,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,29,712,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,30,712,31],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,31,712,32],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[712,32,712,33],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[713,7,713,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[713,12,713,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[715,6,715,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[715,11,715,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[715,22,715,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,7,716,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,10,716,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,11,716,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,22,716,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,24,716,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,26,716,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,27,716,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,28,716,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,29,716,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,30,716,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,34,716,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,35,716,46],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,46,716,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,47,716,53],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,53,716,54],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,54,716,55],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,55,716,56],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,57,716,58],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,59,716,61],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,61,716,62],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,62,716,63],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,63,716,64],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[716,64,716,65],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[717,9,717,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[717,13,717,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[717,14,717,25],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[717,25,717,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[717,26,717,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,9,718,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,10,718,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,13,718,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,15,718,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,16,718,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,22,718,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,23,718,24],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,24,718,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,26,718,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,27,718,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,28,718,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,29,718,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,30,718,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,34,718,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,35,718,46],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,46,718,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,47,718,50],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,50,718,51],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,51,718,52],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,52,718,53],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,53,718,54],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,54,718,55],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,55,718,57],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,57,718,58],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,58,718,59],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,59,718,60],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,60,718,61],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,61,718,65],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,65,718,66],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,66,718,77],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,77,718,78],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,78,718,79],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[718,79,718,80],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,14,719,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,16,719,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,18,719,19],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,19,719,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,20,719,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,21,719,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,22,719,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,26,719,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,27,719,38],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,38,719,39],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,39,719,41],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,42,719,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[719,43,719,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,7,720,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,10,720,11],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,11,720,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,22,720,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,24,720,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,26,720,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,27,720,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,28,720,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,29,720,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,30,720,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,34,720,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,35,720,46],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,46,720,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,47,720,53],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,53,720,54],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,54,720,55],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,55,720,56],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,57,720,58],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,59,720,61],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,61,720,62],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,62,720,63],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,63,720,64],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[720,64,720,65],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[721,9,721,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[721,13,721,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[721,14,721,25],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[721,25,721,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[721,26,721,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,9,722,10],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,10,722,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,13,722,14],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,15,722,16],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,16,722,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,22,722,23],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,23,722,24],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,24,722,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,26,722,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,27,722,28],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,28,722,29],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,29,722,30],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,30,722,34],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,34,722,35],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,35,722,46],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,46,722,47],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,47,722,50],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,50,722,51],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,51,722,52],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,52,722,53],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,53,722,54],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,54,722,55],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,55,722,57],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,57,722,58],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,58,722,59],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,59,722,60],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,60,722,61],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,61,722,65],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,65,722,66],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,66,722,77],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,77,722,78],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,78,722,79],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[722,79,722,80],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,14,723,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,16,723,18],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,18,723,19],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,19,723,20],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,20,723,21],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,21,723,22],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,22,723,26],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,26,723,27],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,27,723,38],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,38,723,39],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,39,723,41],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,42,723,43],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[723,43,723,44],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[724,7,724,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[724,12,724,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[726,6,726,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[726,14,726,15],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[728,7,728,12],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[728,12,728,13],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[729,5,729,6],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[730,3,730,4],\"els\":[\"0:3062:28\",\"0:3\",\"0:1\"]},{\"tk\":[733,3,733,14],\"els\":[\"0:58#out:1\"]},{\"tk\":[733,15,733,16],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[733,17,733,21],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[733,22,733,53],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[733,54,733,55],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[733,56,733,59],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[733,60,733,70],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[734,3,734,13],\"els\":[\"0:3156#out:1\"]},{\"tk\":[734,14,734,15],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[734,16,734,20],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[734,21,734,51],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[734,52,734,53],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[734,54,734,57],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[734,58,734,68],\"els\":[\"0:3062:60\",\"0:3\",\"0:1\"]},{\"tk\":[737,3,737,4],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,5,738,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,12,738,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,19,738,32],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,33,738,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,35,738,36],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,36,738,42],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,42,738,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[738,43,738,44],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[739,5,739,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[739,12,739,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[739,13,739,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[739,15,739,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[739,20,739,21],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[740,5,740,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[740,9,740,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[740,10,740,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,5,743,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,11,743,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,13,743,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,17,743,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,19,743,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,20,743,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,23,743,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,24,743,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,33,743,34],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,34,743,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,36,743,47],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,47,743,48],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[743,48,743,49],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,5,746,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,9,746,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,10,746,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,11,746,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,12,746,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,13,746,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,15,746,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,16,746,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,17,746,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,23,746,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,25,746,26],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,26,746,28],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,28,746,29],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[746,30,746,31],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,7,747,9],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,10,747,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,11,747,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,13,747,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,14,747,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,15,747,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,16,747,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,17,747,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,19,747,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,21,747,26],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,26,747,27],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[747,28,747,29],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[748,9,748,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[748,10,748,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[748,12,748,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[749,9,749,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[749,14,749,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[750,7,750,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[751,5,751,6],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,5,755,6],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,7,755,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,9,755,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,15,755,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,17,755,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,19,755,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,20,755,21],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,21,755,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,22,755,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,23,755,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[755,24,755,25],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,5,756,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,12,756,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,14,756,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,16,756,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,17,756,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,18,756,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,19,756,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,20,756,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[756,24,756,25],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[757,5,757,6],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[758,6,758,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[758,11,758,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[758,19,758,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[761,7,761,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[762,9,762,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[762,16,762,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[762,18,762,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[762,20,762,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[762,22,762,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[763,9,763,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[763,16,763,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[763,22,763,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,9,764,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,12,764,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,14,764,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,16,764,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,17,764,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,18,764,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,19,764,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,20,764,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,24,764,25],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,25,764,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,33,764,34],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,34,764,38],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,38,764,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,39,764,40],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,40,764,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,42,764,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,44,764,46],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,46,764,47],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,47,764,48],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,48,764,49],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,49,764,50],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,50,764,54],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,54,764,55],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,55,764,63],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,63,764,64],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,64,764,69],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,69,764,70],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,70,764,71],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,71,764,72],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[764,72,764,73],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,9,765,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,12,765,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,14,765,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,16,765,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,17,765,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,18,765,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,19,765,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,20,765,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,24,765,25],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,25,765,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,33,765,34],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,34,765,38],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,38,765,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,39,765,40],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,40,765,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,42,765,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,44,765,46],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,46,765,47],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,47,765,48],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,48,765,49],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,49,765,50],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,50,765,54],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,54,765,55],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,55,765,63],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,63,765,64],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,64,765,69],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,69,765,70],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,70,765,71],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,71,765,72],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[765,72,765,73],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,9,766,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,16,766,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,18,766,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,22,766,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,23,766,25],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,25,766,26],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,26,766,28],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,29,766,30],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,31,766,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,33,766,34],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,34,766,36],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,36,766,37],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[766,37,766,38],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[767,9,767,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[767,12,767,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[767,15,767,21],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[767,21,767,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[768,9,768,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[768,12,768,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[768,15,768,21],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[768,21,768,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[771,9,771,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[771,12,771,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[771,13,771,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[771,34,771,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[771,36,771,38],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[771,38,771,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,9,772,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,12,772,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,13,772,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,34,772,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,36,772,37],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,37,772,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[772,39,772,40],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[773,9,773,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[773,14,773,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[774,7,774,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[776,6,776,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[776,11,776,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[776,22,776,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[777,7,777,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[778,9,778,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[778,16,778,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[778,17,778,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,9,779,11],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,12,779,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,13,779,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,15,779,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,16,779,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,17,779,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,18,779,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,19,779,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,23,779,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,24,779,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,35,779,36],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,36,779,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,40,779,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,42,779,45],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,45,779,46],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[779,47,779,48],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,11,780,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,13,780,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,15,780,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,16,780,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,17,780,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,18,780,20],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,20,780,21],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,21,780,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,22,780,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,23,780,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,24,780,28],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,28,780,29],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,29,780,40],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,40,780,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,41,780,42],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,42,780,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,44,780,45],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,46,780,48],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,48,780,49],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,49,780,50],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,50,780,51],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,51,780,52],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,52,780,56],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,56,780,57],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,57,780,68],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,68,780,69],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,69,780,71],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[780,71,780,72],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[781,9,781,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[781,11,781,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[781,16,781,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,11,782,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,13,782,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,15,782,16],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,16,782,17],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,17,782,18],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,18,782,19],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,19,782,21],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,21,782,22],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,22,782,23],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,23,782,24],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,24,782,25],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,25,782,29],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,29,782,30],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,30,782,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,41,782,42],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,42,782,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,43,782,44],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,45,782,46],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,47,782,49],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,49,782,50],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,50,782,51],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,51,782,52],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,52,782,53],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,53,782,57],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,57,782,58],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,58,782,69],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,69,782,70],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[782,70,782,72],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[783,13,783,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[783,15,783,31],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[783,31,783,32],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[784,9,784,10],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,9,786,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,12,786,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,13,786,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,34,786,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,36,786,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,39,786,40],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,40,786,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,41,786,42],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[786,42,786,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,9,787,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,12,787,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,13,787,33],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,34,787,35],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,36,787,39],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,39,787,40],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,40,787,41],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,41,787,42],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[787,42,787,43],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[788,9,788,14],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[788,14,788,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[789,7,789,8],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[791,6,791,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[791,14,791,15],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[793,7,793,12],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[793,12,793,13],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[794,5,794,6],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[795,3,795,4],\"els\":[\"0:3062:29\",\"0:3\",\"0:1\"]},{\"tk\":[800,3,800,6],\"els\":[\"0:3062:58#out:1\"]},{\"tk\":[800,7,800,11],\"els\":[\"0:3062:58#out:1\"]},{\"tk\":[800,12,800,13],\"els\":[\"0:3062:58#out:1\",\"0:3062:58\",\"0:3\",\"0:1\"]},{\"tk\":[800,14,800,25],\"els\":[\"0:58#out:1\"]},{\"tk\":[800,26,800,27],\"els\":[\"0:3062:57\",\"0:3\",\"0:1\"]},{\"tk\":[800,28,800,31],\"els\":[\"0:3062:57\",\"0:3\",\"0:1\"]},{\"tk\":[800,32,800,52],\"els\":[\"0:3062:57\",\"0:3\",\"0:1\"]},{\"tk\":[800,53,800,54],\"els\":[\"0:3062:58\",\"0:3\",\"0:1\"]},{\"tk\":[800,55,800,65],\"els\":[\"0:3156#out:1\"]},{\"tk\":[800,66,800,67],\"els\":[\"0:3062:57\",\"0:3\",\"0:1\"]},{\"tk\":[801,5,801,8],\"els\":[\"0:3062:57\",\"0:3\",\"0:1\"]},{\"tk\":[801,9,801,29],\"els\":[\"0:3062:57\",\"0:3\",\"0:1\"]},{\"tk\":[804,3,804,4],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,5,805,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,12,805,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,19,805,32],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,33,805,35],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,35,805,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,36,805,42],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,42,805,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[805,43,805,44],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[806,5,806,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[806,12,806,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[806,13,806,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[806,15,806,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[806,20,806,21],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[807,5,807,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[807,9,807,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[807,10,807,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,5,810,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,11,810,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,13,810,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,17,810,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,19,810,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,20,810,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,23,810,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,24,810,33],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,33,810,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,34,810,35],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,36,810,47],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,47,810,48],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[810,48,810,49],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,5,813,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,9,813,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,10,813,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,11,813,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,12,813,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,13,813,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,15,813,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,16,813,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,17,813,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,23,813,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,25,813,26],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,26,813,28],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,28,813,29],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[813,30,813,31],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,7,814,9],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,10,814,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,11,814,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,13,814,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,14,814,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,15,814,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,16,814,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,17,814,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,19,814,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,21,814,26],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,26,814,27],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[814,28,814,29],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[815,9,815,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[815,10,815,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[815,12,815,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[816,9,816,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[816,14,816,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[817,7,817,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[818,5,818,6],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,5,822,6],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,7,822,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,9,822,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,15,822,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,17,822,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,19,822,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,20,822,21],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,21,822,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,22,822,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,23,822,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[822,24,822,25],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,5,823,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,12,823,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,14,823,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,16,823,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,17,823,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,18,823,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,19,823,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,20,823,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[823,24,823,25],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[824,5,824,6],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[825,6,825,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[825,11,825,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[825,19,825,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[828,7,828,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[829,9,829,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[829,16,829,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[829,18,829,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[829,20,829,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[829,22,829,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[830,9,830,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[830,16,830,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[830,22,830,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,9,831,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,12,831,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,14,831,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,16,831,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,17,831,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,18,831,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,19,831,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,20,831,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,24,831,25],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,25,831,33],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,33,831,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,34,831,38],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,38,831,39],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,39,831,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,40,831,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,42,831,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,44,831,46],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,46,831,47],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,47,831,48],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,48,831,49],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,49,831,50],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,50,831,54],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,54,831,55],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,55,831,63],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,63,831,64],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,64,831,69],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,69,831,70],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,70,831,71],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,71,831,72],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[831,72,831,73],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,9,832,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,12,832,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,14,832,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,16,832,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,17,832,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,18,832,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,19,832,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,20,832,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,24,832,25],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,25,832,33],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,33,832,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,34,832,38],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,38,832,39],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,39,832,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,40,832,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,42,832,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,44,832,46],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,46,832,47],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,47,832,48],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,48,832,49],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,49,832,50],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,50,832,54],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,54,832,55],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,55,832,63],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,63,832,64],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,64,832,69],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,69,832,70],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,70,832,71],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,71,832,72],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[832,72,832,73],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,9,833,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,16,833,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,18,833,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,22,833,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,23,833,25],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,25,833,26],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,26,833,28],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,29,833,30],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,31,833,33],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,33,833,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,34,833,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,36,833,37],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[833,37,833,38],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[834,9,834,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[834,12,834,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[834,15,834,21],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[834,21,834,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[835,9,835,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[835,12,835,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[835,15,835,21],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[835,21,835,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[838,9,838,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[838,12,838,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[838,13,838,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[838,35,838,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[838,37,838,39],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[838,39,838,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,9,839,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,12,839,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,13,839,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,35,839,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,37,839,38],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,38,839,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[839,40,839,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[840,9,840,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[840,14,840,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[841,7,841,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[843,6,843,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[843,11,843,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[843,22,843,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[844,7,844,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[845,9,845,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[845,16,845,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[845,17,845,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,9,846,11],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,12,846,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,13,846,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,15,846,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,16,846,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,17,846,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,18,846,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,19,846,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,23,846,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,24,846,35],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,35,846,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,36,846,39],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,40,846,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,42,846,45],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,45,846,46],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[846,47,846,48],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,11,847,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,13,847,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,15,847,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,16,847,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,17,847,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,18,847,20],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,20,847,21],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,21,847,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,22,847,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,23,847,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,24,847,28],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,28,847,29],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,29,847,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,40,847,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,41,847,42],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,42,847,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,44,847,45],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,46,847,48],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,48,847,49],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,49,847,50],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,50,847,51],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,51,847,52],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,52,847,56],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,56,847,57],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,57,847,68],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,68,847,69],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,69,847,71],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[847,71,847,72],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[848,9,848,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[848,11,848,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[848,16,848,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,11,849,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,13,849,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,15,849,16],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,16,849,17],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,17,849,18],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,18,849,19],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,19,849,21],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,21,849,22],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,22,849,23],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,23,849,24],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,24,849,25],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,25,849,29],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,29,849,30],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,30,849,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,41,849,42],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,42,849,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,43,849,44],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,45,849,46],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,47,849,49],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,49,849,50],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,50,849,51],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,51,849,52],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,52,849,53],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,53,849,57],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,57,849,58],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,58,849,69],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,69,849,70],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[849,70,849,72],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[850,13,850,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[850,15,850,31],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[850,31,850,32],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[851,9,851,10],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,9,853,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,12,853,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,13,853,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,35,853,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,37,853,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,40,853,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,41,853,42],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,42,853,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[853,43,853,44],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,9,854,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,12,854,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,13,854,34],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,35,854,36],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,37,854,40],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,40,854,41],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,41,854,42],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,42,854,43],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[854,43,854,44],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[855,9,855,14],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[855,14,855,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[856,7,856,8],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[858,6,858,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[858,14,858,15],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[860,7,860,12],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[860,12,860,13],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[861,5,861,6],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[862,3,862,4],\"els\":[\"0:1016:64\",\"0:3\",\"0:1\"]},{\"tk\":[865,3,865,4],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,5,866,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,12,866,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,19,866,32],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,33,866,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,35,866,36],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,36,866,42],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,42,866,43],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[866,43,866,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[867,5,867,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[867,12,867,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[867,13,867,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[867,15,867,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[867,20,867,21],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[868,5,868,8],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[868,9,868,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[868,10,868,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,5,871,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,11,871,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,13,871,17],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,17,871,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,19,871,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,20,871,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,23,871,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,24,871,33],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,33,871,34],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,34,871,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,36,871,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,47,871,48],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[871,48,871,49],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,5,874,8],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,9,874,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,10,874,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,11,874,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,12,874,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,13,874,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,15,874,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,16,874,17],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,17,874,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,23,874,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,25,874,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,26,874,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,28,874,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[874,30,874,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,7,875,9],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,10,875,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,11,875,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,13,875,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,14,875,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,15,875,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,16,875,17],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,17,875,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,19,875,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,21,875,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,26,875,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[875,28,875,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[876,9,876,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[876,10,876,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[876,12,876,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[877,9,877,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[877,14,877,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[878,7,878,8],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[879,5,879,6],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,5,883,6],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,7,883,8],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,9,883,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,15,883,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,17,883,19],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,19,883,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,20,883,21],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,21,883,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,22,883,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,23,883,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[883,24,883,25],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,5,884,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,12,884,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,14,884,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,16,884,17],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,17,884,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,18,884,19],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,19,884,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,20,884,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[884,24,884,25],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[885,5,885,6],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[886,6,886,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[886,11,886,19],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[886,19,886,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,7,888,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,10,888,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,11,888,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,23,888,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,25,888,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,27,888,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,28,888,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,29,888,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,30,888,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,31,888,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,35,888,36],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,36,888,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,44,888,45],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,45,888,50],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,50,888,51],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,51,888,52],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,52,888,53],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[888,54,888,55],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,9,889,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,10,889,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,11,889,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,12,889,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,14,889,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,15,889,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,16,889,17],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,17,889,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,18,889,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,22,889,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,23,889,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,31,889,32],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,32,889,38],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,38,889,39],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,39,889,40],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,40,889,41],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,41,889,43],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,43,889,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,44,889,45],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,45,889,46],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,46,889,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,47,889,51],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,51,889,52],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,52,889,60],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,60,889,61],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,61,889,65],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,65,889,66],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,66,889,67],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,67,889,68],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,68,889,69],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,69,889,71],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,71,889,72],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,72,889,73],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,73,889,74],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[889,74,889,75],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,9,890,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,13,890,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,14,890,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,22,890,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,23,890,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,28,890,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,29,890,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,30,890,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,31,890,32],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[890,32,890,33],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,7,891,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,10,891,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,11,891,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,23,891,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,25,891,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,27,891,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,28,891,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,29,891,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,30,891,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,31,891,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,35,891,36],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,36,891,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,44,891,45],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,45,891,50],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,50,891,51],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,51,891,52],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,52,891,53],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[891,54,891,55],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,9,892,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,10,892,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,11,892,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,12,892,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,14,892,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,15,892,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,16,892,17],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,17,892,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,18,892,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,22,892,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,23,892,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,31,892,32],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,32,892,38],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,38,892,39],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,39,892,40],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,40,892,41],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,41,892,43],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,43,892,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,44,892,45],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,45,892,46],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,46,892,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,47,892,51],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,51,892,52],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,52,892,60],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,60,892,61],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,61,892,65],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,65,892,66],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,66,892,67],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,67,892,68],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,68,892,69],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,69,892,71],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,71,892,72],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,72,892,73],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,73,892,74],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[892,74,892,75],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,9,893,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,13,893,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,14,893,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,22,893,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,23,893,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,28,893,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,29,893,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,30,893,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,31,893,32],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[893,32,893,33],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[894,7,894,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[894,12,894,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[896,6,896,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[896,11,896,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[896,22,896,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,7,897,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,10,897,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,11,897,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,23,897,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,25,897,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,27,897,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,28,897,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,29,897,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,30,897,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,31,897,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,35,897,36],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,36,897,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,47,897,48],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,48,897,54],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,54,897,55],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,55,897,56],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,56,897,57],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,58,897,59],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,60,897,62],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,62,897,63],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,63,897,64],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,64,897,65],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[897,65,897,66],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[898,9,898,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[898,13,898,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[898,14,898,25],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[898,25,898,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[898,26,898,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,9,899,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,10,899,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,13,899,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,15,899,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,16,899,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,22,899,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,23,899,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,24,899,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,26,899,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,27,899,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,28,899,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,29,899,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,30,899,34],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,34,899,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,35,899,46],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,46,899,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,47,899,50],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,50,899,51],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,51,899,52],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,52,899,53],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,53,899,54],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,54,899,55],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,55,899,57],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,57,899,58],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,58,899,59],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,59,899,60],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,60,899,61],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,61,899,65],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,65,899,66],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,66,899,77],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,77,899,78],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,78,899,79],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[899,79,899,80],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,14,900,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,16,900,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,18,900,19],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,19,900,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,20,900,21],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,21,900,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,22,900,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,26,900,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,27,900,38],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,38,900,39],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,39,900,41],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,42,900,43],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[900,43,900,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,7,901,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,10,901,11],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,11,901,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,23,901,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,25,901,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,27,901,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,28,901,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,29,901,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,30,901,31],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,31,901,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,35,901,36],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,36,901,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,47,901,48],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,48,901,54],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,54,901,55],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,55,901,56],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,56,901,57],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,58,901,59],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,60,901,62],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,62,901,63],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,63,901,64],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,64,901,65],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[901,65,901,66],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[902,9,902,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[902,13,902,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[902,14,902,25],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[902,25,902,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[902,26,902,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,9,903,10],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,10,903,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,13,903,14],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,15,903,16],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,16,903,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,22,903,23],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,23,903,24],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,24,903,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,26,903,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,27,903,28],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,28,903,29],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,29,903,30],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,30,903,34],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,34,903,35],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,35,903,46],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,46,903,47],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,47,903,50],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,50,903,51],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,51,903,52],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,52,903,53],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,53,903,54],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,54,903,55],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,55,903,57],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,57,903,58],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,58,903,59],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,59,903,60],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,60,903,61],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,61,903,65],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,65,903,66],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,66,903,77],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,77,903,78],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,78,903,79],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[903,79,903,80],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,14,904,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,16,904,18],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,18,904,19],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,19,904,20],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,20,904,21],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,21,904,22],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,22,904,26],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,26,904,27],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,27,904,38],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,38,904,39],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,39,904,41],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,42,904,43],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[904,43,904,44],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[905,7,905,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[905,12,905,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[907,6,907,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[907,14,907,15],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[909,7,909,12],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[909,12,909,13],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[910,5,910,6],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[911,3,911,4],\"els\":[\"0:1016:63\",\"0:3\",\"0:1\"]},{\"tk\":[914,3,914,4],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,5,915,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,12,915,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,19,915,32],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,33,915,35],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,35,915,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,36,915,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,42,915,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[915,43,915,44],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[916,5,916,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[916,12,916,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[916,13,916,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[916,15,916,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[916,20,916,21],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[917,5,917,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[917,9,917,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[917,10,917,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,5,920,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,11,920,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,13,920,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,17,920,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,19,920,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,20,920,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,23,920,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,24,920,37],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,37,920,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,38,920,39],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,39,920,40],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,40,920,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,41,920,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,43,920,54],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,54,920,55],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[920,55,920,56],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,5,923,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,9,923,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,10,923,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,11,923,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,12,923,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,13,923,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,15,923,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,16,923,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,17,923,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,23,923,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,25,923,26],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,26,923,28],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,28,923,29],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[923,30,923,31],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,7,924,9],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,10,924,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,11,924,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,13,924,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,14,924,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,15,924,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,16,924,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,17,924,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,19,924,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,21,924,26],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,26,924,27],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[924,28,924,29],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[925,9,925,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[925,10,925,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[925,12,925,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[926,9,926,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[926,14,926,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[927,7,927,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[928,5,928,6],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,5,932,6],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,7,932,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,9,932,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,15,932,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,17,932,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,19,932,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,20,932,21],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,21,932,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,22,932,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,23,932,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[932,24,932,25],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,5,933,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,12,933,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,14,933,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,16,933,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,17,933,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,18,933,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,19,933,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,20,933,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[933,24,933,25],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[934,5,934,6],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[935,6,935,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[935,11,935,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[935,19,935,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[938,7,938,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[939,9,939,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[939,16,939,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[939,18,939,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[939,20,939,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[939,22,939,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[940,9,940,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[940,16,940,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[940,22,940,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,9,941,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,12,941,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,14,941,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,16,941,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,17,941,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,18,941,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,19,941,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,20,941,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,24,941,25],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,25,941,33],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,33,941,34],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,34,941,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,38,941,39],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,39,941,40],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,40,941,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,42,941,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,44,941,46],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,46,941,47],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,47,941,48],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,48,941,49],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,49,941,50],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,50,941,54],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,54,941,55],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,55,941,63],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,63,941,64],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,64,941,69],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,69,941,70],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,70,941,71],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,71,941,72],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[941,72,941,73],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,9,942,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,12,942,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,14,942,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,16,942,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,17,942,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,18,942,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,19,942,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,20,942,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,24,942,25],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,25,942,33],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,33,942,34],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,34,942,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,38,942,39],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,39,942,40],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,40,942,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,42,942,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,44,942,46],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,46,942,47],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,47,942,48],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,48,942,49],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,49,942,50],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,50,942,54],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,54,942,55],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,55,942,63],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,63,942,64],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,64,942,69],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,69,942,70],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,70,942,71],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,71,942,72],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[942,72,942,73],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,9,943,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,16,943,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,18,943,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,22,943,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,23,943,25],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,25,943,26],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,26,943,28],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,29,943,30],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,31,943,33],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,33,943,34],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,34,943,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,36,943,37],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[943,37,943,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[944,9,944,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[944,12,944,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[944,15,944,21],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[944,21,944,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[945,9,945,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[945,12,945,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[945,15,945,21],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[945,21,945,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[948,9,948,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[948,12,948,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[948,13,948,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[948,37,948,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[948,39,948,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[948,41,948,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,9,949,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,12,949,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,13,949,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,37,949,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,39,949,40],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,40,949,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[949,42,949,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[950,9,950,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[950,14,950,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[951,7,951,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[953,6,953,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[953,11,953,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[953,22,953,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[954,7,954,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[955,9,955,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[955,16,955,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[955,17,955,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,9,956,11],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,12,956,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,13,956,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,15,956,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,16,956,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,17,956,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,18,956,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,19,956,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,23,956,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,24,956,35],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,35,956,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,36,956,39],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,40,956,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,42,956,45],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,45,956,46],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[956,47,956,48],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,11,957,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,13,957,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,15,957,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,16,957,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,17,957,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,18,957,20],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,20,957,21],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,21,957,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,22,957,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,23,957,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,24,957,28],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,28,957,29],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,29,957,40],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,40,957,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,41,957,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,42,957,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,44,957,45],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,46,957,48],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,48,957,49],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,49,957,50],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,50,957,51],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,51,957,52],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,52,957,56],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,56,957,57],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,57,957,68],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,68,957,69],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,69,957,71],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[957,71,957,72],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[958,9,958,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[958,11,958,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[958,16,958,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,11,959,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,13,959,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,15,959,16],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,16,959,17],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,17,959,18],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,18,959,19],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,19,959,21],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,21,959,22],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,22,959,23],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,23,959,24],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,24,959,25],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,25,959,29],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,29,959,30],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,30,959,41],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,41,959,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,42,959,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,43,959,44],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,45,959,46],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,47,959,49],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,49,959,50],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,50,959,51],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,51,959,52],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,52,959,53],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,53,959,57],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,57,959,58],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,58,959,69],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,69,959,70],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[959,70,959,72],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[960,13,960,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[960,15,960,31],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[960,31,960,32],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[961,9,961,10],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,9,963,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,12,963,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,13,963,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,37,963,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,39,963,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,42,963,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,43,963,44],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,44,963,45],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[963,45,963,46],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,9,964,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,12,964,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,13,964,36],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,37,964,38],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,39,964,42],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,42,964,43],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,43,964,44],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,44,964,45],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[964,45,964,46],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[965,9,965,14],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[965,14,965,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[966,7,966,8],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[968,6,968,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[968,14,968,15],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[970,7,970,12],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[970,12,970,13],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[971,5,971,6],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[972,3,972,4],\"els\":[\"0:977:64\",\"0:3\",\"0:1\"]},{\"tk\":[975,3,975,4],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,5,976,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,12,976,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,19,976,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,33,976,35],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,35,976,36],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,36,976,42],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,42,976,43],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[976,43,976,44],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[977,5,977,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[977,12,977,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[977,13,977,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[977,15,977,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[977,20,977,21],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[978,5,978,8],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[978,9,978,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[978,10,978,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,5,981,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,11,981,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,13,981,17],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,17,981,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,19,981,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,20,981,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,23,981,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,24,981,37],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,37,981,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,38,981,39],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,39,981,40],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,40,981,41],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,41,981,42],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,43,981,54],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,54,981,55],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[981,55,981,56],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,5,984,8],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,9,984,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,10,984,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,11,984,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,12,984,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,13,984,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,15,984,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,16,984,17],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,17,984,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,23,984,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,25,984,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,26,984,28],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,28,984,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[984,30,984,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,7,985,9],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,10,985,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,11,985,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,13,985,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,14,985,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,15,985,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,16,985,17],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,17,985,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,19,985,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,21,985,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,26,985,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[985,28,985,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[986,9,986,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[986,10,986,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[986,12,986,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[987,9,987,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[987,14,987,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[988,7,988,8],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[989,5,989,6],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,5,993,6],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,7,993,8],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,9,993,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,15,993,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,17,993,19],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,19,993,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,20,993,21],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,21,993,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,22,993,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,23,993,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[993,24,993,25],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,5,994,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,12,994,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,14,994,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,16,994,17],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,17,994,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,18,994,19],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,19,994,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,20,994,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[994,24,994,25],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[995,5,995,6],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[996,6,996,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[996,11,996,19],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[996,19,996,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,7,998,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,10,998,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,11,998,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,25,998,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,27,998,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,29,998,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,30,998,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,31,998,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,32,998,33],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,33,998,37],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,37,998,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,38,998,46],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,46,998,47],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,47,998,52],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,52,998,53],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,53,998,54],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,54,998,55],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[998,56,998,57],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,9,999,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,10,999,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,11,999,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,12,999,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,14,999,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,15,999,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,16,999,17],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,17,999,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,18,999,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,22,999,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,23,999,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,31,999,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,32,999,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,38,999,39],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,39,999,40],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,40,999,41],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,41,999,43],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,43,999,44],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,44,999,45],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,45,999,46],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,46,999,47],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,47,999,51],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,51,999,52],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,52,999,60],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,60,999,61],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,61,999,65],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,65,999,66],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,66,999,67],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,67,999,68],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,68,999,69],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,69,999,71],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,71,999,72],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,72,999,73],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,73,999,74],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[999,74,999,75],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,9,1000,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,13,1000,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,14,1000,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,22,1000,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,23,1000,28],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,28,1000,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,29,1000,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,30,1000,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,31,1000,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1000,32,1000,33],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,7,1001,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,10,1001,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,11,1001,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,25,1001,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,27,1001,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,29,1001,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,30,1001,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,31,1001,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,32,1001,33],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,33,1001,37],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,37,1001,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,38,1001,46],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,46,1001,47],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,47,1001,52],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,52,1001,53],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,53,1001,54],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,54,1001,55],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1001,56,1001,57],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,9,1002,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,10,1002,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,11,1002,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,12,1002,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,14,1002,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,15,1002,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,16,1002,17],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,17,1002,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,18,1002,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,22,1002,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,23,1002,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,31,1002,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,32,1002,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,38,1002,39],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,39,1002,40],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,40,1002,41],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,41,1002,43],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,43,1002,44],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,44,1002,45],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,45,1002,46],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,46,1002,47],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,47,1002,51],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,51,1002,52],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,52,1002,60],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,60,1002,61],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,61,1002,65],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,65,1002,66],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,66,1002,67],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,67,1002,68],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,68,1002,69],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,69,1002,71],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,71,1002,72],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,72,1002,73],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,73,1002,74],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1002,74,1002,75],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,9,1003,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,13,1003,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,14,1003,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,22,1003,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,23,1003,28],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,28,1003,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,29,1003,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,30,1003,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,31,1003,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1003,32,1003,33],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1004,7,1004,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1004,12,1004,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1006,6,1006,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1006,11,1006,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1006,22,1006,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,7,1007,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,10,1007,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,11,1007,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,25,1007,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,27,1007,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,29,1007,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,30,1007,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,31,1007,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,32,1007,33],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,33,1007,37],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,37,1007,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,38,1007,49],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,49,1007,50],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,50,1007,56],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,56,1007,57],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,57,1007,58],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,58,1007,59],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,60,1007,61],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,62,1007,64],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,64,1007,65],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,65,1007,66],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,66,1007,67],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1007,67,1007,68],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1008,9,1008,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1008,13,1008,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1008,14,1008,25],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1008,25,1008,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1008,26,1008,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,9,1009,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,10,1009,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,13,1009,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,15,1009,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,16,1009,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,22,1009,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,23,1009,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,24,1009,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,26,1009,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,27,1009,28],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,28,1009,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,29,1009,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,30,1009,34],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,34,1009,35],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,35,1009,46],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,46,1009,47],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,47,1009,50],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,50,1009,51],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,51,1009,52],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,52,1009,53],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,53,1009,54],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,54,1009,55],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,55,1009,57],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,57,1009,58],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,58,1009,59],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,59,1009,60],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,60,1009,61],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,61,1009,65],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,65,1009,66],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,66,1009,77],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,77,1009,78],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,78,1009,79],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1009,79,1009,80],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,14,1010,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,16,1010,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,18,1010,19],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,19,1010,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,20,1010,21],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,21,1010,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,22,1010,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,26,1010,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,27,1010,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,38,1010,39],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,39,1010,41],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,42,1010,43],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1010,43,1010,44],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,7,1011,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,10,1011,11],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,11,1011,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,25,1011,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,27,1011,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,29,1011,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,30,1011,31],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,31,1011,32],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,32,1011,33],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,33,1011,37],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,37,1011,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,38,1011,49],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,49,1011,50],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,50,1011,56],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,56,1011,57],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,57,1011,58],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,58,1011,59],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,60,1011,61],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,62,1011,64],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,64,1011,65],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,65,1011,66],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,66,1011,67],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1011,67,1011,68],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1012,9,1012,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1012,13,1012,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1012,14,1012,25],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1012,25,1012,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1012,26,1012,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,9,1013,10],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,10,1013,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,13,1013,14],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,15,1013,16],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,16,1013,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,22,1013,23],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,23,1013,24],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,24,1013,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,26,1013,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,27,1013,28],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,28,1013,29],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,29,1013,30],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,30,1013,34],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,34,1013,35],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,35,1013,46],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,46,1013,47],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,47,1013,50],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,50,1013,51],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,51,1013,52],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,52,1013,53],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,53,1013,54],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,54,1013,55],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,55,1013,57],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,57,1013,58],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,58,1013,59],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,59,1013,60],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,60,1013,61],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,61,1013,65],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,65,1013,66],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,66,1013,77],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,77,1013,78],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,78,1013,79],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1013,79,1013,80],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,14,1014,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,16,1014,18],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,18,1014,19],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,19,1014,20],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,20,1014,21],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,21,1014,22],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,22,1014,26],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,26,1014,27],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,27,1014,38],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,38,1014,39],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,39,1014,41],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,42,1014,43],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1014,43,1014,44],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1015,7,1015,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1015,12,1015,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1017,6,1017,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1017,14,1017,15],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1019,7,1019,12],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1019,12,1019,13],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1020,5,1020,6],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1021,3,1021,4],\"els\":[\"0:977:63\",\"0:3\",\"0:1\"]},{\"tk\":[1024,3,1024,4],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,5,1025,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,12,1025,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,19,1025,32],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,33,1025,35],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,35,1025,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,36,1025,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,42,1025,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1025,43,1025,44],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1026,5,1026,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1026,12,1026,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1026,13,1026,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1026,15,1026,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1026,20,1026,21],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1027,5,1027,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1027,9,1027,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1027,10,1027,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,5,1030,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,11,1030,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,13,1030,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,17,1030,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,19,1030,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,20,1030,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,23,1030,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,24,1030,37],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,37,1030,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,38,1030,39],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,39,1030,40],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,40,1030,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,41,1030,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,43,1030,54],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,54,1030,55],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1030,55,1030,56],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,5,1033,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,9,1033,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,10,1033,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,11,1033,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,12,1033,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,13,1033,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,15,1033,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,16,1033,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,17,1033,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,23,1033,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,25,1033,26],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,26,1033,28],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,28,1033,29],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1033,30,1033,31],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,7,1034,9],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,10,1034,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,11,1034,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,13,1034,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,14,1034,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,15,1034,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,16,1034,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,17,1034,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,19,1034,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,21,1034,26],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,26,1034,27],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1034,28,1034,29],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1035,9,1035,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1035,10,1035,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1035,12,1035,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1036,9,1036,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1036,14,1036,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1037,7,1037,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1038,5,1038,6],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,5,1042,6],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,7,1042,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,9,1042,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,15,1042,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,17,1042,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,19,1042,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,20,1042,21],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,21,1042,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,22,1042,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,23,1042,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1042,24,1042,25],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,5,1043,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,12,1043,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,14,1043,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,16,1043,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,17,1043,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,18,1043,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,19,1043,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,20,1043,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1043,24,1043,25],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1044,5,1044,6],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1045,6,1045,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1045,11,1045,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1045,19,1045,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1048,7,1048,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1049,9,1049,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1049,16,1049,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1049,18,1049,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1049,20,1049,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1049,22,1049,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1050,9,1050,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1050,16,1050,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1050,22,1050,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,9,1051,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,12,1051,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,14,1051,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,16,1051,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,17,1051,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,18,1051,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,19,1051,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,20,1051,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,24,1051,25],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,25,1051,33],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,33,1051,34],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,34,1051,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,38,1051,39],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,39,1051,40],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,40,1051,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,42,1051,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,44,1051,46],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,46,1051,47],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,47,1051,48],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,48,1051,49],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,49,1051,50],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,50,1051,54],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,54,1051,55],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,55,1051,63],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,63,1051,64],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,64,1051,69],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,69,1051,70],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,70,1051,71],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,71,1051,72],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1051,72,1051,73],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,9,1052,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,12,1052,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,14,1052,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,16,1052,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,17,1052,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,18,1052,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,19,1052,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,20,1052,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,24,1052,25],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,25,1052,33],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,33,1052,34],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,34,1052,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,38,1052,39],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,39,1052,40],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,40,1052,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,42,1052,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,44,1052,46],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,46,1052,47],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,47,1052,48],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,48,1052,49],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,49,1052,50],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,50,1052,54],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,54,1052,55],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,55,1052,63],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,63,1052,64],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,64,1052,69],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,69,1052,70],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,70,1052,71],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,71,1052,72],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1052,72,1052,73],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,9,1053,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,16,1053,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,18,1053,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,22,1053,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,23,1053,25],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,25,1053,26],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,26,1053,28],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,29,1053,30],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,31,1053,33],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,33,1053,34],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,34,1053,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,36,1053,37],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1053,37,1053,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1054,9,1054,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1054,12,1054,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1054,15,1054,21],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1054,21,1054,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1055,9,1055,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1055,12,1055,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1055,15,1055,21],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1055,21,1055,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1058,9,1058,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1058,12,1058,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1058,13,1058,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1058,37,1058,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1058,39,1058,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1058,41,1058,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,9,1059,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,12,1059,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,13,1059,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,37,1059,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,39,1059,40],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,40,1059,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1059,42,1059,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1060,9,1060,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1060,14,1060,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1061,7,1061,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1063,6,1063,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1063,11,1063,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1063,22,1063,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1064,7,1064,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1065,9,1065,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1065,16,1065,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1065,17,1065,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,9,1066,11],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,12,1066,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,13,1066,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,15,1066,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,16,1066,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,17,1066,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,18,1066,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,19,1066,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,23,1066,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,24,1066,35],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,35,1066,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,36,1066,39],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,40,1066,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,42,1066,45],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,45,1066,46],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1066,47,1066,48],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,11,1067,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,13,1067,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,15,1067,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,16,1067,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,17,1067,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,18,1067,20],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,20,1067,21],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,21,1067,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,22,1067,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,23,1067,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,24,1067,28],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,28,1067,29],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,29,1067,40],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,40,1067,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,41,1067,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,42,1067,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,44,1067,45],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,46,1067,48],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,48,1067,49],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,49,1067,50],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,50,1067,51],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,51,1067,52],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,52,1067,56],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,56,1067,57],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,57,1067,68],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,68,1067,69],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,69,1067,71],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1067,71,1067,72],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1068,9,1068,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1068,11,1068,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1068,16,1068,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,11,1069,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,13,1069,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,15,1069,16],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,16,1069,17],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,17,1069,18],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,18,1069,19],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,19,1069,21],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,21,1069,22],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,22,1069,23],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,23,1069,24],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,24,1069,25],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,25,1069,29],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,29,1069,30],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,30,1069,41],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,41,1069,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,42,1069,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,43,1069,44],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,45,1069,46],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,47,1069,49],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,49,1069,50],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,50,1069,51],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,51,1069,52],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,52,1069,53],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,53,1069,57],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,57,1069,58],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,58,1069,69],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,69,1069,70],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1069,70,1069,72],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1070,13,1070,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1070,15,1070,31],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1070,31,1070,32],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1071,9,1071,10],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,9,1073,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,12,1073,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,13,1073,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,37,1073,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,39,1073,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,42,1073,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,43,1073,44],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,44,1073,45],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1073,45,1073,46],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,9,1074,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,12,1074,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,13,1074,36],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,37,1074,38],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,39,1074,42],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,42,1074,43],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,43,1074,44],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,44,1074,45],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1074,45,1074,46],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1075,9,1075,14],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1075,14,1075,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1076,7,1076,8],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1078,6,1078,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1078,14,1078,15],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1080,7,1080,12],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1080,12,1080,13],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1081,5,1081,6],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1082,3,1082,4],\"els\":[\"0:983:64\",\"0:3\",\"0:1\"]},{\"tk\":[1085,3,1085,4],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,5,1086,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,12,1086,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,19,1086,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,33,1086,35],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,35,1086,36],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,36,1086,42],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,42,1086,43],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1086,43,1086,44],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1087,5,1087,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1087,12,1087,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1087,13,1087,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1087,15,1087,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1087,20,1087,21],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1088,5,1088,8],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1088,9,1088,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1088,10,1088,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,5,1091,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,11,1091,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,13,1091,17],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,17,1091,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,19,1091,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,20,1091,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,23,1091,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,24,1091,37],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,37,1091,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,38,1091,39],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,39,1091,40],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,40,1091,41],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,41,1091,42],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,43,1091,54],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,54,1091,55],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1091,55,1091,56],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,5,1094,8],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,9,1094,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,10,1094,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,11,1094,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,12,1094,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,13,1094,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,15,1094,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,16,1094,17],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,17,1094,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,23,1094,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,25,1094,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,26,1094,28],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,28,1094,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1094,30,1094,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,7,1095,9],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,10,1095,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,11,1095,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,13,1095,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,14,1095,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,15,1095,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,16,1095,17],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,17,1095,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,19,1095,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,21,1095,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,26,1095,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1095,28,1095,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1096,9,1096,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1096,10,1096,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1096,12,1096,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1097,9,1097,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1097,14,1097,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1098,7,1098,8],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1099,5,1099,6],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,5,1103,6],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,7,1103,8],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,9,1103,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,15,1103,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,17,1103,19],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,19,1103,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,20,1103,21],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,21,1103,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,22,1103,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,23,1103,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1103,24,1103,25],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,5,1104,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,12,1104,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,14,1104,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,16,1104,17],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,17,1104,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,18,1104,19],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,19,1104,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,20,1104,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1104,24,1104,25],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1105,5,1105,6],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1106,6,1106,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1106,11,1106,19],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1106,19,1106,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,7,1108,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,10,1108,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,11,1108,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,25,1108,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,27,1108,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,29,1108,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,30,1108,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,31,1108,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,32,1108,33],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,33,1108,37],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,37,1108,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,38,1108,46],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,46,1108,47],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,47,1108,52],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,52,1108,53],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,53,1108,54],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,54,1108,55],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1108,56,1108,57],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,9,1109,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,10,1109,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,11,1109,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,12,1109,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,14,1109,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,15,1109,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,16,1109,17],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,17,1109,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,18,1109,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,22,1109,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,23,1109,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,31,1109,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,32,1109,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,38,1109,39],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,39,1109,40],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,40,1109,41],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,41,1109,43],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,43,1109,44],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,44,1109,45],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,45,1109,46],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,46,1109,47],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,47,1109,51],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,51,1109,52],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,52,1109,60],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,60,1109,61],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,61,1109,65],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,65,1109,66],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,66,1109,67],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,67,1109,68],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,68,1109,69],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,69,1109,71],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,71,1109,72],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,72,1109,73],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,73,1109,74],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1109,74,1109,75],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,9,1110,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,13,1110,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,14,1110,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,22,1110,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,23,1110,28],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,28,1110,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,29,1110,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,30,1110,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,31,1110,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1110,32,1110,33],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,7,1111,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,10,1111,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,11,1111,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,25,1111,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,27,1111,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,29,1111,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,30,1111,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,31,1111,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,32,1111,33],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,33,1111,37],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,37,1111,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,38,1111,46],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,46,1111,47],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,47,1111,52],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,52,1111,53],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,53,1111,54],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,54,1111,55],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1111,56,1111,57],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,9,1112,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,10,1112,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,11,1112,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,12,1112,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,14,1112,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,15,1112,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,16,1112,17],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,17,1112,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,18,1112,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,22,1112,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,23,1112,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,31,1112,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,32,1112,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,38,1112,39],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,39,1112,40],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,40,1112,41],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,41,1112,43],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,43,1112,44],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,44,1112,45],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,45,1112,46],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,46,1112,47],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,47,1112,51],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,51,1112,52],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,52,1112,60],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,60,1112,61],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,61,1112,65],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,65,1112,66],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,66,1112,67],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,67,1112,68],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,68,1112,69],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,69,1112,71],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,71,1112,72],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,72,1112,73],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,73,1112,74],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1112,74,1112,75],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,9,1113,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,13,1113,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,14,1113,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,22,1113,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,23,1113,28],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,28,1113,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,29,1113,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,30,1113,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,31,1113,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1113,32,1113,33],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1114,7,1114,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1114,12,1114,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1116,6,1116,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1116,11,1116,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1116,22,1116,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,7,1117,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,10,1117,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,11,1117,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,25,1117,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,27,1117,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,29,1117,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,30,1117,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,31,1117,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,32,1117,33],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,33,1117,37],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,37,1117,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,38,1117,49],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,49,1117,50],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,50,1117,56],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,56,1117,57],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,57,1117,58],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,58,1117,59],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,60,1117,61],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,62,1117,64],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,64,1117,65],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,65,1117,66],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,66,1117,67],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1117,67,1117,68],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1118,9,1118,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1118,13,1118,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1118,14,1118,25],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1118,25,1118,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1118,26,1118,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,9,1119,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,10,1119,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,13,1119,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,15,1119,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,16,1119,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,22,1119,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,23,1119,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,24,1119,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,26,1119,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,27,1119,28],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,28,1119,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,29,1119,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,30,1119,34],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,34,1119,35],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,35,1119,46],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,46,1119,47],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,47,1119,50],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,50,1119,51],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,51,1119,52],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,52,1119,53],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,53,1119,54],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,54,1119,55],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,55,1119,57],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,57,1119,58],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,58,1119,59],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,59,1119,60],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,60,1119,61],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,61,1119,65],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,65,1119,66],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,66,1119,77],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,77,1119,78],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,78,1119,79],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1119,79,1119,80],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,14,1120,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,16,1120,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,18,1120,19],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,19,1120,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,20,1120,21],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,21,1120,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,22,1120,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,26,1120,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,27,1120,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,38,1120,39],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,39,1120,41],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,42,1120,43],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1120,43,1120,44],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,7,1121,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,10,1121,11],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,11,1121,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,25,1121,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,27,1121,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,29,1121,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,30,1121,31],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,31,1121,32],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,32,1121,33],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,33,1121,37],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,37,1121,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,38,1121,49],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,49,1121,50],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,50,1121,56],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,56,1121,57],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,57,1121,58],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,58,1121,59],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,60,1121,61],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,62,1121,64],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,64,1121,65],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,65,1121,66],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,66,1121,67],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1121,67,1121,68],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1122,9,1122,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1122,13,1122,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1122,14,1122,25],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1122,25,1122,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1122,26,1122,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,9,1123,10],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,10,1123,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,13,1123,14],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,15,1123,16],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,16,1123,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,22,1123,23],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,23,1123,24],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,24,1123,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,26,1123,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,27,1123,28],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,28,1123,29],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,29,1123,30],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,30,1123,34],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,34,1123,35],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,35,1123,46],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,46,1123,47],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,47,1123,50],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,50,1123,51],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,51,1123,52],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,52,1123,53],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,53,1123,54],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,54,1123,55],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,55,1123,57],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,57,1123,58],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,58,1123,59],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,59,1123,60],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,60,1123,61],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,61,1123,65],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,65,1123,66],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,66,1123,77],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,77,1123,78],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,78,1123,79],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1123,79,1123,80],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,14,1124,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,16,1124,18],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,18,1124,19],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,19,1124,20],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,20,1124,21],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,21,1124,22],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,22,1124,26],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,26,1124,27],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,27,1124,38],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,38,1124,39],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,39,1124,41],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,42,1124,43],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1124,43,1124,44],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1125,7,1125,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1125,12,1125,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1127,6,1127,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1127,14,1127,15],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1129,7,1129,12],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1129,12,1129,13],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1130,5,1130,6],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1131,3,1131,4],\"els\":[\"0:983:63\",\"0:3\",\"0:1\"]},{\"tk\":[1134,3,1134,4],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,5,1135,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,12,1135,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,19,1135,32],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,33,1135,35],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,35,1135,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,36,1135,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,42,1135,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1135,43,1135,44],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1136,5,1136,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1136,12,1136,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1136,13,1136,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1136,15,1136,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1136,20,1136,21],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1137,5,1137,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1137,9,1137,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1137,10,1137,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,5,1140,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,11,1140,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,13,1140,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,17,1140,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,19,1140,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,20,1140,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,23,1140,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,24,1140,37],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,37,1140,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,38,1140,39],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,39,1140,40],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,40,1140,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,41,1140,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,43,1140,54],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,54,1140,55],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1140,55,1140,56],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,5,1143,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,9,1143,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,10,1143,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,11,1143,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,12,1143,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,13,1143,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,15,1143,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,16,1143,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,17,1143,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,23,1143,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,25,1143,26],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,26,1143,28],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,28,1143,29],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1143,30,1143,31],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,7,1144,9],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,10,1144,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,11,1144,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,13,1144,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,14,1144,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,15,1144,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,16,1144,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,17,1144,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,19,1144,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,21,1144,26],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,26,1144,27],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1144,28,1144,29],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1145,9,1145,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1145,10,1145,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1145,12,1145,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1146,9,1146,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1146,14,1146,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1147,7,1147,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1148,5,1148,6],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,5,1152,6],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,7,1152,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,9,1152,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,15,1152,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,17,1152,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,19,1152,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,20,1152,21],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,21,1152,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,22,1152,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,23,1152,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1152,24,1152,25],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,5,1153,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,12,1153,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,14,1153,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,16,1153,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,17,1153,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,18,1153,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,19,1153,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,20,1153,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1153,24,1153,25],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1154,5,1154,6],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1155,6,1155,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1155,11,1155,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1155,19,1155,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1158,7,1158,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1159,9,1159,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1159,16,1159,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1159,18,1159,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1159,20,1159,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1159,22,1159,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1160,9,1160,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1160,16,1160,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1160,22,1160,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,9,1161,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,12,1161,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,14,1161,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,16,1161,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,17,1161,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,18,1161,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,19,1161,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,20,1161,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,24,1161,25],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,25,1161,33],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,33,1161,34],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,34,1161,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,38,1161,39],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,39,1161,40],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,40,1161,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,42,1161,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,44,1161,46],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,46,1161,47],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,47,1161,48],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,48,1161,49],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,49,1161,50],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,50,1161,54],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,54,1161,55],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,55,1161,63],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,63,1161,64],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,64,1161,69],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,69,1161,70],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,70,1161,71],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,71,1161,72],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1161,72,1161,73],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,9,1162,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,12,1162,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,14,1162,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,16,1162,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,17,1162,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,18,1162,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,19,1162,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,20,1162,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,24,1162,25],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,25,1162,33],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,33,1162,34],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,34,1162,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,38,1162,39],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,39,1162,40],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,40,1162,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,42,1162,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,44,1162,46],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,46,1162,47],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,47,1162,48],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,48,1162,49],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,49,1162,50],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,50,1162,54],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,54,1162,55],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,55,1162,63],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,63,1162,64],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,64,1162,69],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,69,1162,70],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,70,1162,71],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,71,1162,72],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1162,72,1162,73],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,9,1163,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,16,1163,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,18,1163,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,22,1163,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,23,1163,25],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,25,1163,26],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,26,1163,28],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,29,1163,30],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,31,1163,33],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,33,1163,34],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,34,1163,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,36,1163,37],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1163,37,1163,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1164,9,1164,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1164,12,1164,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1164,15,1164,21],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1164,21,1164,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1165,9,1165,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1165,12,1165,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1165,15,1165,21],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1165,21,1165,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1168,9,1168,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1168,12,1168,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1168,13,1168,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1168,37,1168,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1168,39,1168,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1168,41,1168,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,9,1169,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,12,1169,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,13,1169,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,37,1169,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,39,1169,40],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,40,1169,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1169,42,1169,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1170,9,1170,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1170,14,1170,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1171,7,1171,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1173,6,1173,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1173,11,1173,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1173,22,1173,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1174,7,1174,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1175,9,1175,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1175,16,1175,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1175,17,1175,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,9,1176,11],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,12,1176,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,13,1176,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,15,1176,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,16,1176,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,17,1176,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,18,1176,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,19,1176,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,23,1176,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,24,1176,35],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,35,1176,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,36,1176,39],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,40,1176,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,42,1176,45],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,45,1176,46],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1176,47,1176,48],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,11,1177,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,13,1177,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,15,1177,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,16,1177,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,17,1177,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,18,1177,20],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,20,1177,21],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,21,1177,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,22,1177,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,23,1177,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,24,1177,28],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,28,1177,29],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,29,1177,40],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,40,1177,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,41,1177,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,42,1177,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,44,1177,45],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,46,1177,48],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,48,1177,49],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,49,1177,50],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,50,1177,51],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,51,1177,52],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,52,1177,56],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,56,1177,57],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,57,1177,68],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,68,1177,69],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,69,1177,71],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1177,71,1177,72],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1178,9,1178,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1178,11,1178,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1178,16,1178,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,11,1179,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,13,1179,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,15,1179,16],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,16,1179,17],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,17,1179,18],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,18,1179,19],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,19,1179,21],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,21,1179,22],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,22,1179,23],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,23,1179,24],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,24,1179,25],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,25,1179,29],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,29,1179,30],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,30,1179,41],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,41,1179,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,42,1179,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,43,1179,44],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,45,1179,46],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,47,1179,49],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,49,1179,50],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,50,1179,51],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,51,1179,52],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,52,1179,53],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,53,1179,57],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,57,1179,58],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,58,1179,69],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,69,1179,70],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1179,70,1179,72],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1180,13,1180,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1180,15,1180,31],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1180,31,1180,32],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1181,9,1181,10],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,9,1183,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,12,1183,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,13,1183,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,37,1183,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,39,1183,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,42,1183,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,43,1183,44],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,44,1183,45],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1183,45,1183,46],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,9,1184,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,12,1184,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,13,1184,36],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,37,1184,38],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,39,1184,42],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,42,1184,43],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,43,1184,44],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,44,1184,45],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1184,45,1184,46],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1185,9,1185,14],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1185,14,1185,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1186,7,1186,8],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1188,6,1188,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1188,14,1188,15],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1190,7,1190,12],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1190,12,1190,13],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1191,5,1191,6],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1192,3,1192,4],\"els\":[\"0:990:64\",\"0:3\",\"0:1\"]},{\"tk\":[1195,3,1195,4],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,5,1196,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,12,1196,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,19,1196,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,33,1196,35],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,35,1196,36],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,36,1196,42],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,42,1196,43],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1196,43,1196,44],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1197,5,1197,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1197,12,1197,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1197,13,1197,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1197,15,1197,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1197,20,1197,21],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1198,5,1198,8],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1198,9,1198,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1198,10,1198,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,5,1201,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,11,1201,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,13,1201,17],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,17,1201,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,19,1201,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,20,1201,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,23,1201,24],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,24,1201,37],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,37,1201,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,38,1201,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,39,1201,40],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,40,1201,41],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,41,1201,42],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,43,1201,54],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,54,1201,55],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1201,55,1201,56],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,5,1204,8],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,9,1204,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,10,1204,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,11,1204,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,12,1204,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,13,1204,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,15,1204,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,16,1204,17],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,17,1204,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,23,1204,24],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,25,1204,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,26,1204,28],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,28,1204,29],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1204,30,1204,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,7,1205,9],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,10,1205,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,11,1205,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,13,1205,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,14,1205,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,15,1205,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,16,1205,17],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,17,1205,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,19,1205,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,21,1205,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,26,1205,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1205,28,1205,29],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1206,9,1206,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1206,10,1206,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1206,12,1206,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1207,9,1207,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1207,14,1207,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1208,7,1208,8],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1209,5,1209,6],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,5,1213,6],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,7,1213,8],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,9,1213,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,15,1213,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,17,1213,19],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,19,1213,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,20,1213,21],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,21,1213,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,22,1213,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,23,1213,24],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1213,24,1213,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,5,1214,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,12,1214,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,14,1214,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,16,1214,17],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,17,1214,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,18,1214,19],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,19,1214,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,20,1214,24],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1214,24,1214,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1215,5,1215,6],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1216,6,1216,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1216,11,1216,19],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1216,19,1216,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,7,1218,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,10,1218,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,11,1218,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,26,1218,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,28,1218,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,30,1218,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,31,1218,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,32,1218,33],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,33,1218,34],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,34,1218,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,38,1218,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,39,1218,47],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,47,1218,48],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,48,1218,53],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,53,1218,54],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,54,1218,55],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,55,1218,56],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1218,57,1218,58],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,9,1219,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,10,1219,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,11,1219,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,12,1219,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,14,1219,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,15,1219,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,16,1219,17],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,17,1219,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,18,1219,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,22,1219,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,23,1219,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,31,1219,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,32,1219,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,38,1219,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,39,1219,40],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,40,1219,41],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,41,1219,43],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,43,1219,44],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,44,1219,45],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,45,1219,46],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,46,1219,47],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,47,1219,51],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,51,1219,52],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,52,1219,60],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,60,1219,61],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,61,1219,65],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,65,1219,66],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,66,1219,67],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,67,1219,68],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,68,1219,69],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,69,1219,71],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,71,1219,72],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,72,1219,73],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,73,1219,74],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1219,74,1219,75],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,9,1220,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,13,1220,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,14,1220,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,22,1220,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,23,1220,28],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,28,1220,29],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,29,1220,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,30,1220,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,31,1220,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1220,32,1220,33],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,7,1221,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,10,1221,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,11,1221,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,26,1221,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,28,1221,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,30,1221,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,31,1221,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,32,1221,33],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,33,1221,34],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,34,1221,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,38,1221,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,39,1221,47],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,47,1221,48],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,48,1221,53],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,53,1221,54],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,54,1221,55],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,55,1221,56],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1221,57,1221,58],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,9,1222,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,10,1222,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,11,1222,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,12,1222,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,14,1222,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,15,1222,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,16,1222,17],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,17,1222,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,18,1222,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,22,1222,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,23,1222,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,31,1222,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,32,1222,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,38,1222,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,39,1222,40],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,40,1222,41],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,41,1222,43],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,43,1222,44],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,44,1222,45],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,45,1222,46],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,46,1222,47],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,47,1222,51],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,51,1222,52],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,52,1222,60],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,60,1222,61],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,61,1222,65],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,65,1222,66],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,66,1222,67],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,67,1222,68],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,68,1222,69],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,69,1222,71],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,71,1222,72],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,72,1222,73],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,73,1222,74],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1222,74,1222,75],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,9,1223,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,13,1223,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,14,1223,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,22,1223,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,23,1223,28],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,28,1223,29],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,29,1223,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,30,1223,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,31,1223,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1223,32,1223,33],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1224,7,1224,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1224,12,1224,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1226,6,1226,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1226,11,1226,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1226,22,1226,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,7,1227,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,10,1227,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,11,1227,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,26,1227,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,28,1227,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,30,1227,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,31,1227,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,32,1227,33],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,33,1227,34],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,34,1227,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,38,1227,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,39,1227,50],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,50,1227,51],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,51,1227,57],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,57,1227,58],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,58,1227,59],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,59,1227,60],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,61,1227,62],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,63,1227,65],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,65,1227,66],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,66,1227,67],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,67,1227,68],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1227,68,1227,69],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1228,9,1228,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1228,13,1228,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1228,14,1228,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1228,25,1228,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1228,26,1228,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,9,1229,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,10,1229,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,13,1229,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,15,1229,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,16,1229,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,22,1229,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,23,1229,24],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,24,1229,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,26,1229,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,27,1229,28],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,28,1229,29],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,29,1229,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,30,1229,34],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,34,1229,35],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,35,1229,46],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,46,1229,47],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,47,1229,50],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,50,1229,51],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,51,1229,52],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,52,1229,53],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,53,1229,54],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,54,1229,55],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,55,1229,57],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,57,1229,58],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,58,1229,59],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,59,1229,60],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,60,1229,61],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,61,1229,65],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,65,1229,66],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,66,1229,77],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,77,1229,78],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,78,1229,79],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1229,79,1229,80],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,14,1230,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,16,1230,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,18,1230,19],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,19,1230,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,20,1230,21],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,21,1230,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,22,1230,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,26,1230,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,27,1230,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,38,1230,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,39,1230,41],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,42,1230,43],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1230,43,1230,44],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,7,1231,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,10,1231,11],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,11,1231,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,26,1231,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,28,1231,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,30,1231,31],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,31,1231,32],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,32,1231,33],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,33,1231,34],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,34,1231,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,38,1231,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,39,1231,50],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,50,1231,51],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,51,1231,57],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,57,1231,58],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,58,1231,59],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,59,1231,60],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,61,1231,62],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,63,1231,65],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,65,1231,66],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,66,1231,67],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,67,1231,68],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1231,68,1231,69],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1232,9,1232,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1232,13,1232,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1232,14,1232,25],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1232,25,1232,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1232,26,1232,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,9,1233,10],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,10,1233,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,13,1233,14],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,15,1233,16],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,16,1233,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,22,1233,23],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,23,1233,24],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,24,1233,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,26,1233,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,27,1233,28],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,28,1233,29],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,29,1233,30],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,30,1233,34],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,34,1233,35],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,35,1233,46],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,46,1233,47],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,47,1233,50],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,50,1233,51],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,51,1233,52],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,52,1233,53],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,53,1233,54],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,54,1233,55],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,55,1233,57],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,57,1233,58],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,58,1233,59],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,59,1233,60],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,60,1233,61],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,61,1233,65],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,65,1233,66],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,66,1233,77],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,77,1233,78],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,78,1233,79],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1233,79,1233,80],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,14,1234,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,16,1234,18],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,18,1234,19],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,19,1234,20],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,20,1234,21],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,21,1234,22],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,22,1234,26],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,26,1234,27],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,27,1234,38],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,38,1234,39],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,39,1234,41],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,42,1234,43],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1234,43,1234,44],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1235,7,1235,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1235,12,1235,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1237,6,1237,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1237,14,1237,15],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1239,7,1239,12],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1239,12,1239,13],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1240,5,1240,6],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1241,3,1241,4],\"els\":[\"0:990:63\",\"0:3\",\"0:1\"]},{\"tk\":[1244,3,1244,4],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,5,1245,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,12,1245,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,19,1245,32],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,33,1245,35],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,35,1245,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,36,1245,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,42,1245,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1245,43,1245,44],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1246,5,1246,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1246,12,1246,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1246,13,1246,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1246,15,1246,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1246,20,1246,21],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1247,5,1247,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1247,9,1247,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1247,10,1247,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,5,1250,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,11,1250,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,13,1250,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,17,1250,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,19,1250,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,20,1250,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,23,1250,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,24,1250,37],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,37,1250,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,38,1250,40],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,40,1250,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,41,1250,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,42,1250,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,44,1250,55],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,55,1250,56],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1250,56,1250,57],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,5,1253,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,9,1253,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,10,1253,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,11,1253,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,12,1253,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,13,1253,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,15,1253,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,16,1253,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,17,1253,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,23,1253,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,25,1253,26],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,26,1253,28],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,28,1253,29],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1253,30,1253,31],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,7,1254,9],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,10,1254,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,11,1254,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,13,1254,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,14,1254,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,15,1254,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,16,1254,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,17,1254,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,19,1254,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,21,1254,26],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,26,1254,27],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1254,28,1254,29],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1255,9,1255,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1255,10,1255,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1255,12,1255,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1256,9,1256,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1256,14,1256,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1257,7,1257,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1258,5,1258,6],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,5,1262,6],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,7,1262,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,9,1262,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,15,1262,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,17,1262,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,19,1262,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,20,1262,21],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,21,1262,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,22,1262,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,23,1262,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1262,24,1262,25],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,5,1263,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,12,1263,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,14,1263,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,16,1263,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,17,1263,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,18,1263,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,19,1263,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,20,1263,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1263,24,1263,25],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1264,5,1264,6],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1265,6,1265,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1265,11,1265,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1265,19,1265,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1268,7,1268,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1269,9,1269,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1269,16,1269,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1269,18,1269,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1269,20,1269,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1269,22,1269,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1270,9,1270,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1270,16,1270,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1270,22,1270,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,9,1271,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,12,1271,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,14,1271,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,16,1271,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,17,1271,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,18,1271,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,19,1271,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,20,1271,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,24,1271,25],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,25,1271,33],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,33,1271,34],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,34,1271,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,38,1271,39],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,39,1271,40],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,40,1271,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,42,1271,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,44,1271,46],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,46,1271,47],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,47,1271,48],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,48,1271,49],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,49,1271,50],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,50,1271,54],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,54,1271,55],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,55,1271,63],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,63,1271,64],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,64,1271,69],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,69,1271,70],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,70,1271,71],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,71,1271,72],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1271,72,1271,73],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,9,1272,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,12,1272,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,14,1272,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,16,1272,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,17,1272,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,18,1272,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,19,1272,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,20,1272,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,24,1272,25],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,25,1272,33],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,33,1272,34],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,34,1272,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,38,1272,39],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,39,1272,40],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,40,1272,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,42,1272,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,44,1272,46],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,46,1272,47],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,47,1272,48],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,48,1272,49],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,49,1272,50],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,50,1272,54],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,54,1272,55],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,55,1272,63],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,63,1272,64],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,64,1272,69],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,69,1272,70],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,70,1272,71],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,71,1272,72],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1272,72,1272,73],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,9,1273,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,16,1273,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,18,1273,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,22,1273,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,23,1273,25],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,25,1273,26],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,26,1273,28],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,29,1273,30],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,31,1273,33],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,33,1273,34],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,34,1273,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,36,1273,37],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1273,37,1273,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1274,9,1274,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1274,12,1274,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1274,15,1274,21],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1274,21,1274,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1275,9,1275,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1275,12,1275,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1275,15,1275,21],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1275,21,1275,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1278,9,1278,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1278,12,1278,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1278,13,1278,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1278,37,1278,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1278,39,1278,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1278,41,1278,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,9,1279,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,12,1279,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,13,1279,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,37,1279,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,39,1279,40],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,40,1279,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1279,42,1279,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1280,9,1280,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1280,14,1280,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1281,7,1281,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1283,6,1283,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1283,11,1283,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1283,22,1283,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1284,7,1284,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1285,9,1285,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1285,16,1285,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1285,17,1285,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,9,1286,11],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,12,1286,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,13,1286,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,15,1286,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,16,1286,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,17,1286,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,18,1286,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,19,1286,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,23,1286,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,24,1286,35],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,35,1286,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,36,1286,39],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,40,1286,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,42,1286,45],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,45,1286,46],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1286,47,1286,48],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,11,1287,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,13,1287,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,15,1287,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,16,1287,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,17,1287,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,18,1287,20],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,20,1287,21],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,21,1287,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,22,1287,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,23,1287,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,24,1287,28],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,28,1287,29],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,29,1287,40],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,40,1287,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,41,1287,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,42,1287,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,44,1287,45],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,46,1287,48],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,48,1287,49],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,49,1287,50],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,50,1287,51],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,51,1287,52],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,52,1287,56],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,56,1287,57],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,57,1287,68],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,68,1287,69],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,69,1287,71],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1287,71,1287,72],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1288,9,1288,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1288,11,1288,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1288,16,1288,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,11,1289,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,13,1289,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,15,1289,16],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,16,1289,17],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,17,1289,18],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,18,1289,19],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,19,1289,21],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,21,1289,22],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,22,1289,23],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,23,1289,24],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,24,1289,25],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,25,1289,29],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,29,1289,30],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,30,1289,41],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,41,1289,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,42,1289,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,43,1289,44],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,45,1289,46],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,47,1289,49],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,49,1289,50],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,50,1289,51],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,51,1289,52],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,52,1289,53],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,53,1289,57],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,57,1289,58],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,58,1289,69],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,69,1289,70],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1289,70,1289,72],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1290,13,1290,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1290,15,1290,31],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1290,31,1290,32],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1291,9,1291,10],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,9,1293,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,12,1293,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,13,1293,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,37,1293,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,39,1293,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,42,1293,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,43,1293,44],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,44,1293,45],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1293,45,1293,46],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,9,1294,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,12,1294,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,13,1294,36],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,37,1294,38],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,39,1294,42],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,42,1294,43],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,43,1294,44],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,44,1294,45],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1294,45,1294,46],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1295,9,1295,14],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1295,14,1295,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1296,7,1296,8],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1298,6,1298,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1298,14,1298,15],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1300,7,1300,12],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1300,12,1300,13],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1301,5,1301,6],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1302,3,1302,4],\"els\":[\"0:997:64\",\"0:3\",\"0:1\"]},{\"tk\":[1305,3,1305,4],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,5,1306,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,12,1306,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,19,1306,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,33,1306,35],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,35,1306,36],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,36,1306,42],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,42,1306,43],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1306,43,1306,44],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1307,5,1307,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1307,12,1307,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1307,13,1307,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1307,15,1307,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1307,20,1307,21],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1308,5,1308,8],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1308,9,1308,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1308,10,1308,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,5,1311,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,11,1311,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,13,1311,17],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,17,1311,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,19,1311,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,20,1311,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,23,1311,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,24,1311,37],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,37,1311,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,38,1311,40],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,40,1311,41],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,41,1311,42],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,42,1311,43],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,44,1311,55],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,55,1311,56],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1311,56,1311,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,5,1314,8],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,9,1314,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,10,1314,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,11,1314,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,12,1314,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,13,1314,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,15,1314,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,16,1314,17],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,17,1314,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,23,1314,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,25,1314,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,26,1314,28],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,28,1314,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1314,30,1314,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,7,1315,9],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,10,1315,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,11,1315,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,13,1315,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,14,1315,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,15,1315,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,16,1315,17],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,17,1315,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,19,1315,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,21,1315,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,26,1315,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1315,28,1315,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1316,9,1316,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1316,10,1316,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1316,12,1316,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1317,9,1317,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1317,14,1317,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1318,7,1318,8],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1319,5,1319,6],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,5,1323,6],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,7,1323,8],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,9,1323,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,15,1323,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,17,1323,19],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,19,1323,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,20,1323,21],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,21,1323,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,22,1323,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,23,1323,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1323,24,1323,25],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,5,1324,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,12,1324,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,14,1324,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,16,1324,17],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,17,1324,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,18,1324,19],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,19,1324,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,20,1324,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1324,24,1324,25],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1325,5,1325,6],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1326,6,1326,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1326,11,1326,19],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1326,19,1326,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,7,1328,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,10,1328,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,11,1328,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,25,1328,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,27,1328,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,29,1328,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,30,1328,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,31,1328,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,32,1328,33],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,33,1328,37],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,37,1328,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,38,1328,46],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,46,1328,47],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,47,1328,52],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,52,1328,53],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,53,1328,54],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,54,1328,55],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1328,56,1328,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,9,1329,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,10,1329,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,11,1329,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,12,1329,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,14,1329,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,15,1329,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,16,1329,17],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,17,1329,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,18,1329,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,22,1329,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,23,1329,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,31,1329,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,32,1329,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,38,1329,39],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,39,1329,40],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,40,1329,41],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,41,1329,43],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,43,1329,44],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,44,1329,45],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,45,1329,46],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,46,1329,47],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,47,1329,51],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,51,1329,52],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,52,1329,60],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,60,1329,61],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,61,1329,65],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,65,1329,66],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,66,1329,67],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,67,1329,68],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,68,1329,69],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,69,1329,71],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,71,1329,72],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,72,1329,73],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,73,1329,74],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1329,74,1329,75],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,9,1330,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,13,1330,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,14,1330,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,22,1330,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,23,1330,28],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,28,1330,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,29,1330,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,30,1330,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,31,1330,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1330,32,1330,33],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,7,1331,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,10,1331,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,11,1331,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,25,1331,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,27,1331,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,29,1331,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,30,1331,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,31,1331,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,32,1331,33],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,33,1331,37],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,37,1331,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,38,1331,46],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,46,1331,47],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,47,1331,52],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,52,1331,53],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,53,1331,54],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,54,1331,55],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1331,56,1331,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,9,1332,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,10,1332,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,11,1332,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,12,1332,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,14,1332,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,15,1332,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,16,1332,17],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,17,1332,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,18,1332,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,22,1332,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,23,1332,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,31,1332,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,32,1332,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,38,1332,39],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,39,1332,40],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,40,1332,41],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,41,1332,43],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,43,1332,44],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,44,1332,45],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,45,1332,46],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,46,1332,47],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,47,1332,51],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,51,1332,52],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,52,1332,60],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,60,1332,61],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,61,1332,65],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,65,1332,66],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,66,1332,67],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,67,1332,68],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,68,1332,69],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,69,1332,71],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,71,1332,72],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,72,1332,73],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,73,1332,74],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1332,74,1332,75],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,9,1333,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,13,1333,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,14,1333,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,22,1333,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,23,1333,28],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,28,1333,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,29,1333,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,30,1333,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,31,1333,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1333,32,1333,33],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1334,7,1334,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1334,12,1334,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1336,6,1336,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1336,11,1336,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1336,22,1336,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,7,1337,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,10,1337,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,11,1337,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,25,1337,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,27,1337,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,29,1337,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,30,1337,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,31,1337,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,32,1337,33],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,33,1337,37],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,37,1337,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,38,1337,49],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,49,1337,50],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,50,1337,56],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,56,1337,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,57,1337,58],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,58,1337,59],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,60,1337,61],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,62,1337,64],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,64,1337,65],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,65,1337,66],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,66,1337,67],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1337,67,1337,68],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1338,9,1338,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1338,13,1338,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1338,14,1338,25],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1338,25,1338,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1338,26,1338,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,9,1339,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,10,1339,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,13,1339,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,15,1339,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,16,1339,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,22,1339,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,23,1339,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,24,1339,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,26,1339,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,27,1339,28],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,28,1339,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,29,1339,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,30,1339,34],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,34,1339,35],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,35,1339,46],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,46,1339,47],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,47,1339,50],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,50,1339,51],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,51,1339,52],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,52,1339,53],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,53,1339,54],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,54,1339,55],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,55,1339,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,57,1339,58],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,58,1339,59],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,59,1339,60],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,60,1339,61],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,61,1339,65],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,65,1339,66],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,66,1339,77],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,77,1339,78],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,78,1339,79],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1339,79,1339,80],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,14,1340,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,16,1340,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,18,1340,19],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,19,1340,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,20,1340,21],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,21,1340,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,22,1340,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,26,1340,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,27,1340,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,38,1340,39],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,39,1340,41],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,42,1340,43],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1340,43,1340,44],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,7,1341,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,10,1341,11],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,11,1341,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,25,1341,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,27,1341,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,29,1341,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,30,1341,31],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,31,1341,32],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,32,1341,33],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,33,1341,37],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,37,1341,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,38,1341,49],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,49,1341,50],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,50,1341,56],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,56,1341,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,57,1341,58],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,58,1341,59],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,60,1341,61],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,62,1341,64],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,64,1341,65],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,65,1341,66],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,66,1341,67],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1341,67,1341,68],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1342,9,1342,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1342,13,1342,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1342,14,1342,25],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1342,25,1342,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1342,26,1342,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,9,1343,10],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,10,1343,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,13,1343,14],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,15,1343,16],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,16,1343,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,22,1343,23],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,23,1343,24],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,24,1343,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,26,1343,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,27,1343,28],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,28,1343,29],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,29,1343,30],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,30,1343,34],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,34,1343,35],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,35,1343,46],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,46,1343,47],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,47,1343,50],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,50,1343,51],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,51,1343,52],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,52,1343,53],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,53,1343,54],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,54,1343,55],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,55,1343,57],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,57,1343,58],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,58,1343,59],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,59,1343,60],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,60,1343,61],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,61,1343,65],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,65,1343,66],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,66,1343,77],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,77,1343,78],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,78,1343,79],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1343,79,1343,80],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,14,1344,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,16,1344,18],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,18,1344,19],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,19,1344,20],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,20,1344,21],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,21,1344,22],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,22,1344,26],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,26,1344,27],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,27,1344,38],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,38,1344,39],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,39,1344,41],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,42,1344,43],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1344,43,1344,44],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1345,7,1345,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1345,12,1345,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1347,6,1347,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1347,14,1347,15],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1349,7,1349,12],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1349,12,1349,13],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1350,5,1350,6],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1351,3,1351,4],\"els\":[\"0:997:63\",\"0:3\",\"0:1\"]},{\"tk\":[1354,3,1354,4],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,5,1355,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,12,1355,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,19,1355,32],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,33,1355,35],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,35,1355,36],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,36,1355,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,42,1355,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1355,43,1355,44],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1356,5,1356,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1356,12,1356,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1356,13,1356,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1356,15,1356,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1356,20,1356,21],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1357,5,1357,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1357,9,1357,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1357,10,1357,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,5,1360,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,11,1360,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,13,1360,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,17,1360,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,19,1360,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,20,1360,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,23,1360,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,24,1360,37],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,37,1360,38],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,38,1360,40],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,40,1360,41],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,41,1360,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,42,1360,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,44,1360,55],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,55,1360,56],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1360,56,1360,57],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,5,1363,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,9,1363,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,10,1363,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,11,1363,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,12,1363,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,13,1363,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,15,1363,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,16,1363,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,17,1363,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,23,1363,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,25,1363,26],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,26,1363,28],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,28,1363,29],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1363,30,1363,31],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,7,1364,9],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,10,1364,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,11,1364,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,13,1364,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,14,1364,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,15,1364,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,16,1364,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,17,1364,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,19,1364,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,21,1364,26],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,26,1364,27],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1364,28,1364,29],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1365,9,1365,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1365,10,1365,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1365,12,1365,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1366,9,1366,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1366,14,1366,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1367,7,1367,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1368,5,1368,6],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,5,1372,6],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,7,1372,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,9,1372,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,15,1372,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,17,1372,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,19,1372,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,20,1372,21],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,21,1372,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,22,1372,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,23,1372,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1372,24,1372,25],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,5,1373,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,12,1373,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,14,1373,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,16,1373,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,17,1373,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,18,1373,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,19,1373,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,20,1373,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1373,24,1373,25],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1374,5,1374,6],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1375,6,1375,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1375,11,1375,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1375,19,1375,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1378,7,1378,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1379,9,1379,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1379,16,1379,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1379,18,1379,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1379,20,1379,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1379,22,1379,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1380,9,1380,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1380,16,1380,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1380,22,1380,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,9,1381,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,12,1381,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,14,1381,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,16,1381,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,17,1381,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,18,1381,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,19,1381,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,20,1381,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,24,1381,25],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,25,1381,33],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,33,1381,34],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,34,1381,38],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,38,1381,39],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,39,1381,40],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,40,1381,41],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,42,1381,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,44,1381,46],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,46,1381,47],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,47,1381,48],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,48,1381,49],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,49,1381,50],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,50,1381,54],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,54,1381,55],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,55,1381,63],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,63,1381,64],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,64,1381,69],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,69,1381,70],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,70,1381,71],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,71,1381,72],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1381,72,1381,73],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,9,1382,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,12,1382,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,14,1382,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,16,1382,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,17,1382,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,18,1382,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,19,1382,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,20,1382,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,24,1382,25],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,25,1382,33],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,33,1382,34],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,34,1382,38],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,38,1382,39],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,39,1382,40],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,40,1382,41],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,42,1382,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,44,1382,46],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,46,1382,47],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,47,1382,48],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,48,1382,49],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,49,1382,50],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,50,1382,54],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,54,1382,55],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,55,1382,63],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,63,1382,64],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,64,1382,69],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,69,1382,70],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,70,1382,71],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,71,1382,72],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1382,72,1382,73],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,9,1383,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,16,1383,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,18,1383,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,22,1383,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,23,1383,25],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,25,1383,26],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,26,1383,28],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,29,1383,30],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,31,1383,33],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,33,1383,34],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,34,1383,36],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,36,1383,37],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1383,37,1383,38],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1384,9,1384,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1384,12,1384,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1384,15,1384,21],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1384,21,1384,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1385,9,1385,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1385,12,1385,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1385,15,1385,21],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1385,21,1385,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1388,9,1388,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1388,12,1388,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1388,13,1388,37],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1388,38,1388,39],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1388,40,1388,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1388,42,1388,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,9,1389,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,12,1389,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,13,1389,36],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,37,1389,38],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,39,1389,40],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,40,1389,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1389,42,1389,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1390,9,1390,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1390,14,1390,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1391,7,1391,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1393,6,1393,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1393,11,1393,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1393,22,1393,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1394,7,1394,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1395,9,1395,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1395,16,1395,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1395,17,1395,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,9,1396,11],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,12,1396,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,13,1396,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,15,1396,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,16,1396,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,17,1396,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,18,1396,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,19,1396,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,23,1396,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,24,1396,35],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,35,1396,36],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,36,1396,39],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,40,1396,41],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,42,1396,45],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,45,1396,46],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1396,47,1396,48],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,11,1397,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,13,1397,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,15,1397,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,16,1397,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,17,1397,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,18,1397,20],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,20,1397,21],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,21,1397,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,22,1397,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,23,1397,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,24,1397,28],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,28,1397,29],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,29,1397,40],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,40,1397,41],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,41,1397,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,42,1397,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,44,1397,45],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,46,1397,48],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,48,1397,49],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,49,1397,50],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,50,1397,51],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,51,1397,52],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,52,1397,56],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,56,1397,57],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,57,1397,68],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,68,1397,69],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,69,1397,71],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1397,71,1397,72],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1398,9,1398,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1398,11,1398,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1398,16,1398,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,11,1399,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,13,1399,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,15,1399,16],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,16,1399,17],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,17,1399,18],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,18,1399,19],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,19,1399,21],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,21,1399,22],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,22,1399,23],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,23,1399,24],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,24,1399,25],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,25,1399,29],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,29,1399,30],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,30,1399,41],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,41,1399,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,42,1399,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,43,1399,44],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,45,1399,46],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,47,1399,49],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,49,1399,50],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,50,1399,51],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,51,1399,52],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,52,1399,53],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,53,1399,57],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,57,1399,58],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,58,1399,69],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,69,1399,70],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1399,70,1399,72],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1400,13,1400,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1400,15,1400,31],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1400,31,1400,32],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1401,9,1401,10],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,9,1403,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,12,1403,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,13,1403,37],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,38,1403,39],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,40,1403,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,43,1403,44],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,44,1403,45],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,45,1403,46],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1403,46,1403,47],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,9,1404,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,12,1404,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,13,1404,36],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,37,1404,38],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,39,1404,42],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,42,1404,43],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,43,1404,44],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,44,1404,45],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1404,45,1404,46],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1405,9,1405,14],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1405,14,1405,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1406,7,1406,8],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1408,6,1408,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1408,14,1408,15],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1410,7,1410,12],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1410,12,1410,13],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1411,5,1411,6],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1412,3,1412,4],\"els\":[\"0:1004:64\",\"0:3\",\"0:1\"]},{\"tk\":[1415,3,1415,4],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,5,1416,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,12,1416,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,19,1416,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,33,1416,35],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,35,1416,36],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,36,1416,42],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,42,1416,43],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1416,43,1416,44],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1417,5,1417,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1417,12,1417,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1417,13,1417,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1417,15,1417,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1417,20,1417,21],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1418,5,1418,8],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1418,9,1418,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1418,10,1418,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,5,1421,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,11,1421,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,13,1421,17],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,17,1421,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,19,1421,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,20,1421,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,23,1421,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,24,1421,37],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,37,1421,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,38,1421,40],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,40,1421,41],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,41,1421,42],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,42,1421,43],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,44,1421,55],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,55,1421,56],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1421,56,1421,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,5,1424,8],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,9,1424,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,10,1424,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,11,1424,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,12,1424,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,13,1424,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,15,1424,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,16,1424,17],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,17,1424,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,23,1424,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,25,1424,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,26,1424,28],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,28,1424,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1424,30,1424,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,7,1425,9],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,10,1425,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,11,1425,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,13,1425,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,14,1425,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,15,1425,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,16,1425,17],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,17,1425,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,19,1425,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,21,1425,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,26,1425,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1425,28,1425,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1426,9,1426,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1426,10,1426,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1426,12,1426,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1427,9,1427,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1427,14,1427,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1428,7,1428,8],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1429,5,1429,6],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,5,1433,6],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,7,1433,8],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,9,1433,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,15,1433,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,17,1433,19],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,19,1433,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,20,1433,21],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,21,1433,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,22,1433,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,23,1433,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1433,24,1433,25],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,5,1434,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,12,1434,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,14,1434,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,16,1434,17],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,17,1434,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,18,1434,19],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,19,1434,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,20,1434,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1434,24,1434,25],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1435,5,1435,6],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1436,6,1436,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1436,11,1436,19],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1436,19,1436,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,7,1438,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,10,1438,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,11,1438,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,25,1438,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,27,1438,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,29,1438,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,30,1438,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,31,1438,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,32,1438,33],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,33,1438,37],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,37,1438,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,38,1438,46],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,46,1438,47],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,47,1438,52],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,52,1438,53],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,53,1438,54],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,54,1438,55],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1438,56,1438,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,9,1439,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,10,1439,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,11,1439,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,12,1439,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,14,1439,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,15,1439,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,16,1439,17],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,17,1439,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,18,1439,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,22,1439,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,23,1439,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,31,1439,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,32,1439,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,38,1439,39],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,39,1439,40],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,40,1439,41],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,41,1439,43],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,43,1439,44],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,44,1439,45],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,45,1439,46],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,46,1439,47],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,47,1439,51],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,51,1439,52],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,52,1439,60],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,60,1439,61],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,61,1439,65],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,65,1439,66],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,66,1439,67],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,67,1439,68],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,68,1439,69],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,69,1439,71],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,71,1439,72],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,72,1439,73],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,73,1439,74],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1439,74,1439,75],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,9,1440,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,13,1440,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,14,1440,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,22,1440,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,23,1440,28],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,28,1440,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,29,1440,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,30,1440,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,31,1440,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1440,32,1440,33],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,7,1441,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,10,1441,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,11,1441,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,25,1441,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,27,1441,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,29,1441,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,30,1441,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,31,1441,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,32,1441,33],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,33,1441,37],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,37,1441,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,38,1441,46],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,46,1441,47],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,47,1441,52],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,52,1441,53],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,53,1441,54],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,54,1441,55],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1441,56,1441,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,9,1442,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,10,1442,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,11,1442,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,12,1442,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,14,1442,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,15,1442,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,16,1442,17],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,17,1442,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,18,1442,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,22,1442,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,23,1442,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,31,1442,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,32,1442,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,38,1442,39],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,39,1442,40],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,40,1442,41],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,41,1442,43],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,43,1442,44],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,44,1442,45],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,45,1442,46],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,46,1442,47],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,47,1442,51],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,51,1442,52],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,52,1442,60],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,60,1442,61],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,61,1442,65],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,65,1442,66],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,66,1442,67],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,67,1442,68],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,68,1442,69],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,69,1442,71],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,71,1442,72],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,72,1442,73],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,73,1442,74],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1442,74,1442,75],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,9,1443,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,13,1443,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,14,1443,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,22,1443,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,23,1443,28],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,28,1443,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,29,1443,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,30,1443,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,31,1443,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1443,32,1443,33],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1444,7,1444,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1444,12,1444,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1446,6,1446,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1446,11,1446,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1446,22,1446,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,7,1447,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,10,1447,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,11,1447,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,25,1447,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,27,1447,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,29,1447,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,30,1447,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,31,1447,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,32,1447,33],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,33,1447,37],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,37,1447,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,38,1447,49],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,49,1447,50],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,50,1447,56],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,56,1447,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,57,1447,58],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,58,1447,59],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,60,1447,61],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,62,1447,64],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,64,1447,65],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,65,1447,66],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,66,1447,67],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1447,67,1447,68],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1448,9,1448,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1448,13,1448,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1448,14,1448,25],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1448,25,1448,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1448,26,1448,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,9,1449,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,10,1449,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,13,1449,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,15,1449,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,16,1449,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,22,1449,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,23,1449,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,24,1449,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,26,1449,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,27,1449,28],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,28,1449,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,29,1449,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,30,1449,34],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,34,1449,35],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,35,1449,46],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,46,1449,47],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,47,1449,50],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,50,1449,51],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,51,1449,52],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,52,1449,53],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,53,1449,54],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,54,1449,55],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,55,1449,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,57,1449,58],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,58,1449,59],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,59,1449,60],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,60,1449,61],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,61,1449,65],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,65,1449,66],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,66,1449,77],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,77,1449,78],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,78,1449,79],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1449,79,1449,80],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,14,1450,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,16,1450,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,18,1450,19],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,19,1450,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,20,1450,21],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,21,1450,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,22,1450,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,26,1450,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,27,1450,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,38,1450,39],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,39,1450,41],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,42,1450,43],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1450,43,1450,44],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,7,1451,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,10,1451,11],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,11,1451,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,25,1451,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,27,1451,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,29,1451,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,30,1451,31],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,31,1451,32],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,32,1451,33],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,33,1451,37],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,37,1451,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,38,1451,49],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,49,1451,50],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,50,1451,56],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,56,1451,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,57,1451,58],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,58,1451,59],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,60,1451,61],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,62,1451,64],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,64,1451,65],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,65,1451,66],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,66,1451,67],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1451,67,1451,68],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1452,9,1452,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1452,13,1452,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1452,14,1452,25],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1452,25,1452,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1452,26,1452,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,9,1453,10],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,10,1453,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,13,1453,14],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,15,1453,16],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,16,1453,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,22,1453,23],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,23,1453,24],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,24,1453,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,26,1453,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,27,1453,28],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,28,1453,29],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,29,1453,30],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,30,1453,34],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,34,1453,35],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,35,1453,46],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,46,1453,47],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,47,1453,50],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,50,1453,51],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,51,1453,52],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,52,1453,53],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,53,1453,54],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,54,1453,55],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,55,1453,57],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,57,1453,58],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,58,1453,59],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,59,1453,60],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,60,1453,61],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,61,1453,65],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,65,1453,66],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,66,1453,77],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,77,1453,78],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,78,1453,79],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1453,79,1453,80],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,14,1454,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,16,1454,18],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,18,1454,19],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,19,1454,20],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,20,1454,21],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,21,1454,22],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,22,1454,26],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,26,1454,27],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,27,1454,38],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,38,1454,39],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,39,1454,41],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,42,1454,43],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1454,43,1454,44],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1455,7,1455,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1455,12,1455,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1457,6,1457,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1457,14,1457,15],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1459,7,1459,12],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1459,12,1459,13],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1460,5,1460,6],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1461,3,1461,4],\"els\":[\"0:1004:63\",\"0:3\",\"0:1\"]},{\"tk\":[1464,3,1464,4],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,5,1465,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,12,1465,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,19,1465,32],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,33,1465,35],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,35,1465,36],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,36,1465,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,42,1465,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1465,43,1465,44],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1466,5,1466,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1466,12,1466,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1466,13,1466,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1466,15,1466,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1466,20,1466,21],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1467,5,1467,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1467,9,1467,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1467,10,1467,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,5,1470,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,11,1470,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,13,1470,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,17,1470,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,19,1470,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,20,1470,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,23,1470,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,24,1470,37],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,37,1470,38],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,38,1470,40],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,40,1470,41],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,41,1470,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,42,1470,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,44,1470,55],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,55,1470,56],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1470,56,1470,57],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,5,1473,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,9,1473,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,10,1473,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,11,1473,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,12,1473,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,13,1473,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,15,1473,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,16,1473,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,17,1473,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,23,1473,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,25,1473,26],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,26,1473,28],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,28,1473,29],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1473,30,1473,31],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,7,1474,9],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,10,1474,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,11,1474,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,13,1474,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,14,1474,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,15,1474,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,16,1474,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,17,1474,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,19,1474,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,21,1474,26],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,26,1474,27],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1474,28,1474,29],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1475,9,1475,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1475,10,1475,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1475,12,1475,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1476,9,1476,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1476,14,1476,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1477,7,1477,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1478,5,1478,6],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,5,1482,6],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,7,1482,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,9,1482,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,15,1482,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,17,1482,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,19,1482,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,20,1482,21],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,21,1482,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,22,1482,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,23,1482,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1482,24,1482,25],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,5,1483,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,12,1483,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,14,1483,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,16,1483,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,17,1483,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,18,1483,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,19,1483,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,20,1483,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1483,24,1483,25],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1484,5,1484,6],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1485,6,1485,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1485,11,1485,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1485,19,1485,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1488,7,1488,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1489,9,1489,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1489,16,1489,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1489,18,1489,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1489,20,1489,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1489,22,1489,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1490,9,1490,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1490,16,1490,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1490,22,1490,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,9,1491,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,12,1491,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,14,1491,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,16,1491,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,17,1491,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,18,1491,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,19,1491,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,20,1491,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,24,1491,25],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,25,1491,33],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,33,1491,34],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,34,1491,38],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,38,1491,39],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,39,1491,40],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,40,1491,41],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,42,1491,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,44,1491,46],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,46,1491,47],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,47,1491,48],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,48,1491,49],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,49,1491,50],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,50,1491,54],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,54,1491,55],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,55,1491,63],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,63,1491,64],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,64,1491,69],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,69,1491,70],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,70,1491,71],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,71,1491,72],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1491,72,1491,73],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,9,1492,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,12,1492,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,14,1492,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,16,1492,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,17,1492,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,18,1492,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,19,1492,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,20,1492,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,24,1492,25],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,25,1492,33],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,33,1492,34],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,34,1492,38],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,38,1492,39],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,39,1492,40],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,40,1492,41],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,42,1492,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,44,1492,46],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,46,1492,47],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,47,1492,48],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,48,1492,49],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,49,1492,50],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,50,1492,54],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,54,1492,55],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,55,1492,63],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,63,1492,64],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,64,1492,69],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,69,1492,70],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,70,1492,71],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,71,1492,72],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1492,72,1492,73],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,9,1493,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,16,1493,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,18,1493,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,22,1493,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,23,1493,25],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,25,1493,26],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,26,1493,28],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,29,1493,30],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,31,1493,33],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,33,1493,34],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,34,1493,36],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,36,1493,37],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1493,37,1493,38],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1494,9,1494,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1494,12,1494,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1494,15,1494,21],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1494,21,1494,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1495,9,1495,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1495,12,1495,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1495,15,1495,21],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1495,21,1495,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1498,9,1498,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1498,12,1498,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1498,13,1498,37],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1498,38,1498,39],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1498,40,1498,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1498,42,1498,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,9,1499,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,12,1499,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,13,1499,36],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,37,1499,38],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,39,1499,40],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,40,1499,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1499,42,1499,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1500,9,1500,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1500,14,1500,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1501,7,1501,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1503,6,1503,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1503,11,1503,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1503,22,1503,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1504,7,1504,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1505,9,1505,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1505,16,1505,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1505,17,1505,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,9,1506,11],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,12,1506,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,13,1506,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,15,1506,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,16,1506,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,17,1506,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,18,1506,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,19,1506,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,23,1506,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,24,1506,35],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,35,1506,36],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,36,1506,39],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,40,1506,41],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,42,1506,45],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,45,1506,46],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1506,47,1506,48],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,11,1507,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,13,1507,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,15,1507,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,16,1507,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,17,1507,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,18,1507,20],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,20,1507,21],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,21,1507,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,22,1507,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,23,1507,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,24,1507,28],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,28,1507,29],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,29,1507,40],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,40,1507,41],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,41,1507,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,42,1507,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,44,1507,45],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,46,1507,48],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,48,1507,49],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,49,1507,50],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,50,1507,51],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,51,1507,52],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,52,1507,56],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,56,1507,57],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,57,1507,68],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,68,1507,69],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,69,1507,71],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1507,71,1507,72],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1508,9,1508,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1508,11,1508,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1508,16,1508,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,11,1509,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,13,1509,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,15,1509,16],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,16,1509,17],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,17,1509,18],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,18,1509,19],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,19,1509,21],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,21,1509,22],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,22,1509,23],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,23,1509,24],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,24,1509,25],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,25,1509,29],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,29,1509,30],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,30,1509,41],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,41,1509,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,42,1509,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,43,1509,44],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,45,1509,46],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,47,1509,49],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,49,1509,50],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,50,1509,51],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,51,1509,52],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,52,1509,53],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,53,1509,57],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,57,1509,58],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,58,1509,69],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,69,1509,70],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1509,70,1509,72],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1510,13,1510,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1510,15,1510,31],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1510,31,1510,32],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1511,9,1511,10],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,9,1513,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,12,1513,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,13,1513,37],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,38,1513,39],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,40,1513,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,43,1513,44],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,44,1513,45],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,45,1513,46],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1513,46,1513,47],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,9,1514,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,12,1514,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,13,1514,36],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,37,1514,38],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,39,1514,42],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,42,1514,43],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,43,1514,44],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,44,1514,45],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1514,45,1514,46],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1515,9,1515,14],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1515,14,1515,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1516,7,1516,8],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1518,6,1518,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1518,14,1518,15],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1520,7,1520,12],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1520,12,1520,13],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1521,5,1521,6],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1522,3,1522,4],\"els\":[\"0:1011:64\",\"0:3\",\"0:1\"]},{\"tk\":[1525,3,1525,4],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,5,1526,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,12,1526,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,19,1526,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,33,1526,35],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,35,1526,36],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,36,1526,42],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,42,1526,43],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1526,43,1526,44],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1527,5,1527,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1527,12,1527,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1527,13,1527,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1527,15,1527,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1527,20,1527,21],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1528,5,1528,8],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1528,9,1528,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1528,10,1528,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,5,1531,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,11,1531,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,13,1531,17],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,17,1531,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,19,1531,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,20,1531,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,23,1531,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,24,1531,37],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,37,1531,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,38,1531,40],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,40,1531,41],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,41,1531,42],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,42,1531,43],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,44,1531,55],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,55,1531,56],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1531,56,1531,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,5,1534,8],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,9,1534,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,10,1534,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,11,1534,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,12,1534,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,13,1534,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,15,1534,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,16,1534,17],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,17,1534,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,23,1534,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,25,1534,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,26,1534,28],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,28,1534,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1534,30,1534,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,7,1535,9],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,10,1535,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,11,1535,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,13,1535,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,14,1535,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,15,1535,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,16,1535,17],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,17,1535,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,19,1535,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,21,1535,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,26,1535,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1535,28,1535,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1536,9,1536,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1536,10,1536,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1536,12,1536,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1537,9,1537,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1537,14,1537,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1538,7,1538,8],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1539,5,1539,6],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,5,1543,6],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,7,1543,8],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,9,1543,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,15,1543,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,17,1543,19],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,19,1543,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,20,1543,21],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,21,1543,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,22,1543,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,23,1543,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1543,24,1543,25],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,5,1544,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,12,1544,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,14,1544,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,16,1544,17],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,17,1544,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,18,1544,19],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,19,1544,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,20,1544,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1544,24,1544,25],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1545,5,1545,6],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1546,6,1546,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1546,11,1546,19],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1546,19,1546,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,7,1548,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,10,1548,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,11,1548,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,25,1548,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,27,1548,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,29,1548,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,30,1548,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,31,1548,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,32,1548,33],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,33,1548,37],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,37,1548,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,38,1548,46],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,46,1548,47],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,47,1548,52],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,52,1548,53],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,53,1548,54],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,54,1548,55],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1548,56,1548,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,9,1549,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,10,1549,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,11,1549,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,12,1549,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,14,1549,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,15,1549,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,16,1549,17],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,17,1549,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,18,1549,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,22,1549,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,23,1549,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,31,1549,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,32,1549,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,38,1549,39],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,39,1549,40],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,40,1549,41],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,41,1549,43],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,43,1549,44],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,44,1549,45],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,45,1549,46],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,46,1549,47],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,47,1549,51],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,51,1549,52],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,52,1549,60],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,60,1549,61],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,61,1549,65],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,65,1549,66],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,66,1549,67],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,67,1549,68],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,68,1549,69],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,69,1549,71],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,71,1549,72],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,72,1549,73],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,73,1549,74],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1549,74,1549,75],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,9,1550,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,13,1550,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,14,1550,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,22,1550,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,23,1550,28],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,28,1550,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,29,1550,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,30,1550,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,31,1550,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1550,32,1550,33],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,7,1551,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,10,1551,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,11,1551,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,25,1551,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,27,1551,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,29,1551,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,30,1551,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,31,1551,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,32,1551,33],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,33,1551,37],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,37,1551,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,38,1551,46],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,46,1551,47],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,47,1551,52],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,52,1551,53],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,53,1551,54],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,54,1551,55],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1551,56,1551,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,9,1552,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,10,1552,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,11,1552,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,12,1552,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,14,1552,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,15,1552,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,16,1552,17],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,17,1552,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,18,1552,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,22,1552,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,23,1552,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,31,1552,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,32,1552,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,38,1552,39],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,39,1552,40],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,40,1552,41],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,41,1552,43],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,43,1552,44],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,44,1552,45],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,45,1552,46],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,46,1552,47],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,47,1552,51],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,51,1552,52],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,52,1552,60],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,60,1552,61],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,61,1552,65],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,65,1552,66],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,66,1552,67],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,67,1552,68],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,68,1552,69],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,69,1552,71],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,71,1552,72],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,72,1552,73],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,73,1552,74],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1552,74,1552,75],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,9,1553,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,13,1553,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,14,1553,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,22,1553,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,23,1553,28],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,28,1553,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,29,1553,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,30,1553,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,31,1553,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1553,32,1553,33],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1554,7,1554,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1554,12,1554,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1556,6,1556,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1556,11,1556,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1556,22,1556,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,7,1557,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,10,1557,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,11,1557,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,25,1557,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,27,1557,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,29,1557,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,30,1557,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,31,1557,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,32,1557,33],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,33,1557,37],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,37,1557,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,38,1557,49],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,49,1557,50],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,50,1557,56],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,56,1557,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,57,1557,58],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,58,1557,59],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,60,1557,61],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,62,1557,64],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,64,1557,65],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,65,1557,66],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,66,1557,67],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1557,67,1557,68],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1558,9,1558,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1558,13,1558,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1558,14,1558,25],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1558,25,1558,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1558,26,1558,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,9,1559,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,10,1559,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,13,1559,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,15,1559,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,16,1559,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,22,1559,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,23,1559,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,24,1559,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,26,1559,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,27,1559,28],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,28,1559,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,29,1559,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,30,1559,34],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,34,1559,35],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,35,1559,46],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,46,1559,47],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,47,1559,50],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,50,1559,51],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,51,1559,52],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,52,1559,53],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,53,1559,54],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,54,1559,55],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,55,1559,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,57,1559,58],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,58,1559,59],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,59,1559,60],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,60,1559,61],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,61,1559,65],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,65,1559,66],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,66,1559,77],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,77,1559,78],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,78,1559,79],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1559,79,1559,80],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,14,1560,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,16,1560,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,18,1560,19],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,19,1560,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,20,1560,21],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,21,1560,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,22,1560,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,26,1560,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,27,1560,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,38,1560,39],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,39,1560,41],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,42,1560,43],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1560,43,1560,44],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,7,1561,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,10,1561,11],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,11,1561,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,25,1561,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,27,1561,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,29,1561,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,30,1561,31],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,31,1561,32],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,32,1561,33],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,33,1561,37],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,37,1561,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,38,1561,49],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,49,1561,50],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,50,1561,56],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,56,1561,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,57,1561,58],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,58,1561,59],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,60,1561,61],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,62,1561,64],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,64,1561,65],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,65,1561,66],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,66,1561,67],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1561,67,1561,68],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1562,9,1562,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1562,13,1562,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1562,14,1562,25],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1562,25,1562,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1562,26,1562,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,9,1563,10],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,10,1563,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,13,1563,14],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,15,1563,16],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,16,1563,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,22,1563,23],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,23,1563,24],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,24,1563,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,26,1563,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,27,1563,28],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,28,1563,29],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,29,1563,30],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,30,1563,34],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,34,1563,35],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,35,1563,46],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,46,1563,47],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,47,1563,50],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,50,1563,51],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,51,1563,52],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,52,1563,53],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,53,1563,54],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,54,1563,55],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,55,1563,57],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,57,1563,58],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,58,1563,59],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,59,1563,60],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,60,1563,61],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,61,1563,65],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,65,1563,66],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,66,1563,77],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,77,1563,78],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,78,1563,79],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1563,79,1563,80],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,14,1564,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,16,1564,18],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,18,1564,19],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,19,1564,20],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,20,1564,21],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,21,1564,22],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,22,1564,26],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,26,1564,27],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,27,1564,38],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,38,1564,39],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,39,1564,41],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,42,1564,43],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1564,43,1564,44],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1565,7,1565,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1565,12,1565,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1567,6,1567,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1567,14,1567,15],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1569,7,1569,12],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1569,12,1569,13],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1570,5,1570,6],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1571,3,1571,4],\"els\":[\"0:1011:63\",\"0:3\",\"0:1\"]},{\"tk\":[1574,3,1574,4],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,5,1575,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,12,1575,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,19,1575,32],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,33,1575,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,35,1575,36],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,36,1575,42],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,42,1575,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1575,43,1575,44],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1576,5,1576,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1576,12,1576,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1576,13,1576,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1576,15,1576,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1576,20,1576,21],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1577,5,1577,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1577,9,1577,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1577,10,1577,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,5,1580,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,11,1580,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,13,1580,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,17,1580,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,19,1580,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,20,1580,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,23,1580,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,24,1580,33],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,33,1580,34],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,34,1580,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,36,1580,47],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,47,1580,48],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1580,48,1580,49],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,5,1583,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,9,1583,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,10,1583,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,11,1583,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,12,1583,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,13,1583,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,15,1583,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,16,1583,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,17,1583,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,23,1583,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,25,1583,26],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,26,1583,28],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,28,1583,29],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1583,30,1583,31],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,7,1584,9],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,10,1584,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,11,1584,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,13,1584,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,14,1584,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,15,1584,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,16,1584,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,17,1584,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,19,1584,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,21,1584,26],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,26,1584,27],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1584,28,1584,29],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1585,9,1585,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1585,10,1585,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1585,12,1585,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1586,9,1586,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1586,14,1586,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1587,7,1587,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1588,5,1588,6],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,5,1592,6],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,7,1592,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,9,1592,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,15,1592,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,17,1592,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,19,1592,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,20,1592,21],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,21,1592,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,22,1592,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,23,1592,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1592,24,1592,25],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,5,1593,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,12,1593,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,14,1593,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,16,1593,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,17,1593,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,18,1593,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,19,1593,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,20,1593,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1593,24,1593,25],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1594,5,1594,6],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1595,6,1595,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1595,11,1595,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1595,19,1595,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1598,7,1598,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1599,9,1599,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1599,16,1599,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1599,18,1599,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1599,20,1599,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1599,22,1599,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1600,9,1600,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1600,16,1600,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1600,22,1600,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,9,1601,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,12,1601,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,14,1601,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,16,1601,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,17,1601,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,18,1601,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,19,1601,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,20,1601,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,24,1601,25],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,25,1601,33],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,33,1601,34],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,34,1601,38],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,38,1601,39],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,39,1601,40],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,40,1601,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,42,1601,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,44,1601,46],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,46,1601,47],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,47,1601,48],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,48,1601,49],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,49,1601,50],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,50,1601,54],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,54,1601,55],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,55,1601,63],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,63,1601,64],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,64,1601,69],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,69,1601,70],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,70,1601,71],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,71,1601,72],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1601,72,1601,73],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,9,1602,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,12,1602,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,14,1602,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,16,1602,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,17,1602,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,18,1602,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,19,1602,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,20,1602,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,24,1602,25],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,25,1602,33],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,33,1602,34],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,34,1602,38],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,38,1602,39],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,39,1602,40],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,40,1602,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,42,1602,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,44,1602,46],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,46,1602,47],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,47,1602,48],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,48,1602,49],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,49,1602,50],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,50,1602,54],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,54,1602,55],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,55,1602,63],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,63,1602,64],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,64,1602,69],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,69,1602,70],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,70,1602,71],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,71,1602,72],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1602,72,1602,73],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,9,1603,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,16,1603,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,18,1603,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,22,1603,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,23,1603,25],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,25,1603,26],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,26,1603,28],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,29,1603,30],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,31,1603,33],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,33,1603,34],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,34,1603,36],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,36,1603,37],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1603,37,1603,38],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1604,9,1604,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1604,12,1604,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1604,15,1604,21],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1604,21,1604,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1605,9,1605,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1605,12,1605,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1605,15,1605,21],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1605,21,1605,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1608,9,1608,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1608,12,1608,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1608,13,1608,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1608,36,1608,37],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1608,38,1608,40],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1608,40,1608,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,9,1609,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,12,1609,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,13,1609,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,36,1609,37],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,38,1609,39],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,39,1609,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1609,41,1609,42],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1610,9,1610,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1610,14,1610,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1611,7,1611,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1613,6,1613,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1613,11,1613,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1613,22,1613,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1614,7,1614,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1615,9,1615,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1615,16,1615,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1615,17,1615,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,9,1616,11],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,12,1616,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,13,1616,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,15,1616,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,16,1616,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,17,1616,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,18,1616,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,19,1616,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,23,1616,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,24,1616,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,35,1616,36],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,36,1616,39],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,40,1616,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,42,1616,45],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,45,1616,46],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1616,47,1616,48],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,11,1617,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,13,1617,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,15,1617,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,16,1617,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,17,1617,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,18,1617,20],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,20,1617,21],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,21,1617,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,22,1617,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,23,1617,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,24,1617,28],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,28,1617,29],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,29,1617,40],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,40,1617,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,41,1617,42],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,42,1617,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,44,1617,45],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,46,1617,48],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,48,1617,49],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,49,1617,50],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,50,1617,51],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,51,1617,52],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,52,1617,56],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,56,1617,57],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,57,1617,68],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,68,1617,69],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,69,1617,71],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1617,71,1617,72],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1618,9,1618,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1618,11,1618,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1618,16,1618,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,11,1619,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,13,1619,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,15,1619,16],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,16,1619,17],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,17,1619,18],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,18,1619,19],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,19,1619,21],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,21,1619,22],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,22,1619,23],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,23,1619,24],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,24,1619,25],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,25,1619,29],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,29,1619,30],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,30,1619,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,41,1619,42],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,42,1619,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,43,1619,44],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,45,1619,46],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,47,1619,49],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,49,1619,50],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,50,1619,51],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,51,1619,52],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,52,1619,53],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,53,1619,57],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,57,1619,58],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,58,1619,69],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,69,1619,70],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1619,70,1619,72],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1620,13,1620,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1620,15,1620,31],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1620,31,1620,32],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1621,9,1621,10],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,9,1623,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,12,1623,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,13,1623,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,36,1623,37],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,38,1623,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,41,1623,42],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,42,1623,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,43,1623,44],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1623,44,1623,45],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,9,1624,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,12,1624,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,13,1624,35],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,36,1624,37],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,38,1624,41],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,41,1624,42],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,42,1624,43],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,43,1624,44],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1624,44,1624,45],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1625,9,1625,14],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1625,14,1625,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1626,7,1626,8],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1628,6,1628,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1628,14,1628,15],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1630,7,1630,12],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1630,12,1630,13],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1631,5,1631,6],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1632,3,1632,4],\"els\":[\"0:3063:5\",\"0:3\",\"0:1\"]},{\"tk\":[1635,3,1635,17],\"els\":[\"0:3062:27:3#out:1\"]},{\"tk\":[1635,18,1635,19],\"els\":[\"0:3101\",\"0:3\",\"0:1\"]},{\"tk\":[1635,20,1635,23],\"els\":[\"0:3101\",\"0:3\",\"0:1\"]},{\"tk\":[1635,24,1635,47],\"els\":[\"0:3101\",\"0:3\",\"0:1\"]},{\"tk\":[1635,48,1635,49],\"els\":[\"0:3101\",\"0:3\",\"0:1\"]},{\"tk\":[1635,50,1635,53],\"els\":[\"0:3101\",\"0:3\",\"0:1\"]},{\"tk\":[1635,54,1635,58],\"els\":[\"0:3101\",\"0:3\",\"0:1\"]},{\"tk\":[1645,3,1645,6],\"els\":[\"0:3103#out:1\"]},{\"tk\":[1645,7,1645,15],\"els\":[\"0:3103#out:1\"]},{\"tk\":[1645,16,1645,17],\"els\":[\"0:3103#out:1\",\"0:3103\",\"0:3\",\"0:1\"]},{\"tk\":[1645,19,1645,20],\"els\":[\"0:3063:4\",\"0:3\",\"0:1\"]},{\"tk\":[1645,20,1645,23],\"els\":[\"0:3063:4\",\"0:3\",\"0:1\"]},{\"tk\":[1645,24,1645,46],\"els\":[\"0:3063:4\",\"0:3\",\"0:1\"]},{\"tk\":[1645,47,1645,48],\"els\":[\"0:3102\",\"0:3\",\"0:1\"]},{\"tk\":[1645,49,1645,53],\"els\":[\"0:3099\",\"0:3\",\"0:1\"]},{\"tk\":[1645,54,1645,68],\"els\":[\"0:3062:27:3#out:1\"]},{\"tk\":[1645,70,1645,71],\"els\":[\"0:3100\",\"0:3\",\"0:1\"]},{\"tk\":[1645,72,1645,76],\"els\":[\"0:3098\",\"0:3\",\"0:1\"]},{\"tk\":[1646,20,1646,34],\"els\":[\"0:3062:27:3#out:1\"]},{\"tk\":[1646,36,1646,37],\"els\":[\"0:3104\",\"0:3\",\"0:1\"]},{\"tk\":[1646,38,1646,41],\"els\":[\"0:3104\",\"0:3\",\"0:1\"]},{\"tk\":[1646,42,1646,64],\"els\":[\"0:3104\",\"0:3\",\"0:1\"]},{\"tk\":[1646,66,1646,67],\"els\":[\"0:3103\",\"0:3\",\"0:1\"]},{\"tk\":[1647,5,1647,8],\"els\":[\"0:3103\",\"0:3\",\"0:1\"]},{\"tk\":[1647,9,1647,31],\"els\":[\"0:3103\",\"0:3\",\"0:1\"]},{\"tk\":[1652,3,1652,4],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,4,1652,8],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,8,1652,9],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,10,1652,16],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,16,1652,17],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,17,1652,18],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,18,1652,21],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,21,1652,22],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,22,1652,31],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,31,1652,32],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,32,1652,33],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,33,1652,34],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,34,1652,35],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,36,1652,37],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,37,1652,40],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,40,1652,41],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,41,1652,64],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1652,64,1652,65],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1653,17,1653,18],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1653,18,1653,19],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1653,19,1653,20],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,3,1654,4],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,4,1654,8],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,8,1654,9],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,10,1654,16],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,16,1654,17],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,17,1654,18],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,18,1654,21],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,21,1654,22],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,22,1654,31],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,31,1654,32],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,32,1654,33],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,33,1654,34],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,34,1654,35],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,36,1654,37],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,37,1654,40],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,40,1654,41],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,41,1654,49],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1654,49,1654,50],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1655,17,1655,18],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1655,18,1655,19],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1655,19,1655,20],\"els\":[\"0:3107\",\"0:3\",\"0:1\"]},{\"tk\":[1660,3,1660,4],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1661,5,1661,24],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1661,25,1661,40],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1661,41,1661,42],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1661,43,1661,44],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1662,7,1662,8],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1662,8,1662,19],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1662,20,1662,21],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1662,22,1662,40],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1662,40,1662,41],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,7,1663,8],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,8,1663,19],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,20,1663,21],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,22,1663,23],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,23,1663,24],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,24,1663,31],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,31,1663,32],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,32,1663,34],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,34,1663,35],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1663,35,1663,36],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1664,7,1664,8],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1664,8,1664,17],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1664,18,1664,19],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1664,20,1664,25],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1664,25,1664,26],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1665,7,1665,8],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1665,8,1665,18],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1665,19,1665,20],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1665,21,1665,24],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1665,24,1665,25],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1666,7,1666,8],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1666,8,1666,18],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1666,19,1666,20],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1666,21,1666,26],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1666,26,1666,27],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1667,7,1667,8],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1667,8,1667,17],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1667,18,1667,19],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1667,20,1667,25],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1668,5,1668,6],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1668,6,1668,7],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,5,1670,27],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,27,1670,28],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,28,1670,29],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,29,1670,30],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,31,1670,32],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,32,1670,33],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,34,1670,35],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,35,1670,50],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,50,1670,51],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,52,1670,56],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,56,1670,57],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1670,57,1670,58],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,5,1671,21],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,21,1671,22],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,22,1671,23],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,23,1671,24],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,25,1671,26],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,26,1671,27],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,28,1671,29],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,29,1671,44],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,44,1671,45],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,46,1671,50],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,50,1671,51],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,52,1671,53],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,53,1671,56],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,56,1671,57],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,57,1671,66],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,66,1671,67],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,67,1671,68],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,68,1671,69],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,69,1671,70],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1671,70,1671,71],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1672,3,1672,4],\"els\":[\"0:2913\",\"0:3\",\"0:1\"]},{\"tk\":[1677,3,1677,4],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,4,1677,8],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,8,1677,9],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,10,1677,16],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,16,1677,17],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,17,1677,18],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,18,1677,21],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,21,1677,22],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,22,1677,30],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,30,1677,31],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,31,1677,32],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,32,1677,33],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,33,1677,34],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,35,1677,36],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,36,1677,39],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,39,1677,40],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,40,1677,49],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1677,49,1677,50],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1678,17,1678,18],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1678,18,1678,19],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1678,19,1678,20],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,3,1679,4],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,4,1679,8],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,8,1679,9],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,10,1679,16],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,16,1679,17],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,17,1679,18],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,18,1679,21],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,21,1679,22],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,22,1679,30],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,30,1679,31],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,31,1679,32],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,32,1679,33],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,33,1679,34],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,35,1679,36],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,36,1679,39],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,39,1679,40],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,40,1679,44],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1679,44,1679,45],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1680,17,1680,18],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1680,18,1680,19],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1680,19,1680,20],\"els\":[\"0:3106\",\"0:3\",\"0:1\"]},{\"tk\":[1685,3,1685,4],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1686,5,1686,24],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1686,25,1686,40],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1686,41,1686,42],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1686,43,1686,44],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1687,7,1687,8],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1687,8,1687,19],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1687,20,1687,21],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1687,22,1687,40],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1687,40,1687,41],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,7,1688,8],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,8,1688,19],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,20,1688,21],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,22,1688,23],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,23,1688,24],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,24,1688,31],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,31,1688,32],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,32,1688,34],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,34,1688,35],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1688,35,1688,36],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1689,7,1689,8],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1689,8,1689,17],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1689,18,1689,19],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1689,20,1689,25],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1689,25,1689,26],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1690,7,1690,8],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1690,8,1690,18],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1690,19,1690,20],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1690,21,1690,24],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1690,24,1690,25],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1691,7,1691,8],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1691,8,1691,18],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1691,19,1691,20],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1691,21,1691,26],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1691,26,1691,27],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1692,7,1692,8],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1692,8,1692,17],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1692,18,1692,19],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1692,20,1692,25],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1693,5,1693,6],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1693,6,1693,7],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,5,1695,27],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,27,1695,28],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,28,1695,29],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,29,1695,30],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,31,1695,32],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,32,1695,33],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,34,1695,35],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,35,1695,50],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,50,1695,51],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,52,1695,56],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,56,1695,57],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1695,57,1695,58],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,5,1696,21],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,21,1696,22],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,22,1696,23],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,23,1696,24],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,25,1696,26],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,26,1696,27],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,28,1696,29],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,29,1696,44],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,44,1696,45],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,46,1696,50],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,50,1696,51],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,52,1696,53],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,53,1696,56],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,56,1696,57],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,57,1696,65],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,65,1696,66],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,66,1696,67],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,67,1696,68],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,68,1696,69],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1696,69,1696,70],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1697,3,1697,4],\"els\":[\"0:2912\",\"0:3\",\"0:1\"]},{\"tk\":[1706,3,1706,6],\"els\":[\"0:2910\",\"0:3\",\"0:1\"]},{\"tk\":[1706,7,1706,17],\"els\":[\"0:2910\",\"0:3\",\"0:1\"]},{\"tk\":[1706,18,1706,19],\"els\":[\"0:2910\",\"0:3\",\"0:1\"]},{\"tk\":[1706,21,1706,25],\"els\":[\"0:482\",\"0:3\",\"0:1\"]},{\"tk\":[1706,26,1706,27],\"els\":[\"0:482\",\"0:3\",\"0:1\"]},{\"tk\":[1706,28,1706,31],\"els\":[\"0:3010\",\"0:3\",\"0:1\"]},{\"tk\":[1706,32,1706,54],\"els\":[\"0:3010\",\"0:3\",\"0:1\"]},{\"tk\":[1706,55,1706,56],\"els\":[\"0:3010\",\"0:3\",\"0:1\"]},{\"tk\":[1706,57,1706,60],\"els\":[\"0:3010\",\"0:3\",\"0:1\"]},{\"tk\":[1706,61,1706,65],\"els\":[\"0:3010\",\"0:3\",\"0:1\"]},{\"tk\":[1706,66,1706,67],\"els\":[\"0:3010\",\"0:3\",\"0:1\"]},{\"tk\":[1706,68,1706,69],\"els\":[\"0:3010\",\"0:3\",\"0:1\",\"0:3117\"]},{\"tk\":[1706,77,1706,78],\"els\":[\"0:2908\",\"0:3\",\"0:1\"]},{\"tk\":[1707,5,1707,15],\"els\":[\"0:2908\",\"0:3\",\"0:1\"]},{\"tk\":[1707,16,1707,17],\"els\":[\"0:2910\",\"0:3\",\"0:1\"]},{\"tk\":[1707,18,1707,22],\"els\":[\"0:2910\",\"0:3\",\"0:1\",\"0:2907\"]},{\"tk\":[1710,3,1710,5],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1710,7,1710,10],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1710,11,1710,21],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1710,22,1710,23],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1710,24,1710,29],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1714,5,1714,8],\"els\":[\"0:2909\",\"0:3\",\"0:1\",\"0:2909#out:1\"]},{\"tk\":[1714,9,1714,19],\"els\":[\"0:2909\",\"0:3\",\"0:1\",\"0:2909#out:1\"]},{\"tk\":[1714,20,1714,21],\"els\":[\"0:2910\",\"0:2909\",\"0:3\",\"0:1\",\"0:2909#out:1\"]},{\"tk\":[1714,22,1714,27],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1715,10,1715,12],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1715,14,1715,17],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1715,18,1715,28],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1715,29,1715,30],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1715,31,1715,36],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1719,5,1719,8],\"els\":[\"0:2909\",\"0:3\",\"0:1\",\"0:2909#out:1\"]},{\"tk\":[1719,9,1719,19],\"els\":[\"0:2909\",\"0:3\",\"0:1\",\"0:2909#out:1\"]},{\"tk\":[1719,20,1719,21],\"els\":[\"0:2910\",\"0:2909\",\"0:3\",\"0:1\",\"0:2909#out:1\"]},{\"tk\":[1719,22,1719,27],\"els\":[\"0:2909\",\"0:3\",\"0:1\"]},{\"tk\":[1727,3,1727,4],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,5,1728,13],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,14,1728,19],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,20,1728,21],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,22,1728,40],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,41,1728,42],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,43,1728,46],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,46,1728,47],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,47,1728,57],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1728,57,1728,58],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,5,1729,29],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,29,1729,30],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,30,1729,38],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,38,1729,39],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,40,1729,42],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,42,1729,43],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,44,1729,72],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,72,1729,73],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,74,1729,79],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1729,79,1729,80],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1730,7,1730,8],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1730,8,1730,9],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1730,10,1730,14],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1730,14,1730,15],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1730,15,1730,16],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1731,3,1731,4],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[1734,3,1734,4],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,5,1735,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,12,1735,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,19,1735,32],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,33,1735,35],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,35,1735,36],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,36,1735,42],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,42,1735,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1735,43,1735,44],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1736,5,1736,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1736,12,1736,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1736,13,1736,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1736,15,1736,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1736,20,1736,21],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1737,5,1737,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1737,9,1737,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1737,10,1737,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,5,1740,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,11,1740,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,13,1740,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,17,1740,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,19,1740,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,20,1740,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,23,1740,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,24,1740,33],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,33,1740,34],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,34,1740,35],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,36,1740,47],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,47,1740,48],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1740,48,1740,49],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,5,1743,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,9,1743,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,10,1743,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,11,1743,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,12,1743,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,13,1743,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,15,1743,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,16,1743,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,17,1743,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,23,1743,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,25,1743,26],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,26,1743,28],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,28,1743,29],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1743,30,1743,31],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,7,1744,9],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,10,1744,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,11,1744,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,13,1744,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,14,1744,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,15,1744,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,16,1744,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,17,1744,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,19,1744,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,21,1744,26],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,26,1744,27],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1744,28,1744,29],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1745,9,1745,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1745,10,1745,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1745,12,1745,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1746,9,1746,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1746,14,1746,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1747,7,1747,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1748,5,1748,6],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,5,1752,6],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,7,1752,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,9,1752,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,15,1752,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,17,1752,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,19,1752,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,20,1752,21],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,21,1752,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,22,1752,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,23,1752,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1752,24,1752,25],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,5,1753,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,12,1753,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,14,1753,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,16,1753,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,17,1753,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,18,1753,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,19,1753,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,20,1753,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1753,24,1753,25],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1754,5,1754,6],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1755,6,1755,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1755,11,1755,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1755,19,1755,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1758,7,1758,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1759,9,1759,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1759,16,1759,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1759,18,1759,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1759,20,1759,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1759,22,1759,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1760,9,1760,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1760,16,1760,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1760,22,1760,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,9,1761,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,12,1761,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,14,1761,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,16,1761,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,17,1761,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,18,1761,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,19,1761,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,20,1761,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,24,1761,25],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,25,1761,33],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,33,1761,34],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,34,1761,38],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,38,1761,39],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,39,1761,40],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,40,1761,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,42,1761,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,44,1761,46],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,46,1761,47],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,47,1761,48],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,48,1761,49],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,49,1761,50],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,50,1761,54],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,54,1761,55],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,55,1761,63],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,63,1761,64],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,64,1761,69],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,69,1761,70],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,70,1761,71],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,71,1761,72],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1761,72,1761,73],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,9,1762,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,12,1762,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,14,1762,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,16,1762,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,17,1762,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,18,1762,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,19,1762,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,20,1762,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,24,1762,25],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,25,1762,33],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,33,1762,34],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,34,1762,38],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,38,1762,39],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,39,1762,40],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,40,1762,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,42,1762,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,44,1762,46],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,46,1762,47],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,47,1762,48],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,48,1762,49],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,49,1762,50],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,50,1762,54],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,54,1762,55],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,55,1762,63],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,63,1762,64],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,64,1762,69],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,69,1762,70],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,70,1762,71],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,71,1762,72],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1762,72,1762,73],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,9,1763,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,16,1763,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,18,1763,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,22,1763,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,23,1763,25],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,25,1763,26],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,26,1763,28],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,29,1763,30],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,31,1763,33],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,33,1763,34],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,34,1763,36],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,36,1763,37],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1763,37,1763,38],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1764,9,1764,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1764,12,1764,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1764,15,1764,21],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1764,21,1764,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1765,9,1765,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1765,12,1765,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1765,15,1765,21],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1765,21,1765,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1768,9,1768,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1768,12,1768,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1768,13,1768,35],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1768,36,1768,37],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1768,38,1768,40],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1768,40,1768,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,9,1769,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,12,1769,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,13,1769,36],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,37,1769,38],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,39,1769,40],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,40,1769,42],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1769,42,1769,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1770,9,1770,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1770,14,1770,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1771,7,1771,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1773,6,1773,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1773,11,1773,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1773,22,1773,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1774,7,1774,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1775,9,1775,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1775,16,1775,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1775,17,1775,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,9,1776,11],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,12,1776,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,13,1776,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,15,1776,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,16,1776,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,17,1776,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,18,1776,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,19,1776,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,23,1776,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,24,1776,35],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,35,1776,36],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,36,1776,39],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,40,1776,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,42,1776,45],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,45,1776,46],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1776,47,1776,48],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,11,1777,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,13,1777,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,15,1777,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,16,1777,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,17,1777,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,18,1777,20],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,20,1777,21],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,21,1777,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,22,1777,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,23,1777,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,24,1777,28],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,28,1777,29],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,29,1777,40],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,40,1777,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,41,1777,42],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,42,1777,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,44,1777,45],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,46,1777,48],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,48,1777,49],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,49,1777,50],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,50,1777,51],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,51,1777,52],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,52,1777,56],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,56,1777,57],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,57,1777,68],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,68,1777,69],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,69,1777,71],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1777,71,1777,72],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1778,9,1778,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1778,11,1778,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1778,16,1778,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,11,1779,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,13,1779,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,15,1779,16],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,16,1779,17],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,17,1779,18],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,18,1779,19],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,19,1779,21],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,21,1779,22],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,22,1779,23],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,23,1779,24],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,24,1779,25],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,25,1779,29],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,29,1779,30],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,30,1779,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,41,1779,42],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,42,1779,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,43,1779,44],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,45,1779,46],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,47,1779,49],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,49,1779,50],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,50,1779,51],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,51,1779,52],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,52,1779,53],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,53,1779,57],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,57,1779,58],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,58,1779,69],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,69,1779,70],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1779,70,1779,72],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1780,13,1780,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1780,15,1780,31],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1780,31,1780,32],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1781,9,1781,10],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,9,1783,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,12,1783,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,13,1783,35],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,36,1783,37],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,38,1783,41],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,41,1783,42],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,42,1783,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,43,1783,44],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1783,44,1783,45],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,9,1784,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,12,1784,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,13,1784,36],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,37,1784,38],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,39,1784,42],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,42,1784,43],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,43,1784,44],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,44,1784,45],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1784,45,1784,46],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1785,9,1785,14],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1785,14,1785,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1786,7,1786,8],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1788,6,1788,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1788,14,1788,15],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1790,7,1790,12],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1790,12,1790,13],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1791,5,1791,6],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1792,3,1792,4],\"els\":[\"0:3062:33\",\"0:3\",\"0:1\"]},{\"tk\":[1799,3,1799,25],\"els\":[\"0:3062:26#out:1\"]},{\"tk\":[1799,26,1799,27],\"els\":[\"0:3062:26#out:1\",\"0:3062:26\",\"0:3\",\"0:1\"]},{\"tk\":[1799,28,1799,39],\"els\":[\"0:58#out:1\"]},{\"tk\":[1799,40,1799,41],\"els\":[\"0:3062:50\",\"0:3\",\"0:1\"]},{\"tk\":[1799,42,1799,43],\"els\":[\"0:3062:32\",\"0:3\",\"0:1\"]},{\"tk\":[1799,43,1799,46],\"els\":[\"0:3062:32\",\"0:3\",\"0:1\"]},{\"tk\":[1799,47,1799,70],\"els\":[\"0:3062:32\",\"0:3\",\"0:1\"]},{\"tk\":[1799,71,1799,72],\"els\":[\"0:3062:51\",\"0:3\",\"0:1\"]},{\"tk\":[1800,5,1800,15],\"els\":[\"0:3156#out:1\"]},{\"tk\":[1800,16,1800,17],\"els\":[\"0:3062:50\",\"0:3\",\"0:1\"]},{\"tk\":[1800,18,1800,21],\"els\":[\"0:3062:50\",\"0:3\",\"0:1\"]},{\"tk\":[1800,22,1800,44],\"els\":[\"0:3062:50\",\"0:3\",\"0:1\"]},{\"tk\":[1803,3,1803,4],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,5,1804,13],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,14,1804,15],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,16,1804,35],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,35,1804,36],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,36,1804,40],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,40,1804,41],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,41,1804,58],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1804,58,1804,59],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1805,5,1805,13],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1805,14,1805,16],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1805,17,1805,35],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1805,35,1805,36],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1805,36,1805,58],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1805,58,1805,59],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1806,3,1806,4],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1813,3,1813,7],\"els\":[\"0:3062:43\",\"0:3\",\"0:1\",\"0:3062:44\"]},{\"tk\":[1813,8,1813,26],\"els\":[\"0:3062:43\",\"0:3\",\"0:1\",\"0:3062:44\"]},{\"tk\":[1813,27,1813,28],\"els\":[\"0:3062:43\",\"0:3\",\"0:1\"]},{\"tk\":[1813,29,1813,34],\"els\":[\"0:3062:42\",\"0:3\",\"0:1\"]},{\"tk\":[1813,35,1813,36],\"els\":[\"0:3062:42\",\"0:3\",\"0:1\"]},{\"tk\":[1813,37,1813,38],\"els\":[\"0:3062:27:3\",\"0:3\",\"0:1\"]},{\"tk\":[1813,47,1813,55],\"els\":[\"0:3062:27:3\",\"0:3\",\"0:1\"]},{\"tk\":[1813,56,1813,57],\"els\":[\"0:3062:43\",\"0:3\",\"0:1\"]},{\"tk\":[1813,58,1813,61],\"els\":[\"0:3062:43\",\"0:3\",\"0:1\"]},{\"tk\":[1813,62,1813,71],\"els\":[\"0:3062:43\",\"0:3\",\"0:1\"]},{\"tk\":[1816,3,1816,7],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1816,8,1816,24],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1816,24,1816,25],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1816,25,1816,26],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1816,28,1816,29],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1816,30,1816,33],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1816,34,1816,43],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,3,1817,7],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,8,1817,24],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,24,1817,25],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,25,1817,26],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,28,1817,29],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,30,1817,33],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1817,34,1817,38],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,3,1818,7],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,8,1818,24],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,24,1818,25],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,25,1818,26],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,28,1818,29],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,30,1818,33],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1818,34,1818,57],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,3,1819,7],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,8,1819,24],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,24,1819,25],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,25,1819,26],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,28,1819,29],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,30,1819,33],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1819,34,1819,42],\"els\":[\"0:3224\",\"0:3\",\"0:1\"]},{\"tk\":[1822,3,1822,7],\"els\":[\"0:2892\",\"0:3\",\"0:1\"]},{\"tk\":[1822,8,1822,26],\"els\":[\"0:2892\",\"0:3\",\"0:1\"]},{\"tk\":[1822,27,1822,28],\"els\":[\"0:2892\",\"0:3\",\"0:1\"]},{\"tk\":[1822,29,1822,32],\"els\":[\"0:2892\",\"0:3\",\"0:1\"]},{\"tk\":[1822,33,1822,54],\"els\":[\"0:2892\",\"0:3\",\"0:1\"]},{\"tk\":[1825,3,1825,4],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1826,5,1826,11],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1826,12,1826,16],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1826,16,1826,17],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1826,17,1826,18],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1826,18,1826,19],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1826,19,1826,20],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,5,1827,9],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,9,1827,10],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,10,1827,11],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,11,1827,12],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,13,1827,14],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,15,1827,18],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,18,1827,19],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,19,1827,23],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,23,1827,24],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,24,1827,41],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1827,41,1827,42],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,5,1828,9],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,9,1828,10],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,10,1828,11],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,11,1828,12],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,13,1828,15],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,16,1828,35],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,35,1828,36],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,36,1828,58],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1828,58,1828,59],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,5,1829,6],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,6,1829,10],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,10,1829,11],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,12,1829,18],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,18,1829,19],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,19,1829,20],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,20,1829,24],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,24,1829,25],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,25,1829,42],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,42,1829,43],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,44,1829,48],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1829,48,1829,49],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,19,1830,25],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,25,1830,26],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,26,1830,32],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,32,1830,33],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,33,1830,34],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,34,1830,35],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,35,1830,36],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1830,36,1830,37],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1831,3,1831,4],\"els\":[\"0:3062:25\",\"0:3\",\"0:1\"]},{\"tk\":[1852,3,1852,5],\"els\":[\"0:14\"]},{\"tk\":[1852,7,1852,10],\"els\":[\"0:14\"]},{\"tk\":[1852,10,1852,12],\"els\":[\"0:14\"]},{\"tk\":[1852,12,1852,18],\"els\":[\"0:14\"]},{\"tk\":[1852,18,1852,19],\"els\":[\"0:14\"]},{\"tk\":[1852,19,1852,34],\"els\":[\"0:14\"]},{\"tk\":[1852,34,1852,35],\"els\":[\"0:14\"]},{\"tk\":[1852,35,1852,41],\"els\":[\"0:14\"]},{\"tk\":[1856,5,1856,9],\"els\":[\"0:14\"]},{\"tk\":[1856,10,1856,31],\"els\":[\"0:14\"]},{\"tk\":[1856,31,1856,32],\"els\":[\"0:14\"]},{\"tk\":[1856,32,1856,33],\"els\":[\"0:14\"]},{\"tk\":[1856,35,1856,36],\"els\":[\"0:14\"]},{\"tk\":[1856,37,1856,40],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1856,41,1856,45],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1856,46,1856,47],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1856,48,1856,51],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1856,52,1856,73],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1856,74,1856,75],\"els\":[\"0:1016:19\",\"0:3\",\"0:1\"]},{\"tk\":[1857,7,1857,10],\"els\":[\"0:1016:19\",\"0:3\",\"0:1\"]},{\"tk\":[1857,11,1857,22],\"els\":[\"0:1016:19\",\"0:3\",\"0:1\"]},{\"tk\":[1858,5,1858,9],\"els\":[\"0:14\"]},{\"tk\":[1858,10,1858,31],\"els\":[\"0:14\"]},{\"tk\":[1858,31,1858,32],\"els\":[\"0:14\"]},{\"tk\":[1858,32,1858,33],\"els\":[\"0:14\"]},{\"tk\":[1858,35,1858,36],\"els\":[\"0:14\"]},{\"tk\":[1858,37,1858,40],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1858,41,1858,45],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1858,46,1858,47],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1858,48,1858,51],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1858,52,1858,73],\"els\":[\"0:1016:18\",\"0:3\",\"0:1\"]},{\"tk\":[1858,74,1858,75],\"els\":[\"0:1016:19\",\"0:3\",\"0:1\"]},{\"tk\":[1859,7,1859,10],\"els\":[\"0:1016:19\",\"0:3\",\"0:1\"]},{\"tk\":[1859,11,1859,22],\"els\":[\"0:1016:19\",\"0:3\",\"0:1\"]},{\"tk\":[1860,5,1860,9],\"els\":[\"0:14\"]},{\"tk\":[1860,10,1860,31],\"els\":[\"0:14\"]},{\"tk\":[1860,31,1860,32],\"els\":[\"0:14\"]},{\"tk\":[1860,32,1860,33],\"els\":[\"0:14\"]},{\"tk\":[1860,35,1860,36],\"els\":[\"0:14\"]},{\"tk\":[1860,37,1860,40],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1860,41,1860,64],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1861,5,1861,9],\"els\":[\"0:14\"]},{\"tk\":[1861,10,1861,31],\"els\":[\"0:14\"]},{\"tk\":[1861,31,1861,32],\"els\":[\"0:14\"]},{\"tk\":[1861,32,1861,33],\"els\":[\"0:14\"]},{\"tk\":[1861,35,1861,36],\"els\":[\"0:14\"]},{\"tk\":[1861,37,1861,40],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1861,41,1861,63],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1862,5,1862,9],\"els\":[\"0:14\"]},{\"tk\":[1862,10,1862,31],\"els\":[\"0:14\"]},{\"tk\":[1862,31,1862,32],\"els\":[\"0:14\"]},{\"tk\":[1862,32,1862,33],\"els\":[\"0:14\"]},{\"tk\":[1862,35,1862,36],\"els\":[\"0:14\"]},{\"tk\":[1862,37,1862,40],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1862,41,1862,54],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1862,54,1862,55],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1862,55,1862,56],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1862,58,1862,59],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1863,7,1863,10],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1863,11,1863,34],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1863,35,1863,36],\"els\":[\"0:977:19\",\"0:3\",\"0:1\"]},{\"tk\":[1863,37,1863,40],\"els\":[\"0:977:19\",\"0:3\",\"0:1\"]},{\"tk\":[1863,41,1863,54],\"els\":[\"0:977:19\",\"0:3\",\"0:1\"]},{\"tk\":[1864,5,1864,9],\"els\":[\"0:14\"]},{\"tk\":[1864,10,1864,31],\"els\":[\"0:14\"]},{\"tk\":[1864,31,1864,32],\"els\":[\"0:14\"]},{\"tk\":[1864,32,1864,33],\"els\":[\"0:14\"]},{\"tk\":[1864,35,1864,36],\"els\":[\"0:14\"]},{\"tk\":[1864,37,1864,40],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1864,41,1864,54],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1864,54,1864,55],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1864,55,1864,56],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1864,58,1864,59],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1865,7,1865,10],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1865,11,1865,34],\"els\":[\"0:977:18\",\"0:3\",\"0:1\"]},{\"tk\":[1865,35,1865,36],\"els\":[\"0:977:19\",\"0:3\",\"0:1\"]},{\"tk\":[1865,37,1865,40],\"els\":[\"0:977:19\",\"0:3\",\"0:1\"]},{\"tk\":[1865,41,1865,54],\"els\":[\"0:977:19\",\"0:3\",\"0:1\"]},{\"tk\":[1866,5,1866,9],\"els\":[\"0:14\"]},{\"tk\":[1866,10,1866,31],\"els\":[\"0:14\"]},{\"tk\":[1866,31,1866,32],\"els\":[\"0:14\"]},{\"tk\":[1866,32,1866,33],\"els\":[\"0:14\"]},{\"tk\":[1866,35,1866,36],\"els\":[\"0:14\"]},{\"tk\":[1866,37,1866,40],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1866,41,1866,54],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1866,54,1866,55],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1866,55,1866,56],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1867,5,1867,9],\"els\":[\"0:14\"]},{\"tk\":[1867,10,1867,31],\"els\":[\"0:14\"]},{\"tk\":[1867,31,1867,32],\"els\":[\"0:14\"]},{\"tk\":[1867,32,1867,33],\"els\":[\"0:14\"]},{\"tk\":[1867,35,1867,36],\"els\":[\"0:14\"]},{\"tk\":[1867,37,1867,40],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1867,41,1867,54],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1867,54,1867,55],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1867,55,1867,56],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1867,58,1867,59],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1868,7,1868,10],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1868,11,1868,34],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1868,35,1868,36],\"els\":[\"0:983:19\",\"0:3\",\"0:1\"]},{\"tk\":[1868,37,1868,40],\"els\":[\"0:983:19\",\"0:3\",\"0:1\"]},{\"tk\":[1868,41,1868,54],\"els\":[\"0:983:19\",\"0:3\",\"0:1\"]},{\"tk\":[1869,5,1869,9],\"els\":[\"0:14\"]},{\"tk\":[1869,10,1869,31],\"els\":[\"0:14\"]},{\"tk\":[1869,31,1869,32],\"els\":[\"0:14\"]},{\"tk\":[1869,32,1869,33],\"els\":[\"0:14\"]},{\"tk\":[1869,35,1869,36],\"els\":[\"0:14\"]},{\"tk\":[1869,37,1869,40],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1869,41,1869,54],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1869,54,1869,55],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1869,55,1869,56],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1869,58,1869,59],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1870,7,1870,10],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1870,11,1870,34],\"els\":[\"0:983:18\",\"0:3\",\"0:1\"]},{\"tk\":[1870,35,1870,36],\"els\":[\"0:983:19\",\"0:3\",\"0:1\"]},{\"tk\":[1870,37,1870,40],\"els\":[\"0:983:19\",\"0:3\",\"0:1\"]},{\"tk\":[1870,41,1870,54],\"els\":[\"0:983:19\",\"0:3\",\"0:1\"]},{\"tk\":[1871,5,1871,9],\"els\":[\"0:14\"]},{\"tk\":[1871,10,1871,31],\"els\":[\"0:14\"]},{\"tk\":[1871,31,1871,32],\"els\":[\"0:14\"]},{\"tk\":[1871,32,1871,33],\"els\":[\"0:14\"]},{\"tk\":[1871,35,1871,36],\"els\":[\"0:14\"]},{\"tk\":[1871,37,1871,40],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1871,41,1871,54],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1871,54,1871,55],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1871,55,1871,56],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1872,5,1872,9],\"els\":[\"0:14\"]},{\"tk\":[1872,10,1872,31],\"els\":[\"0:14\"]},{\"tk\":[1872,31,1872,32],\"els\":[\"0:14\"]},{\"tk\":[1872,32,1872,34],\"els\":[\"0:14\"]},{\"tk\":[1872,36,1872,37],\"els\":[\"0:14\"]},{\"tk\":[1872,38,1872,41],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1872,42,1872,55],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1872,55,1872,56],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1872,56,1872,57],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1872,59,1872,60],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1873,7,1873,10],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1873,11,1873,34],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1873,35,1873,36],\"els\":[\"0:990:19\",\"0:3\",\"0:1\"]},{\"tk\":[1873,37,1873,40],\"els\":[\"0:990:19\",\"0:3\",\"0:1\"]},{\"tk\":[1873,41,1873,55],\"els\":[\"0:990:19\",\"0:3\",\"0:1\"]},{\"tk\":[1874,5,1874,9],\"els\":[\"0:14\"]},{\"tk\":[1874,10,1874,31],\"els\":[\"0:14\"]},{\"tk\":[1874,31,1874,32],\"els\":[\"0:14\"]},{\"tk\":[1874,32,1874,34],\"els\":[\"0:14\"]},{\"tk\":[1874,36,1874,37],\"els\":[\"0:14\"]},{\"tk\":[1874,38,1874,41],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1874,42,1874,55],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1874,55,1874,56],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1874,56,1874,57],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1874,59,1874,60],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1875,7,1875,10],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1875,11,1875,34],\"els\":[\"0:990:18\",\"0:3\",\"0:1\"]},{\"tk\":[1875,35,1875,36],\"els\":[\"0:990:19\",\"0:3\",\"0:1\"]},{\"tk\":[1875,37,1875,40],\"els\":[\"0:990:19\",\"0:3\",\"0:1\"]},{\"tk\":[1875,41,1875,55],\"els\":[\"0:990:19\",\"0:3\",\"0:1\"]},{\"tk\":[1876,5,1876,9],\"els\":[\"0:14\"]},{\"tk\":[1876,10,1876,31],\"els\":[\"0:14\"]},{\"tk\":[1876,31,1876,32],\"els\":[\"0:14\"]},{\"tk\":[1876,32,1876,34],\"els\":[\"0:14\"]},{\"tk\":[1876,36,1876,37],\"els\":[\"0:14\"]},{\"tk\":[1876,38,1876,41],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1876,42,1876,55],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1876,55,1876,56],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1876,56,1876,58],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1877,5,1877,9],\"els\":[\"0:14\"]},{\"tk\":[1877,10,1877,31],\"els\":[\"0:14\"]},{\"tk\":[1877,31,1877,32],\"els\":[\"0:14\"]},{\"tk\":[1877,32,1877,34],\"els\":[\"0:14\"]},{\"tk\":[1877,36,1877,37],\"els\":[\"0:14\"]},{\"tk\":[1877,38,1877,41],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1877,42,1877,55],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1877,55,1877,56],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1877,56,1877,58],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1877,60,1877,61],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1878,7,1878,10],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1878,11,1878,34],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1878,35,1878,36],\"els\":[\"0:997:19\",\"0:3\",\"0:1\"]},{\"tk\":[1878,37,1878,40],\"els\":[\"0:997:19\",\"0:3\",\"0:1\"]},{\"tk\":[1878,41,1878,54],\"els\":[\"0:997:19\",\"0:3\",\"0:1\"]},{\"tk\":[1879,5,1879,9],\"els\":[\"0:14\"]},{\"tk\":[1879,10,1879,31],\"els\":[\"0:14\"]},{\"tk\":[1879,31,1879,32],\"els\":[\"0:14\"]},{\"tk\":[1879,32,1879,34],\"els\":[\"0:14\"]},{\"tk\":[1879,36,1879,37],\"els\":[\"0:14\"]},{\"tk\":[1879,38,1879,41],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1879,42,1879,55],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1879,55,1879,56],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1879,56,1879,58],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1879,60,1879,61],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1880,7,1880,10],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1880,11,1880,34],\"els\":[\"0:997:18\",\"0:3\",\"0:1\"]},{\"tk\":[1880,35,1880,36],\"els\":[\"0:997:19\",\"0:3\",\"0:1\"]},{\"tk\":[1880,37,1880,40],\"els\":[\"0:997:19\",\"0:3\",\"0:1\"]},{\"tk\":[1880,41,1880,54],\"els\":[\"0:997:19\",\"0:3\",\"0:1\"]},{\"tk\":[1881,5,1881,9],\"els\":[\"0:14\"]},{\"tk\":[1881,10,1881,31],\"els\":[\"0:14\"]},{\"tk\":[1881,31,1881,32],\"els\":[\"0:14\"]},{\"tk\":[1881,32,1881,34],\"els\":[\"0:14\"]},{\"tk\":[1881,36,1881,37],\"els\":[\"0:14\"]},{\"tk\":[1881,38,1881,41],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1881,42,1881,55],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1881,55,1881,56],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1881,56,1881,58],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1882,5,1882,9],\"els\":[\"0:14\"]},{\"tk\":[1882,10,1882,31],\"els\":[\"0:14\"]},{\"tk\":[1882,31,1882,32],\"els\":[\"0:14\"]},{\"tk\":[1882,32,1882,34],\"els\":[\"0:14\"]},{\"tk\":[1882,36,1882,37],\"els\":[\"0:14\"]},{\"tk\":[1882,38,1882,41],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1882,42,1882,55],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1882,55,1882,56],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1882,56,1882,58],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1882,60,1882,61],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1883,7,1883,10],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1883,11,1883,35],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1883,36,1883,37],\"els\":[\"0:1004:19\",\"0:3\",\"0:1\"]},{\"tk\":[1883,38,1883,41],\"els\":[\"0:1004:19\",\"0:3\",\"0:1\"]},{\"tk\":[1883,42,1883,55],\"els\":[\"0:1004:19\",\"0:3\",\"0:1\"]},{\"tk\":[1884,5,1884,9],\"els\":[\"0:14\"]},{\"tk\":[1884,10,1884,31],\"els\":[\"0:14\"]},{\"tk\":[1884,31,1884,32],\"els\":[\"0:14\"]},{\"tk\":[1884,32,1884,34],\"els\":[\"0:14\"]},{\"tk\":[1884,36,1884,37],\"els\":[\"0:14\"]},{\"tk\":[1884,38,1884,41],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1884,42,1884,55],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1884,55,1884,56],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1884,56,1884,58],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1884,60,1884,61],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1885,7,1885,10],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1885,11,1885,34],\"els\":[\"0:1004:18\",\"0:3\",\"0:1\"]},{\"tk\":[1885,35,1885,36],\"els\":[\"0:1004:19\",\"0:3\",\"0:1\"]},{\"tk\":[1885,37,1885,40],\"els\":[\"0:1004:19\",\"0:3\",\"0:1\"]},{\"tk\":[1885,41,1885,54],\"els\":[\"0:1004:19\",\"0:3\",\"0:1\"]},{\"tk\":[1886,5,1886,9],\"els\":[\"0:14\"]},{\"tk\":[1886,10,1886,31],\"els\":[\"0:14\"]},{\"tk\":[1886,31,1886,32],\"els\":[\"0:14\"]},{\"tk\":[1886,32,1886,34],\"els\":[\"0:14\"]},{\"tk\":[1886,36,1886,37],\"els\":[\"0:14\"]},{\"tk\":[1886,38,1886,41],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1886,42,1886,55],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1886,55,1886,56],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1886,56,1886,58],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1887,5,1887,9],\"els\":[\"0:14\"]},{\"tk\":[1887,10,1887,31],\"els\":[\"0:14\"]},{\"tk\":[1887,31,1887,32],\"els\":[\"0:14\"]},{\"tk\":[1887,32,1887,34],\"els\":[\"0:14\"]},{\"tk\":[1887,36,1887,37],\"els\":[\"0:14\"]},{\"tk\":[1887,38,1887,41],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1887,42,1887,55],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1887,55,1887,56],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1887,56,1887,58],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1887,60,1887,61],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1888,7,1888,10],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1888,11,1888,35],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1888,36,1888,37],\"els\":[\"0:1011:19\",\"0:3\",\"0:1\"]},{\"tk\":[1888,38,1888,41],\"els\":[\"0:1011:19\",\"0:3\",\"0:1\"]},{\"tk\":[1888,42,1888,55],\"els\":[\"0:1011:19\",\"0:3\",\"0:1\"]},{\"tk\":[1889,5,1889,9],\"els\":[\"0:14\"]},{\"tk\":[1889,10,1889,31],\"els\":[\"0:14\"]},{\"tk\":[1889,31,1889,32],\"els\":[\"0:14\"]},{\"tk\":[1889,32,1889,34],\"els\":[\"0:14\"]},{\"tk\":[1889,36,1889,37],\"els\":[\"0:14\"]},{\"tk\":[1889,38,1889,41],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1889,42,1889,55],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1889,55,1889,56],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1889,56,1889,58],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1889,60,1889,61],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1890,7,1890,10],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1890,11,1890,34],\"els\":[\"0:1011:18\",\"0:3\",\"0:1\"]},{\"tk\":[1890,35,1890,36],\"els\":[\"0:1011:19\",\"0:3\",\"0:1\"]},{\"tk\":[1890,37,1890,40],\"els\":[\"0:1011:19\",\"0:3\",\"0:1\"]},{\"tk\":[1890,41,1890,54],\"els\":[\"0:1011:19\",\"0:3\",\"0:1\"]},{\"tk\":[1891,5,1891,9],\"els\":[\"0:14\"]},{\"tk\":[1891,10,1891,31],\"els\":[\"0:14\"]},{\"tk\":[1891,31,1891,32],\"els\":[\"0:14\"]},{\"tk\":[1891,32,1891,34],\"els\":[\"0:14\"]},{\"tk\":[1891,36,1891,37],\"els\":[\"0:14\"]},{\"tk\":[1891,38,1891,41],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1891,42,1891,55],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1891,55,1891,56],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1891,56,1891,58],\"els\":[\"0:6\",\"0:3\",\"0:1\"]},{\"tk\":[1911,3,1911,9],\"els\":[\"0:14#out:1\",\"0:14\"]},{\"tk\":[1911,11,1911,14],\"els\":[\"0:14#out:1\"]},{\"tk\":[1911,15,1911,29],\"els\":[\"0:14#out:1\"]},{\"tk\":[1911,29,1911,30],\"els\":[\"0:14#out:1\"]},{\"tk\":[1911,30,1911,31],\"els\":[\"0:14#out:1\"]},{\"tk\":[1911,35,1911,39],\"els\":[\"0:14\"]},{\"tk\":[1911,40,1911,61],\"els\":[\"0:14\"]},{\"tk\":[1911,61,1911,62],\"els\":[\"0:14\"]},{\"tk\":[1911,62,1911,63],\"els\":[\"0:14\"]},{\"tk\":[1911,66,1911,69],\"els\":[\"0:14#out:1\",\"0:14\"]},{\"tk\":[1911,70,1911,71],\"els\":[\"0:14#out:1\",\"0:14\"]},{\"tk\":[1911,72,1911,78],\"els\":[\"0:14#out:1\",\"0:14\"]},{\"tk\":[1920,3,1920,4],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,4,1920,8],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,8,1920,9],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,9,1920,15],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,15,1920,16],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,16,1920,17],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,17,1920,24],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,24,1920,25],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,25,1920,26],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,26,1920,27],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,27,1920,30],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,30,1920,31],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,31,1920,42],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,42,1920,43],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,43,1920,44],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,44,1920,45],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,46,1920,47],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,48,1920,49],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,49,1920,50],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,51,1920,52],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,52,1920,59],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,59,1920,60],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,60,1920,61],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,61,1920,62],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,62,1920,65],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,65,1920,66],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1920,66,1920,80],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,16,1921,17],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,17,1921,18],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,18,1921,19],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,19,1921,20],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,21,1921,23],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,23,1921,24],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1921,24,1921,25],\"els\":[\"0:2756\",\"0:2753\",\"0:2749\"]},{\"tk\":[1926,3,1926,7],\"els\":[\"0:2761\",\"0:2753\",\"0:2749\",\"0:2759\"]},{\"tk\":[1926,8,1926,22],\"els\":[\"0:2761\",\"0:2753\",\"0:2749\",\"0:2759\"]},{\"tk\":[1926,23,1926,24],\"els\":[\"0:2761\",\"0:2753\",\"0:2749\"]},{\"tk\":[1926,25,1926,26],\"els\":[\"0:2761\",\"0:2753\",\"0:2749\"]},{\"tk\":[1926,26,1926,30],\"els\":[\"0:2759\",\"0:2753\",\"0:2749\"]},{\"tk\":[1926,31,1926,45],\"els\":[\"0:2759\",\"0:2753\",\"0:2749\"]},{\"tk\":[1933,3,1933,7],\"els\":[\"0:2751\"]},{\"tk\":[1933,8,1933,18],\"els\":[\"0:2751\"]},{\"tk\":[1933,19,1933,20],\"els\":[\"0:2751\"]},{\"tk\":[1933,21,1933,25],\"els\":[\"0:2751\",\"0:2759\"]},{\"tk\":[1933,26,1933,40],\"els\":[\"0:2751\",\"0:2759\"]},{\"tk\":[1943,3,1943,7],\"els\":[\"0:2752\"]},{\"tk\":[1943,8,1943,19],\"els\":[\"0:2752\"]},{\"tk\":[1943,19,1943,20],\"els\":[\"0:2752\"]},{\"tk\":[1943,20,1943,21],\"els\":[\"0:2752\"]},{\"tk\":[1943,23,1943,24],\"els\":[\"0:2752\"]},{\"tk\":[1943,25,1943,29],\"els\":[\"0:2763\",\"0:2753\",\"0:2749\",\"0:2757\"]},{\"tk\":[1944,3,1944,9],\"els\":[\"0:2752\"]},{\"tk\":[1944,11,1944,15],\"els\":[\"0:2752\"]},{\"tk\":[1944,16,1944,27],\"els\":[\"0:2752\"]},{\"tk\":[1944,27,1944,28],\"els\":[\"0:2752\"]},{\"tk\":[1944,28,1944,29],\"els\":[\"0:2752\"]},{\"tk\":[1944,33,1944,36],\"els\":[\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1944,37,1944,48],\"els\":[\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1944,48,1944,49],\"els\":[\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1944,49,1944,50],\"els\":[\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1944,53,1944,56],\"els\":[\"0:2752\",\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1944,57,1944,58],\"els\":[\"0:2752\",\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1944,59,1944,65],\"els\":[\"0:2752\",\"0:2763\",\"0:2753\",\"0:2749\"]},{\"tk\":[1945,3,1945,7],\"els\":[\"0:2752\"]},{\"tk\":[1945,8,1945,19],\"els\":[\"0:2752\"]},{\"tk\":[1945,19,1945,20],\"els\":[\"0:2752\"]},{\"tk\":[1945,20,1945,22],\"els\":[\"0:2752\"]},{\"tk\":[1945,24,1945,25],\"els\":[\"0:2752\"]},{\"tk\":[1945,26,1945,30],\"els\":[\"0:2763\",\"0:2753\",\"0:2749\",\"0:2758\"]},{\"tk\":[1954,3,1954,4],\"els\":[\"0:2587\"]},{\"tk\":[1955,5,1955,10],\"els\":[\"0:2587\"]},{\"tk\":[1955,11,1955,32],\"els\":[\"0:2587\"]},{\"tk\":[1955,33,1955,51],\"els\":[\"0:2587\"]},{\"tk\":[1955,52,1955,53],\"els\":[\"0:2587\"]},{\"tk\":[1955,54,1955,55],\"els\":[\"0:2587\"]},{\"tk\":[1956,7,1956,8],\"els\":[\"0:2587\"]},{\"tk\":[1956,8,1956,16],\"els\":[\"0:2587\"]},{\"tk\":[1956,17,1956,18],\"els\":[\"0:2587\"]},{\"tk\":[1956,19,1956,44],\"els\":[\"0:2587\"]},{\"tk\":[1956,44,1956,45],\"els\":[\"0:2587\"]},{\"tk\":[1957,7,1957,8],\"els\":[\"0:2587\"]},{\"tk\":[1957,8,1957,18],\"els\":[\"0:2587\"]},{\"tk\":[1957,19,1957,20],\"els\":[\"0:2587\"]},{\"tk\":[1957,21,1957,24],\"els\":[\"0:2587\"]},{\"tk\":[1957,24,1957,25],\"els\":[\"0:2587\"]},{\"tk\":[1958,7,1958,8],\"els\":[\"0:2587\"]},{\"tk\":[1958,8,1958,22],\"els\":[\"0:2587\"]},{\"tk\":[1958,23,1958,24],\"els\":[\"0:2587\"]},{\"tk\":[1958,25,1958,53],\"els\":[\"0:2587\"]},{\"tk\":[1958,53,1958,54],\"els\":[\"0:2587\"]},{\"tk\":[1959,7,1959,8],\"els\":[\"0:2587\"]},{\"tk\":[1959,8,1959,25],\"els\":[\"0:2587\"]},{\"tk\":[1959,26,1959,27],\"els\":[\"0:2587\"]},{\"tk\":[1959,28,1959,33],\"els\":[\"0:2587\"]},{\"tk\":[1959,33,1959,34],\"els\":[\"0:2587\"]},{\"tk\":[1960,7,1960,8],\"els\":[\"0:2587\"]},{\"tk\":[1960,8,1960,19],\"els\":[\"0:2587\"]},{\"tk\":[1960,20,1960,21],\"els\":[\"0:2587\"]},{\"tk\":[1960,22,1960,41],\"els\":[\"0:2587\"]},{\"tk\":[1960,41,1960,42],\"els\":[\"0:2587\"]},{\"tk\":[1963,7,1963,8],\"els\":[\"0:2587\"]},{\"tk\":[1963,8,1963,15],\"els\":[\"0:2587\"]},{\"tk\":[1963,16,1963,17],\"els\":[\"0:2587\"]},{\"tk\":[1963,18,1963,19],\"els\":[\"0:2587\"]},{\"tk\":[1964,9,1964,10],\"els\":[\"0:2587\"]},{\"tk\":[1964,10,1964,17],\"els\":[\"0:2587\"]},{\"tk\":[1964,18,1964,19],\"els\":[\"0:2587\"]},{\"tk\":[1964,20,1964,22],\"els\":[\"0:2587\"]},{\"tk\":[1964,22,1964,23],\"els\":[\"0:2587\"]},{\"tk\":[1965,9,1965,10],\"els\":[\"0:2587\"]},{\"tk\":[1965,10,1965,19],\"els\":[\"0:2587\"]},{\"tk\":[1965,20,1965,21],\"els\":[\"0:2587\"]},{\"tk\":[1965,22,1965,24],\"els\":[\"0:2587\"]},{\"tk\":[1965,24,1965,25],\"els\":[\"0:2587\"]},{\"tk\":[1966,9,1966,10],\"els\":[\"0:2587\"]},{\"tk\":[1966,10,1966,19],\"els\":[\"0:2587\"]},{\"tk\":[1966,20,1966,21],\"els\":[\"0:2587\"]},{\"tk\":[1966,22,1966,24],\"els\":[\"0:2587\"]},{\"tk\":[1966,24,1966,25],\"els\":[\"0:2587\"]},{\"tk\":[1967,9,1967,10],\"els\":[\"0:2587\"]},{\"tk\":[1967,10,1967,20],\"els\":[\"0:2587\"]},{\"tk\":[1967,21,1967,22],\"els\":[\"0:2587\"]},{\"tk\":[1967,23,1967,26],\"els\":[\"0:2587\"]},{\"tk\":[1967,26,1967,27],\"els\":[\"0:2587\"]},{\"tk\":[1968,9,1968,10],\"els\":[\"0:2587\"]},{\"tk\":[1968,10,1968,20],\"els\":[\"0:2587\"]},{\"tk\":[1968,21,1968,22],\"els\":[\"0:2587\"]},{\"tk\":[1968,23,1968,25],\"els\":[\"0:2587\"]},{\"tk\":[1969,7,1969,8],\"els\":[\"0:2587\"]},{\"tk\":[1969,8,1969,9],\"els\":[\"0:2587\"]},{\"tk\":[1972,7,1972,8],\"els\":[\"0:2587\"]},{\"tk\":[1972,8,1972,19],\"els\":[\"0:2587\"]},{\"tk\":[1972,20,1972,21],\"els\":[\"0:2587\"]},{\"tk\":[1972,22,1972,23],\"els\":[\"0:2587\"]},{\"tk\":[1973,9,1973,10],\"els\":[\"0:2587\"]},{\"tk\":[1973,10,1973,17],\"els\":[\"0:2587\"]},{\"tk\":[1973,18,1973,19],\"els\":[\"0:2587\"]},{\"tk\":[1973,20,1973,22],\"els\":[\"0:2587\"]},{\"tk\":[1973,22,1973,23],\"els\":[\"0:2587\"]},{\"tk\":[1974,9,1974,10],\"els\":[\"0:2587\"]},{\"tk\":[1974,10,1974,19],\"els\":[\"0:2587\"]},{\"tk\":[1974,20,1974,21],\"els\":[\"0:2587\"]},{\"tk\":[1974,22,1974,24],\"els\":[\"0:2587\"]},{\"tk\":[1974,24,1974,25],\"els\":[\"0:2587\"]},{\"tk\":[1975,9,1975,10],\"els\":[\"0:2587\"]},{\"tk\":[1975,10,1975,19],\"els\":[\"0:2587\"]},{\"tk\":[1975,20,1975,21],\"els\":[\"0:2587\"]},{\"tk\":[1975,22,1975,24],\"els\":[\"0:2587\"]},{\"tk\":[1975,24,1975,25],\"els\":[\"0:2587\"]},{\"tk\":[1976,9,1976,10],\"els\":[\"0:2587\"]},{\"tk\":[1976,10,1976,20],\"els\":[\"0:2587\"]},{\"tk\":[1976,21,1976,22],\"els\":[\"0:2587\"]},{\"tk\":[1976,23,1976,25],\"els\":[\"0:2587\"]},{\"tk\":[1976,25,1976,26],\"els\":[\"0:2587\"]},{\"tk\":[1977,9,1977,10],\"els\":[\"0:2587\"]},{\"tk\":[1977,10,1977,20],\"els\":[\"0:2587\"]},{\"tk\":[1977,21,1977,22],\"els\":[\"0:2587\"]},{\"tk\":[1977,23,1977,25],\"els\":[\"0:2587\"]},{\"tk\":[1978,7,1978,8],\"els\":[\"0:2587\"]},{\"tk\":[1978,8,1978,9],\"els\":[\"0:2587\"]},{\"tk\":[1979,7,1979,8],\"els\":[\"0:2587\"]},{\"tk\":[1979,8,1979,17],\"els\":[\"0:2587\"]},{\"tk\":[1979,18,1979,19],\"els\":[\"0:2587\"]},{\"tk\":[1979,20,1979,25],\"els\":[\"0:2587\"]},{\"tk\":[1979,25,1979,26],\"els\":[\"0:2587\"]},{\"tk\":[1980,7,1980,8],\"els\":[\"0:2587\"]},{\"tk\":[1980,8,1980,15],\"els\":[\"0:2587\"]},{\"tk\":[1980,16,1980,17],\"els\":[\"0:2587\"]},{\"tk\":[1980,18,1980,40],\"els\":[\"0:2587\"]},{\"tk\":[1980,40,1980,41],\"els\":[\"0:2587\"]},{\"tk\":[1981,7,1981,8],\"els\":[\"0:2587\"]},{\"tk\":[1981,8,1981,24],\"els\":[\"0:2587\"]},{\"tk\":[1981,25,1981,26],\"els\":[\"0:2587\"]},{\"tk\":[1981,27,1981,29],\"els\":[\"0:2587\"]},{\"tk\":[1981,29,1981,30],\"els\":[\"0:2587\"]},{\"tk\":[1982,7,1982,8],\"els\":[\"0:2587\"]},{\"tk\":[1982,8,1982,21],\"els\":[\"0:2587\"]},{\"tk\":[1982,22,1982,23],\"els\":[\"0:2587\"]},{\"tk\":[1982,24,1982,55],\"els\":[\"0:2587\"]},{\"tk\":[1982,55,1982,56],\"els\":[\"0:2587\"]},{\"tk\":[1983,5,1983,6],\"els\":[\"0:2587\"]},{\"tk\":[1983,6,1983,7],\"els\":[\"0:2587\"]},{\"tk\":[1986,5,1986,21],\"els\":[\"0:2587\"]},{\"tk\":[1986,21,1986,22],\"els\":[\"0:2587\"]},{\"tk\":[1986,22,1986,25],\"els\":[\"0:2587\"]},{\"tk\":[1986,25,1986,26],\"els\":[\"0:2587\"]},{\"tk\":[1986,27,1986,42],\"els\":[\"0:2587\"]},{\"tk\":[1986,42,1986,43],\"els\":[\"0:2587\"]},{\"tk\":[1986,44,1986,48],\"els\":[\"0:2587\"]},{\"tk\":[1986,48,1986,49],\"els\":[\"0:2587\"]},{\"tk\":[1986,49,1986,50],\"els\":[\"0:2587\"]},{\"tk\":[1987,5,1987,27],\"els\":[\"0:2587\"]},{\"tk\":[1987,27,1987,28],\"els\":[\"0:2587\"]},{\"tk\":[1987,28,1987,33],\"els\":[\"0:2587\"]},{\"tk\":[1987,33,1987,34],\"els\":[\"0:2587\"]},{\"tk\":[1987,35,1987,36],\"els\":[\"0:2587\"]},{\"tk\":[1987,36,1987,37],\"els\":[\"0:2587\"]},{\"tk\":[1987,38,1987,51],\"els\":[\"0:2587\"]},{\"tk\":[1987,51,1987,52],\"els\":[\"0:2587\"]},{\"tk\":[1987,52,1987,53],\"els\":[\"0:2587\"]},{\"tk\":[1990,5,1990,21],\"els\":[\"0:2587\"]},{\"tk\":[1990,21,1990,22],\"els\":[\"0:2587\"]},{\"tk\":[1990,22,1990,25],\"els\":[\"0:2587\"]},{\"tk\":[1990,25,1990,26],\"els\":[\"0:2587\"]},{\"tk\":[1990,27,1990,42],\"els\":[\"0:2587\"]},{\"tk\":[1990,42,1990,43],\"els\":[\"0:2587\"]},{\"tk\":[1990,44,1990,48],\"els\":[\"0:2587\"]},{\"tk\":[1990,48,1990,49],\"els\":[\"0:2587\"]},{\"tk\":[1990,49,1990,50],\"els\":[\"0:2587\"]},{\"tk\":[1991,5,1991,27],\"els\":[\"0:2587\"]},{\"tk\":[1991,27,1991,28],\"els\":[\"0:2587\"]},{\"tk\":[1991,28,1991,33],\"els\":[\"0:2587\"]},{\"tk\":[1991,33,1991,34],\"els\":[\"0:2587\"]},{\"tk\":[1991,35,1991,36],\"els\":[\"0:2587\"]},{\"tk\":[1991,36,1991,37],\"els\":[\"0:2587\"]},{\"tk\":[1991,38,1991,51],\"els\":[\"0:2587\"]},{\"tk\":[1991,51,1991,52],\"els\":[\"0:2587\"]},{\"tk\":[1991,52,1991,53],\"els\":[\"0:2587\"]},{\"tk\":[1994,5,1994,21],\"els\":[\"0:2587\"]},{\"tk\":[1994,21,1994,22],\"els\":[\"0:2587\"]},{\"tk\":[1994,22,1994,25],\"els\":[\"0:2587\"]},{\"tk\":[1994,25,1994,26],\"els\":[\"0:2587\"]},{\"tk\":[1994,27,1994,45],\"els\":[\"0:2587\"]},{\"tk\":[1994,45,1994,46],\"els\":[\"0:2587\"]},{\"tk\":[1994,47,1994,51],\"els\":[\"0:2587\"]},{\"tk\":[1994,51,1994,52],\"els\":[\"0:2587\"]},{\"tk\":[1994,52,1994,53],\"els\":[\"0:2587\"]},{\"tk\":[1995,5,1995,21],\"els\":[\"0:2587\"]},{\"tk\":[1995,21,1995,22],\"els\":[\"0:2587\"]},{\"tk\":[1995,22,1995,23],\"els\":[\"0:2587\"]},{\"tk\":[1995,23,1995,24],\"els\":[\"0:2587\"]},{\"tk\":[1995,25,1995,26],\"els\":[\"0:2587\"]},{\"tk\":[1995,26,1995,39],\"els\":[\"0:2587\"]},{\"tk\":[1995,39,1995,40],\"els\":[\"0:2587\"]},{\"tk\":[1995,41,1995,42],\"els\":[\"0:2587\"]},{\"tk\":[1995,42,1995,60],\"els\":[\"0:2587\"]},{\"tk\":[1995,60,1995,61],\"els\":[\"0:2587\"]},{\"tk\":[1995,61,1995,62],\"els\":[\"0:2587\"]},{\"tk\":[1996,3,1996,4],\"els\":[\"0:2587\"]},{\"tk\":[1999,3,1999,4],\"els\":[\"0:2586\"]},{\"tk\":[2000,5,2000,11],\"els\":[\"0:2586\"]},{\"tk\":[2000,12,2000,26],\"els\":[\"0:2586\"]},{\"tk\":[2000,27,2000,38],\"els\":[\"0:2586\"]},{\"tk\":[2000,38,2000,39],\"els\":[\"0:2586\"]},{\"tk\":[2003,5,2003,21],\"els\":[\"0:2586\"]},{\"tk\":[2003,21,2003,22],\"els\":[\"0:2586\"]},{\"tk\":[2003,22,2003,25],\"els\":[\"0:2586\"]},{\"tk\":[2003,25,2003,26],\"els\":[\"0:2586\"]},{\"tk\":[2003,27,2003,42],\"els\":[\"0:2586\"]},{\"tk\":[2003,42,2003,43],\"els\":[\"0:2586\"]},{\"tk\":[2003,44,2003,48],\"els\":[\"0:2586\"]},{\"tk\":[2003,48,2003,49],\"els\":[\"0:2586\"]},{\"tk\":[2003,49,2003,50],\"els\":[\"0:2586\"]},{\"tk\":[2006,5,2006,23],\"els\":[\"0:2586\"]},{\"tk\":[2006,23,2006,24],\"els\":[\"0:2586\"]},{\"tk\":[2006,24,2006,29],\"els\":[\"0:2586\"]},{\"tk\":[2006,29,2006,30],\"els\":[\"0:2586\"]},{\"tk\":[2006,31,2006,32],\"els\":[\"0:2586\"]},{\"tk\":[2006,32,2006,33],\"els\":[\"0:2586\"]},{\"tk\":[2006,34,2006,47],\"els\":[\"0:2586\"]},{\"tk\":[2006,47,2006,48],\"els\":[\"0:2586\"]},{\"tk\":[2006,48,2006,49],\"els\":[\"0:2586\"]},{\"tk\":[2009,5,2009,21],\"els\":[\"0:2586\"]},{\"tk\":[2009,21,2009,22],\"els\":[\"0:2586\"]},{\"tk\":[2009,22,2009,25],\"els\":[\"0:2586\"]},{\"tk\":[2009,25,2009,26],\"els\":[\"0:2586\"]},{\"tk\":[2009,27,2009,42],\"els\":[\"0:2586\"]},{\"tk\":[2009,42,2009,43],\"els\":[\"0:2586\"]},{\"tk\":[2009,44,2009,48],\"els\":[\"0:2586\"]},{\"tk\":[2009,48,2009,49],\"els\":[\"0:2586\"]},{\"tk\":[2009,49,2009,50],\"els\":[\"0:2586\"]},{\"tk\":[2012,5,2012,23],\"els\":[\"0:2586\"]},{\"tk\":[2012,23,2012,24],\"els\":[\"0:2586\"]},{\"tk\":[2012,24,2012,29],\"els\":[\"0:2586\"]},{\"tk\":[2012,29,2012,30],\"els\":[\"0:2586\"]},{\"tk\":[2012,31,2012,32],\"els\":[\"0:2586\"]},{\"tk\":[2012,32,2012,33],\"els\":[\"0:2586\"]},{\"tk\":[2012,34,2012,47],\"els\":[\"0:2586\"]},{\"tk\":[2012,47,2012,48],\"els\":[\"0:2586\"]},{\"tk\":[2012,48,2012,49],\"els\":[\"0:2586\"]},{\"tk\":[2015,5,2015,34],\"els\":[\"0:2586\"]},{\"tk\":[2015,34,2015,35],\"els\":[\"0:2586\"]},{\"tk\":[2015,35,2015,38],\"els\":[\"0:2586\"]},{\"tk\":[2015,38,2015,39],\"els\":[\"0:2586\"]},{\"tk\":[2015,40,2015,57],\"els\":[\"0:2586\"]},{\"tk\":[2015,57,2015,58],\"els\":[\"0:2586\"]},{\"tk\":[2015,59,2015,63],\"els\":[\"0:2586\"]},{\"tk\":[2015,63,2015,64],\"els\":[\"0:2586\"]},{\"tk\":[2016,7,2016,24],\"els\":[\"0:2586\"]},{\"tk\":[2016,24,2016,25],\"els\":[\"0:2586\"]},{\"tk\":[2016,26,2016,27],\"els\":[\"0:2586\"]},{\"tk\":[2016,27,2016,28],\"els\":[\"0:2586\"]},{\"tk\":[2016,29,2016,30],\"els\":[\"0:2586\"]},{\"tk\":[2016,30,2016,31],\"els\":[\"0:2586\"]},{\"tk\":[2016,31,2016,32],\"els\":[\"0:2586\"]},{\"tk\":[2019,5,2019,21],\"els\":[\"0:2586\"]},{\"tk\":[2019,21,2019,22],\"els\":[\"0:2586\"]},{\"tk\":[2019,22,2019,25],\"els\":[\"0:2586\"]},{\"tk\":[2019,25,2019,26],\"els\":[\"0:2586\"]},{\"tk\":[2019,27,2019,44],\"els\":[\"0:2586\"]},{\"tk\":[2019,44,2019,45],\"els\":[\"0:2586\"]},{\"tk\":[2019,46,2019,50],\"els\":[\"0:2586\"]},{\"tk\":[2019,50,2019,51],\"els\":[\"0:2586\"]},{\"tk\":[2019,51,2019,52],\"els\":[\"0:2586\"]},{\"tk\":[2020,5,2020,10],\"els\":[\"0:2586\"]},{\"tk\":[2020,11,2020,31],\"els\":[\"0:2586\"]},{\"tk\":[2020,32,2020,46],\"els\":[\"0:2586\"]},{\"tk\":[2020,47,2020,48],\"els\":[\"0:2586\"]},{\"tk\":[2020,49,2020,50],\"els\":[\"0:2586\"]},{\"tk\":[2021,7,2021,8],\"els\":[\"0:2586\"]},{\"tk\":[2021,8,2021,20],\"els\":[\"0:2586\"]},{\"tk\":[2021,21,2021,22],\"els\":[\"0:2586\"]},{\"tk\":[2021,23,2021,46],\"els\":[\"0:2586\"]},{\"tk\":[2021,46,2021,47],\"els\":[\"0:2586\"]},{\"tk\":[2022,7,2022,8],\"els\":[\"0:2586\"]},{\"tk\":[2022,8,2022,16],\"els\":[\"0:2586\"]},{\"tk\":[2022,17,2022,18],\"els\":[\"0:2586\"]},{\"tk\":[2022,19,2022,26],\"els\":[\"0:2586\"]},{\"tk\":[2022,26,2022,27],\"els\":[\"0:2586\"]},{\"tk\":[2023,7,2023,8],\"els\":[\"0:2586\"]},{\"tk\":[2023,8,2023,18],\"els\":[\"0:2586\"]},{\"tk\":[2023,19,2023,20],\"els\":[\"0:2586\"]},{\"tk\":[2023,21,2023,43],\"els\":[\"0:2586\"]},{\"tk\":[2023,43,2023,44],\"els\":[\"0:2586\"]},{\"tk\":[2024,7,2024,8],\"els\":[\"0:2586\"]},{\"tk\":[2024,8,2024,20],\"els\":[\"0:2586\"]},{\"tk\":[2024,21,2024,22],\"els\":[\"0:2586\"]},{\"tk\":[2024,23,2024,42],\"els\":[\"0:2586\"]},{\"tk\":[2024,42,2024,43],\"els\":[\"0:2586\"]},{\"tk\":[2025,7,2025,8],\"els\":[\"0:2586\"]},{\"tk\":[2025,8,2025,23],\"els\":[\"0:2586\"]},{\"tk\":[2025,24,2025,25],\"els\":[\"0:2586\"]},{\"tk\":[2025,26,2025,48],\"els\":[\"0:2586\"]},{\"tk\":[2025,48,2025,49],\"els\":[\"0:2586\"]},{\"tk\":[2026,7,2026,8],\"els\":[\"0:2586\"]},{\"tk\":[2026,8,2026,20],\"els\":[\"0:2586\"]},{\"tk\":[2026,21,2026,22],\"els\":[\"0:2586\"]},{\"tk\":[2026,23,2026,25],\"els\":[\"0:2586\"]},{\"tk\":[2026,25,2026,26],\"els\":[\"0:2586\"]},{\"tk\":[2027,7,2027,8],\"els\":[\"0:2586\"]},{\"tk\":[2027,8,2027,20],\"els\":[\"0:2586\"]},{\"tk\":[2027,21,2027,22],\"els\":[\"0:2586\"]},{\"tk\":[2027,23,2027,25],\"els\":[\"0:2586\"]},{\"tk\":[2027,25,2027,26],\"els\":[\"0:2586\"]},{\"tk\":[2028,5,2028,6],\"els\":[\"0:2586\"]},{\"tk\":[2028,6,2028,7],\"els\":[\"0:2586\"]},{\"tk\":[2031,5,2031,20],\"els\":[\"0:2586\"]},{\"tk\":[2031,20,2031,21],\"els\":[\"0:2586\"]},{\"tk\":[2031,21,2031,22],\"els\":[\"0:2586\"]},{\"tk\":[2031,22,2031,23],\"els\":[\"0:2586\"]},{\"tk\":[2031,24,2031,25],\"els\":[\"0:2586\"]},{\"tk\":[2031,25,2031,36],\"els\":[\"0:2586\"]},{\"tk\":[2031,36,2031,37],\"els\":[\"0:2586\"]},{\"tk\":[2031,38,2031,39],\"els\":[\"0:2586\"]},{\"tk\":[2031,39,2031,53],\"els\":[\"0:2586\"]},{\"tk\":[2031,53,2031,54],\"els\":[\"0:2586\"]},{\"tk\":[2031,54,2031,55],\"els\":[\"0:2586\"]},{\"tk\":[2032,3,2032,4],\"els\":[\"0:2586\"]},{\"tk\":[2035,3,2035,4],\"els\":[\"0:2723\"]},{\"tk\":[2036,5,2036,30],\"els\":[\"0:2723\"]},{\"tk\":[2036,31,2036,42],\"els\":[\"0:2723\"]},{\"tk\":[2036,43,2036,44],\"els\":[\"0:2723\"]},{\"tk\":[2036,45,2036,63],\"els\":[\"0:2723\"]},{\"tk\":[2036,63,2036,64],\"els\":[\"0:2723\"]},{\"tk\":[2037,5,2037,24],\"els\":[\"0:2723\"]},{\"tk\":[2037,25,2037,31],\"els\":[\"0:2723\"]},{\"tk\":[2037,32,2037,33],\"els\":[\"0:2723\"]},{\"tk\":[2037,34,2037,35],\"els\":[\"0:2723\"]},{\"tk\":[2038,7,2038,8],\"els\":[\"0:2723\"]},{\"tk\":[2038,8,2038,19],\"els\":[\"0:2723\"]},{\"tk\":[2038,20,2038,21],\"els\":[\"0:2723\"]},{\"tk\":[2038,22,2038,40],\"els\":[\"0:2723\"]},{\"tk\":[2038,40,2038,41],\"els\":[\"0:2723\"]},{\"tk\":[2039,7,2039,8],\"els\":[\"0:2723\"]},{\"tk\":[2039,8,2039,19],\"els\":[\"0:2723\"]},{\"tk\":[2039,20,2039,21],\"els\":[\"0:2723\"]},{\"tk\":[2039,22,2039,23],\"els\":[\"0:2723\"]},{\"tk\":[2039,23,2039,24],\"els\":[\"0:2723\"]},{\"tk\":[2040,7,2040,8],\"els\":[\"0:2723\"]},{\"tk\":[2040,8,2040,17],\"els\":[\"0:2723\"]},{\"tk\":[2040,18,2040,19],\"els\":[\"0:2723\"]},{\"tk\":[2040,20,2040,25],\"els\":[\"0:2723\"]},{\"tk\":[2040,25,2040,26],\"els\":[\"0:2723\"]},{\"tk\":[2041,7,2041,8],\"els\":[\"0:2723\"]},{\"tk\":[2041,8,2041,18],\"els\":[\"0:2723\"]},{\"tk\":[2041,19,2041,20],\"els\":[\"0:2723\"]},{\"tk\":[2041,21,2041,22],\"els\":[\"0:2723\"]},{\"tk\":[2041,22,2041,23],\"els\":[\"0:2723\"]},{\"tk\":[2042,7,2042,8],\"els\":[\"0:2723\"]},{\"tk\":[2042,8,2042,18],\"els\":[\"0:2723\"]},{\"tk\":[2042,19,2042,20],\"els\":[\"0:2723\"]},{\"tk\":[2042,21,2042,26],\"els\":[\"0:2723\"]},{\"tk\":[2042,26,2042,27],\"els\":[\"0:2723\"]},{\"tk\":[2043,7,2043,8],\"els\":[\"0:2723\"]},{\"tk\":[2043,8,2043,17],\"els\":[\"0:2723\"]},{\"tk\":[2043,18,2043,19],\"els\":[\"0:2723\"]},{\"tk\":[2043,20,2043,25],\"els\":[\"0:2723\"]},{\"tk\":[2044,5,2044,6],\"els\":[\"0:2723\"]},{\"tk\":[2044,6,2044,7],\"els\":[\"0:2723\"]},{\"tk\":[2046,5,2046,27],\"els\":[\"0:2723\"]},{\"tk\":[2046,27,2046,28],\"els\":[\"0:2723\"]},{\"tk\":[2046,28,2046,29],\"els\":[\"0:2723\"]},{\"tk\":[2046,29,2046,30],\"els\":[\"0:2723\"]},{\"tk\":[2046,31,2046,33],\"els\":[\"0:2723\"]},{\"tk\":[2046,33,2046,34],\"els\":[\"0:2723\"]},{\"tk\":[2046,35,2046,36],\"els\":[\"0:2723\"]},{\"tk\":[2046,36,2046,42],\"els\":[\"0:2723\"]},{\"tk\":[2046,42,2046,43],\"els\":[\"0:2723\"]},{\"tk\":[2046,44,2046,48],\"els\":[\"0:2723\"]},{\"tk\":[2046,48,2046,49],\"els\":[\"0:2723\"]},{\"tk\":[2046,49,2046,50],\"els\":[\"0:2723\"]},{\"tk\":[2047,5,2047,30],\"els\":[\"0:2723\"]},{\"tk\":[2047,30,2047,31],\"els\":[\"0:2723\"]},{\"tk\":[2047,31,2047,32],\"els\":[\"0:2723\"]},{\"tk\":[2047,32,2047,33],\"els\":[\"0:2723\"]},{\"tk\":[2047,34,2047,60],\"els\":[\"0:2723\"]},{\"tk\":[2047,60,2047,61],\"els\":[\"0:2723\"]},{\"tk\":[2047,61,2047,62],\"els\":[\"0:2723\"]},{\"tk\":[2048,5,2048,36],\"els\":[\"0:2723\"]},{\"tk\":[2048,36,2048,37],\"els\":[\"0:2723\"]},{\"tk\":[2048,37,2048,38],\"els\":[\"0:2723\"]},{\"tk\":[2048,38,2048,39],\"els\":[\"0:2723\"]},{\"tk\":[2048,40,2048,51],\"els\":[\"0:2723\"]},{\"tk\":[2048,51,2048,52],\"els\":[\"0:2723\"]},{\"tk\":[2048,53,2048,55],\"els\":[\"0:2723\"]},{\"tk\":[2048,55,2048,56],\"els\":[\"0:2723\"]},{\"tk\":[2048,57,2048,60],\"els\":[\"0:2723\"]},{\"tk\":[2048,60,2048,61],\"els\":[\"0:2723\"]},{\"tk\":[2048,61,2048,62],\"els\":[\"0:2723\"]},{\"tk\":[2049,3,2049,4],\"els\":[\"0:2723\"]},{\"tk\":[2052,3,2052,4],\"els\":[\"0:2724\"]},{\"tk\":[2053,5,2053,30],\"els\":[\"0:2724\"]},{\"tk\":[2053,31,2053,42],\"els\":[\"0:2724\"]},{\"tk\":[2053,43,2053,44],\"els\":[\"0:2724\"]},{\"tk\":[2053,45,2053,63],\"els\":[\"0:2724\"]},{\"tk\":[2053,63,2053,64],\"els\":[\"0:2724\"]},{\"tk\":[2054,5,2054,24],\"els\":[\"0:2724\"]},{\"tk\":[2054,25,2054,31],\"els\":[\"0:2724\"]},{\"tk\":[2054,32,2054,33],\"els\":[\"0:2724\"]},{\"tk\":[2054,34,2054,35],\"els\":[\"0:2724\"]},{\"tk\":[2055,7,2055,8],\"els\":[\"0:2724\"]},{\"tk\":[2055,8,2055,19],\"els\":[\"0:2724\"]},{\"tk\":[2055,20,2055,21],\"els\":[\"0:2724\"]},{\"tk\":[2055,22,2055,40],\"els\":[\"0:2724\"]},{\"tk\":[2055,40,2055,41],\"els\":[\"0:2724\"]},{\"tk\":[2056,7,2056,8],\"els\":[\"0:2724\"]},{\"tk\":[2056,8,2056,19],\"els\":[\"0:2724\"]},{\"tk\":[2056,20,2056,21],\"els\":[\"0:2724\"]},{\"tk\":[2056,22,2056,23],\"els\":[\"0:2724\"]},{\"tk\":[2056,23,2056,24],\"els\":[\"0:2724\"]},{\"tk\":[2057,7,2057,8],\"els\":[\"0:2724\"]},{\"tk\":[2057,8,2057,17],\"els\":[\"0:2724\"]},{\"tk\":[2057,18,2057,19],\"els\":[\"0:2724\"]},{\"tk\":[2057,20,2057,25],\"els\":[\"0:2724\"]},{\"tk\":[2057,25,2057,26],\"els\":[\"0:2724\"]},{\"tk\":[2058,7,2058,8],\"els\":[\"0:2724\"]},{\"tk\":[2058,8,2058,18],\"els\":[\"0:2724\"]},{\"tk\":[2058,19,2058,20],\"els\":[\"0:2724\"]},{\"tk\":[2058,21,2058,22],\"els\":[\"0:2724\"]},{\"tk\":[2058,22,2058,23],\"els\":[\"0:2724\"]},{\"tk\":[2059,7,2059,8],\"els\":[\"0:2724\"]},{\"tk\":[2059,8,2059,18],\"els\":[\"0:2724\"]},{\"tk\":[2059,19,2059,20],\"els\":[\"0:2724\"]},{\"tk\":[2059,21,2059,26],\"els\":[\"0:2724\"]},{\"tk\":[2059,26,2059,27],\"els\":[\"0:2724\"]},{\"tk\":[2060,7,2060,8],\"els\":[\"0:2724\"]},{\"tk\":[2060,8,2060,17],\"els\":[\"0:2724\"]},{\"tk\":[2060,18,2060,19],\"els\":[\"0:2724\"]},{\"tk\":[2060,20,2060,25],\"els\":[\"0:2724\"]},{\"tk\":[2061,5,2061,6],\"els\":[\"0:2724\"]},{\"tk\":[2061,6,2061,7],\"els\":[\"0:2724\"]},{\"tk\":[2063,5,2063,27],\"els\":[\"0:2724\"]},{\"tk\":[2063,27,2063,28],\"els\":[\"0:2724\"]},{\"tk\":[2063,28,2063,29],\"els\":[\"0:2724\"]},{\"tk\":[2063,29,2063,30],\"els\":[\"0:2724\"]},{\"tk\":[2063,31,2063,33],\"els\":[\"0:2724\"]},{\"tk\":[2063,33,2063,34],\"els\":[\"0:2724\"]},{\"tk\":[2063,35,2063,36],\"els\":[\"0:2724\"]},{\"tk\":[2063,36,2063,42],\"els\":[\"0:2724\"]},{\"tk\":[2063,42,2063,43],\"els\":[\"0:2724\"]},{\"tk\":[2063,44,2063,48],\"els\":[\"0:2724\"]},{\"tk\":[2063,48,2063,49],\"els\":[\"0:2724\"]},{\"tk\":[2063,49,2063,50],\"els\":[\"0:2724\"]},{\"tk\":[2064,5,2064,30],\"els\":[\"0:2724\"]},{\"tk\":[2064,30,2064,31],\"els\":[\"0:2724\"]},{\"tk\":[2064,31,2064,32],\"els\":[\"0:2724\"]},{\"tk\":[2064,32,2064,33],\"els\":[\"0:2724\"]},{\"tk\":[2064,34,2064,60],\"els\":[\"0:2724\"]},{\"tk\":[2064,60,2064,61],\"els\":[\"0:2724\"]},{\"tk\":[2064,61,2064,62],\"els\":[\"0:2724\"]},{\"tk\":[2065,5,2065,36],\"els\":[\"0:2724\"]},{\"tk\":[2065,36,2065,37],\"els\":[\"0:2724\"]},{\"tk\":[2065,37,2065,38],\"els\":[\"0:2724\"]},{\"tk\":[2065,38,2065,39],\"els\":[\"0:2724\"]},{\"tk\":[2065,40,2065,51],\"els\":[\"0:2724\"]},{\"tk\":[2065,51,2065,52],\"els\":[\"0:2724\"]},{\"tk\":[2065,53,2065,55],\"els\":[\"0:2724\"]},{\"tk\":[2065,55,2065,56],\"els\":[\"0:2724\"]},{\"tk\":[2065,57,2065,60],\"els\":[\"0:2724\"]},{\"tk\":[2065,60,2065,61],\"els\":[\"0:2724\"]},{\"tk\":[2065,61,2065,62],\"els\":[\"0:2724\"]},{\"tk\":[2066,3,2066,4],\"els\":[\"0:2724\"]},{\"tk\":[2069,3,2069,4],\"els\":[\"0:2725\"]},{\"tk\":[2070,5,2070,30],\"els\":[\"0:2725\"]},{\"tk\":[2070,31,2070,42],\"els\":[\"0:2725\"]},{\"tk\":[2070,43,2070,44],\"els\":[\"0:2725\"]},{\"tk\":[2070,45,2070,63],\"els\":[\"0:2725\"]},{\"tk\":[2070,63,2070,64],\"els\":[\"0:2725\"]},{\"tk\":[2071,5,2071,24],\"els\":[\"0:2725\"]},{\"tk\":[2071,25,2071,31],\"els\":[\"0:2725\"]},{\"tk\":[2071,32,2071,33],\"els\":[\"0:2725\"]},{\"tk\":[2071,34,2071,35],\"els\":[\"0:2725\"]},{\"tk\":[2072,7,2072,8],\"els\":[\"0:2725\"]},{\"tk\":[2072,8,2072,19],\"els\":[\"0:2725\"]},{\"tk\":[2072,20,2072,21],\"els\":[\"0:2725\"]},{\"tk\":[2072,22,2072,40],\"els\":[\"0:2725\"]},{\"tk\":[2072,40,2072,41],\"els\":[\"0:2725\"]},{\"tk\":[2073,7,2073,8],\"els\":[\"0:2725\"]},{\"tk\":[2073,8,2073,19],\"els\":[\"0:2725\"]},{\"tk\":[2073,20,2073,21],\"els\":[\"0:2725\"]},{\"tk\":[2073,22,2073,23],\"els\":[\"0:2725\"]},{\"tk\":[2073,23,2073,24],\"els\":[\"0:2725\"]},{\"tk\":[2074,7,2074,8],\"els\":[\"0:2725\"]},{\"tk\":[2074,8,2074,17],\"els\":[\"0:2725\"]},{\"tk\":[2074,18,2074,19],\"els\":[\"0:2725\"]},{\"tk\":[2074,20,2074,25],\"els\":[\"0:2725\"]},{\"tk\":[2074,25,2074,26],\"els\":[\"0:2725\"]},{\"tk\":[2075,7,2075,8],\"els\":[\"0:2725\"]},{\"tk\":[2075,8,2075,18],\"els\":[\"0:2725\"]},{\"tk\":[2075,19,2075,20],\"els\":[\"0:2725\"]},{\"tk\":[2075,21,2075,22],\"els\":[\"0:2725\"]},{\"tk\":[2075,22,2075,23],\"els\":[\"0:2725\"]},{\"tk\":[2076,7,2076,8],\"els\":[\"0:2725\"]},{\"tk\":[2076,8,2076,18],\"els\":[\"0:2725\"]},{\"tk\":[2076,19,2076,20],\"els\":[\"0:2725\"]},{\"tk\":[2076,21,2076,26],\"els\":[\"0:2725\"]},{\"tk\":[2076,26,2076,27],\"els\":[\"0:2725\"]},{\"tk\":[2077,7,2077,8],\"els\":[\"0:2725\"]},{\"tk\":[2077,8,2077,17],\"els\":[\"0:2725\"]},{\"tk\":[2077,18,2077,19],\"els\":[\"0:2725\"]},{\"tk\":[2077,20,2077,25],\"els\":[\"0:2725\"]},{\"tk\":[2078,5,2078,6],\"els\":[\"0:2725\"]},{\"tk\":[2078,6,2078,7],\"els\":[\"0:2725\"]},{\"tk\":[2080,5,2080,27],\"els\":[\"0:2725\"]},{\"tk\":[2080,27,2080,28],\"els\":[\"0:2725\"]},{\"tk\":[2080,28,2080,29],\"els\":[\"0:2725\"]},{\"tk\":[2080,29,2080,30],\"els\":[\"0:2725\"]},{\"tk\":[2080,31,2080,33],\"els\":[\"0:2725\"]},{\"tk\":[2080,33,2080,34],\"els\":[\"0:2725\"]},{\"tk\":[2080,35,2080,36],\"els\":[\"0:2725\"]},{\"tk\":[2080,36,2080,42],\"els\":[\"0:2725\"]},{\"tk\":[2080,42,2080,43],\"els\":[\"0:2725\"]},{\"tk\":[2080,44,2080,48],\"els\":[\"0:2725\"]},{\"tk\":[2080,48,2080,49],\"els\":[\"0:2725\"]},{\"tk\":[2080,49,2080,50],\"els\":[\"0:2725\"]},{\"tk\":[2081,5,2081,30],\"els\":[\"0:2725\"]},{\"tk\":[2081,30,2081,31],\"els\":[\"0:2725\"]},{\"tk\":[2081,31,2081,32],\"els\":[\"0:2725\"]},{\"tk\":[2081,32,2081,33],\"els\":[\"0:2725\"]},{\"tk\":[2081,34,2081,60],\"els\":[\"0:2725\"]},{\"tk\":[2081,60,2081,61],\"els\":[\"0:2725\"]},{\"tk\":[2081,61,2081,62],\"els\":[\"0:2725\"]},{\"tk\":[2082,5,2082,36],\"els\":[\"0:2725\"]},{\"tk\":[2082,36,2082,37],\"els\":[\"0:2725\"]},{\"tk\":[2082,37,2082,38],\"els\":[\"0:2725\"]},{\"tk\":[2082,38,2082,39],\"els\":[\"0:2725\"]},{\"tk\":[2082,40,2082,51],\"els\":[\"0:2725\"]},{\"tk\":[2082,51,2082,52],\"els\":[\"0:2725\"]},{\"tk\":[2082,53,2082,55],\"els\":[\"0:2725\"]},{\"tk\":[2082,55,2082,56],\"els\":[\"0:2725\"]},{\"tk\":[2082,57,2082,60],\"els\":[\"0:2725\"]},{\"tk\":[2082,60,2082,61],\"els\":[\"0:2725\"]},{\"tk\":[2082,61,2082,62],\"els\":[\"0:2725\"]},{\"tk\":[2083,3,2083,4],\"els\":[\"0:2725\"]},{\"tk\":[2086,3,2086,4],\"els\":[\"0:2726\"]},{\"tk\":[2087,5,2087,30],\"els\":[\"0:2726\"]},{\"tk\":[2087,31,2087,42],\"els\":[\"0:2726\"]},{\"tk\":[2087,43,2087,44],\"els\":[\"0:2726\"]},{\"tk\":[2087,45,2087,63],\"els\":[\"0:2726\"]},{\"tk\":[2087,63,2087,64],\"els\":[\"0:2726\"]},{\"tk\":[2088,5,2088,24],\"els\":[\"0:2726\"]},{\"tk\":[2088,25,2088,31],\"els\":[\"0:2726\"]},{\"tk\":[2088,32,2088,33],\"els\":[\"0:2726\"]},{\"tk\":[2088,34,2088,35],\"els\":[\"0:2726\"]},{\"tk\":[2089,7,2089,8],\"els\":[\"0:2726\"]},{\"tk\":[2089,8,2089,19],\"els\":[\"0:2726\"]},{\"tk\":[2089,20,2089,21],\"els\":[\"0:2726\"]},{\"tk\":[2089,22,2089,40],\"els\":[\"0:2726\"]},{\"tk\":[2089,40,2089,41],\"els\":[\"0:2726\"]},{\"tk\":[2090,7,2090,8],\"els\":[\"0:2726\"]},{\"tk\":[2090,8,2090,19],\"els\":[\"0:2726\"]},{\"tk\":[2090,20,2090,21],\"els\":[\"0:2726\"]},{\"tk\":[2090,22,2090,23],\"els\":[\"0:2726\"]},{\"tk\":[2090,23,2090,24],\"els\":[\"0:2726\"]},{\"tk\":[2091,7,2091,8],\"els\":[\"0:2726\"]},{\"tk\":[2091,8,2091,17],\"els\":[\"0:2726\"]},{\"tk\":[2091,18,2091,19],\"els\":[\"0:2726\"]},{\"tk\":[2091,20,2091,25],\"els\":[\"0:2726\"]},{\"tk\":[2091,25,2091,26],\"els\":[\"0:2726\"]},{\"tk\":[2092,7,2092,8],\"els\":[\"0:2726\"]},{\"tk\":[2092,8,2092,18],\"els\":[\"0:2726\"]},{\"tk\":[2092,19,2092,20],\"els\":[\"0:2726\"]},{\"tk\":[2092,21,2092,22],\"els\":[\"0:2726\"]},{\"tk\":[2092,22,2092,23],\"els\":[\"0:2726\"]},{\"tk\":[2093,7,2093,8],\"els\":[\"0:2726\"]},{\"tk\":[2093,8,2093,18],\"els\":[\"0:2726\"]},{\"tk\":[2093,19,2093,20],\"els\":[\"0:2726\"]},{\"tk\":[2093,21,2093,26],\"els\":[\"0:2726\"]},{\"tk\":[2093,26,2093,27],\"els\":[\"0:2726\"]},{\"tk\":[2094,7,2094,8],\"els\":[\"0:2726\"]},{\"tk\":[2094,8,2094,17],\"els\":[\"0:2726\"]},{\"tk\":[2094,18,2094,19],\"els\":[\"0:2726\"]},{\"tk\":[2094,20,2094,25],\"els\":[\"0:2726\"]},{\"tk\":[2095,5,2095,6],\"els\":[\"0:2726\"]},{\"tk\":[2095,6,2095,7],\"els\":[\"0:2726\"]},{\"tk\":[2097,5,2097,27],\"els\":[\"0:2726\"]},{\"tk\":[2097,27,2097,28],\"els\":[\"0:2726\"]},{\"tk\":[2097,28,2097,29],\"els\":[\"0:2726\"]},{\"tk\":[2097,29,2097,30],\"els\":[\"0:2726\"]},{\"tk\":[2097,31,2097,33],\"els\":[\"0:2726\"]},{\"tk\":[2097,33,2097,34],\"els\":[\"0:2726\"]},{\"tk\":[2097,35,2097,36],\"els\":[\"0:2726\"]},{\"tk\":[2097,36,2097,42],\"els\":[\"0:2726\"]},{\"tk\":[2097,42,2097,43],\"els\":[\"0:2726\"]},{\"tk\":[2097,44,2097,48],\"els\":[\"0:2726\"]},{\"tk\":[2097,48,2097,49],\"els\":[\"0:2726\"]},{\"tk\":[2097,49,2097,50],\"els\":[\"0:2726\"]},{\"tk\":[2098,5,2098,30],\"els\":[\"0:2726\"]},{\"tk\":[2098,30,2098,31],\"els\":[\"0:2726\"]},{\"tk\":[2098,31,2098,32],\"els\":[\"0:2726\"]},{\"tk\":[2098,32,2098,33],\"els\":[\"0:2726\"]},{\"tk\":[2098,34,2098,60],\"els\":[\"0:2726\"]},{\"tk\":[2098,60,2098,61],\"els\":[\"0:2726\"]},{\"tk\":[2098,61,2098,62],\"els\":[\"0:2726\"]},{\"tk\":[2099,5,2099,36],\"els\":[\"0:2726\"]},{\"tk\":[2099,36,2099,37],\"els\":[\"0:2726\"]},{\"tk\":[2099,37,2099,38],\"els\":[\"0:2726\"]},{\"tk\":[2099,38,2099,39],\"els\":[\"0:2726\"]},{\"tk\":[2099,40,2099,51],\"els\":[\"0:2726\"]},{\"tk\":[2099,51,2099,52],\"els\":[\"0:2726\"]},{\"tk\":[2099,53,2099,55],\"els\":[\"0:2726\"]},{\"tk\":[2099,55,2099,56],\"els\":[\"0:2726\"]},{\"tk\":[2099,57,2099,60],\"els\":[\"0:2726\"]},{\"tk\":[2099,60,2099,61],\"els\":[\"0:2726\"]},{\"tk\":[2099,61,2099,62],\"els\":[\"0:2726\"]},{\"tk\":[2100,3,2100,4],\"els\":[\"0:2726\"]},{\"tk\":[2103,3,2103,4],\"els\":[\"0:2727\"]},{\"tk\":[2104,5,2104,30],\"els\":[\"0:2727\"]},{\"tk\":[2104,31,2104,42],\"els\":[\"0:2727\"]},{\"tk\":[2104,43,2104,44],\"els\":[\"0:2727\"]},{\"tk\":[2104,45,2104,63],\"els\":[\"0:2727\"]},{\"tk\":[2104,63,2104,64],\"els\":[\"0:2727\"]},{\"tk\":[2105,5,2105,24],\"els\":[\"0:2727\"]},{\"tk\":[2105,25,2105,31],\"els\":[\"0:2727\"]},{\"tk\":[2105,32,2105,33],\"els\":[\"0:2727\"]},{\"tk\":[2105,34,2105,35],\"els\":[\"0:2727\"]},{\"tk\":[2106,7,2106,8],\"els\":[\"0:2727\"]},{\"tk\":[2106,8,2106,19],\"els\":[\"0:2727\"]},{\"tk\":[2106,20,2106,21],\"els\":[\"0:2727\"]},{\"tk\":[2106,22,2106,40],\"els\":[\"0:2727\"]},{\"tk\":[2106,40,2106,41],\"els\":[\"0:2727\"]},{\"tk\":[2107,7,2107,8],\"els\":[\"0:2727\"]},{\"tk\":[2107,8,2107,19],\"els\":[\"0:2727\"]},{\"tk\":[2107,20,2107,21],\"els\":[\"0:2727\"]},{\"tk\":[2107,22,2107,23],\"els\":[\"0:2727\"]},{\"tk\":[2107,23,2107,24],\"els\":[\"0:2727\"]},{\"tk\":[2108,7,2108,8],\"els\":[\"0:2727\"]},{\"tk\":[2108,8,2108,17],\"els\":[\"0:2727\"]},{\"tk\":[2108,18,2108,19],\"els\":[\"0:2727\"]},{\"tk\":[2108,20,2108,25],\"els\":[\"0:2727\"]},{\"tk\":[2108,25,2108,26],\"els\":[\"0:2727\"]},{\"tk\":[2109,7,2109,8],\"els\":[\"0:2727\"]},{\"tk\":[2109,8,2109,18],\"els\":[\"0:2727\"]},{\"tk\":[2109,19,2109,20],\"els\":[\"0:2727\"]},{\"tk\":[2109,21,2109,22],\"els\":[\"0:2727\"]},{\"tk\":[2109,22,2109,23],\"els\":[\"0:2727\"]},{\"tk\":[2110,7,2110,8],\"els\":[\"0:2727\"]},{\"tk\":[2110,8,2110,18],\"els\":[\"0:2727\"]},{\"tk\":[2110,19,2110,20],\"els\":[\"0:2727\"]},{\"tk\":[2110,21,2110,26],\"els\":[\"0:2727\"]},{\"tk\":[2110,26,2110,27],\"els\":[\"0:2727\"]},{\"tk\":[2111,7,2111,8],\"els\":[\"0:2727\"]},{\"tk\":[2111,8,2111,17],\"els\":[\"0:2727\"]},{\"tk\":[2111,18,2111,19],\"els\":[\"0:2727\"]},{\"tk\":[2111,20,2111,25],\"els\":[\"0:2727\"]},{\"tk\":[2112,5,2112,6],\"els\":[\"0:2727\"]},{\"tk\":[2112,6,2112,7],\"els\":[\"0:2727\"]},{\"tk\":[2114,5,2114,27],\"els\":[\"0:2727\"]},{\"tk\":[2114,27,2114,28],\"els\":[\"0:2727\"]},{\"tk\":[2114,28,2114,29],\"els\":[\"0:2727\"]},{\"tk\":[2114,29,2114,30],\"els\":[\"0:2727\"]},{\"tk\":[2114,31,2114,32],\"els\":[\"0:2727\"]},{\"tk\":[2114,32,2114,33],\"els\":[\"0:2727\"]},{\"tk\":[2114,34,2114,35],\"els\":[\"0:2727\"]},{\"tk\":[2114,35,2114,41],\"els\":[\"0:2727\"]},{\"tk\":[2114,41,2114,42],\"els\":[\"0:2727\"]},{\"tk\":[2114,43,2114,47],\"els\":[\"0:2727\"]},{\"tk\":[2114,47,2114,48],\"els\":[\"0:2727\"]},{\"tk\":[2114,48,2114,49],\"els\":[\"0:2727\"]},{\"tk\":[2115,5,2115,30],\"els\":[\"0:2727\"]},{\"tk\":[2115,30,2115,31],\"els\":[\"0:2727\"]},{\"tk\":[2115,31,2115,32],\"els\":[\"0:2727\"]},{\"tk\":[2115,32,2115,33],\"els\":[\"0:2727\"]},{\"tk\":[2115,34,2115,60],\"els\":[\"0:2727\"]},{\"tk\":[2115,60,2115,61],\"els\":[\"0:2727\"]},{\"tk\":[2115,61,2115,62],\"els\":[\"0:2727\"]},{\"tk\":[2116,5,2116,36],\"els\":[\"0:2727\"]},{\"tk\":[2116,36,2116,37],\"els\":[\"0:2727\"]},{\"tk\":[2116,37,2116,38],\"els\":[\"0:2727\"]},{\"tk\":[2116,38,2116,39],\"els\":[\"0:2727\"]},{\"tk\":[2116,40,2116,51],\"els\":[\"0:2727\"]},{\"tk\":[2116,51,2116,52],\"els\":[\"0:2727\"]},{\"tk\":[2116,53,2116,54],\"els\":[\"0:2727\"]},{\"tk\":[2116,54,2116,55],\"els\":[\"0:2727\"]},{\"tk\":[2116,56,2116,59],\"els\":[\"0:2727\"]},{\"tk\":[2116,59,2116,60],\"els\":[\"0:2727\"]},{\"tk\":[2116,60,2116,61],\"els\":[\"0:2727\"]},{\"tk\":[2117,3,2117,4],\"els\":[\"0:2727\"]},{\"tk\":[2120,3,2120,4],\"els\":[\"0:2728\"]},{\"tk\":[2121,5,2121,30],\"els\":[\"0:2728\"]},{\"tk\":[2121,31,2121,42],\"els\":[\"0:2728\"]},{\"tk\":[2121,43,2121,44],\"els\":[\"0:2728\"]},{\"tk\":[2121,45,2121,63],\"els\":[\"0:2728\"]},{\"tk\":[2121,63,2121,64],\"els\":[\"0:2728\"]},{\"tk\":[2122,5,2122,24],\"els\":[\"0:2728\"]},{\"tk\":[2122,25,2122,31],\"els\":[\"0:2728\"]},{\"tk\":[2122,32,2122,33],\"els\":[\"0:2728\"]},{\"tk\":[2122,34,2122,35],\"els\":[\"0:2728\"]},{\"tk\":[2123,7,2123,8],\"els\":[\"0:2728\"]},{\"tk\":[2123,8,2123,19],\"els\":[\"0:2728\"]},{\"tk\":[2123,20,2123,21],\"els\":[\"0:2728\"]},{\"tk\":[2123,22,2123,40],\"els\":[\"0:2728\"]},{\"tk\":[2123,40,2123,41],\"els\":[\"0:2728\"]},{\"tk\":[2124,7,2124,8],\"els\":[\"0:2728\"]},{\"tk\":[2124,8,2124,19],\"els\":[\"0:2728\"]},{\"tk\":[2124,20,2124,21],\"els\":[\"0:2728\"]},{\"tk\":[2124,22,2124,23],\"els\":[\"0:2728\"]},{\"tk\":[2124,23,2124,24],\"els\":[\"0:2728\"]},{\"tk\":[2125,7,2125,8],\"els\":[\"0:2728\"]},{\"tk\":[2125,8,2125,17],\"els\":[\"0:2728\"]},{\"tk\":[2125,18,2125,19],\"els\":[\"0:2728\"]},{\"tk\":[2125,20,2125,25],\"els\":[\"0:2728\"]},{\"tk\":[2125,25,2125,26],\"els\":[\"0:2728\"]},{\"tk\":[2126,7,2126,8],\"els\":[\"0:2728\"]},{\"tk\":[2126,8,2126,18],\"els\":[\"0:2728\"]},{\"tk\":[2126,19,2126,20],\"els\":[\"0:2728\"]},{\"tk\":[2126,21,2126,22],\"els\":[\"0:2728\"]},{\"tk\":[2126,22,2126,23],\"els\":[\"0:2728\"]},{\"tk\":[2127,7,2127,8],\"els\":[\"0:2728\"]},{\"tk\":[2127,8,2127,18],\"els\":[\"0:2728\"]},{\"tk\":[2127,19,2127,20],\"els\":[\"0:2728\"]},{\"tk\":[2127,21,2127,26],\"els\":[\"0:2728\"]},{\"tk\":[2127,26,2127,27],\"els\":[\"0:2728\"]},{\"tk\":[2128,7,2128,8],\"els\":[\"0:2728\"]},{\"tk\":[2128,8,2128,17],\"els\":[\"0:2728\"]},{\"tk\":[2128,18,2128,19],\"els\":[\"0:2728\"]},{\"tk\":[2128,20,2128,25],\"els\":[\"0:2728\"]},{\"tk\":[2129,5,2129,6],\"els\":[\"0:2728\"]},{\"tk\":[2129,6,2129,7],\"els\":[\"0:2728\"]},{\"tk\":[2131,5,2131,27],\"els\":[\"0:2728\"]},{\"tk\":[2131,27,2131,28],\"els\":[\"0:2728\"]},{\"tk\":[2131,28,2131,29],\"els\":[\"0:2728\"]},{\"tk\":[2131,29,2131,30],\"els\":[\"0:2728\"]},{\"tk\":[2131,31,2131,32],\"els\":[\"0:2728\"]},{\"tk\":[2131,32,2131,33],\"els\":[\"0:2728\"]},{\"tk\":[2131,34,2131,35],\"els\":[\"0:2728\"]},{\"tk\":[2131,35,2131,41],\"els\":[\"0:2728\"]},{\"tk\":[2131,41,2131,42],\"els\":[\"0:2728\"]},{\"tk\":[2131,43,2131,47],\"els\":[\"0:2728\"]},{\"tk\":[2131,47,2131,48],\"els\":[\"0:2728\"]},{\"tk\":[2131,48,2131,49],\"els\":[\"0:2728\"]},{\"tk\":[2132,5,2132,30],\"els\":[\"0:2728\"]},{\"tk\":[2132,30,2132,31],\"els\":[\"0:2728\"]},{\"tk\":[2132,31,2132,32],\"els\":[\"0:2728\"]},{\"tk\":[2132,32,2132,33],\"els\":[\"0:2728\"]},{\"tk\":[2132,34,2132,60],\"els\":[\"0:2728\"]},{\"tk\":[2132,60,2132,61],\"els\":[\"0:2728\"]},{\"tk\":[2132,61,2132,62],\"els\":[\"0:2728\"]},{\"tk\":[2133,5,2133,36],\"els\":[\"0:2728\"]},{\"tk\":[2133,36,2133,37],\"els\":[\"0:2728\"]},{\"tk\":[2133,37,2133,38],\"els\":[\"0:2728\"]},{\"tk\":[2133,38,2133,39],\"els\":[\"0:2728\"]},{\"tk\":[2133,40,2133,51],\"els\":[\"0:2728\"]},{\"tk\":[2133,51,2133,52],\"els\":[\"0:2728\"]},{\"tk\":[2133,53,2133,54],\"els\":[\"0:2728\"]},{\"tk\":[2133,54,2133,55],\"els\":[\"0:2728\"]},{\"tk\":[2133,56,2133,59],\"els\":[\"0:2728\"]},{\"tk\":[2133,59,2133,60],\"els\":[\"0:2728\"]},{\"tk\":[2133,60,2133,61],\"els\":[\"0:2728\"]},{\"tk\":[2134,3,2134,4],\"els\":[\"0:2728\"]},{\"tk\":[2137,3,2137,4],\"els\":[\"0:2729\"]},{\"tk\":[2138,5,2138,30],\"els\":[\"0:2729\"]},{\"tk\":[2138,31,2138,42],\"els\":[\"0:2729\"]},{\"tk\":[2138,43,2138,44],\"els\":[\"0:2729\"]},{\"tk\":[2138,45,2138,63],\"els\":[\"0:2729\"]},{\"tk\":[2138,63,2138,64],\"els\":[\"0:2729\"]},{\"tk\":[2139,5,2139,24],\"els\":[\"0:2729\"]},{\"tk\":[2139,25,2139,31],\"els\":[\"0:2729\"]},{\"tk\":[2139,32,2139,33],\"els\":[\"0:2729\"]},{\"tk\":[2139,34,2139,35],\"els\":[\"0:2729\"]},{\"tk\":[2140,7,2140,8],\"els\":[\"0:2729\"]},{\"tk\":[2140,8,2140,19],\"els\":[\"0:2729\"]},{\"tk\":[2140,20,2140,21],\"els\":[\"0:2729\"]},{\"tk\":[2140,22,2140,40],\"els\":[\"0:2729\"]},{\"tk\":[2140,40,2140,41],\"els\":[\"0:2729\"]},{\"tk\":[2141,7,2141,8],\"els\":[\"0:2729\"]},{\"tk\":[2141,8,2141,19],\"els\":[\"0:2729\"]},{\"tk\":[2141,20,2141,21],\"els\":[\"0:2729\"]},{\"tk\":[2141,22,2141,23],\"els\":[\"0:2729\"]},{\"tk\":[2141,23,2141,24],\"els\":[\"0:2729\"]},{\"tk\":[2142,7,2142,8],\"els\":[\"0:2729\"]},{\"tk\":[2142,8,2142,17],\"els\":[\"0:2729\"]},{\"tk\":[2142,18,2142,19],\"els\":[\"0:2729\"]},{\"tk\":[2142,20,2142,25],\"els\":[\"0:2729\"]},{\"tk\":[2142,25,2142,26],\"els\":[\"0:2729\"]},{\"tk\":[2143,7,2143,8],\"els\":[\"0:2729\"]},{\"tk\":[2143,8,2143,18],\"els\":[\"0:2729\"]},{\"tk\":[2143,19,2143,20],\"els\":[\"0:2729\"]},{\"tk\":[2143,21,2143,22],\"els\":[\"0:2729\"]},{\"tk\":[2143,22,2143,23],\"els\":[\"0:2729\"]},{\"tk\":[2144,7,2144,8],\"els\":[\"0:2729\"]},{\"tk\":[2144,8,2144,18],\"els\":[\"0:2729\"]},{\"tk\":[2144,19,2144,20],\"els\":[\"0:2729\"]},{\"tk\":[2144,21,2144,26],\"els\":[\"0:2729\"]},{\"tk\":[2144,26,2144,27],\"els\":[\"0:2729\"]},{\"tk\":[2145,7,2145,8],\"els\":[\"0:2729\"]},{\"tk\":[2145,8,2145,17],\"els\":[\"0:2729\"]},{\"tk\":[2145,18,2145,19],\"els\":[\"0:2729\"]},{\"tk\":[2145,20,2145,25],\"els\":[\"0:2729\"]},{\"tk\":[2146,5,2146,6],\"els\":[\"0:2729\"]},{\"tk\":[2146,6,2146,7],\"els\":[\"0:2729\"]},{\"tk\":[2148,5,2148,27],\"els\":[\"0:2729\"]},{\"tk\":[2148,27,2148,28],\"els\":[\"0:2729\"]},{\"tk\":[2148,28,2148,29],\"els\":[\"0:2729\"]},{\"tk\":[2148,29,2148,30],\"els\":[\"0:2729\"]},{\"tk\":[2148,31,2148,33],\"els\":[\"0:2729\"]},{\"tk\":[2148,33,2148,34],\"els\":[\"0:2729\"]},{\"tk\":[2148,35,2148,36],\"els\":[\"0:2729\"]},{\"tk\":[2148,36,2148,42],\"els\":[\"0:2729\"]},{\"tk\":[2148,42,2148,43],\"els\":[\"0:2729\"]},{\"tk\":[2148,44,2148,48],\"els\":[\"0:2729\"]},{\"tk\":[2148,48,2148,49],\"els\":[\"0:2729\"]},{\"tk\":[2148,49,2148,50],\"els\":[\"0:2729\"]},{\"tk\":[2149,5,2149,30],\"els\":[\"0:2729\"]},{\"tk\":[2149,30,2149,31],\"els\":[\"0:2729\"]},{\"tk\":[2149,31,2149,32],\"els\":[\"0:2729\"]},{\"tk\":[2149,32,2149,33],\"els\":[\"0:2729\"]},{\"tk\":[2149,34,2149,60],\"els\":[\"0:2729\"]},{\"tk\":[2149,60,2149,61],\"els\":[\"0:2729\"]},{\"tk\":[2149,61,2149,62],\"els\":[\"0:2729\"]},{\"tk\":[2150,5,2150,36],\"els\":[\"0:2729\"]},{\"tk\":[2150,36,2150,37],\"els\":[\"0:2729\"]},{\"tk\":[2150,37,2150,38],\"els\":[\"0:2729\"]},{\"tk\":[2150,38,2150,39],\"els\":[\"0:2729\"]},{\"tk\":[2150,40,2150,51],\"els\":[\"0:2729\"]},{\"tk\":[2150,51,2150,52],\"els\":[\"0:2729\"]},{\"tk\":[2150,53,2150,55],\"els\":[\"0:2729\"]},{\"tk\":[2150,55,2150,56],\"els\":[\"0:2729\"]},{\"tk\":[2150,57,2150,60],\"els\":[\"0:2729\"]},{\"tk\":[2150,60,2150,61],\"els\":[\"0:2729\"]},{\"tk\":[2150,61,2150,62],\"els\":[\"0:2729\"]},{\"tk\":[2151,3,2151,4],\"els\":[\"0:2729\"]},{\"tk\":[2154,3,2154,4],\"els\":[\"0:2730\"]},{\"tk\":[2155,5,2155,30],\"els\":[\"0:2730\"]},{\"tk\":[2155,31,2155,42],\"els\":[\"0:2730\"]},{\"tk\":[2155,43,2155,44],\"els\":[\"0:2730\"]},{\"tk\":[2155,45,2155,63],\"els\":[\"0:2730\"]},{\"tk\":[2155,63,2155,64],\"els\":[\"0:2730\"]},{\"tk\":[2156,5,2156,24],\"els\":[\"0:2730\"]},{\"tk\":[2156,25,2156,31],\"els\":[\"0:2730\"]},{\"tk\":[2156,32,2156,33],\"els\":[\"0:2730\"]},{\"tk\":[2156,34,2156,35],\"els\":[\"0:2730\"]},{\"tk\":[2157,7,2157,8],\"els\":[\"0:2730\"]},{\"tk\":[2157,8,2157,19],\"els\":[\"0:2730\"]},{\"tk\":[2157,20,2157,21],\"els\":[\"0:2730\"]},{\"tk\":[2157,22,2157,40],\"els\":[\"0:2730\"]},{\"tk\":[2157,40,2157,41],\"els\":[\"0:2730\"]},{\"tk\":[2158,7,2158,8],\"els\":[\"0:2730\"]},{\"tk\":[2158,8,2158,19],\"els\":[\"0:2730\"]},{\"tk\":[2158,20,2158,21],\"els\":[\"0:2730\"]},{\"tk\":[2158,22,2158,23],\"els\":[\"0:2730\"]},{\"tk\":[2158,23,2158,24],\"els\":[\"0:2730\"]},{\"tk\":[2159,7,2159,8],\"els\":[\"0:2730\"]},{\"tk\":[2159,8,2159,17],\"els\":[\"0:2730\"]},{\"tk\":[2159,18,2159,19],\"els\":[\"0:2730\"]},{\"tk\":[2159,20,2159,25],\"els\":[\"0:2730\"]},{\"tk\":[2159,25,2159,26],\"els\":[\"0:2730\"]},{\"tk\":[2160,7,2160,8],\"els\":[\"0:2730\"]},{\"tk\":[2160,8,2160,18],\"els\":[\"0:2730\"]},{\"tk\":[2160,19,2160,20],\"els\":[\"0:2730\"]},{\"tk\":[2160,21,2160,22],\"els\":[\"0:2730\"]},{\"tk\":[2160,22,2160,23],\"els\":[\"0:2730\"]},{\"tk\":[2161,7,2161,8],\"els\":[\"0:2730\"]},{\"tk\":[2161,8,2161,18],\"els\":[\"0:2730\"]},{\"tk\":[2161,19,2161,20],\"els\":[\"0:2730\"]},{\"tk\":[2161,21,2161,26],\"els\":[\"0:2730\"]},{\"tk\":[2161,26,2161,27],\"els\":[\"0:2730\"]},{\"tk\":[2162,7,2162,8],\"els\":[\"0:2730\"]},{\"tk\":[2162,8,2162,17],\"els\":[\"0:2730\"]},{\"tk\":[2162,18,2162,19],\"els\":[\"0:2730\"]},{\"tk\":[2162,20,2162,25],\"els\":[\"0:2730\"]},{\"tk\":[2163,5,2163,6],\"els\":[\"0:2730\"]},{\"tk\":[2163,6,2163,7],\"els\":[\"0:2730\"]},{\"tk\":[2165,5,2165,27],\"els\":[\"0:2730\"]},{\"tk\":[2165,27,2165,28],\"els\":[\"0:2730\"]},{\"tk\":[2165,28,2165,29],\"els\":[\"0:2730\"]},{\"tk\":[2165,29,2165,30],\"els\":[\"0:2730\"]},{\"tk\":[2165,31,2165,33],\"els\":[\"0:2730\"]},{\"tk\":[2165,33,2165,34],\"els\":[\"0:2730\"]},{\"tk\":[2165,35,2165,36],\"els\":[\"0:2730\"]},{\"tk\":[2165,36,2165,42],\"els\":[\"0:2730\"]},{\"tk\":[2165,42,2165,43],\"els\":[\"0:2730\"]},{\"tk\":[2165,44,2165,48],\"els\":[\"0:2730\"]},{\"tk\":[2165,48,2165,49],\"els\":[\"0:2730\"]},{\"tk\":[2165,49,2165,50],\"els\":[\"0:2730\"]},{\"tk\":[2166,5,2166,30],\"els\":[\"0:2730\"]},{\"tk\":[2166,30,2166,31],\"els\":[\"0:2730\"]},{\"tk\":[2166,31,2166,32],\"els\":[\"0:2730\"]},{\"tk\":[2166,32,2166,33],\"els\":[\"0:2730\"]},{\"tk\":[2166,34,2166,60],\"els\":[\"0:2730\"]},{\"tk\":[2166,60,2166,61],\"els\":[\"0:2730\"]},{\"tk\":[2166,61,2166,62],\"els\":[\"0:2730\"]},{\"tk\":[2167,5,2167,36],\"els\":[\"0:2730\"]},{\"tk\":[2167,36,2167,37],\"els\":[\"0:2730\"]},{\"tk\":[2167,37,2167,38],\"els\":[\"0:2730\"]},{\"tk\":[2167,38,2167,39],\"els\":[\"0:2730\"]},{\"tk\":[2167,40,2167,51],\"els\":[\"0:2730\"]},{\"tk\":[2167,51,2167,52],\"els\":[\"0:2730\"]},{\"tk\":[2167,53,2167,55],\"els\":[\"0:2730\"]},{\"tk\":[2167,55,2167,56],\"els\":[\"0:2730\"]},{\"tk\":[2167,57,2167,60],\"els\":[\"0:2730\"]},{\"tk\":[2167,60,2167,61],\"els\":[\"0:2730\"]},{\"tk\":[2167,61,2167,62],\"els\":[\"0:2730\"]},{\"tk\":[2168,3,2168,4],\"els\":[\"0:2730\"]},{\"tk\":[2171,3,2171,4],\"els\":[\"0:2731\"]},{\"tk\":[2172,5,2172,30],\"els\":[\"0:2731\"]},{\"tk\":[2172,31,2172,42],\"els\":[\"0:2731\"]},{\"tk\":[2172,43,2172,44],\"els\":[\"0:2731\"]},{\"tk\":[2172,45,2172,63],\"els\":[\"0:2731\"]},{\"tk\":[2172,63,2172,64],\"els\":[\"0:2731\"]},{\"tk\":[2173,5,2173,24],\"els\":[\"0:2731\"]},{\"tk\":[2173,25,2173,31],\"els\":[\"0:2731\"]},{\"tk\":[2173,32,2173,33],\"els\":[\"0:2731\"]},{\"tk\":[2173,34,2173,35],\"els\":[\"0:2731\"]},{\"tk\":[2174,7,2174,8],\"els\":[\"0:2731\"]},{\"tk\":[2174,8,2174,19],\"els\":[\"0:2731\"]},{\"tk\":[2174,20,2174,21],\"els\":[\"0:2731\"]},{\"tk\":[2174,22,2174,40],\"els\":[\"0:2731\"]},{\"tk\":[2174,40,2174,41],\"els\":[\"0:2731\"]},{\"tk\":[2175,7,2175,8],\"els\":[\"0:2731\"]},{\"tk\":[2175,8,2175,19],\"els\":[\"0:2731\"]},{\"tk\":[2175,20,2175,21],\"els\":[\"0:2731\"]},{\"tk\":[2175,22,2175,23],\"els\":[\"0:2731\"]},{\"tk\":[2175,23,2175,24],\"els\":[\"0:2731\"]},{\"tk\":[2176,7,2176,8],\"els\":[\"0:2731\"]},{\"tk\":[2176,8,2176,17],\"els\":[\"0:2731\"]},{\"tk\":[2176,18,2176,19],\"els\":[\"0:2731\"]},{\"tk\":[2176,20,2176,25],\"els\":[\"0:2731\"]},{\"tk\":[2176,25,2176,26],\"els\":[\"0:2731\"]},{\"tk\":[2177,7,2177,8],\"els\":[\"0:2731\"]},{\"tk\":[2177,8,2177,18],\"els\":[\"0:2731\"]},{\"tk\":[2177,19,2177,20],\"els\":[\"0:2731\"]},{\"tk\":[2177,21,2177,22],\"els\":[\"0:2731\"]},{\"tk\":[2177,22,2177,23],\"els\":[\"0:2731\"]},{\"tk\":[2178,7,2178,8],\"els\":[\"0:2731\"]},{\"tk\":[2178,8,2178,18],\"els\":[\"0:2731\"]},{\"tk\":[2178,19,2178,20],\"els\":[\"0:2731\"]},{\"tk\":[2178,21,2178,26],\"els\":[\"0:2731\"]},{\"tk\":[2178,26,2178,27],\"els\":[\"0:2731\"]},{\"tk\":[2179,7,2179,8],\"els\":[\"0:2731\"]},{\"tk\":[2179,8,2179,17],\"els\":[\"0:2731\"]},{\"tk\":[2179,18,2179,19],\"els\":[\"0:2731\"]},{\"tk\":[2179,20,2179,25],\"els\":[\"0:2731\"]},{\"tk\":[2180,5,2180,6],\"els\":[\"0:2731\"]},{\"tk\":[2180,6,2180,7],\"els\":[\"0:2731\"]},{\"tk\":[2182,5,2182,27],\"els\":[\"0:2731\"]},{\"tk\":[2182,27,2182,28],\"els\":[\"0:2731\"]},{\"tk\":[2182,28,2182,29],\"els\":[\"0:2731\"]},{\"tk\":[2182,29,2182,30],\"els\":[\"0:2731\"]},{\"tk\":[2182,31,2182,32],\"els\":[\"0:2731\"]},{\"tk\":[2182,32,2182,33],\"els\":[\"0:2731\"]},{\"tk\":[2182,34,2182,35],\"els\":[\"0:2731\"]},{\"tk\":[2182,35,2182,41],\"els\":[\"0:2731\"]},{\"tk\":[2182,41,2182,42],\"els\":[\"0:2731\"]},{\"tk\":[2182,43,2182,47],\"els\":[\"0:2731\"]},{\"tk\":[2182,47,2182,48],\"els\":[\"0:2731\"]},{\"tk\":[2182,48,2182,49],\"els\":[\"0:2731\"]},{\"tk\":[2183,5,2183,30],\"els\":[\"0:2731\"]},{\"tk\":[2183,30,2183,31],\"els\":[\"0:2731\"]},{\"tk\":[2183,31,2183,32],\"els\":[\"0:2731\"]},{\"tk\":[2183,32,2183,33],\"els\":[\"0:2731\"]},{\"tk\":[2183,34,2183,60],\"els\":[\"0:2731\"]},{\"tk\":[2183,60,2183,61],\"els\":[\"0:2731\"]},{\"tk\":[2183,61,2183,62],\"els\":[\"0:2731\"]},{\"tk\":[2184,5,2184,36],\"els\":[\"0:2731\"]},{\"tk\":[2184,36,2184,37],\"els\":[\"0:2731\"]},{\"tk\":[2184,37,2184,38],\"els\":[\"0:2731\"]},{\"tk\":[2184,38,2184,39],\"els\":[\"0:2731\"]},{\"tk\":[2184,40,2184,51],\"els\":[\"0:2731\"]},{\"tk\":[2184,51,2184,52],\"els\":[\"0:2731\"]},{\"tk\":[2184,53,2184,54],\"els\":[\"0:2731\"]},{\"tk\":[2184,54,2184,55],\"els\":[\"0:2731\"]},{\"tk\":[2184,56,2184,59],\"els\":[\"0:2731\"]},{\"tk\":[2184,59,2184,60],\"els\":[\"0:2731\"]},{\"tk\":[2184,60,2184,61],\"els\":[\"0:2731\"]},{\"tk\":[2185,3,2185,4],\"els\":[\"0:2731\"]},{\"tk\":[2188,3,2188,4],\"els\":[\"0:2732\"]},{\"tk\":[2189,5,2189,30],\"els\":[\"0:2732\"]},{\"tk\":[2189,31,2189,42],\"els\":[\"0:2732\"]},{\"tk\":[2189,43,2189,44],\"els\":[\"0:2732\"]},{\"tk\":[2189,45,2189,63],\"els\":[\"0:2732\"]},{\"tk\":[2189,63,2189,64],\"els\":[\"0:2732\"]},{\"tk\":[2190,5,2190,24],\"els\":[\"0:2732\"]},{\"tk\":[2190,25,2190,31],\"els\":[\"0:2732\"]},{\"tk\":[2190,32,2190,33],\"els\":[\"0:2732\"]},{\"tk\":[2190,34,2190,35],\"els\":[\"0:2732\"]},{\"tk\":[2191,7,2191,8],\"els\":[\"0:2732\"]},{\"tk\":[2191,8,2191,19],\"els\":[\"0:2732\"]},{\"tk\":[2191,20,2191,21],\"els\":[\"0:2732\"]},{\"tk\":[2191,22,2191,40],\"els\":[\"0:2732\"]},{\"tk\":[2191,40,2191,41],\"els\":[\"0:2732\"]},{\"tk\":[2192,7,2192,8],\"els\":[\"0:2732\"]},{\"tk\":[2192,8,2192,19],\"els\":[\"0:2732\"]},{\"tk\":[2192,20,2192,21],\"els\":[\"0:2732\"]},{\"tk\":[2192,22,2192,23],\"els\":[\"0:2732\"]},{\"tk\":[2192,23,2192,24],\"els\":[\"0:2732\"]},{\"tk\":[2193,7,2193,8],\"els\":[\"0:2732\"]},{\"tk\":[2193,8,2193,17],\"els\":[\"0:2732\"]},{\"tk\":[2193,18,2193,19],\"els\":[\"0:2732\"]},{\"tk\":[2193,20,2193,25],\"els\":[\"0:2732\"]},{\"tk\":[2193,25,2193,26],\"els\":[\"0:2732\"]},{\"tk\":[2194,7,2194,8],\"els\":[\"0:2732\"]},{\"tk\":[2194,8,2194,18],\"els\":[\"0:2732\"]},{\"tk\":[2194,19,2194,20],\"els\":[\"0:2732\"]},{\"tk\":[2194,21,2194,22],\"els\":[\"0:2732\"]},{\"tk\":[2194,22,2194,23],\"els\":[\"0:2732\"]},{\"tk\":[2195,7,2195,8],\"els\":[\"0:2732\"]},{\"tk\":[2195,8,2195,18],\"els\":[\"0:2732\"]},{\"tk\":[2195,19,2195,20],\"els\":[\"0:2732\"]},{\"tk\":[2195,21,2195,26],\"els\":[\"0:2732\"]},{\"tk\":[2195,26,2195,27],\"els\":[\"0:2732\"]},{\"tk\":[2196,7,2196,8],\"els\":[\"0:2732\"]},{\"tk\":[2196,8,2196,17],\"els\":[\"0:2732\"]},{\"tk\":[2196,18,2196,19],\"els\":[\"0:2732\"]},{\"tk\":[2196,20,2196,25],\"els\":[\"0:2732\"]},{\"tk\":[2197,5,2197,6],\"els\":[\"0:2732\"]},{\"tk\":[2197,6,2197,7],\"els\":[\"0:2732\"]},{\"tk\":[2199,5,2199,27],\"els\":[\"0:2732\"]},{\"tk\":[2199,27,2199,28],\"els\":[\"0:2732\"]},{\"tk\":[2199,28,2199,29],\"els\":[\"0:2732\"]},{\"tk\":[2199,29,2199,30],\"els\":[\"0:2732\"]},{\"tk\":[2199,31,2199,32],\"els\":[\"0:2732\"]},{\"tk\":[2199,32,2199,33],\"els\":[\"0:2732\"]},{\"tk\":[2199,34,2199,35],\"els\":[\"0:2732\"]},{\"tk\":[2199,35,2199,41],\"els\":[\"0:2732\"]},{\"tk\":[2199,41,2199,42],\"els\":[\"0:2732\"]},{\"tk\":[2199,43,2199,47],\"els\":[\"0:2732\"]},{\"tk\":[2199,47,2199,48],\"els\":[\"0:2732\"]},{\"tk\":[2199,48,2199,49],\"els\":[\"0:2732\"]},{\"tk\":[2200,5,2200,30],\"els\":[\"0:2732\"]},{\"tk\":[2200,30,2200,31],\"els\":[\"0:2732\"]},{\"tk\":[2200,31,2200,32],\"els\":[\"0:2732\"]},{\"tk\":[2200,32,2200,33],\"els\":[\"0:2732\"]},{\"tk\":[2200,34,2200,60],\"els\":[\"0:2732\"]},{\"tk\":[2200,60,2200,61],\"els\":[\"0:2732\"]},{\"tk\":[2200,61,2200,62],\"els\":[\"0:2732\"]},{\"tk\":[2201,5,2201,36],\"els\":[\"0:2732\"]},{\"tk\":[2201,36,2201,37],\"els\":[\"0:2732\"]},{\"tk\":[2201,37,2201,38],\"els\":[\"0:2732\"]},{\"tk\":[2201,38,2201,39],\"els\":[\"0:2732\"]},{\"tk\":[2201,40,2201,51],\"els\":[\"0:2732\"]},{\"tk\":[2201,51,2201,52],\"els\":[\"0:2732\"]},{\"tk\":[2201,53,2201,54],\"els\":[\"0:2732\"]},{\"tk\":[2201,54,2201,55],\"els\":[\"0:2732\"]},{\"tk\":[2201,56,2201,59],\"els\":[\"0:2732\"]},{\"tk\":[2201,59,2201,60],\"els\":[\"0:2732\"]},{\"tk\":[2201,60,2201,61],\"els\":[\"0:2732\"]},{\"tk\":[2202,3,2202,4],\"els\":[\"0:2732\"]},{\"tk\":[2205,3,2205,4],\"els\":[\"0:2733\"]},{\"tk\":[2206,5,2206,30],\"els\":[\"0:2733\"]},{\"tk\":[2206,31,2206,42],\"els\":[\"0:2733\"]},{\"tk\":[2206,43,2206,44],\"els\":[\"0:2733\"]},{\"tk\":[2206,45,2206,63],\"els\":[\"0:2733\"]},{\"tk\":[2206,63,2206,64],\"els\":[\"0:2733\"]},{\"tk\":[2207,5,2207,24],\"els\":[\"0:2733\"]},{\"tk\":[2207,25,2207,31],\"els\":[\"0:2733\"]},{\"tk\":[2207,32,2207,33],\"els\":[\"0:2733\"]},{\"tk\":[2207,34,2207,35],\"els\":[\"0:2733\"]},{\"tk\":[2208,7,2208,8],\"els\":[\"0:2733\"]},{\"tk\":[2208,8,2208,19],\"els\":[\"0:2733\"]},{\"tk\":[2208,20,2208,21],\"els\":[\"0:2733\"]},{\"tk\":[2208,22,2208,40],\"els\":[\"0:2733\"]},{\"tk\":[2208,40,2208,41],\"els\":[\"0:2733\"]},{\"tk\":[2209,7,2209,8],\"els\":[\"0:2733\"]},{\"tk\":[2209,8,2209,19],\"els\":[\"0:2733\"]},{\"tk\":[2209,20,2209,21],\"els\":[\"0:2733\"]},{\"tk\":[2209,22,2209,23],\"els\":[\"0:2733\"]},{\"tk\":[2209,23,2209,24],\"els\":[\"0:2733\"]},{\"tk\":[2210,7,2210,8],\"els\":[\"0:2733\"]},{\"tk\":[2210,8,2210,17],\"els\":[\"0:2733\"]},{\"tk\":[2210,18,2210,19],\"els\":[\"0:2733\"]},{\"tk\":[2210,20,2210,25],\"els\":[\"0:2733\"]},{\"tk\":[2210,25,2210,26],\"els\":[\"0:2733\"]},{\"tk\":[2211,7,2211,8],\"els\":[\"0:2733\"]},{\"tk\":[2211,8,2211,18],\"els\":[\"0:2733\"]},{\"tk\":[2211,19,2211,20],\"els\":[\"0:2733\"]},{\"tk\":[2211,21,2211,22],\"els\":[\"0:2733\"]},{\"tk\":[2211,22,2211,23],\"els\":[\"0:2733\"]},{\"tk\":[2212,7,2212,8],\"els\":[\"0:2733\"]},{\"tk\":[2212,8,2212,18],\"els\":[\"0:2733\"]},{\"tk\":[2212,19,2212,20],\"els\":[\"0:2733\"]},{\"tk\":[2212,21,2212,26],\"els\":[\"0:2733\"]},{\"tk\":[2212,26,2212,27],\"els\":[\"0:2733\"]},{\"tk\":[2213,7,2213,8],\"els\":[\"0:2733\"]},{\"tk\":[2213,8,2213,17],\"els\":[\"0:2733\"]},{\"tk\":[2213,18,2213,19],\"els\":[\"0:2733\"]},{\"tk\":[2213,20,2213,25],\"els\":[\"0:2733\"]},{\"tk\":[2214,5,2214,6],\"els\":[\"0:2733\"]},{\"tk\":[2214,6,2214,7],\"els\":[\"0:2733\"]},{\"tk\":[2216,5,2216,27],\"els\":[\"0:2733\"]},{\"tk\":[2216,27,2216,28],\"els\":[\"0:2733\"]},{\"tk\":[2216,28,2216,29],\"els\":[\"0:2733\"]},{\"tk\":[2216,29,2216,30],\"els\":[\"0:2733\"]},{\"tk\":[2216,31,2216,32],\"els\":[\"0:2733\"]},{\"tk\":[2216,32,2216,33],\"els\":[\"0:2733\"]},{\"tk\":[2216,34,2216,35],\"els\":[\"0:2733\"]},{\"tk\":[2216,35,2216,41],\"els\":[\"0:2733\"]},{\"tk\":[2216,41,2216,42],\"els\":[\"0:2733\"]},{\"tk\":[2216,43,2216,47],\"els\":[\"0:2733\"]},{\"tk\":[2216,47,2216,48],\"els\":[\"0:2733\"]},{\"tk\":[2216,48,2216,49],\"els\":[\"0:2733\"]},{\"tk\":[2217,5,2217,30],\"els\":[\"0:2733\"]},{\"tk\":[2217,30,2217,31],\"els\":[\"0:2733\"]},{\"tk\":[2217,31,2217,32],\"els\":[\"0:2733\"]},{\"tk\":[2217,32,2217,33],\"els\":[\"0:2733\"]},{\"tk\":[2217,34,2217,60],\"els\":[\"0:2733\"]},{\"tk\":[2217,60,2217,61],\"els\":[\"0:2733\"]},{\"tk\":[2217,61,2217,62],\"els\":[\"0:2733\"]},{\"tk\":[2218,5,2218,36],\"els\":[\"0:2733\"]},{\"tk\":[2218,36,2218,37],\"els\":[\"0:2733\"]},{\"tk\":[2218,37,2218,38],\"els\":[\"0:2733\"]},{\"tk\":[2218,38,2218,39],\"els\":[\"0:2733\"]},{\"tk\":[2218,40,2218,51],\"els\":[\"0:2733\"]},{\"tk\":[2218,51,2218,52],\"els\":[\"0:2733\"]},{\"tk\":[2218,53,2218,54],\"els\":[\"0:2733\"]},{\"tk\":[2218,54,2218,55],\"els\":[\"0:2733\"]},{\"tk\":[2218,56,2218,59],\"els\":[\"0:2733\"]},{\"tk\":[2218,59,2218,60],\"els\":[\"0:2733\"]},{\"tk\":[2218,60,2218,61],\"els\":[\"0:2733\"]},{\"tk\":[2219,3,2219,4],\"els\":[\"0:2733\"]},{\"tk\":[2222,3,2222,4],\"els\":[\"0:2734\"]},{\"tk\":[2223,5,2223,30],\"els\":[\"0:2734\"]},{\"tk\":[2223,31,2223,42],\"els\":[\"0:2734\"]},{\"tk\":[2223,43,2223,44],\"els\":[\"0:2734\"]},{\"tk\":[2223,45,2223,63],\"els\":[\"0:2734\"]},{\"tk\":[2223,63,2223,64],\"els\":[\"0:2734\"]},{\"tk\":[2224,5,2224,24],\"els\":[\"0:2734\"]},{\"tk\":[2224,25,2224,31],\"els\":[\"0:2734\"]},{\"tk\":[2224,32,2224,33],\"els\":[\"0:2734\"]},{\"tk\":[2224,34,2224,35],\"els\":[\"0:2734\"]},{\"tk\":[2225,7,2225,8],\"els\":[\"0:2734\"]},{\"tk\":[2225,8,2225,19],\"els\":[\"0:2734\"]},{\"tk\":[2225,20,2225,21],\"els\":[\"0:2734\"]},{\"tk\":[2225,22,2225,40],\"els\":[\"0:2734\"]},{\"tk\":[2225,40,2225,41],\"els\":[\"0:2734\"]},{\"tk\":[2226,7,2226,8],\"els\":[\"0:2734\"]},{\"tk\":[2226,8,2226,19],\"els\":[\"0:2734\"]},{\"tk\":[2226,20,2226,21],\"els\":[\"0:2734\"]},{\"tk\":[2226,22,2226,23],\"els\":[\"0:2734\"]},{\"tk\":[2226,23,2226,24],\"els\":[\"0:2734\"]},{\"tk\":[2227,7,2227,8],\"els\":[\"0:2734\"]},{\"tk\":[2227,8,2227,17],\"els\":[\"0:2734\"]},{\"tk\":[2227,18,2227,19],\"els\":[\"0:2734\"]},{\"tk\":[2227,20,2227,25],\"els\":[\"0:2734\"]},{\"tk\":[2227,25,2227,26],\"els\":[\"0:2734\"]},{\"tk\":[2228,7,2228,8],\"els\":[\"0:2734\"]},{\"tk\":[2228,8,2228,18],\"els\":[\"0:2734\"]},{\"tk\":[2228,19,2228,20],\"els\":[\"0:2734\"]},{\"tk\":[2228,21,2228,22],\"els\":[\"0:2734\"]},{\"tk\":[2228,22,2228,23],\"els\":[\"0:2734\"]},{\"tk\":[2229,7,2229,8],\"els\":[\"0:2734\"]},{\"tk\":[2229,8,2229,18],\"els\":[\"0:2734\"]},{\"tk\":[2229,19,2229,20],\"els\":[\"0:2734\"]},{\"tk\":[2229,21,2229,26],\"els\":[\"0:2734\"]},{\"tk\":[2229,26,2229,27],\"els\":[\"0:2734\"]},{\"tk\":[2230,7,2230,8],\"els\":[\"0:2734\"]},{\"tk\":[2230,8,2230,17],\"els\":[\"0:2734\"]},{\"tk\":[2230,18,2230,19],\"els\":[\"0:2734\"]},{\"tk\":[2230,20,2230,25],\"els\":[\"0:2734\"]},{\"tk\":[2231,5,2231,6],\"els\":[\"0:2734\"]},{\"tk\":[2231,6,2231,7],\"els\":[\"0:2734\"]},{\"tk\":[2233,5,2233,27],\"els\":[\"0:2734\"]},{\"tk\":[2233,27,2233,28],\"els\":[\"0:2734\"]},{\"tk\":[2233,28,2233,29],\"els\":[\"0:2734\"]},{\"tk\":[2233,29,2233,30],\"els\":[\"0:2734\"]},{\"tk\":[2233,31,2233,32],\"els\":[\"0:2734\"]},{\"tk\":[2233,32,2233,33],\"els\":[\"0:2734\"]},{\"tk\":[2233,34,2233,35],\"els\":[\"0:2734\"]},{\"tk\":[2233,35,2233,41],\"els\":[\"0:2734\"]},{\"tk\":[2233,41,2233,42],\"els\":[\"0:2734\"]},{\"tk\":[2233,43,2233,47],\"els\":[\"0:2734\"]},{\"tk\":[2233,47,2233,48],\"els\":[\"0:2734\"]},{\"tk\":[2233,48,2233,49],\"els\":[\"0:2734\"]},{\"tk\":[2234,5,2234,30],\"els\":[\"0:2734\"]},{\"tk\":[2234,30,2234,31],\"els\":[\"0:2734\"]},{\"tk\":[2234,31,2234,32],\"els\":[\"0:2734\"]},{\"tk\":[2234,32,2234,33],\"els\":[\"0:2734\"]},{\"tk\":[2234,34,2234,60],\"els\":[\"0:2734\"]},{\"tk\":[2234,60,2234,61],\"els\":[\"0:2734\"]},{\"tk\":[2234,61,2234,62],\"els\":[\"0:2734\"]},{\"tk\":[2235,5,2235,36],\"els\":[\"0:2734\"]},{\"tk\":[2235,36,2235,37],\"els\":[\"0:2734\"]},{\"tk\":[2235,37,2235,38],\"els\":[\"0:2734\"]},{\"tk\":[2235,38,2235,39],\"els\":[\"0:2734\"]},{\"tk\":[2235,40,2235,51],\"els\":[\"0:2734\"]},{\"tk\":[2235,51,2235,52],\"els\":[\"0:2734\"]},{\"tk\":[2235,53,2235,54],\"els\":[\"0:2734\"]},{\"tk\":[2235,54,2235,55],\"els\":[\"0:2734\"]},{\"tk\":[2235,56,2235,59],\"els\":[\"0:2734\"]},{\"tk\":[2235,59,2235,60],\"els\":[\"0:2734\"]},{\"tk\":[2235,60,2235,61],\"els\":[\"0:2734\"]},{\"tk\":[2236,3,2236,4],\"els\":[\"0:2734\"]},{\"tk\":[2239,3,2239,4],\"els\":[\"0:2735\"]},{\"tk\":[2240,5,2240,30],\"els\":[\"0:2735\"]},{\"tk\":[2240,31,2240,42],\"els\":[\"0:2735\"]},{\"tk\":[2240,43,2240,44],\"els\":[\"0:2735\"]},{\"tk\":[2240,45,2240,63],\"els\":[\"0:2735\"]},{\"tk\":[2240,63,2240,64],\"els\":[\"0:2735\"]},{\"tk\":[2241,5,2241,24],\"els\":[\"0:2735\"]},{\"tk\":[2241,25,2241,31],\"els\":[\"0:2735\"]},{\"tk\":[2241,32,2241,33],\"els\":[\"0:2735\"]},{\"tk\":[2241,34,2241,35],\"els\":[\"0:2735\"]},{\"tk\":[2242,7,2242,8],\"els\":[\"0:2735\"]},{\"tk\":[2242,8,2242,19],\"els\":[\"0:2735\"]},{\"tk\":[2242,20,2242,21],\"els\":[\"0:2735\"]},{\"tk\":[2242,22,2242,40],\"els\":[\"0:2735\"]},{\"tk\":[2242,40,2242,41],\"els\":[\"0:2735\"]},{\"tk\":[2243,7,2243,8],\"els\":[\"0:2735\"]},{\"tk\":[2243,8,2243,19],\"els\":[\"0:2735\"]},{\"tk\":[2243,20,2243,21],\"els\":[\"0:2735\"]},{\"tk\":[2243,22,2243,23],\"els\":[\"0:2735\"]},{\"tk\":[2243,23,2243,24],\"els\":[\"0:2735\"]},{\"tk\":[2244,7,2244,8],\"els\":[\"0:2735\"]},{\"tk\":[2244,8,2244,17],\"els\":[\"0:2735\"]},{\"tk\":[2244,18,2244,19],\"els\":[\"0:2735\"]},{\"tk\":[2244,20,2244,25],\"els\":[\"0:2735\"]},{\"tk\":[2244,25,2244,26],\"els\":[\"0:2735\"]},{\"tk\":[2245,7,2245,8],\"els\":[\"0:2735\"]},{\"tk\":[2245,8,2245,18],\"els\":[\"0:2735\"]},{\"tk\":[2245,19,2245,20],\"els\":[\"0:2735\"]},{\"tk\":[2245,21,2245,22],\"els\":[\"0:2735\"]},{\"tk\":[2245,22,2245,23],\"els\":[\"0:2735\"]},{\"tk\":[2246,7,2246,8],\"els\":[\"0:2735\"]},{\"tk\":[2246,8,2246,18],\"els\":[\"0:2735\"]},{\"tk\":[2246,19,2246,20],\"els\":[\"0:2735\"]},{\"tk\":[2246,21,2246,26],\"els\":[\"0:2735\"]},{\"tk\":[2246,26,2246,27],\"els\":[\"0:2735\"]},{\"tk\":[2247,7,2247,8],\"els\":[\"0:2735\"]},{\"tk\":[2247,8,2247,17],\"els\":[\"0:2735\"]},{\"tk\":[2247,18,2247,19],\"els\":[\"0:2735\"]},{\"tk\":[2247,20,2247,25],\"els\":[\"0:2735\"]},{\"tk\":[2248,5,2248,6],\"els\":[\"0:2735\"]},{\"tk\":[2248,6,2248,7],\"els\":[\"0:2735\"]},{\"tk\":[2250,5,2250,27],\"els\":[\"0:2735\"]},{\"tk\":[2250,27,2250,28],\"els\":[\"0:2735\"]},{\"tk\":[2250,28,2250,29],\"els\":[\"0:2735\"]},{\"tk\":[2250,29,2250,30],\"els\":[\"0:2735\"]},{\"tk\":[2250,31,2250,32],\"els\":[\"0:2735\"]},{\"tk\":[2250,32,2250,33],\"els\":[\"0:2735\"]},{\"tk\":[2250,34,2250,35],\"els\":[\"0:2735\"]},{\"tk\":[2250,35,2250,41],\"els\":[\"0:2735\"]},{\"tk\":[2250,41,2250,42],\"els\":[\"0:2735\"]},{\"tk\":[2250,43,2250,47],\"els\":[\"0:2735\"]},{\"tk\":[2250,47,2250,48],\"els\":[\"0:2735\"]},{\"tk\":[2250,48,2250,49],\"els\":[\"0:2735\"]},{\"tk\":[2251,5,2251,30],\"els\":[\"0:2735\"]},{\"tk\":[2251,30,2251,31],\"els\":[\"0:2735\"]},{\"tk\":[2251,31,2251,32],\"els\":[\"0:2735\"]},{\"tk\":[2251,32,2251,33],\"els\":[\"0:2735\"]},{\"tk\":[2251,34,2251,60],\"els\":[\"0:2735\"]},{\"tk\":[2251,60,2251,61],\"els\":[\"0:2735\"]},{\"tk\":[2251,61,2251,62],\"els\":[\"0:2735\"]},{\"tk\":[2252,5,2252,36],\"els\":[\"0:2735\"]},{\"tk\":[2252,36,2252,37],\"els\":[\"0:2735\"]},{\"tk\":[2252,37,2252,38],\"els\":[\"0:2735\"]},{\"tk\":[2252,38,2252,39],\"els\":[\"0:2735\"]},{\"tk\":[2252,40,2252,51],\"els\":[\"0:2735\"]},{\"tk\":[2252,51,2252,52],\"els\":[\"0:2735\"]},{\"tk\":[2252,53,2252,54],\"els\":[\"0:2735\"]},{\"tk\":[2252,54,2252,55],\"els\":[\"0:2735\"]},{\"tk\":[2252,56,2252,59],\"els\":[\"0:2735\"]},{\"tk\":[2252,59,2252,60],\"els\":[\"0:2735\"]},{\"tk\":[2252,60,2252,61],\"els\":[\"0:2735\"]},{\"tk\":[2253,3,2253,4],\"els\":[\"0:2735\"]},{\"tk\":[2256,3,2256,4],\"els\":[\"0:2736\"]},{\"tk\":[2257,5,2257,30],\"els\":[\"0:2736\"]},{\"tk\":[2257,31,2257,42],\"els\":[\"0:2736\"]},{\"tk\":[2257,43,2257,44],\"els\":[\"0:2736\"]},{\"tk\":[2257,45,2257,63],\"els\":[\"0:2736\"]},{\"tk\":[2257,63,2257,64],\"els\":[\"0:2736\"]},{\"tk\":[2258,5,2258,24],\"els\":[\"0:2736\"]},{\"tk\":[2258,25,2258,31],\"els\":[\"0:2736\"]},{\"tk\":[2258,32,2258,33],\"els\":[\"0:2736\"]},{\"tk\":[2258,34,2258,35],\"els\":[\"0:2736\"]},{\"tk\":[2259,7,2259,8],\"els\":[\"0:2736\"]},{\"tk\":[2259,8,2259,19],\"els\":[\"0:2736\"]},{\"tk\":[2259,20,2259,21],\"els\":[\"0:2736\"]},{\"tk\":[2259,22,2259,40],\"els\":[\"0:2736\"]},{\"tk\":[2259,40,2259,41],\"els\":[\"0:2736\"]},{\"tk\":[2260,7,2260,8],\"els\":[\"0:2736\"]},{\"tk\":[2260,8,2260,19],\"els\":[\"0:2736\"]},{\"tk\":[2260,20,2260,21],\"els\":[\"0:2736\"]},{\"tk\":[2260,22,2260,23],\"els\":[\"0:2736\"]},{\"tk\":[2260,23,2260,24],\"els\":[\"0:2736\"]},{\"tk\":[2261,7,2261,8],\"els\":[\"0:2736\"]},{\"tk\":[2261,8,2261,17],\"els\":[\"0:2736\"]},{\"tk\":[2261,18,2261,19],\"els\":[\"0:2736\"]},{\"tk\":[2261,20,2261,25],\"els\":[\"0:2736\"]},{\"tk\":[2261,25,2261,26],\"els\":[\"0:2736\"]},{\"tk\":[2262,7,2262,8],\"els\":[\"0:2736\"]},{\"tk\":[2262,8,2262,18],\"els\":[\"0:2736\"]},{\"tk\":[2262,19,2262,20],\"els\":[\"0:2736\"]},{\"tk\":[2262,21,2262,22],\"els\":[\"0:2736\"]},{\"tk\":[2262,22,2262,23],\"els\":[\"0:2736\"]},{\"tk\":[2263,7,2263,8],\"els\":[\"0:2736\"]},{\"tk\":[2263,8,2263,18],\"els\":[\"0:2736\"]},{\"tk\":[2263,19,2263,20],\"els\":[\"0:2736\"]},{\"tk\":[2263,21,2263,26],\"els\":[\"0:2736\"]},{\"tk\":[2263,26,2263,27],\"els\":[\"0:2736\"]},{\"tk\":[2264,7,2264,8],\"els\":[\"0:2736\"]},{\"tk\":[2264,8,2264,17],\"els\":[\"0:2736\"]},{\"tk\":[2264,18,2264,19],\"els\":[\"0:2736\"]},{\"tk\":[2264,20,2264,25],\"els\":[\"0:2736\"]},{\"tk\":[2265,5,2265,6],\"els\":[\"0:2736\"]},{\"tk\":[2265,6,2265,7],\"els\":[\"0:2736\"]},{\"tk\":[2267,5,2267,27],\"els\":[\"0:2736\"]},{\"tk\":[2267,27,2267,28],\"els\":[\"0:2736\"]},{\"tk\":[2267,28,2267,29],\"els\":[\"0:2736\"]},{\"tk\":[2267,29,2267,30],\"els\":[\"0:2736\"]},{\"tk\":[2267,31,2267,32],\"els\":[\"0:2736\"]},{\"tk\":[2267,32,2267,33],\"els\":[\"0:2736\"]},{\"tk\":[2267,34,2267,35],\"els\":[\"0:2736\"]},{\"tk\":[2267,35,2267,41],\"els\":[\"0:2736\"]},{\"tk\":[2267,41,2267,42],\"els\":[\"0:2736\"]},{\"tk\":[2267,43,2267,47],\"els\":[\"0:2736\"]},{\"tk\":[2267,47,2267,48],\"els\":[\"0:2736\"]},{\"tk\":[2267,48,2267,49],\"els\":[\"0:2736\"]},{\"tk\":[2268,5,2268,30],\"els\":[\"0:2736\"]},{\"tk\":[2268,30,2268,31],\"els\":[\"0:2736\"]},{\"tk\":[2268,31,2268,32],\"els\":[\"0:2736\"]},{\"tk\":[2268,32,2268,33],\"els\":[\"0:2736\"]},{\"tk\":[2268,34,2268,60],\"els\":[\"0:2736\"]},{\"tk\":[2268,60,2268,61],\"els\":[\"0:2736\"]},{\"tk\":[2268,61,2268,62],\"els\":[\"0:2736\"]},{\"tk\":[2269,5,2269,36],\"els\":[\"0:2736\"]},{\"tk\":[2269,36,2269,37],\"els\":[\"0:2736\"]},{\"tk\":[2269,37,2269,38],\"els\":[\"0:2736\"]},{\"tk\":[2269,38,2269,39],\"els\":[\"0:2736\"]},{\"tk\":[2269,40,2269,51],\"els\":[\"0:2736\"]},{\"tk\":[2269,51,2269,52],\"els\":[\"0:2736\"]},{\"tk\":[2269,53,2269,54],\"els\":[\"0:2736\"]},{\"tk\":[2269,54,2269,55],\"els\":[\"0:2736\"]},{\"tk\":[2269,56,2269,59],\"els\":[\"0:2736\"]},{\"tk\":[2269,59,2269,60],\"els\":[\"0:2736\"]},{\"tk\":[2269,60,2269,61],\"els\":[\"0:2736\"]},{\"tk\":[2270,3,2270,4],\"els\":[\"0:2736\"]},{\"tk\":[2273,3,2273,4],\"els\":[\"0:2737\"]},{\"tk\":[2274,5,2274,30],\"els\":[\"0:2737\"]},{\"tk\":[2274,31,2274,42],\"els\":[\"0:2737\"]},{\"tk\":[2274,43,2274,44],\"els\":[\"0:2737\"]},{\"tk\":[2274,45,2274,63],\"els\":[\"0:2737\"]},{\"tk\":[2274,63,2274,64],\"els\":[\"0:2737\"]},{\"tk\":[2275,5,2275,24],\"els\":[\"0:2737\"]},{\"tk\":[2275,25,2275,31],\"els\":[\"0:2737\"]},{\"tk\":[2275,32,2275,33],\"els\":[\"0:2737\"]},{\"tk\":[2275,34,2275,35],\"els\":[\"0:2737\"]},{\"tk\":[2276,7,2276,8],\"els\":[\"0:2737\"]},{\"tk\":[2276,8,2276,19],\"els\":[\"0:2737\"]},{\"tk\":[2276,20,2276,21],\"els\":[\"0:2737\"]},{\"tk\":[2276,22,2276,40],\"els\":[\"0:2737\"]},{\"tk\":[2276,40,2276,41],\"els\":[\"0:2737\"]},{\"tk\":[2277,7,2277,8],\"els\":[\"0:2737\"]},{\"tk\":[2277,8,2277,19],\"els\":[\"0:2737\"]},{\"tk\":[2277,20,2277,21],\"els\":[\"0:2737\"]},{\"tk\":[2277,22,2277,23],\"els\":[\"0:2737\"]},{\"tk\":[2277,23,2277,24],\"els\":[\"0:2737\"]},{\"tk\":[2278,7,2278,8],\"els\":[\"0:2737\"]},{\"tk\":[2278,8,2278,17],\"els\":[\"0:2737\"]},{\"tk\":[2278,18,2278,19],\"els\":[\"0:2737\"]},{\"tk\":[2278,20,2278,25],\"els\":[\"0:2737\"]},{\"tk\":[2278,25,2278,26],\"els\":[\"0:2737\"]},{\"tk\":[2279,7,2279,8],\"els\":[\"0:2737\"]},{\"tk\":[2279,8,2279,18],\"els\":[\"0:2737\"]},{\"tk\":[2279,19,2279,20],\"els\":[\"0:2737\"]},{\"tk\":[2279,21,2279,22],\"els\":[\"0:2737\"]},{\"tk\":[2279,22,2279,23],\"els\":[\"0:2737\"]},{\"tk\":[2280,7,2280,8],\"els\":[\"0:2737\"]},{\"tk\":[2280,8,2280,18],\"els\":[\"0:2737\"]},{\"tk\":[2280,19,2280,20],\"els\":[\"0:2737\"]},{\"tk\":[2280,21,2280,26],\"els\":[\"0:2737\"]},{\"tk\":[2280,26,2280,27],\"els\":[\"0:2737\"]},{\"tk\":[2281,7,2281,8],\"els\":[\"0:2737\"]},{\"tk\":[2281,8,2281,17],\"els\":[\"0:2737\"]},{\"tk\":[2281,18,2281,19],\"els\":[\"0:2737\"]},{\"tk\":[2281,20,2281,25],\"els\":[\"0:2737\"]},{\"tk\":[2282,5,2282,6],\"els\":[\"0:2737\"]},{\"tk\":[2282,6,2282,7],\"els\":[\"0:2737\"]},{\"tk\":[2284,5,2284,27],\"els\":[\"0:2737\"]},{\"tk\":[2284,27,2284,28],\"els\":[\"0:2737\"]},{\"tk\":[2284,28,2284,29],\"els\":[\"0:2737\"]},{\"tk\":[2284,29,2284,30],\"els\":[\"0:2737\"]},{\"tk\":[2284,31,2284,33],\"els\":[\"0:2737\"]},{\"tk\":[2284,33,2284,34],\"els\":[\"0:2737\"]},{\"tk\":[2284,35,2284,36],\"els\":[\"0:2737\"]},{\"tk\":[2284,36,2284,42],\"els\":[\"0:2737\"]},{\"tk\":[2284,42,2284,43],\"els\":[\"0:2737\"]},{\"tk\":[2284,44,2284,48],\"els\":[\"0:2737\"]},{\"tk\":[2284,48,2284,49],\"els\":[\"0:2737\"]},{\"tk\":[2284,49,2284,50],\"els\":[\"0:2737\"]},{\"tk\":[2285,5,2285,30],\"els\":[\"0:2737\"]},{\"tk\":[2285,30,2285,31],\"els\":[\"0:2737\"]},{\"tk\":[2285,31,2285,32],\"els\":[\"0:2737\"]},{\"tk\":[2285,32,2285,33],\"els\":[\"0:2737\"]},{\"tk\":[2285,34,2285,60],\"els\":[\"0:2737\"]},{\"tk\":[2285,60,2285,61],\"els\":[\"0:2737\"]},{\"tk\":[2285,61,2285,62],\"els\":[\"0:2737\"]},{\"tk\":[2286,5,2286,36],\"els\":[\"0:2737\"]},{\"tk\":[2286,36,2286,37],\"els\":[\"0:2737\"]},{\"tk\":[2286,37,2286,38],\"els\":[\"0:2737\"]},{\"tk\":[2286,38,2286,39],\"els\":[\"0:2737\"]},{\"tk\":[2286,40,2286,51],\"els\":[\"0:2737\"]},{\"tk\":[2286,51,2286,52],\"els\":[\"0:2737\"]},{\"tk\":[2286,53,2286,55],\"els\":[\"0:2737\"]},{\"tk\":[2286,55,2286,56],\"els\":[\"0:2737\"]},{\"tk\":[2286,57,2286,60],\"els\":[\"0:2737\"]},{\"tk\":[2286,60,2286,61],\"els\":[\"0:2737\"]},{\"tk\":[2286,61,2286,62],\"els\":[\"0:2737\"]},{\"tk\":[2287,3,2287,4],\"els\":[\"0:2737\"]},{\"tk\":[2290,3,2290,4],\"els\":[\"0:2738\"]},{\"tk\":[2291,5,2291,30],\"els\":[\"0:2738\"]},{\"tk\":[2291,31,2291,42],\"els\":[\"0:2738\"]},{\"tk\":[2291,43,2291,44],\"els\":[\"0:2738\"]},{\"tk\":[2291,45,2291,63],\"els\":[\"0:2738\"]},{\"tk\":[2291,63,2291,64],\"els\":[\"0:2738\"]},{\"tk\":[2292,5,2292,24],\"els\":[\"0:2738\"]},{\"tk\":[2292,25,2292,31],\"els\":[\"0:2738\"]},{\"tk\":[2292,32,2292,33],\"els\":[\"0:2738\"]},{\"tk\":[2292,34,2292,35],\"els\":[\"0:2738\"]},{\"tk\":[2293,7,2293,8],\"els\":[\"0:2738\"]},{\"tk\":[2293,8,2293,19],\"els\":[\"0:2738\"]},{\"tk\":[2293,20,2293,21],\"els\":[\"0:2738\"]},{\"tk\":[2293,22,2293,40],\"els\":[\"0:2738\"]},{\"tk\":[2293,40,2293,41],\"els\":[\"0:2738\"]},{\"tk\":[2294,7,2294,8],\"els\":[\"0:2738\"]},{\"tk\":[2294,8,2294,19],\"els\":[\"0:2738\"]},{\"tk\":[2294,20,2294,21],\"els\":[\"0:2738\"]},{\"tk\":[2294,22,2294,23],\"els\":[\"0:2738\"]},{\"tk\":[2294,23,2294,24],\"els\":[\"0:2738\"]},{\"tk\":[2295,7,2295,8],\"els\":[\"0:2738\"]},{\"tk\":[2295,8,2295,17],\"els\":[\"0:2738\"]},{\"tk\":[2295,18,2295,19],\"els\":[\"0:2738\"]},{\"tk\":[2295,20,2295,25],\"els\":[\"0:2738\"]},{\"tk\":[2295,25,2295,26],\"els\":[\"0:2738\"]},{\"tk\":[2296,7,2296,8],\"els\":[\"0:2738\"]},{\"tk\":[2296,8,2296,18],\"els\":[\"0:2738\"]},{\"tk\":[2296,19,2296,20],\"els\":[\"0:2738\"]},{\"tk\":[2296,21,2296,22],\"els\":[\"0:2738\"]},{\"tk\":[2296,22,2296,23],\"els\":[\"0:2738\"]},{\"tk\":[2297,7,2297,8],\"els\":[\"0:2738\"]},{\"tk\":[2297,8,2297,18],\"els\":[\"0:2738\"]},{\"tk\":[2297,19,2297,20],\"els\":[\"0:2738\"]},{\"tk\":[2297,21,2297,26],\"els\":[\"0:2738\"]},{\"tk\":[2297,26,2297,27],\"els\":[\"0:2738\"]},{\"tk\":[2298,7,2298,8],\"els\":[\"0:2738\"]},{\"tk\":[2298,8,2298,17],\"els\":[\"0:2738\"]},{\"tk\":[2298,18,2298,19],\"els\":[\"0:2738\"]},{\"tk\":[2298,20,2298,25],\"els\":[\"0:2738\"]},{\"tk\":[2299,5,2299,6],\"els\":[\"0:2738\"]},{\"tk\":[2299,6,2299,7],\"els\":[\"0:2738\"]},{\"tk\":[2301,5,2301,27],\"els\":[\"0:2738\"]},{\"tk\":[2301,27,2301,28],\"els\":[\"0:2738\"]},{\"tk\":[2301,28,2301,29],\"els\":[\"0:2738\"]},{\"tk\":[2301,29,2301,30],\"els\":[\"0:2738\"]},{\"tk\":[2301,31,2301,33],\"els\":[\"0:2738\"]},{\"tk\":[2301,33,2301,34],\"els\":[\"0:2738\"]},{\"tk\":[2301,35,2301,36],\"els\":[\"0:2738\"]},{\"tk\":[2301,36,2301,42],\"els\":[\"0:2738\"]},{\"tk\":[2301,42,2301,43],\"els\":[\"0:2738\"]},{\"tk\":[2301,44,2301,48],\"els\":[\"0:2738\"]},{\"tk\":[2301,48,2301,49],\"els\":[\"0:2738\"]},{\"tk\":[2301,49,2301,50],\"els\":[\"0:2738\"]},{\"tk\":[2302,5,2302,30],\"els\":[\"0:2738\"]},{\"tk\":[2302,30,2302,31],\"els\":[\"0:2738\"]},{\"tk\":[2302,31,2302,32],\"els\":[\"0:2738\"]},{\"tk\":[2302,32,2302,33],\"els\":[\"0:2738\"]},{\"tk\":[2302,34,2302,60],\"els\":[\"0:2738\"]},{\"tk\":[2302,60,2302,61],\"els\":[\"0:2738\"]},{\"tk\":[2302,61,2302,62],\"els\":[\"0:2738\"]},{\"tk\":[2303,5,2303,36],\"els\":[\"0:2738\"]},{\"tk\":[2303,36,2303,37],\"els\":[\"0:2738\"]},{\"tk\":[2303,37,2303,38],\"els\":[\"0:2738\"]},{\"tk\":[2303,38,2303,39],\"els\":[\"0:2738\"]},{\"tk\":[2303,40,2303,51],\"els\":[\"0:2738\"]},{\"tk\":[2303,51,2303,52],\"els\":[\"0:2738\"]},{\"tk\":[2303,53,2303,55],\"els\":[\"0:2738\"]},{\"tk\":[2303,55,2303,56],\"els\":[\"0:2738\"]},{\"tk\":[2303,57,2303,60],\"els\":[\"0:2738\"]},{\"tk\":[2303,60,2303,61],\"els\":[\"0:2738\"]},{\"tk\":[2303,61,2303,62],\"els\":[\"0:2738\"]},{\"tk\":[2304,3,2304,4],\"els\":[\"0:2738\"]},{\"tk\":[2312,3,2312,19],\"els\":[\"0:2815\"]},{\"tk\":[2312,20,2312,21],\"els\":[\"0:2815\"]},{\"tk\":[2312,21,2312,24],\"els\":[\"0:2815\"]},{\"tk\":[2312,24,2312,25],\"els\":[\"0:2815\"]},{\"tk\":[2312,26,2312,41],\"els\":[\"0:2815\"]},{\"tk\":[2312,41,2312,42],\"els\":[\"0:2815\"]},{\"tk\":[2312,43,2312,47],\"els\":[\"0:2815\"]},{\"tk\":[2312,47,2312,48],\"els\":[\"0:2815\"]},{\"tk\":[2312,48,2312,49],\"els\":[\"0:2815\"]},{\"tk\":[2315,3,2315,21],\"els\":[\"0:2815\"]},{\"tk\":[2315,22,2315,23],\"els\":[\"0:2815\"]},{\"tk\":[2315,23,2315,28],\"els\":[\"0:2815\"]},{\"tk\":[2315,28,2315,29],\"els\":[\"0:2815\"]},{\"tk\":[2315,30,2315,31],\"els\":[\"0:2815\"]},{\"tk\":[2315,31,2315,32],\"els\":[\"0:2815\"]},{\"tk\":[2315,33,2315,46],\"els\":[\"0:2815\"]},{\"tk\":[2315,46,2315,47],\"els\":[\"0:2815\"]},{\"tk\":[2315,47,2315,48],\"els\":[\"0:2815\"]},{\"tk\":[2318,3,2318,32],\"els\":[\"0:2815\"]},{\"tk\":[2318,33,2318,34],\"els\":[\"0:2815\"]},{\"tk\":[2318,34,2318,37],\"els\":[\"0:2815\"]},{\"tk\":[2318,37,2318,38],\"els\":[\"0:2815\"]},{\"tk\":[2318,39,2318,47],\"els\":[\"0:2815\"]},{\"tk\":[2318,47,2318,48],\"els\":[\"0:2815\"]},{\"tk\":[2318,49,2318,53],\"els\":[\"0:2815\"]},{\"tk\":[2318,53,2318,54],\"els\":[\"0:2815\"]},{\"tk\":[2318,55,2318,67],\"els\":[\"0:2815\"]},{\"tk\":[2318,67,2318,68],\"els\":[\"0:2815\"]},{\"tk\":[2318,69,2318,70],\"els\":[\"0:2815\"]},{\"tk\":[2318,70,2318,71],\"els\":[\"0:2815\"]},{\"tk\":[2318,72,2318,73],\"els\":[\"0:2815\"]},{\"tk\":[2318,73,2318,74],\"els\":[\"0:2815\"]},{\"tk\":[2318,74,2318,75],\"els\":[\"0:2815\"]},{\"tk\":[2321,3,2321,19],\"els\":[\"0:2815\"]},{\"tk\":[2321,20,2321,21],\"els\":[\"0:2815\"]},{\"tk\":[2321,21,2321,24],\"els\":[\"0:2815\"]},{\"tk\":[2321,24,2321,25],\"els\":[\"0:2815\"]},{\"tk\":[2321,26,2321,34],\"els\":[\"0:2815\"]},{\"tk\":[2321,34,2321,35],\"els\":[\"0:2815\"]},{\"tk\":[2321,36,2321,40],\"els\":[\"0:2815\"]},{\"tk\":[2321,40,2321,41],\"els\":[\"0:2815\"]},{\"tk\":[2321,41,2321,42],\"els\":[\"0:2815\"]},{\"tk\":[2324,3,2324,15],\"els\":[\"0:2815\"]},{\"tk\":[2324,16,2324,17],\"els\":[\"0:2815\"]},{\"tk\":[2324,17,2324,25],\"els\":[\"0:2815\"]},{\"tk\":[2324,25,2324,26],\"els\":[\"0:2815\"]},{\"tk\":[2324,27,2324,28],\"els\":[\"0:2815\"]},{\"tk\":[2324,28,2324,53],\"els\":[\"0:2815\"]},{\"tk\":[2324,53,2324,54],\"els\":[\"0:2815\"]},{\"tk\":[2324,55,2324,56],\"els\":[\"0:2815\"]},{\"tk\":[2324,56,2324,71],\"els\":[\"0:2815\"]},{\"tk\":[2324,71,2324,72],\"els\":[\"0:2815\"]},{\"tk\":[2324,72,2324,73],\"els\":[\"0:2815\"]},{\"tk\":[2325,3,2325,18],\"els\":[\"0:2815\"]},{\"tk\":[2325,19,2325,20],\"els\":[\"0:2815\"]},{\"tk\":[2325,20,2325,28],\"els\":[\"0:2815\"]},{\"tk\":[2325,28,2325,29],\"els\":[\"0:2815\"]},{\"tk\":[2325,30,2325,31],\"els\":[\"0:2815\"]},{\"tk\":[2325,31,2325,55],\"els\":[\"0:2815\"]},{\"tk\":[2325,55,2325,56],\"els\":[\"0:2815\"]},{\"tk\":[2325,56,2325,57],\"els\":[\"0:2815\"]},{\"tk\":[2326,3,2326,27],\"els\":[\"0:2815\"]},{\"tk\":[2326,27,2326,28],\"els\":[\"0:2815\"]},{\"tk\":[2326,28,2326,32],\"els\":[\"0:2815\"]},{\"tk\":[2326,32,2326,33],\"els\":[\"0:2815\"]},{\"tk\":[2326,34,2326,35],\"els\":[\"0:2815\"]},{\"tk\":[2326,35,2326,36],\"els\":[\"0:2815\"]},{\"tk\":[2326,37,2326,42],\"els\":[\"0:2815\"]},{\"tk\":[2326,42,2326,43],\"els\":[\"0:2815\"]},{\"tk\":[2326,43,2326,44],\"els\":[\"0:2815\"]},{\"tk\":[2329,3,2329,4],\"els\":[\"0:2811\"]},{\"tk\":[2330,5,2330,10],\"els\":[\"0:2811\"]},{\"tk\":[2330,11,2330,33],\"els\":[\"0:2811\"]},{\"tk\":[2330,34,2330,42],\"els\":[\"0:2811\"]},{\"tk\":[2330,43,2330,44],\"els\":[\"0:2811\"]},{\"tk\":[2330,45,2330,46],\"els\":[\"0:2811\"]},{\"tk\":[2331,7,2331,8],\"els\":[\"0:2811\"]},{\"tk\":[2331,8,2331,19],\"els\":[\"0:2811\"]},{\"tk\":[2331,20,2331,21],\"els\":[\"0:2811\"]},{\"tk\":[2331,22,2331,38],\"els\":[\"0:2811\"]},{\"tk\":[2331,38,2331,39],\"els\":[\"0:2811\"]},{\"tk\":[2332,7,2332,8],\"els\":[\"0:2811\"]},{\"tk\":[2332,8,2332,18],\"els\":[\"0:2811\"]},{\"tk\":[2332,19,2332,20],\"els\":[\"0:2811\"]},{\"tk\":[2332,21,2332,23],\"els\":[\"0:2811\"]},{\"tk\":[2332,23,2332,24],\"els\":[\"0:2811\"]},{\"tk\":[2333,7,2333,8],\"els\":[\"0:2811\"]},{\"tk\":[2333,8,2333,18],\"els\":[\"0:2811\"]},{\"tk\":[2333,19,2333,20],\"els\":[\"0:2811\"]},{\"tk\":[2333,21,2333,41],\"els\":[\"0:2811\"]},{\"tk\":[2333,41,2333,42],\"els\":[\"0:2811\"]},{\"tk\":[2334,7,2334,8],\"els\":[\"0:2811\"]},{\"tk\":[2334,8,2334,18],\"els\":[\"0:2811\"]},{\"tk\":[2334,19,2334,20],\"els\":[\"0:2811\"]},{\"tk\":[2334,21,2334,34],\"els\":[\"0:2811\"]},{\"tk\":[2334,34,2334,35],\"els\":[\"0:2811\"]},{\"tk\":[2335,7,2335,8],\"els\":[\"0:2811\"]},{\"tk\":[2335,8,2335,15],\"els\":[\"0:2811\"]},{\"tk\":[2335,16,2335,17],\"els\":[\"0:2811\"]},{\"tk\":[2335,18,2335,38],\"els\":[\"0:2811\"]},{\"tk\":[2335,38,2335,39],\"els\":[\"0:2811\"]},{\"tk\":[2336,7,2336,8],\"els\":[\"0:2811\"]},{\"tk\":[2336,8,2336,21],\"els\":[\"0:2811\"]},{\"tk\":[2336,22,2336,23],\"els\":[\"0:2811\"]},{\"tk\":[2336,24,2336,46],\"els\":[\"0:2811\"]},{\"tk\":[2336,46,2336,47],\"els\":[\"0:2811\"]},{\"tk\":[2337,7,2337,8],\"els\":[\"0:2811\"]},{\"tk\":[2337,8,2337,18],\"els\":[\"0:2811\"]},{\"tk\":[2337,19,2337,20],\"els\":[\"0:2811\"]},{\"tk\":[2337,21,2337,43],\"els\":[\"0:2811\"]},{\"tk\":[2337,43,2337,44],\"els\":[\"0:2811\"]},{\"tk\":[2338,7,2338,8],\"els\":[\"0:2811\"]},{\"tk\":[2338,8,2338,17],\"els\":[\"0:2811\"]},{\"tk\":[2338,18,2338,19],\"els\":[\"0:2811\"]},{\"tk\":[2338,20,2338,24],\"els\":[\"0:2811\"]},{\"tk\":[2338,24,2338,25],\"els\":[\"0:2811\"]},{\"tk\":[2339,7,2339,8],\"els\":[\"0:2811\"]},{\"tk\":[2339,8,2339,18],\"els\":[\"0:2811\"]},{\"tk\":[2339,19,2339,20],\"els\":[\"0:2811\"]},{\"tk\":[2339,21,2339,40],\"els\":[\"0:2811\"]},{\"tk\":[2339,40,2339,41],\"els\":[\"0:2811\"]},{\"tk\":[2340,7,2340,8],\"els\":[\"0:2811\"]},{\"tk\":[2340,8,2340,28],\"els\":[\"0:2811\"]},{\"tk\":[2340,29,2340,30],\"els\":[\"0:2811\"]},{\"tk\":[2340,31,2340,36],\"els\":[\"0:2811\"]},{\"tk\":[2340,36,2340,37],\"els\":[\"0:2811\"]},{\"tk\":[2341,7,2341,8],\"els\":[\"0:2811\"]},{\"tk\":[2341,8,2341,30],\"els\":[\"0:2811\"]},{\"tk\":[2341,31,2341,32],\"els\":[\"0:2811\"]},{\"tk\":[2341,33,2341,38],\"els\":[\"0:2811\"]},{\"tk\":[2342,5,2342,6],\"els\":[\"0:2811\"]},{\"tk\":[2342,6,2342,7],\"els\":[\"0:2811\"]},{\"tk\":[2344,5,2344,10],\"els\":[\"0:2811\"]},{\"tk\":[2344,11,2344,31],\"els\":[\"0:2811\"]},{\"tk\":[2344,32,2344,44],\"els\":[\"0:2811\"]},{\"tk\":[2344,45,2344,46],\"els\":[\"0:2811\"]},{\"tk\":[2344,47,2344,48],\"els\":[\"0:2811\"]},{\"tk\":[2345,7,2345,8],\"els\":[\"0:2811\"]},{\"tk\":[2345,8,2345,21],\"els\":[\"0:2811\"]},{\"tk\":[2345,22,2345,23],\"els\":[\"0:2811\"]},{\"tk\":[2345,24,2345,29],\"els\":[\"0:2811\"]},{\"tk\":[2345,29,2345,30],\"els\":[\"0:2811\"]},{\"tk\":[2346,7,2346,8],\"els\":[\"0:2811\"]},{\"tk\":[2346,8,2346,32],\"els\":[\"0:2811\"]},{\"tk\":[2346,33,2346,34],\"els\":[\"0:2811\"]},{\"tk\":[2346,35,2346,40],\"els\":[\"0:2811\"]},{\"tk\":[2346,40,2346,41],\"els\":[\"0:2811\"]},{\"tk\":[2347,7,2347,8],\"els\":[\"0:2811\"]},{\"tk\":[2347,8,2347,30],\"els\":[\"0:2811\"]},{\"tk\":[2347,31,2347,32],\"els\":[\"0:2811\"]},{\"tk\":[2347,33,2347,38],\"els\":[\"0:2811\"]},{\"tk\":[2347,38,2347,39],\"els\":[\"0:2811\"]},{\"tk\":[2348,7,2348,8],\"els\":[\"0:2811\"]},{\"tk\":[2348,8,2348,16],\"els\":[\"0:2811\"]},{\"tk\":[2348,17,2348,18],\"els\":[\"0:2811\"]},{\"tk\":[2348,19,2348,20],\"els\":[\"0:2811\"]},{\"tk\":[2348,20,2348,21],\"els\":[\"0:2811\"]},{\"tk\":[2349,7,2349,8],\"els\":[\"0:2811\"]},{\"tk\":[2349,8,2349,16],\"els\":[\"0:2811\"]},{\"tk\":[2349,17,2349,18],\"els\":[\"0:2811\"]},{\"tk\":[2349,19,2349,20],\"els\":[\"0:2811\"]},{\"tk\":[2350,5,2350,6],\"els\":[\"0:2811\"]},{\"tk\":[2350,6,2350,7],\"els\":[\"0:2811\"]},{\"tk\":[2352,5,2352,10],\"els\":[\"0:2811\"]},{\"tk\":[2352,11,2352,31],\"els\":[\"0:2811\"]},{\"tk\":[2352,32,2352,45],\"els\":[\"0:2811\"]},{\"tk\":[2352,46,2352,47],\"els\":[\"0:2811\"]},{\"tk\":[2352,48,2352,49],\"els\":[\"0:2811\"]},{\"tk\":[2353,7,2353,8],\"els\":[\"0:2811\"]},{\"tk\":[2353,8,2353,19],\"els\":[\"0:2811\"]},{\"tk\":[2353,20,2353,21],\"els\":[\"0:2811\"]},{\"tk\":[2353,22,2353,27],\"els\":[\"0:2811\"]},{\"tk\":[2353,27,2353,28],\"els\":[\"0:2811\"]},{\"tk\":[2354,7,2354,8],\"els\":[\"0:2811\"]},{\"tk\":[2354,8,2354,17],\"els\":[\"0:2811\"]},{\"tk\":[2354,18,2354,19],\"els\":[\"0:2811\"]},{\"tk\":[2354,20,2354,33],\"els\":[\"0:2811\"]},{\"tk\":[2355,5,2355,6],\"els\":[\"0:2811\"]},{\"tk\":[2355,6,2355,7],\"els\":[\"0:2811\"]},{\"tk\":[2358,5,2358,21],\"els\":[\"0:2811\"]},{\"tk\":[2358,21,2358,22],\"els\":[\"0:2811\"]},{\"tk\":[2358,22,2358,25],\"els\":[\"0:2811\"]},{\"tk\":[2358,25,2358,26],\"els\":[\"0:2811\"]},{\"tk\":[2358,27,2358,41],\"els\":[\"0:2811\"]},{\"tk\":[2358,41,2358,42],\"els\":[\"0:2811\"]},{\"tk\":[2358,43,2358,48],\"els\":[\"0:2811\"]},{\"tk\":[2358,48,2358,49],\"els\":[\"0:2811\"]},{\"tk\":[2358,49,2358,50],\"els\":[\"0:2811\"]},{\"tk\":[2361,5,2361,34],\"els\":[\"0:2811\"]},{\"tk\":[2361,34,2361,35],\"els\":[\"0:2811\"]},{\"tk\":[2361,35,2361,38],\"els\":[\"0:2811\"]},{\"tk\":[2361,38,2361,39],\"els\":[\"0:2811\"]},{\"tk\":[2361,40,2361,54],\"els\":[\"0:2811\"]},{\"tk\":[2361,54,2361,55],\"els\":[\"0:2811\"]},{\"tk\":[2361,56,2361,60],\"els\":[\"0:2811\"]},{\"tk\":[2361,60,2361,61],\"els\":[\"0:2811\"]},{\"tk\":[2361,62,2361,74],\"els\":[\"0:2811\"]},{\"tk\":[2361,74,2361,75],\"els\":[\"0:2811\"]},{\"tk\":[2361,76,2361,77],\"els\":[\"0:2811\"]},{\"tk\":[2361,77,2361,78],\"els\":[\"0:2811\"]},{\"tk\":[2361,79,2361,80],\"els\":[\"0:2811\"]},{\"tk\":[2361,80,2361,81],\"els\":[\"0:2811\"]},{\"tk\":[2361,81,2361,82],\"els\":[\"0:2811\"]},{\"tk\":[2364,5,2364,21],\"els\":[\"0:2811\"]},{\"tk\":[2364,21,2364,22],\"els\":[\"0:2811\"]},{\"tk\":[2364,22,2364,25],\"els\":[\"0:2811\"]},{\"tk\":[2364,25,2364,26],\"els\":[\"0:2811\"]},{\"tk\":[2364,27,2364,41],\"els\":[\"0:2811\"]},{\"tk\":[2364,41,2364,42],\"els\":[\"0:2811\"]},{\"tk\":[2364,43,2364,47],\"els\":[\"0:2811\"]},{\"tk\":[2364,47,2364,48],\"els\":[\"0:2811\"]},{\"tk\":[2364,48,2364,49],\"els\":[\"0:2811\"]},{\"tk\":[2365,5,2365,18],\"els\":[\"0:2811\"]},{\"tk\":[2365,18,2365,19],\"els\":[\"0:2811\"]},{\"tk\":[2365,19,2365,20],\"els\":[\"0:2811\"]},{\"tk\":[2365,20,2365,21],\"els\":[\"0:2811\"]},{\"tk\":[2365,21,2365,22],\"els\":[\"0:2811\"]},{\"tk\":[2368,5,2368,28],\"els\":[\"0:2811\"]},{\"tk\":[2368,28,2368,29],\"els\":[\"0:2811\"]},{\"tk\":[2368,29,2368,30],\"els\":[\"0:2811\"]},{\"tk\":[2368,30,2368,31],\"els\":[\"0:2811\"]},{\"tk\":[2368,32,2368,33],\"els\":[\"0:2811\"]},{\"tk\":[2368,33,2368,41],\"els\":[\"0:2811\"]},{\"tk\":[2368,41,2368,42],\"els\":[\"0:2811\"]},{\"tk\":[2368,42,2368,43],\"els\":[\"0:2811\"]},{\"tk\":[2369,5,2369,28],\"els\":[\"0:2811\"]},{\"tk\":[2369,28,2369,29],\"els\":[\"0:2811\"]},{\"tk\":[2369,29,2369,30],\"els\":[\"0:2811\"]},{\"tk\":[2369,30,2369,31],\"els\":[\"0:2811\"]},{\"tk\":[2369,31,2369,57],\"els\":[\"0:2811\"]},{\"tk\":[2369,57,2369,58],\"els\":[\"0:2811\"]},{\"tk\":[2369,58,2369,59],\"els\":[\"0:2811\"]},{\"tk\":[2370,5,2370,28],\"els\":[\"0:2811\"]},{\"tk\":[2370,28,2370,29],\"els\":[\"0:2811\"]},{\"tk\":[2370,29,2370,30],\"els\":[\"0:2811\"]},{\"tk\":[2370,30,2370,31],\"els\":[\"0:2811\"]},{\"tk\":[2370,32,2370,33],\"els\":[\"0:2811\"]},{\"tk\":[2370,33,2370,45],\"els\":[\"0:2811\"]},{\"tk\":[2370,45,2370,46],\"els\":[\"0:2811\"]},{\"tk\":[2370,46,2370,47],\"els\":[\"0:2811\"]},{\"tk\":[2371,5,2371,28],\"els\":[\"0:2811\"]},{\"tk\":[2371,28,2371,29],\"els\":[\"0:2811\"]},{\"tk\":[2371,29,2371,30],\"els\":[\"0:2811\"]},{\"tk\":[2371,30,2371,31],\"els\":[\"0:2811\"]},{\"tk\":[2371,32,2371,33],\"els\":[\"0:2811\"]},{\"tk\":[2371,33,2371,46],\"els\":[\"0:2811\"]},{\"tk\":[2371,46,2371,47],\"els\":[\"0:2811\"]},{\"tk\":[2371,47,2371,48],\"els\":[\"0:2811\"]},{\"tk\":[2374,5,2374,28],\"els\":[\"0:2811\"]},{\"tk\":[2374,28,2374,29],\"els\":[\"0:2811\"]},{\"tk\":[2374,29,2374,30],\"els\":[\"0:2811\"]},{\"tk\":[2374,30,2374,31],\"els\":[\"0:2811\"]},{\"tk\":[2374,31,2374,32],\"els\":[\"0:2811\"]},{\"tk\":[2375,3,2375,4],\"els\":[\"0:2811\"]},{\"tk\":[2380,3,2380,35],\"els\":[\"0:2717\"]},{\"tk\":[2380,35,2380,36],\"els\":[\"0:2717\"]},{\"tk\":[2380,36,2380,37],\"els\":[\"0:2717\"]},{\"tk\":[2380,37,2380,38],\"els\":[\"0:2717\"]},{\"tk\":[2380,39,2380,56],\"els\":[\"0:2717\"]},{\"tk\":[2380,56,2380,57],\"els\":[\"0:2717\"]},{\"tk\":[2380,58,2380,59],\"els\":[\"0:2717\"]},{\"tk\":[2380,59,2380,63],\"els\":[\"0:2717\"]},{\"tk\":[2380,64,2380,65],\"els\":[\"0:2717\"]},{\"tk\":[2380,65,2380,66],\"els\":[\"0:2717\"]},{\"tk\":[2380,66,2380,67],\"els\":[\"0:2717\"]},{\"tk\":[2380,67,2380,68],\"els\":[\"0:2717\"]},{\"tk\":[2380,68,2380,69],\"els\":[\"0:2717\"]},{\"tk\":[2386,3,2386,4],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,5,2388,21],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,21,2388,22],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,22,2388,25],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,25,2388,26],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,27,2388,42],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,42,2388,43],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,44,2388,48],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,48,2388,49],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2388,49,2388,50],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2391,5,2391,10],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2391,11,2391,32],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2391,33,2391,47],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2391,48,2391,49],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2391,50,2391,51],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2392,7,2392,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2392,8,2392,12],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2392,13,2392,14],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2392,15,2392,20],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2392,20,2392,21],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2393,7,2393,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2393,8,2393,18],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2393,19,2393,20],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2393,21,2393,23],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2393,23,2393,24],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2394,7,2394,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2394,8,2394,18],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2394,19,2394,20],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2394,21,2394,51],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2394,51,2394,52],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2395,7,2395,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2395,8,2395,21],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2395,22,2395,23],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2395,24,2395,29],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2395,29,2395,30],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2396,7,2396,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2396,8,2396,19],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2396,20,2396,21],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2396,22,2396,45],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2396,45,2396,46],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2397,7,2397,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2397,8,2397,11],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2397,12,2397,13],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2397,14,2397,30],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2397,30,2397,31],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2398,7,2398,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2398,8,2398,15],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2398,16,2398,17],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2398,18,2398,23],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2398,23,2398,24],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2399,7,2399,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2399,8,2399,17],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2399,18,2399,19],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2399,20,2399,41],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2399,41,2399,42],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2400,7,2400,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2400,8,2400,20],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2400,21,2400,22],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2400,23,2400,27],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2400,27,2400,28],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2401,7,2401,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2401,8,2401,16],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2401,17,2401,18],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2401,19,2401,22],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2401,22,2401,23],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2402,7,2402,8],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2402,8,2402,17],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2402,18,2402,19],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2402,20,2402,40],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2402,40,2402,41],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2403,5,2403,6],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2403,6,2403,7],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,5,2406,18],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,18,2406,19],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,19,2406,20],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,20,2406,21],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,22,2406,23],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,23,2406,37],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,37,2406,38],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2406,38,2406,39],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2407,3,2407,4],\"els\":[\"0:2777\",\"0:3\",\"0:1\"]},{\"tk\":[2410,3,2410,4],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,5,2412,21],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,21,2412,22],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,22,2412,25],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,25,2412,26],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,27,2412,42],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,42,2412,43],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,44,2412,48],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,48,2412,49],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2412,49,2412,50],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2415,5,2415,10],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2415,11,2415,32],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2415,33,2415,46],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2415,47,2415,48],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2415,49,2415,50],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2416,7,2416,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2416,8,2416,12],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2416,13,2416,14],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2416,15,2416,20],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2416,20,2416,21],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2417,7,2417,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2417,8,2417,18],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2417,19,2417,20],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2417,21,2417,22],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2417,22,2417,23],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2418,7,2418,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2418,8,2418,18],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2418,19,2418,20],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2418,21,2418,51],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2418,51,2418,52],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2419,7,2419,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2419,8,2419,21],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2419,22,2419,23],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2419,24,2419,29],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2419,29,2419,30],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2420,7,2420,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2420,8,2420,19],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2420,20,2420,21],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2420,22,2420,45],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2420,45,2420,46],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2421,7,2421,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2421,8,2421,11],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2421,12,2421,13],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2421,14,2421,30],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2421,30,2421,31],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2422,7,2422,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2422,8,2422,15],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2422,16,2422,17],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2422,18,2422,23],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2422,23,2422,24],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2423,7,2423,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2423,8,2423,17],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2423,18,2423,19],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2423,20,2423,41],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2423,41,2423,42],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2424,7,2424,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2424,8,2424,20],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2424,21,2424,22],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2424,23,2424,27],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2424,27,2424,28],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2425,7,2425,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2425,8,2425,16],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2425,17,2425,18],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2425,19,2425,22],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2425,22,2425,23],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2426,7,2426,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2426,8,2426,17],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2426,18,2426,19],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2426,20,2426,41],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2426,41,2426,42],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2427,7,2427,8],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2427,8,2427,17],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2427,18,2427,19],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2427,20,2427,22],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2428,5,2428,6],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2428,6,2428,7],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,5,2431,18],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,18,2431,19],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,19,2431,20],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,20,2431,21],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,22,2431,23],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,23,2431,36],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,36,2431,37],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2431,37,2431,38],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2432,3,2432,4],\"els\":[\"0:3225\",\"0:3\",\"0:1\"]},{\"tk\":[2435,3,2435,4],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,5,2437,21],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,21,2437,22],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,22,2437,25],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,25,2437,26],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,27,2437,42],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,42,2437,43],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,44,2437,48],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,48,2437,49],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2437,49,2437,50],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2440,5,2440,10],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2440,11,2440,32],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2440,33,2440,46],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2440,47,2440,48],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2440,49,2440,50],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2441,7,2441,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2441,8,2441,12],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2441,13,2441,14],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2441,15,2441,20],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2441,20,2441,21],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2442,7,2442,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2442,8,2442,18],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2442,19,2442,20],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2442,21,2442,22],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2442,22,2442,23],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2443,7,2443,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2443,8,2443,18],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2443,19,2443,20],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2443,21,2443,51],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2443,51,2443,52],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2444,7,2444,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2444,8,2444,21],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2444,22,2444,23],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2444,24,2444,29],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2444,29,2444,30],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2445,7,2445,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2445,8,2445,19],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2445,20,2445,21],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2445,22,2445,45],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2445,45,2445,46],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2446,7,2446,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2446,8,2446,11],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2446,12,2446,13],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2446,14,2446,30],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2446,30,2446,31],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2447,7,2447,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2447,8,2447,15],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2447,16,2447,17],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2447,18,2447,23],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2447,23,2447,24],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2448,7,2448,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2448,8,2448,17],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2448,18,2448,19],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2448,20,2448,41],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2448,41,2448,42],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2449,7,2449,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2449,8,2449,20],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2449,21,2449,22],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2449,23,2449,27],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2449,27,2449,28],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2450,7,2450,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2450,8,2450,16],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2450,17,2450,18],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2450,19,2450,22],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2450,22,2450,23],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2451,7,2451,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2451,8,2451,17],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2451,18,2451,19],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2451,20,2451,41],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2451,41,2451,42],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2452,7,2452,8],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2452,8,2452,17],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2452,18,2452,19],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2452,20,2452,22],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2453,5,2453,6],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2453,6,2453,7],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,5,2456,18],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,18,2456,19],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,19,2456,20],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,20,2456,21],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,22,2456,23],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,23,2456,36],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,36,2456,37],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2456,37,2456,38],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2457,3,2457,4],\"els\":[\"0:3226\",\"0:3\",\"0:1\"]},{\"tk\":[2460,3,2460,4],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,5,2462,21],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,21,2462,22],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,22,2462,25],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,25,2462,26],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,27,2462,42],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,42,2462,43],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,44,2462,48],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,48,2462,49],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2462,49,2462,50],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2465,5,2465,10],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2465,11,2465,32],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2465,33,2465,47],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2465,48,2465,49],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2465,50,2465,51],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2466,7,2466,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2466,8,2466,12],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2466,13,2466,14],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2466,15,2466,20],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2466,20,2466,21],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2467,7,2467,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2467,8,2467,18],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2467,19,2467,20],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2467,21,2467,23],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2467,23,2467,24],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2468,7,2468,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2468,8,2468,18],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2468,19,2468,20],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2468,21,2468,51],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2468,51,2468,52],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2469,7,2469,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2469,8,2469,21],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2469,22,2469,23],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2469,24,2469,29],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2469,29,2469,30],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2470,7,2470,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2470,8,2470,19],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2470,20,2470,21],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2470,22,2470,45],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2470,45,2470,46],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2471,7,2471,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2471,8,2471,11],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2471,12,2471,13],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2471,14,2471,30],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2471,30,2471,31],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2472,7,2472,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2472,8,2472,15],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2472,16,2472,17],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2472,18,2472,23],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2472,23,2472,24],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2473,7,2473,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2473,8,2473,17],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2473,18,2473,19],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2473,20,2473,41],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2473,41,2473,42],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2474,7,2474,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2474,8,2474,20],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2474,21,2474,22],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2474,23,2474,27],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2474,27,2474,28],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2475,7,2475,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2475,8,2475,16],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2475,17,2475,18],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2475,19,2475,22],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2475,22,2475,23],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2476,7,2476,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2476,8,2476,17],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2476,18,2476,19],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2476,20,2476,41],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2476,41,2476,42],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2477,7,2477,8],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2477,8,2477,17],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2477,18,2477,19],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2477,20,2477,22],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2478,5,2478,6],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2478,6,2478,7],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,5,2481,18],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,18,2481,19],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,19,2481,20],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,20,2481,21],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,22,2481,23],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,23,2481,37],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,37,2481,38],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2481,38,2481,39],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2482,3,2482,4],\"els\":[\"0:3227\",\"0:3\",\"0:1\"]},{\"tk\":[2485,3,2485,4],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,5,2487,21],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,21,2487,22],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,22,2487,25],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,25,2487,26],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,27,2487,42],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,42,2487,43],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,44,2487,48],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,48,2487,49],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2487,49,2487,50],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2490,5,2490,10],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2490,11,2490,32],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2490,33,2490,46],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2490,47,2490,48],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2490,49,2490,50],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2491,7,2491,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2491,8,2491,12],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2491,13,2491,14],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2491,15,2491,20],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2491,20,2491,21],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2492,7,2492,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2492,8,2492,18],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2492,19,2492,20],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2492,21,2492,22],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2492,22,2492,23],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2493,7,2493,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2493,8,2493,18],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2493,19,2493,20],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2493,21,2493,51],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2493,51,2493,52],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2494,7,2494,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2494,8,2494,21],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2494,22,2494,23],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2494,24,2494,29],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2494,29,2494,30],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2495,7,2495,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2495,8,2495,19],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2495,20,2495,21],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2495,22,2495,45],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2495,45,2495,46],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2496,7,2496,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2496,8,2496,11],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2496,12,2496,13],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2496,14,2496,30],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2496,30,2496,31],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2497,7,2497,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2497,8,2497,15],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2497,16,2497,17],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2497,18,2497,23],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2497,23,2497,24],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2498,7,2498,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2498,8,2498,17],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2498,18,2498,19],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2498,20,2498,41],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2498,41,2498,42],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2499,7,2499,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2499,8,2499,20],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2499,21,2499,22],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2499,23,2499,27],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2499,27,2499,28],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2500,7,2500,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2500,8,2500,16],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2500,17,2500,18],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2500,19,2500,22],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2500,22,2500,23],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2501,7,2501,8],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2501,8,2501,17],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2501,18,2501,19],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2501,20,2501,40],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2501,40,2501,41],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2502,5,2502,6],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2502,6,2502,7],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,5,2505,18],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,18,2505,19],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,19,2505,20],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,20,2505,21],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,22,2505,23],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,23,2505,36],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,36,2505,37],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2505,37,2505,38],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2506,3,2506,4],\"els\":[\"0:2781\",\"0:3\",\"0:1\"]},{\"tk\":[2509,3,2509,4],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,5,2511,21],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,21,2511,22],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,22,2511,25],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,25,2511,26],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,27,2511,42],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,42,2511,43],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,44,2511,48],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,48,2511,49],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2511,49,2511,50],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2514,5,2514,10],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2514,11,2514,32],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2514,33,2514,46],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2514,47,2514,48],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2514,49,2514,50],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2515,7,2515,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2515,8,2515,12],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2515,13,2515,14],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2515,15,2515,20],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2515,20,2515,21],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2516,7,2516,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2516,8,2516,18],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2516,19,2516,20],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2516,21,2516,22],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2516,22,2516,23],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2517,7,2517,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2517,8,2517,18],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2517,19,2517,20],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2517,21,2517,51],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2517,51,2517,52],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2518,7,2518,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2518,8,2518,21],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2518,22,2518,23],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2518,24,2518,29],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2518,29,2518,30],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2519,7,2519,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2519,8,2519,19],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2519,20,2519,21],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2519,22,2519,45],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2519,45,2519,46],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2520,7,2520,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2520,8,2520,11],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2520,12,2520,13],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2520,14,2520,30],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2520,30,2520,31],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2521,7,2521,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2521,8,2521,15],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2521,16,2521,17],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2521,18,2521,23],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2521,23,2521,24],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2522,7,2522,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2522,8,2522,17],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2522,18,2522,19],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2522,20,2522,41],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2522,41,2522,42],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2523,7,2523,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2523,8,2523,20],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2523,21,2523,22],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2523,23,2523,27],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2523,27,2523,28],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2524,7,2524,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2524,8,2524,16],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2524,17,2524,18],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2524,19,2524,22],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2524,22,2524,23],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2525,7,2525,8],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2525,8,2525,17],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2525,18,2525,19],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2525,20,2525,40],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2525,40,2525,41],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2526,5,2526,6],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2526,6,2526,7],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,5,2529,18],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,18,2529,19],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,19,2529,20],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,20,2529,21],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,22,2529,23],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,23,2529,36],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,36,2529,37],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2529,37,2529,38],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2530,3,2530,4],\"els\":[\"0:2782\",\"0:3\",\"0:1\"]},{\"tk\":[2533,3,2533,4],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,5,2535,21],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,21,2535,22],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,22,2535,25],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,25,2535,26],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,27,2535,42],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,42,2535,43],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,44,2535,48],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,48,2535,49],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2535,49,2535,50],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2538,5,2538,10],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2538,11,2538,32],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2538,33,2538,46],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2538,47,2538,48],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2538,49,2538,50],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2539,7,2539,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2539,8,2539,12],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2539,13,2539,14],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2539,15,2539,20],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2539,20,2539,21],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2540,7,2540,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2540,8,2540,18],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2540,19,2540,20],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2540,21,2540,22],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2540,22,2540,23],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2541,7,2541,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2541,8,2541,18],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2541,19,2541,20],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2541,21,2541,51],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2541,51,2541,52],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2542,7,2542,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2542,8,2542,21],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2542,22,2542,23],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2542,24,2542,29],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2542,29,2542,30],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2543,7,2543,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2543,8,2543,19],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2543,20,2543,21],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2543,22,2543,45],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2543,45,2543,46],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2544,7,2544,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2544,8,2544,11],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2544,12,2544,13],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2544,14,2544,30],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2544,30,2544,31],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2545,7,2545,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2545,8,2545,15],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2545,16,2545,17],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2545,18,2545,23],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2545,23,2545,24],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2546,7,2546,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2546,8,2546,17],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2546,18,2546,19],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2546,20,2546,41],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2546,41,2546,42],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2547,7,2547,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2547,8,2547,20],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2547,21,2547,22],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2547,23,2547,27],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2547,27,2547,28],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2548,7,2548,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2548,8,2548,16],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2548,17,2548,18],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2548,19,2548,22],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2548,22,2548,23],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2549,7,2549,8],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2549,8,2549,17],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2549,18,2549,19],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2549,20,2549,40],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2549,40,2549,41],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2550,5,2550,6],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2550,6,2550,7],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,5,2553,18],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,18,2553,19],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,19,2553,20],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,20,2553,21],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,22,2553,23],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,23,2553,36],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,36,2553,37],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2553,37,2553,38],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2554,3,2554,4],\"els\":[\"0:2783\",\"0:3\",\"0:1\"]},{\"tk\":[2557,3,2557,4],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,5,2559,21],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,21,2559,22],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,22,2559,25],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,25,2559,26],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,27,2559,42],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,42,2559,43],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,44,2559,48],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,48,2559,49],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2559,49,2559,50],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2562,5,2562,10],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2562,11,2562,32],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2562,33,2562,46],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2562,47,2562,48],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2562,49,2562,50],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2563,7,2563,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2563,8,2563,12],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2563,13,2563,14],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2563,15,2563,20],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2563,20,2563,21],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2564,7,2564,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2564,8,2564,18],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2564,19,2564,20],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2564,21,2564,22],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2564,22,2564,23],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2565,7,2565,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2565,8,2565,18],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2565,19,2565,20],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2565,21,2565,51],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2565,51,2565,52],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2566,7,2566,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2566,8,2566,21],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2566,22,2566,23],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2566,24,2566,29],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2566,29,2566,30],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2567,7,2567,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2567,8,2567,19],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2567,20,2567,21],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2567,22,2567,45],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2567,45,2567,46],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2568,7,2568,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2568,8,2568,11],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2568,12,2568,13],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2568,14,2568,30],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2568,30,2568,31],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2569,7,2569,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2569,8,2569,15],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2569,16,2569,17],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2569,18,2569,23],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2569,23,2569,24],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2570,7,2570,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2570,8,2570,17],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2570,18,2570,19],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2570,20,2570,41],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2570,41,2570,42],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2571,7,2571,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2571,8,2571,20],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2571,21,2571,22],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2571,23,2571,27],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2571,27,2571,28],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2572,7,2572,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2572,8,2572,16],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2572,17,2572,18],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2572,19,2572,22],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2572,22,2572,23],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2573,7,2573,8],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2573,8,2573,17],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2573,18,2573,19],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2573,20,2573,40],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2573,40,2573,41],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2574,5,2574,6],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2574,6,2574,7],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,5,2577,18],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,18,2577,19],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,19,2577,20],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,20,2577,21],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,22,2577,23],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,23,2577,36],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,36,2577,37],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2577,37,2577,38],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2578,3,2578,4],\"els\":[\"0:2784\",\"0:3\",\"0:1\"]},{\"tk\":[2581,3,2581,4],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,5,2583,21],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,21,2583,22],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,22,2583,25],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,25,2583,26],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,27,2583,42],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,42,2583,43],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,44,2583,48],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,48,2583,49],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2583,49,2583,50],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2586,5,2586,10],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2586,11,2586,32],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2586,33,2586,47],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2586,48,2586,49],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2586,50,2586,51],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2587,7,2587,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2587,8,2587,12],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2587,13,2587,14],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2587,15,2587,20],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2587,20,2587,21],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2588,7,2588,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2588,8,2588,18],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2588,19,2588,20],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2588,21,2588,23],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2588,23,2588,24],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2589,7,2589,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2589,8,2589,18],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2589,19,2589,20],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2589,21,2589,51],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2589,51,2589,52],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2590,7,2590,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2590,8,2590,21],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2590,22,2590,23],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2590,24,2590,29],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2590,29,2590,30],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2591,7,2591,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2591,8,2591,19],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2591,20,2591,21],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2591,22,2591,45],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2591,45,2591,46],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2592,7,2592,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2592,8,2592,11],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2592,12,2592,13],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2592,14,2592,30],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2592,30,2592,31],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2593,7,2593,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2593,8,2593,15],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2593,16,2593,17],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2593,18,2593,23],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2593,23,2593,24],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2594,7,2594,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2594,8,2594,17],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2594,18,2594,19],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2594,20,2594,41],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2594,41,2594,42],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2595,7,2595,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2595,8,2595,20],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2595,21,2595,22],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2595,23,2595,27],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2595,27,2595,28],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2596,7,2596,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2596,8,2596,16],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2596,17,2596,18],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2596,19,2596,22],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2596,22,2596,23],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2597,7,2597,8],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2597,8,2597,17],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2597,18,2597,19],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2597,20,2597,40],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2597,40,2597,41],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2598,5,2598,6],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2598,6,2598,7],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,5,2601,18],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,18,2601,19],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,19,2601,20],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,20,2601,21],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,22,2601,23],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,23,2601,37],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,37,2601,38],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2601,38,2601,39],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2602,3,2602,4],\"els\":[\"0:2785\",\"0:3\",\"0:1\"]},{\"tk\":[2605,3,2605,4],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,5,2607,21],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,21,2607,22],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,22,2607,25],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,25,2607,26],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,27,2607,42],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,42,2607,43],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,44,2607,48],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,48,2607,49],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2607,49,2607,50],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2610,5,2610,10],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2610,11,2610,32],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2610,33,2610,47],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2610,48,2610,49],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2610,50,2610,51],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2611,7,2611,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2611,8,2611,12],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2611,13,2611,14],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2611,15,2611,20],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2611,20,2611,21],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2612,7,2612,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2612,8,2612,18],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2612,19,2612,20],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2612,21,2612,23],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2612,23,2612,24],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2613,7,2613,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2613,8,2613,18],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2613,19,2613,20],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2613,21,2613,51],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2613,51,2613,52],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2614,7,2614,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2614,8,2614,21],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2614,22,2614,23],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2614,24,2614,29],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2614,29,2614,30],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2615,7,2615,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2615,8,2615,19],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2615,20,2615,21],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2615,22,2615,45],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2615,45,2615,46],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2616,7,2616,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2616,8,2616,11],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2616,12,2616,13],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2616,14,2616,30],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2616,30,2616,31],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2617,7,2617,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2617,8,2617,15],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2617,16,2617,17],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2617,18,2617,23],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2617,23,2617,24],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2618,7,2618,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2618,8,2618,17],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2618,18,2618,19],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2618,20,2618,41],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2618,41,2618,42],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2619,7,2619,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2619,8,2619,20],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2619,21,2619,22],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2619,23,2619,27],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2619,27,2619,28],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2620,7,2620,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2620,8,2620,16],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2620,17,2620,18],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2620,19,2620,22],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2620,22,2620,23],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2621,7,2621,8],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2621,8,2621,17],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2621,18,2621,19],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2621,20,2621,40],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2621,40,2621,41],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2622,5,2622,6],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2622,6,2622,7],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,5,2625,18],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,18,2625,19],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,19,2625,20],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,20,2625,21],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,22,2625,23],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,23,2625,37],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,37,2625,38],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2625,38,2625,39],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2626,3,2626,4],\"els\":[\"0:2786\",\"0:3\",\"0:1\"]},{\"tk\":[2629,3,2629,4],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,5,2631,21],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,21,2631,22],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,22,2631,25],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,25,2631,26],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,27,2631,42],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,42,2631,43],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,44,2631,48],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,48,2631,49],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2631,49,2631,50],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2634,5,2634,10],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2634,11,2634,32],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2634,33,2634,47],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2634,48,2634,49],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2634,50,2634,51],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2635,7,2635,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2635,8,2635,12],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2635,13,2635,14],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2635,15,2635,20],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2635,20,2635,21],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2636,7,2636,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2636,8,2636,18],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2636,19,2636,20],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2636,21,2636,23],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2636,23,2636,24],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2637,7,2637,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2637,8,2637,18],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2637,19,2637,20],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2637,21,2637,51],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2637,51,2637,52],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2638,7,2638,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2638,8,2638,21],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2638,22,2638,23],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2638,24,2638,29],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2638,29,2638,30],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2639,7,2639,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2639,8,2639,19],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2639,20,2639,21],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2639,22,2639,45],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2639,45,2639,46],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2640,7,2640,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2640,8,2640,11],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2640,12,2640,13],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2640,14,2640,30],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2640,30,2640,31],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2641,7,2641,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2641,8,2641,15],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2641,16,2641,17],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2641,18,2641,23],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2641,23,2641,24],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2642,7,2642,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2642,8,2642,17],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2642,18,2642,19],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2642,20,2642,41],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2642,41,2642,42],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2643,7,2643,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2643,8,2643,20],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2643,21,2643,22],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2643,23,2643,27],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2643,27,2643,28],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2644,7,2644,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2644,8,2644,16],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2644,17,2644,18],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2644,19,2644,22],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2644,22,2644,23],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2645,7,2645,8],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2645,8,2645,17],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2645,18,2645,19],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2645,20,2645,40],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2645,40,2645,41],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2646,5,2646,6],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2646,6,2646,7],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,5,2649,18],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,18,2649,19],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,19,2649,20],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,20,2649,21],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,22,2649,23],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,23,2649,37],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,37,2649,38],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2649,38,2649,39],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2650,3,2650,4],\"els\":[\"0:2787\",\"0:3\",\"0:1\"]},{\"tk\":[2653,3,2653,4],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,5,2655,21],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,21,2655,22],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,22,2655,25],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,25,2655,26],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,27,2655,42],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,42,2655,43],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,44,2655,48],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,48,2655,49],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2655,49,2655,50],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2658,5,2658,10],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2658,11,2658,32],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2658,33,2658,47],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2658,48,2658,49],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2658,50,2658,51],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2659,7,2659,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2659,8,2659,12],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2659,13,2659,14],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2659,15,2659,20],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2659,20,2659,21],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2660,7,2660,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2660,8,2660,18],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2660,19,2660,20],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2660,21,2660,23],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2660,23,2660,24],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2661,7,2661,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2661,8,2661,18],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2661,19,2661,20],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2661,21,2661,51],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2661,51,2661,52],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2662,7,2662,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2662,8,2662,21],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2662,22,2662,23],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2662,24,2662,29],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2662,29,2662,30],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2663,7,2663,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2663,8,2663,19],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2663,20,2663,21],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2663,22,2663,45],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2663,45,2663,46],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2664,7,2664,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2664,8,2664,11],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2664,12,2664,13],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2664,14,2664,30],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2664,30,2664,31],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2665,7,2665,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2665,8,2665,15],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2665,16,2665,17],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2665,18,2665,23],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2665,23,2665,24],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2666,7,2666,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2666,8,2666,17],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2666,18,2666,19],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2666,20,2666,41],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2666,41,2666,42],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2667,7,2667,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2667,8,2667,20],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2667,21,2667,22],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2667,23,2667,27],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2667,27,2667,28],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2668,7,2668,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2668,8,2668,16],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2668,17,2668,18],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2668,19,2668,22],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2668,22,2668,23],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2669,7,2669,8],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2669,8,2669,17],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2669,18,2669,19],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2669,20,2669,40],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2669,40,2669,41],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2670,5,2670,6],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2670,6,2670,7],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,5,2673,18],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,18,2673,19],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,19,2673,20],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,20,2673,21],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,22,2673,23],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,23,2673,37],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,37,2673,38],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2673,38,2673,39],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2674,3,2674,4],\"els\":[\"0:2788\",\"0:3\",\"0:1\"]},{\"tk\":[2677,3,2677,4],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2678,5,2678,22],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2678,23,2678,41],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2678,42,2678,43],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2678,44,2678,45],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2679,7,2679,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2680,9,2680,13],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2680,13,2680,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2681,9,2681,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2681,14,2681,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2682,9,2682,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2682,14,2682,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2683,9,2683,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2683,14,2683,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2684,9,2684,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2684,14,2684,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2685,9,2685,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2685,14,2685,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2686,9,2686,25],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2686,25,2686,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2687,9,2687,25],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2687,25,2687,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2688,9,2688,25],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2688,25,2688,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2689,9,2689,25],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2689,25,2689,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2690,9,2690,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2690,14,2690,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2691,9,2691,23],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2691,23,2691,24],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2692,7,2692,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2692,8,2692,9],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2693,7,2693,34],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2693,34,2693,35],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2694,7,2694,27],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2694,27,2694,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2695,7,2695,33],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2695,33,2695,34],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2696,7,2696,22],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2696,22,2696,23],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2697,7,2697,12],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2697,12,2697,13],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2698,7,2698,12],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2699,5,2699,6],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2699,6,2699,7],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2701,5,2701,29],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2701,30,2701,44],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2701,45,2701,46],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2701,47,2701,48],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2702,7,2702,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2702,28,2702,29],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2703,7,2703,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2703,8,2703,9],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2704,7,2704,12],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2704,12,2704,13],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2706,7,2706,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2707,9,2707,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2707,14,2707,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2708,9,2708,10],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2708,10,2708,11],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2709,9,2709,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2710,7,2710,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2710,8,2710,9],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2712,7,2712,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2713,9,2713,14],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2713,14,2713,15],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2714,9,2714,10],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2714,10,2714,11],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2715,9,2715,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2716,7,2716,8],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2717,5,2717,6],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2717,6,2717,7],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,5,2720,21],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,21,2720,22],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,22,2720,25],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,25,2720,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,27,2720,42],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,42,2720,43],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,44,2720,48],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,48,2720,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2720,49,2720,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,5,2723,23],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,23,2723,24],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,24,2723,29],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,29,2723,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,31,2723,33],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,33,2723,34],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,35,2723,48],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,48,2723,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2723,49,2723,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,5,2726,21],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,21,2726,22],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,22,2726,25],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,25,2726,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,27,2726,42],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,42,2726,43],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,44,2726,48],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,48,2726,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2726,49,2726,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,5,2729,23],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,23,2729,24],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,24,2729,29],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,29,2729,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,31,2729,33],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,33,2729,34],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,35,2729,48],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,48,2729,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2729,49,2729,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,5,2732,34],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,35,2732,36],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,36,2732,39],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,39,2732,40],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,41,2732,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,49,2732,50],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,51,2732,55],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,55,2732,56],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,57,2732,69],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,69,2732,70],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,71,2732,72],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,72,2732,73],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,74,2732,75],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,75,2732,76],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2732,76,2732,77],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,5,2735,21],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,22,2735,23],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,23,2735,26],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,26,2735,27],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,28,2735,36],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,36,2735,37],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,38,2735,42],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,42,2735,43],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2735,43,2735,44],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2738,5,2738,11],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2738,12,2738,23],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2738,24,2738,39],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2738,39,2738,40],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,5,2739,17],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,17,2739,18],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,18,2739,19],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,19,2739,20],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,21,2739,22],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,22,2739,40],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,40,2739,41],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,42,2739,43],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,43,2739,58],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,58,2739,59],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2739,59,2739,60],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,5,2742,28],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,28,2742,29],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,29,2742,30],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,30,2742,31],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,32,2742,33],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,33,2742,47],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,47,2742,48],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2742,48,2742,49],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2743,3,2743,4],\"els\":[\"0:2883\",\"0:3\",\"0:1\"]},{\"tk\":[2746,3,2746,4],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,5,2748,21],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,21,2748,22],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,22,2748,25],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,25,2748,26],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,27,2748,42],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,42,2748,43],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,44,2748,48],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,48,2748,49],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2748,49,2748,50],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2751,5,2751,10],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2751,11,2751,32],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2751,33,2751,47],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2751,48,2751,49],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2751,50,2751,51],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2752,7,2752,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2752,8,2752,12],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2752,13,2752,14],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2752,15,2752,20],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2752,20,2752,21],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2753,7,2753,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2753,8,2753,18],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2753,19,2753,20],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2753,21,2753,23],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2753,23,2753,24],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2754,7,2754,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2754,8,2754,18],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2754,19,2754,20],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2754,21,2754,51],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2754,51,2754,52],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2755,7,2755,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2755,8,2755,21],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2755,22,2755,23],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2755,24,2755,29],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2755,29,2755,30],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2756,7,2756,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2756,8,2756,19],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2756,20,2756,21],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2756,22,2756,45],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2756,45,2756,46],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2757,7,2757,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2757,8,2757,11],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2757,12,2757,13],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2757,14,2757,30],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2757,30,2757,31],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2758,7,2758,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2758,8,2758,15],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2758,16,2758,17],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2758,18,2758,23],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2758,23,2758,24],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2759,7,2759,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2759,8,2759,17],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2759,18,2759,19],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2759,20,2759,41],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2759,41,2759,42],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2760,7,2760,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2760,8,2760,20],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2760,21,2760,22],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2760,23,2760,27],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2760,27,2760,28],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2761,7,2761,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2761,8,2761,16],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2761,17,2761,18],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2761,19,2761,22],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2761,22,2761,23],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2762,7,2762,8],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2762,8,2762,17],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2762,18,2762,19],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2762,20,2762,40],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2762,40,2762,41],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2763,5,2763,6],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2763,6,2763,7],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,5,2766,18],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,18,2766,19],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,19,2766,20],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,20,2766,21],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,22,2766,23],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,23,2766,37],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,37,2766,38],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2766,38,2766,39],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2767,3,2767,4],\"els\":[\"0:2778\",\"0:3\",\"0:1\"]},{\"tk\":[2774,3,2774,19],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,20,2774,21],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,21,2774,24],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,24,2774,25],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,26,2774,41],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,41,2774,42],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,43,2774,47],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,47,2774,48],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2774,48,2774,49],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,3,2777,21],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,22,2777,23],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,23,2777,28],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,28,2777,29],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,30,2777,32],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,32,2777,33],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,34,2777,47],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,47,2777,48],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2777,48,2777,49],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,3,2780,32],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,33,2780,34],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,34,2780,37],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,37,2780,38],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,39,2780,47],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,47,2780,48],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,49,2780,53],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,53,2780,54],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,55,2780,67],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,67,2780,68],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,69,2780,70],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,70,2780,71],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,72,2780,73],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,73,2780,74],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2780,74,2780,75],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,3,2783,19],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,20,2783,21],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,21,2783,24],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,24,2783,25],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,26,2783,34],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,34,2783,35],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,36,2783,40],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,40,2783,41],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2783,41,2783,42],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,3,2786,15],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,16,2786,17],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,17,2786,25],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,25,2786,26],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,27,2786,28],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,28,2786,53],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,53,2786,54],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,55,2786,56],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,56,2786,71],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,71,2786,72],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2786,72,2786,73],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,3,2787,18],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,19,2787,20],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,20,2787,28],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,28,2787,29],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,30,2787,31],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,31,2787,55],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,55,2787,56],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2787,56,2787,57],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,3,2788,27],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,27,2788,28],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,28,2788,32],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,32,2788,33],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,34,2788,35],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,35,2788,36],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,37,2788,42],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,42,2788,43],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2788,43,2788,44],\"els\":[\"0:2904\",\"0:3\",\"0:1\"]},{\"tk\":[2793,3,2793,7],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[2793,8,2793,37],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[2793,38,2793,39],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[2793,40,2793,44],\"els\":[\"0:3\",\"0:1\"]},{\"tk\":[2797,3,2797,7],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2797,8,2797,39],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2797,40,2797,41],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2797,42,2797,44],\"els\":[\"0:3035\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2800,3,2800,7],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2800,8,2800,39],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2800,40,2800,41],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2800,42,2800,44],\"els\":[\"0:3054\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2803,3,2803,7],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2803,8,2803,39],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2803,40,2803,41],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2803,42,2803,44],\"els\":[\"0:3052\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2806,3,2806,7],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2806,8,2806,39],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2806,40,2806,41],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]},{\"tk\":[2806,42,2806,44],\"els\":[\"0:3053\",\"0:3029\",\"0:3\",\"0:1\"]}]}}}","blocks":[{"RTWName":"<Root>/ADC_Config","SIDString":"Final_project_template:2811"},{"RTWName":"<S1>/Array of 6 base IDs","SIDString":"Final_project_template:2588"},{"RTWName":"<S5>/FCAN_Receive","SIDString":"Final_project_template:2723"},{"RTWName":"<S5>/FCAN_Receive1","SIDString":"Final_project_template:2724"},{"RTWName":"<S5>/FCAN_Receive10","SIDString":"Final_project_template:2725"},{"RTWName":"<S5>/FCAN_Receive11","SIDString":"Final_project_template:2726"},{"RTWName":"<S5>/FCAN_Receive12","SIDString":"Final_project_template:2727"},{"RTWName":"<S5>/FCAN_Receive13","SIDString":"Final_project_template:2728"},{"RTWName":"<S5>/FCAN_Receive14","SIDString":"Final_project_template:2729"},{"RTWName":"<S5>/FCAN_Receive15","SIDString":"Final_project_template:2730"},{"RTWName":"<S5>/FCAN_Receive2","SIDString":"Final_project_template:2731"},{"RTWName":"<S5>/FCAN_Receive3","SIDString":"Final_project_template:2732"},{"RTWName":"<S5>/FCAN_Receive4","SIDString":"Final_project_template:2733"},{"RTWName":"<S5>/FCAN_Receive5","SIDString":"Final_project_template:2734"},{"RTWName":"<S5>/FCAN_Receive6","SIDString":"Final_project_template:2735"},{"RTWName":"<S5>/FCAN_Receive7","SIDString":"Final_project_template:2736"},{"RTWName":"<S5>/FCAN_Receive8","SIDString":"Final_project_template:2737"},{"RTWName":"<S5>/FCAN_Receive9","SIDString":"Final_project_template:2738"},{"RTWName":"<S6>/ID","SIDString":"Final_project_template:2590"},{"RTWName":"<S6>/data","SIDString":"Final_project_template:2591"},{"RTWName":"<S6>/CAN Base IDs (Cars 1-6)","SIDString":"Final_project_template:2592"},{"RTWName":"<S6>/function","SIDString":"Final_project_template:2593"},{"RTWName":"<S7>/Vehicle Base ID","SIDString":"Final_project_template:2595"},{"RTWName":"<S7>/CAN ID","SIDString":"Final_project_template:2596"},{"RTWName":"<S7>/Data","SIDString":"Final_project_template:2597"},{"RTWName":"<S7>/If","SIDString":"Final_project_template:2598"},{"RTWName":"<S7>/Mux3","SIDString":"Final_project_template:2599"},{"RTWName":"<S7>/Subtract","SIDString":"Final_project_template:2600"},{"RTWName":"<S13>/s,n","SIDString":"Final_project_template:2602"},{"RTWName":"<S13>/Action Port","SIDString":"Final_project_template:2603"},{"RTWName":"<S13>/Byte Unpacking ","SIDString":"Final_project_template:2604"},{"RTWName":"<S13>/s","SIDString":"Final_project_template:2605"},{"RTWName":"<S13>/n","SIDString":"Final_project_template:2606"},{"RTWName":"<S14>/psi,us","SIDString":"Final_project_template:2608"},{"RTWName":"<S14>/Action Port","SIDString":"Final_project_template:2609"},{"RTWName":"<S14>/Byte Unpacking ","SIDString":"Final_project_template:2610"},{"RTWName":"<S14>/psi","SIDString":"Final_project_template:2611"},{"RTWName":"<S14>/us","SIDString":"Final_project_template:2612"},{"RTWName":"<S7>/Out1","SIDString":"Final_project_template:2613"},{"RTWName":"<S8>/Vehicle Base ID","SIDString":"Final_project_template:2615"},{"RTWName":"<S8>/CAN ID","SIDString":"Final_project_template:2616"},{"RTWName":"<S8>/Data","SIDString":"Final_project_template:2617"},{"RTWName":"<S8>/If","SIDString":"Final_project_template:2618"},{"RTWName":"<S8>/Mux3","SIDString":"Final_project_template:2619"},{"RTWName":"<S8>/Subtract","SIDString":"Final_project_template:2620"},{"RTWName":"<S15>/s,n","SIDString":"Final_project_template:2622"},{"RTWName":"<S15>/Action Port","SIDString":"Final_project_template:2623"},{"RTWName":"<S15>/Byte Unpacking ","SIDString":"Final_project_template:2624"},{"RTWName":"<S15>/s","SIDString":"Final_project_template:2625"},{"RTWName":"<S15>/n","SIDString":"Final_project_template:2626"},{"RTWName":"<S16>/psi,us","SIDString":"Final_project_template:2628"},{"RTWName":"<S16>/Action Port","SIDString":"Final_project_template:2629"},{"RTWName":"<S16>/Byte Unpacking ","SIDString":"Final_project_template:2630"},{"RTWName":"<S16>/psi","SIDString":"Final_project_template:2631"},{"RTWName":"<S16>/us","SIDString":"Final_project_template:2632"},{"RTWName":"<S8>/Out1","SIDString":"Final_project_template:2633"},{"RTWName":"<S9>/Vehicle Base ID","SIDString":"Final_project_template:2635"},{"RTWName":"<S9>/CAN ID","SIDString":"Final_project_template:2636"},{"RTWName":"<S9>/Data","SIDString":"Final_project_template:2637"},{"RTWName":"<S9>/If","SIDString":"Final_project_template:2638"},{"RTWName":"<S9>/Mux3","SIDString":"Final_project_template:2639"},{"RTWName":"<S9>/Subtract","SIDString":"Final_project_template:2640"},{"RTWName":"<S17>/s,n","SIDString":"Final_project_template:2642"},{"RTWName":"<S17>/Action Port","SIDString":"Final_project_template:2643"},{"RTWName":"<S17>/Byte Unpacking ","SIDString":"Final_project_template:2644"},{"RTWName":"<S17>/s","SIDString":"Final_project_template:2645"},{"RTWName":"<S17>/n","SIDString":"Final_project_template:2646"},{"RTWName":"<S18>/psi,us","SIDString":"Final_project_template:2648"},{"RTWName":"<S18>/Action Port","SIDString":"Final_project_template:2649"},{"RTWName":"<S18>/Byte Unpacking ","SIDString":"Final_project_template:2650"},{"RTWName":"<S18>/psi","SIDString":"Final_project_template:2651"},{"RTWName":"<S18>/us","SIDString":"Final_project_template:2652"},{"RTWName":"<S9>/Out1","SIDString":"Final_project_template:2653"},{"RTWName":"<S10>/Vehicle Base ID","SIDString":"Final_project_template:2655"},{"RTWName":"<S10>/CAN ID","SIDString":"Final_project_template:2656"},{"RTWName":"<S10>/Data","SIDString":"Final_project_template:2657"},{"RTWName":"<S10>/If","SIDString":"Final_project_template:2658"},{"RTWName":"<S10>/Mux3","SIDString":"Final_project_template:2659"},{"RTWName":"<S10>/Subtract","SIDString":"Final_project_template:2660"},{"RTWName":"<S19>/s,n","SIDString":"Final_project_template:2662"},{"RTWName":"<S19>/Action Port","SIDString":"Final_project_template:2663"},{"RTWName":"<S19>/Byte Unpacking ","SIDString":"Final_project_template:2664"},{"RTWName":"<S19>/s","SIDString":"Final_project_template:2665"},{"RTWName":"<S19>/n","SIDString":"Final_project_template:2666"},{"RTWName":"<S20>/psi,us","SIDString":"Final_project_template:2668"},{"RTWName":"<S20>/Action Port","SIDString":"Final_project_template:2669"},{"RTWName":"<S20>/Byte Unpacking ","SIDString":"Final_project_template:2670"},{"RTWName":"<S20>/psi","SIDString":"Final_project_template:2671"},{"RTWName":"<S20>/us","SIDString":"Final_project_template:2672"},{"RTWName":"<S10>/Out1","SIDString":"Final_project_template:2673"},{"RTWName":"<S11>/Vehicle Base ID","SIDString":"Final_project_template:2675"},{"RTWName":"<S11>/CAN ID","SIDString":"Final_project_template:2676"},{"RTWName":"<S11>/Data","SIDString":"Final_project_template:2677"},{"RTWName":"<S11>/If","SIDString":"Final_project_template:2678"},{"RTWName":"<S11>/Mux3","SIDString":"Final_project_template:2679"},{"RTWName":"<S11>/Subtract","SIDString":"Final_project_template:2680"},{"RTWName":"<S21>/s,n","SIDString":"Final_project_template:2682"},{"RTWName":"<S21>/Action Port","SIDString":"Final_project_template:2683"},{"RTWName":"<S21>/Byte Unpacking ","SIDString":"Final_project_template:2684"},{"RTWName":"<S21>/s","SIDString":"Final_project_template:2685"},{"RTWName":"<S21>/n","SIDString":"Final_project_template:2686"},{"RTWName":"<S22>/psi,us","SIDString":"Final_project_template:2688"},{"RTWName":"<S22>/Action Port","SIDString":"Final_project_template:2689"},{"RTWName":"<S22>/Byte Unpacking ","SIDString":"Final_project_template:2690"},{"RTWName":"<S22>/psi","SIDString":"Final_project_template:2691"},{"RTWName":"<S22>/us","SIDString":"Final_project_template:2692"},{"RTWName":"<S11>/Out1","SIDString":"Final_project_template:2693"},{"RTWName":"<S12>/Vehicle Base ID","SIDString":"Final_project_template:2695"},{"RTWName":"<S12>/CAN ID","SIDString":"Final_project_template:2696"},{"RTWName":"<S12>/Data","SIDString":"Final_project_template:2697"},{"RTWName":"<S12>/If","SIDString":"Final_project_template:2698"},{"RTWName":"<S12>/Mux3","SIDString":"Final_project_template:2699"},{"RTWName":"<S12>/Subtract","SIDString":"Final_project_template:2700"},{"RTWName":"<S23>/s,n","SIDString":"Final_project_template:2702"},{"RTWName":"<S23>/Action Port","SIDString":"Final_project_template:2703"},{"RTWName":"<S23>/Byte Unpacking ","SIDString":"Final_project_template:2704"},{"RTWName":"<S23>/s","SIDString":"Final_project_template:2705"},{"RTWName":"<S23>/n","SIDString":"Final_project_template:2706"},{"RTWName":"<S24>/psi,us","SIDString":"Final_project_template:2708"},{"RTWName":"<S24>/Action Port","SIDString":"Final_project_template:2709"},{"RTWName":"<S24>/Byte Unpacking ","SIDString":"Final_project_template:2710"},{"RTWName":"<S24>/psi","SIDString":"Final_project_template:2711"},{"RTWName":"<S24>/us","SIDString":"Final_project_template:2712"},{"RTWName":"<S12>/Out1","SIDString":"Final_project_template:2713"},{"RTWName":"<S6>/Demux","SIDString":"Final_project_template:2714"},{"RTWName":"<S6>/Mux","SIDString":"Final_project_template:2715"},{"RTWName":"<S6>/s, n, psi, us (Cars 1-6)","SIDString":"Final_project_template:2716"},{"RTWName":"<S1>/FCAN_Isr","SIDString":"Final_project_template:2717"},{"RTWName":"<S1>/Terminator1","SIDString":"Final_project_template:2718"},{"RTWName":"<S1>/Terminator2","SIDString":"Final_project_template:2719"},{"RTWName":"<S1>/Terminator3","SIDString":"Final_project_template:2720"},{"RTWName":"<S1>/Cars 1-6","SIDString":"Final_project_template:2721"},{"RTWName":"<Root>/FCAN_Config","SIDString":"Final_project_template:2587"},{"RTWName":"<Root>/Function-Call\nTop","SIDString":"Final_project_template:1"},{"RTWName":"<S2>/s,n,psi,us (Cars 1-6)","SIDString":"Final_project_template:1819"},{"RTWName":"<S2>/function","SIDString":"Final_project_template:5"},{"RTWName":"<S25>/This Car","SIDString":"Final_project_template:2791"},{"RTWName":"<S25>/Cars 1-6","SIDString":"Final_project_template:2793"},{"RTWName":"<S25>/ACC_en","SIDString":"Final_project_template:2794"},{"RTWName":"<S25>/Cruise Speed","SIDString":"Final_project_template:2795"},{"RTWName":"<S25>/Throttle","SIDString":"Final_project_template:2796"},{"RTWName":"<S29>/ACC_Enable","SIDString":"Final_project_template:3176"},{"RTWName":"<S29>/s,n,psi,us (Cars 1 - 6)","SIDString":"Final_project_template:3177"},{"RTWName":"<S29>/s,n,psi,us (This Car)","SIDString":"Final_project_template:3178"},{"RTWName":"<S33>:1","SIDString":"Final_project_template:3179:1"},{"RTWName":"<S33>:3","SIDString":"Final_project_template:3179:3"},{"RTWName":"<S33>:4","SIDString":"Final_project_template:3179:4"},{"RTWName":"<S33>:2","SIDString":"Final_project_template:3179:2"},{"RTWName":"<S33>:5","SIDString":"Final_project_template:3179:5"},{"RTWName":"<S33>:6","SIDString":"Final_project_template:3179:6"},{"RTWName":"<S33>:8","SIDString":"Final_project_template:3179:8"},{"RTWName":"<S33>:7","SIDString":"Final_project_template:3179:7"},{"RTWName":"<S33>:10","SIDString":"Final_project_template:3179:10"},{"RTWName":"<S33>:9","SIDString":"Final_project_template:3179:9"},{"RTWName":"<S29>/Demux","SIDString":"Final_project_template:3180"},{"RTWName":"<S29>/Display","SIDString":"Final_project_template:3181"},{"RTWName":"<S29>/Display1","SIDString":"Final_project_template:3182"},{"RTWName":"<S29>/Display2","SIDString":"Final_project_template:3183"},{"RTWName":"<S29>/Mux","SIDString":"Final_project_template:3184"},{"RTWName":"<S29>/S-Function Builder","SIDString":"Final_project_template:3185"},{"RTWName":"<S29>/Scope","SIDString":"Final_project_template:3186"},{"RTWName":"<S29>/Terminator","SIDString":"Final_project_template:3187"},{"RTWName":"<S29>/Terminator1","SIDString":"Final_project_template:3188"},{"RTWName":"<S29>/en_man","SIDString":"Final_project_template:3189"},{"RTWName":"<S29>/en_vel","SIDString":"Final_project_template:3190"},{"RTWName":"<S29>/en_pos","SIDString":"Final_project_template:3191"},{"RTWName":"<S29>/lead_s","SIDString":"Final_project_template:3192"},{"RTWName":"<S29>/lead_us","SIDString":"Final_project_template:3193"},{"RTWName":"<S25>/Constant","SIDString":"Final_project_template:3194"},{"RTWName":"<S25>/Demux","SIDString":"Final_project_template:3195"},{"RTWName":"<S25>/Digital_Output","SIDString":"Final_project_template:3225"},{"RTWName":"<S25>/Digital_Output1","SIDString":"Final_project_template:3226"},{"RTWName":"<S25>/Digital_Output2","SIDString":"Final_project_template:3227"},{"RTWName":"<S30>/Throttle","SIDString":"Final_project_template:3221"},{"RTWName":"<S30>/Enable","SIDString":"Final_project_template:3222"},{"RTWName":"<S30>/Out1","SIDString":"Final_project_template:3223"},{"RTWName":"<S25>/Merge","SIDString":"Final_project_template:3199"},{"RTWName":"<S31>/Reference Following \nDistance","SIDString":"Final_project_template:3159"},{"RTWName":"<S31>/s","SIDString":"Final_project_template:3160"},{"RTWName":"<S31>/Lead s","SIDString":"Final_project_template:3161"},{"RTWName":"<S31>/us","SIDString":"Final_project_template:3162"},{"RTWName":"<S31>/Lead us","SIDString":"Final_project_template:3163"},{"RTWName":"<S31>/Enable","SIDString":"Final_project_template:3164"},{"RTWName":"<S31>/D-gain","SIDString":"Final_project_template:3165"},{"RTWName":"<S31>/Feed-forward","SIDString":"Final_project_template:3166"},{"RTWName":"<S31>/P-gain","SIDString":"Final_project_template:3167"},{"RTWName":"<S31>/Sum1","SIDString":"Final_project_template:3168"},{"RTWName":"<S31>/Sum2","SIDString":"Final_project_template:3169"},{"RTWName":"<S31>/Sum3","SIDString":"Final_project_template:3170"},{"RTWName":"<S31>/Sum4","SIDString":"Final_project_template:3171"},{"RTWName":"<S31>/Sum5","SIDString":"Final_project_template:3172"},{"RTWName":"<S31>/Fd","SIDString":"Final_project_template:3173"},{"RTWName":"<S32>/Speed Set Point","SIDString":"Final_project_template:3139"},{"RTWName":"<S32>/Speed","SIDString":"Final_project_template:3140"},{"RTWName":"<S32>/Enable","SIDString":"Final_project_template:3141"},{"RTWName":"<S32>/Gain","SIDString":"Final_project_template:3142"},{"RTWName":"<S34>/Error","SIDString":"Final_project_template:3144"},{"RTWName":"<S34>/Gain","SIDString":"Final_project_template:3145"},{"RTWName":"<S34>/Gain1","SIDString":"Final_project_template:3146"},{"RTWName":"<S35>/X_dot","SIDString":"Final_project_template:3148"},{"RTWName":"<S35>/Gain","SIDString":"Final_project_template:3149"},{"RTWName":"<S35>/Sum","SIDString":"Final_project_template:3150"},{"RTWName":"<S35>/Unit Delay","SIDString":"Final_project_template:3151"},{"RTWName":"<S35>/X","SIDString":"Final_project_template:3152"},{"RTWName":"<S34>/Sum","SIDString":"Final_project_template:3153"},{"RTWName":"<S34>/U","SIDString":"Final_project_template:3154"},{"RTWName":"<S32>/Sum","SIDString":"Final_project_template:3155"},{"RTWName":"<S32>/Sum1","SIDString":"Final_project_template:3156"},{"RTWName":"<S32>/Fd","SIDString":"Final_project_template:3157"},{"RTWName":"<S25>/Terminator","SIDString":"Final_project_template:3196"},{"RTWName":"<S25>/Terminator1","SIDString":"Final_project_template:3197"},{"RTWName":"<S25>/Fd","SIDString":"Final_project_template:2792"},{"RTWName":"<S4294967295>/n","SIDString":"Final_project_template:2807"},{"RTWName":"<S4294967295>/Delta","SIDString":"Final_project_template:2809"},{"RTWName":"<S4294967295>/us_en","SIDString":"Final_project_template:2810"},{"RTWName":"<S4294967295>/Auto Torque","SIDString":"Final_project_template:2808"},{"RTWName":"<S2>/Constant","SIDString":"Final_project_template:3115"},{"RTWName":"<S26>/Digital_Input","SIDString":"Final_project_template:2777"},{"RTWName":"<S26>/Digital_Input1","SIDString":"Final_project_template:2778"},{"RTWName":"<S26>/Gain","SIDString":"Final_project_template:62"},{"RTWName":"<S36>/Add","SIDString":"Final_project_template:56"},{"RTWName":"<S36>/Data Type Conversion","SIDString":"Final_project_template:2867"},{"RTWName":"<S36>/Data Type Conversion1","SIDString":"Final_project_template:2868"},{"RTWName":"<S36>/Data Type Conversion2","SIDString":"Final_project_template:2869"},{"RTWName":"<S36>/Data Type Conversion3","SIDString":"Final_project_template:2870"},{"RTWName":"<S36>/Data Type Conversion4","SIDString":"Final_project_template:2875"},{"RTWName":"<S36>/Data Type Conversion5","SIDString":"Final_project_template:2876"},{"RTWName":"<S36>/Data Type Conversion6","SIDString":"Final_project_template:2877"},{"RTWName":"<S36>/Data Type Conversion7","SIDString":"Final_project_template:2878"},{"RTWName":"<S36>/Data Type Conversion8","SIDString":"Final_project_template:57"},{"RTWName":"<S36>/Digital_Input","SIDString":"Final_project_template:2781"},{"RTWName":"<S36>/Digital_Input1","SIDString":"Final_project_template:2782"},{"RTWName":"<S36>/Digital_Input2","SIDString":"Final_project_template:2783"},{"RTWName":"<S36>/Digital_Input3","SIDString":"Final_project_template:2784"},{"RTWName":"<S36>/Digital_Input4","SIDString":"Final_project_template:2785"},{"RTWName":"<S36>/Digital_Input5","SIDString":"Final_project_template:2786"},{"RTWName":"<S36>/Digital_Input6","SIDString":"Final_project_template:2787"},{"RTWName":"<S36>/Digital_Input7","SIDString":"Final_project_template:2788"},{"RTWName":"<S36>/Gain","SIDString":"Final_project_template:58"},{"RTWName":"<S36>/Shift\nArithmetic","SIDString":"Final_project_template:2871"},{"RTWName":"<S36>/Shift\nArithmetic1","SIDString":"Final_project_template:2872"},{"RTWName":"<S36>/Shift\nArithmetic2","SIDString":"Final_project_template:2873"},{"RTWName":"<S36>/Shift\nArithmetic3","SIDString":"Final_project_template:2874"},{"RTWName":"<S36>/Shift\nArithmetic4","SIDString":"Final_project_template:2879"},{"RTWName":"<S36>/Shift\nArithmetic5","SIDString":"Final_project_template:2880"},{"RTWName":"<S36>/Shift\nArithmetic6","SIDString":"Final_project_template:2881"},{"RTWName":"<S36>/Shift\nArithmetic7","SIDString":"Final_project_template:2882"},{"RTWName":"<S36>/Speed","SIDString":"Final_project_template:40"},{"RTWName":"<S37>/ADC_Start","SIDString":"Final_project_template:2899"},{"RTWName":"<S37>/Constant","SIDString":"Final_project_template:2900"},{"RTWName":"<S37>/Gain","SIDString":"Final_project_template:2902"},{"RTWName":"<S37>/Sum","SIDString":"Final_project_template:2901"},{"RTWName":"<S37>/Fd","SIDString":"Final_project_template:65"},{"RTWName":"<S38>/Gain","SIDString":"Final_project_template:2898"},{"RTWName":"<S38>/Quadrature_Decoder","SIDString":"Final_project_template:2883"},{"RTWName":"<S39>/In1","SIDString":"Final_project_template:2885"},{"RTWName":"<S39>/Data Type Conversion","SIDString":"Final_project_template:2886"},{"RTWName":"<S39>/Data Type Conversion1","SIDString":"Final_project_template:2887"},{"RTWName":"<S39>/Data Type Conversion2","SIDString":"Final_project_template:2888"},{"RTWName":"<S39>/Gain","SIDString":"Final_project_template:2889"},{"RTWName":"<S39>/Sum","SIDString":"Final_project_template:2890"},{"RTWName":"<S39>/Sum1","SIDString":"Final_project_template:2891"},{"RTWName":"<S39>/Unit Delay","SIDString":"Final_project_template:2892"},{"RTWName":"<S39>/Unit Delay1","SIDString":"Final_project_template:2893"},{"RTWName":"<S39>/Wheel Position (deg)","SIDString":"Final_project_template:2894"},{"RTWName":"<S38>/Terminator","SIDString":"Final_project_template:2895"},{"RTWName":"<S38>/Terminator1","SIDString":"Final_project_template:2896"},{"RTWName":"<S38>/Terminator2","SIDString":"Final_project_template:2897"},{"RTWName":"<S38>/Haptic Wheel Position\n(radians)","SIDString":"Final_project_template:596"},{"RTWName":"<S26>/ACC_enable","SIDString":"Final_project_template:30"},{"RTWName":"<S26>/Cruise Control Speed","SIDString":"Final_project_template:31"},{"RTWName":"<S26>/Steering Angle (delta)","SIDString":"Final_project_template:32"},{"RTWName":"<S26>/Throttle (Fd)","SIDString":"Final_project_template:33"},{"RTWName":"<S26>/Automatic Steering Enable","SIDString":"Final_project_template:34"},{"RTWName":"<S27>/s, n, psi, us (Cars 1-6)","SIDString":"Final_project_template:25"},{"RTWName":"<S27>/s, n, psi, us (This Car)","SIDString":"Final_project_template:278"},{"RTWName":"<S27>/u (This car)","SIDString":"Final_project_template:279"},{"RTWName":"<S27>/Self-Aligning Torque","SIDString":"Final_project_template:280"},{"RTWName":"<S27>/Auto Torque","SIDString":"Final_project_template:281"},{"RTWName":"<S40>/s,n,psi,us","SIDString":"Final_project_template:499"},{"RTWName":"<S40>/Demux","SIDString":"Final_project_template:500"},{"RTWName":"<S40>/Mux","SIDString":"Final_project_template:501"},{"RTWName":"<S40>/Terminator","SIDString":"Final_project_template:502"},{"RTWName":"<S44>/s","SIDString":"Final_project_template:1016:11"},{"RTWName":"<S44>/n","SIDString":"Final_project_template:1016:12"},{"RTWName":"<S44>/Demux","SIDString":"Final_project_template:1016:13"},{"RTWName":"<S44>/Look up P1","SIDString":"Final_project_template:1016:63"},{"RTWName":"<S44>/Look up Right Vector1","SIDString":"Final_project_template:1016:64"},{"RTWName":"<S44>/Mux","SIDString":"Final_project_template:1016:16"},{"RTWName":"<S44>/Mux1","SIDString":"Final_project_template:1016:17"},{"RTWName":"<S44>/Product","SIDString":"Final_project_template:1016:18"},{"RTWName":"<S44>/Sum","SIDString":"Final_project_template:1016:19"},{"RTWName":"<S44>/x","SIDString":"Final_project_template:1016:20"},{"RTWName":"<S44>/y","SIDString":"Final_project_template:1016:21"},{"RTWName":"<S40>/x,y,psi","SIDString":"Final_project_template:504"},{"RTWName":"<S41>/s,n,psi,us (Cars 1 - 6)","SIDString":"Final_project_template:506"},{"RTWName":"<S41>/Demux","SIDString":"Final_project_template:507"},{"RTWName":"<S45>/s,n,psi,us","SIDString":"Final_project_template:509"},{"RTWName":"<S45>/Demux","SIDString":"Final_project_template:510"},{"RTWName":"<S45>/Mux","SIDString":"Final_project_template:511"},{"RTWName":"<S45>/Terminator","SIDString":"Final_project_template:512"},{"RTWName":"<S51>/s","SIDString":"Final_project_template:977:11"},{"RTWName":"<S51>/n","SIDString":"Final_project_template:977:12"},{"RTWName":"<S51>/Demux","SIDString":"Final_project_template:977:13"},{"RTWName":"<S51>/Look up P1","SIDString":"Final_project_template:977:63"},{"RTWName":"<S51>/Look up Right Vector1","SIDString":"Final_project_template:977:64"},{"RTWName":"<S51>/Mux","SIDString":"Final_project_template:977:16"},{"RTWName":"<S51>/Mux1","SIDString":"Final_project_template:977:17"},{"RTWName":"<S51>/Product","SIDString":"Final_project_template:977:18"},{"RTWName":"<S51>/Sum","SIDString":"Final_project_template:977:19"},{"RTWName":"<S51>/x","SIDString":"Final_project_template:977:20"},{"RTWName":"<S51>/y","SIDString":"Final_project_template:977:21"},{"RTWName":"<S45>/x,y,psi","SIDString":"Final_project_template:514"},{"RTWName":"<S46>/s,n,psi,us","SIDString":"Final_project_template:979"},{"RTWName":"<S46>/Demux","SIDString":"Final_project_template:980"},{"RTWName":"<S46>/Mux","SIDString":"Final_project_template:981"},{"RTWName":"<S46>/Terminator","SIDString":"Final_project_template:982"},{"RTWName":"<S52>/s","SIDString":"Final_project_template:983:11"},{"RTWName":"<S52>/n","SIDString":"Final_project_template:983:12"},{"RTWName":"<S52>/Demux","SIDString":"Final_project_template:983:13"},{"RTWName":"<S52>/Look up P1","SIDString":"Final_project_template:983:63"},{"RTWName":"<S52>/Look up Right Vector1","SIDString":"Final_project_template:983:64"},{"RTWName":"<S52>/Mux","SIDString":"Final_project_template:983:16"},{"RTWName":"<S52>/Mux1","SIDString":"Final_project_template:983:17"},{"RTWName":"<S52>/Product","SIDString":"Final_project_template:983:18"},{"RTWName":"<S52>/Sum","SIDString":"Final_project_template:983:19"},{"RTWName":"<S52>/x","SIDString":"Final_project_template:983:20"},{"RTWName":"<S52>/y","SIDString":"Final_project_template:983:21"},{"RTWName":"<S46>/x,y,psi","SIDString":"Final_project_template:984"},{"RTWName":"<S47>/s,n,psi,us","SIDString":"Final_project_template:986"},{"RTWName":"<S47>/Demux","SIDString":"Final_project_template:987"},{"RTWName":"<S47>/Mux","SIDString":"Final_project_template:988"},{"RTWName":"<S47>/Terminator","SIDString":"Final_project_template:989"},{"RTWName":"<S53>/s","SIDString":"Final_project_template:990:11"},{"RTWName":"<S53>/n","SIDString":"Final_project_template:990:12"},{"RTWName":"<S53>/Demux","SIDString":"Final_project_template:990:13"},{"RTWName":"<S53>/Look up P1","SIDString":"Final_project_template:990:63"},{"RTWName":"<S53>/Look up Right Vector1","SIDString":"Final_project_template:990:64"},{"RTWName":"<S53>/Mux","SIDString":"Final_project_template:990:16"},{"RTWName":"<S53>/Mux1","SIDString":"Final_project_template:990:17"},{"RTWName":"<S53>/Product","SIDString":"Final_project_template:990:18"},{"RTWName":"<S53>/Sum","SIDString":"Final_project_template:990:19"},{"RTWName":"<S53>/x","SIDString":"Final_project_template:990:20"},{"RTWName":"<S53>/y","SIDString":"Final_project_template:990:21"},{"RTWName":"<S47>/x,y,psi","SIDString":"Final_project_template:991"},{"RTWName":"<S48>/s,n,psi,us","SIDString":"Final_project_template:993"},{"RTWName":"<S48>/Demux","SIDString":"Final_project_template:994"},{"RTWName":"<S48>/Mux","SIDString":"Final_project_template:995"},{"RTWName":"<S48>/Terminator","SIDString":"Final_project_template:996"},{"RTWName":"<S54>/s","SIDString":"Final_project_template:997:11"},{"RTWName":"<S54>/n","SIDString":"Final_project_template:997:12"},{"RTWName":"<S54>/Demux","SIDString":"Final_project_template:997:13"},{"RTWName":"<S54>/Look up P1","SIDString":"Final_project_template:997:63"},{"RTWName":"<S54>/Look up Right Vector1","SIDString":"Final_project_template:997:64"},{"RTWName":"<S54>/Mux","SIDString":"Final_project_template:997:16"},{"RTWName":"<S54>/Mux1","SIDString":"Final_project_template:997:17"},{"RTWName":"<S54>/Product","SIDString":"Final_project_template:997:18"},{"RTWName":"<S54>/Sum","SIDString":"Final_project_template:997:19"},{"RTWName":"<S54>/x","SIDString":"Final_project_template:997:20"},{"RTWName":"<S54>/y","SIDString":"Final_project_template:997:21"},{"RTWName":"<S48>/x,y,psi","SIDString":"Final_project_template:998"},{"RTWName":"<S49>/s,n,psi,us","SIDString":"Final_project_template:1000"},{"RTWName":"<S49>/Demux","SIDString":"Final_project_template:1001"},{"RTWName":"<S49>/Mux","SIDString":"Final_project_template:1002"},{"RTWName":"<S49>/Terminator","SIDString":"Final_project_template:1003"},{"RTWName":"<S55>/s","SIDString":"Final_project_template:1004:11"},{"RTWName":"<S55>/n","SIDString":"Final_project_template:1004:12"},{"RTWName":"<S55>/Demux","SIDString":"Final_project_template:1004:13"},{"RTWName":"<S55>/Look up P1","SIDString":"Final_project_template:1004:63"},{"RTWName":"<S55>/Look up Right Vector1","SIDString":"Final_project_template:1004:64"},{"RTWName":"<S55>/Mux","SIDString":"Final_project_template:1004:16"},{"RTWName":"<S55>/Mux1","SIDString":"Final_project_template:1004:17"},{"RTWName":"<S55>/Product","SIDString":"Final_project_template:1004:18"},{"RTWName":"<S55>/Sum","SIDString":"Final_project_template:1004:19"},{"RTWName":"<S55>/x","SIDString":"Final_project_template:1004:20"},{"RTWName":"<S55>/y","SIDString":"Final_project_template:1004:21"},{"RTWName":"<S49>/x,y,psi","SIDString":"Final_project_template:1005"},{"RTWName":"<S50>/s,n,psi,us","SIDString":"Final_project_template:1007"},{"RTWName":"<S50>/Demux","SIDString":"Final_project_template:1008"},{"RTWName":"<S50>/Mux","SIDString":"Final_project_template:1009"},{"RTWName":"<S50>/Terminator","SIDString":"Final_project_template:1010"},{"RTWName":"<S56>/s","SIDString":"Final_project_template:1011:11"},{"RTWName":"<S56>/n","SIDString":"Final_project_template:1011:12"},{"RTWName":"<S56>/Demux","SIDString":"Final_project_template:1011:13"},{"RTWName":"<S56>/Look up P1","SIDString":"Final_project_template:1011:63"},{"RTWName":"<S56>/Look up Right Vector1","SIDString":"Final_project_template:1011:64"},{"RTWName":"<S56>/Mux","SIDString":"Final_project_template:1011:16"},{"RTWName":"<S56>/Mux1","SIDString":"Final_project_template:1011:17"},{"RTWName":"<S56>/Product","SIDString":"Final_project_template:1011:18"},{"RTWName":"<S56>/Sum","SIDString":"Final_project_template:1011:19"},{"RTWName":"<S56>/x","SIDString":"Final_project_template:1011:20"},{"RTWName":"<S56>/y","SIDString":"Final_project_template:1011:21"},{"RTWName":"<S50>/x,y,psi","SIDString":"Final_project_template:1012"},{"RTWName":"<S41>/Mux","SIDString":"Final_project_template:550"},{"RTWName":"<S41>/x,y,psi (Cars 1 - 6)","SIDString":"Final_project_template:551"},{"RTWName":"<S27>/Mux","SIDString":"Final_project_template:552"},{"RTWName":"<S27>/Sum1","SIDString":"Final_project_template:482"},{"RTWName":"<S42>/s,n,psi,us","SIDString":"Final_project_template:554"},{"RTWName":"<S42>/Byte Pack","SIDString":"Final_project_template:3106"},{"RTWName":"<S42>/Byte Pack1","SIDString":"Final_project_template:3107"},{"RTWName":"<S42>/Constant","SIDString":"Final_project_template:3108"},{"RTWName":"<S42>/Constant1","SIDString":"Final_project_template:3109"},{"RTWName":"<S42>/Demux","SIDString":"Final_project_template:3105"},{"RTWName":"<S42>/psi,us","SIDString":"Final_project_template:2913"},{"RTWName":"<S42>/s,n","SIDString":"Final_project_template:2912"},{"RTWName":"<S43>/Reaction Torque","SIDString":"Final_project_template:484"},{"RTWName":"<S43>/Constant","SIDString":"Final_project_template:2903"},{"RTWName":"<S43>/FTM_PWM_Config","SIDString":"Final_project_template:2904"},{"RTWName":"<S57>/In1","SIDString":"Final_project_template:2906"},{"RTWName":"<S57>/Constant","SIDString":"Final_project_template:2907"},{"RTWName":"<S57>/Gain","SIDString":"Final_project_template:2908"},{"RTWName":"<S57>/Saturation","SIDString":"Final_project_template:2909"},{"RTWName":"<S57>/Sum","SIDString":"Final_project_template:2910"},{"RTWName":"<S57>/Out1","SIDString":"Final_project_template:2911"},{"RTWName":"<S27>/x, y, pxi (Cars 1-6)","SIDString":"Final_project_template:26"},{"RTWName":"<S2>/Terminator3","SIDString":"Final_project_template:3114"},{"RTWName":"<S2>/Terminator4","SIDString":"Final_project_template:3116"},{"RTWName":"<S2>/Unit Delay","SIDString":"Final_project_template:3224"},{"RTWName":"<S28>/Fd","SIDString":"Final_project_template:2799"},{"RTWName":"<S28>/Delta","SIDString":"Final_project_template:2801"},{"RTWName":"<S28>/Mux","SIDString":"Final_project_template:3066"},{"RTWName":"<S58>/Fd","SIDString":"Final_project_template:3030"},{"RTWName":"<S58>/delta","SIDString":"Final_project_template:3031"},{"RTWName":"<S60>/Fd","SIDString":"Final_project_template:3034"},{"RTWName":"<S60>/Discrete-Time\nIntegrator","SIDString":"Final_project_template:3035"},{"RTWName":"<S60>/Gain","SIDString":"Final_project_template:3036"},{"RTWName":"<S60>/Gain1","SIDString":"Final_project_template:3037"},{"RTWName":"<S60>/Sum","SIDString":"Final_project_template:3038"},{"RTWName":"<S60>/u","SIDString":"Final_project_template:3039"},{"RTWName":"<S61>/u","SIDString":"Final_project_template:3041"},{"RTWName":"<S61>/delta","SIDString":"Final_project_template:3042"},{"RTWName":"<S61>/psi","SIDString":"Final_project_template:3043"},{"RTWName":"<S61>/S-Function Builder","SIDString":"Final_project_template:3044"},{"RTWName":"<S61>/xdot","SIDString":"Final_project_template:3045"},{"RTWName":"<S61>/ydot","SIDString":"Final_project_template:3046"},{"RTWName":"<S61>/psidot","SIDString":"Final_project_template:3047"},{"RTWName":"<S62>/xdot","SIDString":"Final_project_template:3049"},{"RTWName":"<S62>/ydot","SIDString":"Final_project_template:3050"},{"RTWName":"<S62>/psidot","SIDString":"Final_project_template:3051"},{"RTWName":"<S62>/Discrete-Time\nIntegrator","SIDString":"Final_project_template:3052"},{"RTWName":"<S62>/Discrete-Time\nIntegrator1","SIDString":"Final_project_template:3053"},{"RTWName":"<S62>/Discrete-Time\nIntegrator2","SIDString":"Final_project_template:3054"},{"RTWName":"<S62>/x","SIDString":"Final_project_template:3055"},{"RTWName":"<S62>/y","SIDString":"Final_project_template:3056"},{"RTWName":"<S62>/psi","SIDString":"Final_project_template:3057"},{"RTWName":"<S58>/x","SIDString":"Final_project_template:3058"},{"RTWName":"<S58>/y","SIDString":"Final_project_template:3059"},{"RTWName":"<S58>/psi","SIDString":"Final_project_template:3060"},{"RTWName":"<S58>/u","SIDString":"Final_project_template:3061"},{"RTWName":"<S59>/x","SIDString":"Final_project_template:3088"},{"RTWName":"<S59>/y","SIDString":"Final_project_template:3089"},{"RTWName":"<S59>/psi","SIDString":"Final_project_template:3091"},{"RTWName":"<S59>/delta","SIDString":"Final_project_template:3092"},{"RTWName":"<S59>/u","SIDString":"Final_project_template:3093"},{"RTWName":"<S59>/Constant","SIDString":"Final_project_template:3117"},{"RTWName":"<S59>/Product","SIDString":"Final_project_template:3010"},{"RTWName":"<S63>/x","SIDString":"Final_project_template:3081"},{"RTWName":"<S63>/y","SIDString":"Final_project_template:3082"},{"RTWName":"<S65>/s","SIDString":"Final_project_template:3063:3"},{"RTWName":"<S65>/Gain","SIDString":"Final_project_template:3063:4"},{"RTWName":"<S65>/Look up Right Vector","SIDString":"Final_project_template:3063:5"},{"RTWName":"<S65>/fx","SIDString":"Final_project_template:3063:6"},{"RTWName":"<S65>/fy","SIDString":"Final_project_template:3063:7"},{"RTWName":"<S66>/x","SIDString":"Final_project_template:3062:23"},{"RTWName":"<S66>/y","SIDString":"Final_project_template:3062:24"},{"RTWName":"<S66>/Controller","SIDString":"Final_project_template:3062:25"},{"RTWName":"<S66>/Data \nType \nConversion","SIDString":"Final_project_template:3062:26"},{"RTWName":"<S67>/DTS reference","SIDString":"Final_project_template:3062:27:1"},{"RTWName":"<S67>/u","SIDString":"Final_project_template:3062:27:2"},{"RTWName":"<S67>/Conversion","SIDString":"Final_project_template:3062:27:3"},{"RTWName":"<S67>/Data Type\nDuplicate","SIDString":"Final_project_template:3062:27:4"},{"RTWName":"<S67>/y","SIDString":"Final_project_template:3062:27:5"},{"RTWName":"<S66>/Look up P","SIDString":"Final_project_template:3062:28"},{"RTWName":"<S66>/Look up Right Vector","SIDString":"Final_project_template:3062:29"},{"RTWName":"<S68>/s","SIDString":"Final_project_template:3062:31"},{"RTWName":"<S68>/Gain","SIDString":"Final_project_template:3062:32"},{"RTWName":"<S68>/Look up Right Vector","SIDString":"Final_project_template:3062:33"},{"RTWName":"<S68>/fx","SIDString":"Final_project_template:3062:34"},{"RTWName":"<S68>/fy","SIDString":"Final_project_template:3062:35"},{"RTWName":"<S66>/Mux","SIDString":"Final_project_template:3062:36"},{"RTWName":"<S66>/Mux1","SIDString":"Final_project_template:3062:37"},{"RTWName":"<S66>/Mux2","SIDString":"Final_project_template:3062:38"},{"RTWName":"<S66>/Mux3","SIDString":"Final_project_template:3062:39"},{"RTWName":"<S69>/X_dot","SIDString":"Final_project_template:3062:41"},{"RTWName":"<S69>/Gain","SIDString":"Final_project_template:3062:42"},{"RTWName":"<S69>/Sum","SIDString":"Final_project_template:3062:43"},{"RTWName":"<S69>/Unit Delay","SIDString":"Final_project_template:3062:44"},{"RTWName":"<S69>/X","SIDString":"Final_project_template:3062:45"},{"RTWName":"<S70>/u1","SIDString":"Final_project_template:3062:47"},{"RTWName":"<S70>/u2","SIDString":"Final_project_template:3062:48"},{"RTWName":"<S70>/Demux","SIDString":"Final_project_template:3062:49"},{"RTWName":"<S70>/Product","SIDString":"Final_project_template:3062:50"},{"RTWName":"<S70>/Sum1","SIDString":"Final_project_template:3062:51"},{"RTWName":"<S70>/y","SIDString":"Final_project_template:3062:52"},{"RTWName":"<S71>/u1","SIDString":"Final_project_template:3062:54"},{"RTWName":"<S71>/u2","SIDString":"Final_project_template:3062:55"},{"RTWName":"<S71>/Demux","SIDString":"Final_project_template:3062:56"},{"RTWName":"<S71>/Product","SIDString":"Final_project_template:3062:57"},{"RTWName":"<S71>/Sum1","SIDString":"Final_project_template:3062:58"},{"RTWName":"<S71>/n","SIDString":"Final_project_template:3062:59"},{"RTWName":"<S66>/Sum","SIDString":"Final_project_template:3062:60"},{"RTWName":"<S66>/s","SIDString":"Final_project_template:3062:61"},{"RTWName":"<S66>/n","SIDString":"Final_project_template:3062:62"},{"RTWName":"<S63>/s","SIDString":"Final_project_template:3083"},{"RTWName":"<S63>/n","SIDString":"Final_project_template:3084"},{"RTWName":"<S63>/fx","SIDString":"Final_project_template:3085"},{"RTWName":"<S63>/fy","SIDString":"Final_project_template:3086"},{"RTWName":"<S64>/fx","SIDString":"Final_project_template:3073"},{"RTWName":"<S64>/psi","SIDString":"Final_project_template:3074"},{"RTWName":"<S64>/delta","SIDString":"Final_project_template:3075"},{"RTWName":"<S64>/fy","SIDString":"Final_project_template:3076"},{"RTWName":"<S64>/u","SIDString":"Final_project_template:3079"},{"RTWName":"<S64>/Product","SIDString":"Final_project_template:3102"},{"RTWName":"<S64>/Product1","SIDString":"Final_project_template:3103"},{"RTWName":"<S64>/Product2","SIDString":"Final_project_template:3104"},{"RTWName":"<S64>/Sum","SIDString":"Final_project_template:3100"},{"RTWName":"<S64>/Sum1","SIDString":"Final_project_template:3101"},{"RTWName":"<S64>/Trigonometric\nFunction","SIDString":"Final_project_template:3098"},{"RTWName":"<S64>/Trigonometric\nFunction1","SIDString":"Final_project_template:3099"},{"RTWName":"<S64>/us","SIDString":"Final_project_template:3077"},{"RTWName":"<S59>/s","SIDString":"Final_project_template:3094"},{"RTWName":"<S59>/n","SIDString":"Final_project_template:3095"},{"RTWName":"<S59>/self aligning t","SIDString":"Final_project_template:3096"},{"RTWName":"<S59>/us","SIDString":"Final_project_template:3097"},{"RTWName":"<S28>/s, n, psi, us(your car)","SIDString":"Final_project_template:2800"},{"RTWName":"<S28>/u (your car)","SIDString":"Final_project_template:2802"},{"RTWName":"<S28>/Self-Align Torque","SIDString":"Final_project_template:2803"},{"RTWName":"<S28>/n","SIDString":"Final_project_template:2804"},{"RTWName":"<S2>/Serial","SIDString":"Final_project_template:6"},{"RTWName":"<Root>/LPUART_Config","SIDString":"Final_project_template:2586"},{"RTWName":"<Root>/MBD_S32K1xx_Config_Information","SIDString":"Final_project_template:2585"},{"RTWName":"<Root>/Rate Transition","SIDString":"Final_project_template:14"},{"RTWName":"<S3>/Constant","SIDString":"Final_project_template:2813"},{"RTWName":"<S3>/Constant1","SIDString":"Final_project_template:2814"},{"RTWName":"<S3>/FTM_PWM_Config","SIDString":"Final_project_template:2815"},{"RTWName":"<S4>/data","SIDString":"Final_project_template:2748"},{"RTWName":"<S4>/Function-Call\nGenerator1","SIDString":"Final_project_template:2749"},{"RTWName":"<S4>/Function-Call\nGenerator2","SIDString":"Final_project_template:2750"},{"RTWName":"<S4>/RT","SIDString":"Final_project_template:2751"},{"RTWName":"<S4>/RT1","SIDString":"Final_project_template:2752"},{"RTWName":"<S72>/data","SIDString":"Final_project_template:2754"},{"RTWName":"<S72>/Trigger","SIDString":"Final_project_template:2755"},{"RTWName":"<S72>/Byte Packing ","SIDString":"Final_project_template:2756"},{"RTWName":"<S72>/Constant2","SIDString":"Final_project_template:2757"},{"RTWName":"<S72>/Constant3","SIDString":"Final_project_template:2758"},{"RTWName":"<S72>/Delay","SIDString":"Final_project_template:2759"},{"RTWName":"<S72>/Mux","SIDString":"Final_project_template:2760"},{"RTWName":"<S72>/NOT","SIDString":"Final_project_template:2761"},{"RTWName":"<S72>/reset","SIDString":"Final_project_template:2762"},{"RTWName":"<S72>/data_out","SIDString":"Final_project_template:2763"},{"RTWName":"<S73>/reset","SIDString":"Final_project_template:2765"},{"RTWName":"<S73>/data","SIDString":"Final_project_template:2766"},{"RTWName":"<S73>/Trigger","SIDString":"Final_project_template:2767"},{"RTWName":"<S73>/Index\nVector","SIDString":"Final_project_template:2768"},{"RTWName":"<S73>/LPUART_Transmit","SIDString":"Final_project_template:2769"},{"RTWName":"<S74>/Reset","SIDString":"Final_project_template:2771"},{"RTWName":"<S74>/Constant","SIDString":"Final_project_template:2772"},{"RTWName":"<S74>/Delay","SIDString":"Final_project_template:2773"},{"RTWName":"<S74>/Sum","SIDString":"Final_project_template:2774"},{"RTWName":"<S74>/Out1","SIDString":"Final_project_template:2775"},{"RTWName":"<Root>/Can Network Inputs","SIDString":"Final_project_template:2094"},{"RTWName":"<S1>/Can Message Mailbox Setup","SIDString":"Final_project_template:2722"},{"RTWName":"<S1>/Extract CAN data","SIDString":"Final_project_template:2589"},{"RTWName":"<S6>/Data to s,n,psi,us ","SIDString":"Final_project_template:2594"},{"RTWName":"<S7>/Switch Case Action\nSubsystem2","SIDString":"Final_project_template:2601"},{"RTWName":"<S7>/Switch Case Action\nSubsystem3","SIDString":"Final_project_template:2607"},{"RTWName":"<S6>/Data to s,n,psi,us 1","SIDString":"Final_project_template:2614"},{"RTWName":"<S8>/Switch Case Action\nSubsystem2","SIDString":"Final_project_template:2621"},{"RTWName":"<S8>/Switch Case Action\nSubsystem3","SIDString":"Final_project_template:2627"},{"RTWName":"<S6>/Data to s,n,psi,us 2","SIDString":"Final_project_template:2634"},{"RTWName":"<S9>/Switch Case Action\nSubsystem2","SIDString":"Final_project_template:2641"},{"RTWName":"<S9>/Switch Case Action\nSubsystem3","SIDString":"Final_project_template:2647"},{"RTWName":"<S6>/Data to s,n,psi,us 3","SIDString":"Final_project_template:2654"},{"RTWName":"<S10>/Switch Case Action\nSubsystem2","SIDString":"Final_project_template:2661"},{"RTWName":"<S10>/Switch Case Action\nSubsystem3","SIDString":"Final_project_template:2667"},{"RTWName":"<S6>/Data to s,n,psi,us 4","SIDString":"Final_project_template:2674"},{"RTWName":"<S11>/Switch Case Action\nSubsystem2","SIDString":"Final_project_template:2681"},{"RTWName":"<S11>/Switch Case Action\nSubsystem3","SIDString":"Final_project_template:2687"},{"RTWName":"<S6>/Data to s,n,psi,us 5","SIDString":"Final_project_template:2694"},{"RTWName":"<S12>/Switch Case Action\nSubsystem2","SIDString":"Final_project_template:2701"},{"RTWName":"<S12>/Switch Case Action\nSubsystem3","SIDString":"Final_project_template:2707"},{"RTWName":"<Root>/High Level Design","SIDString":"Final_project_template:3"},{"RTWName":"<S2>/ACC","SIDString":"Final_project_template:2790"},{"RTWName":"<S25>/ACC State Logic","SIDString":"Final_project_template:3175"},{"RTWName":"<S29>/Chart","SIDString":"Final_project_template:3179"},{"RTWName":"<S25>/Enabled\nSubsystem","SIDString":"Final_project_template:3220"},{"RTWName":"<S25>/Position Ctrl","SIDString":"Final_project_template:3158"},{"RTWName":"<S25>/Speed Ctrl","SIDString":"Final_project_template:3138"},{"RTWName":"<S32>/PI","SIDString":"Final_project_template:3143"},{"RTWName":"<S34>/My Discrete Integrator","SIDString":"Final_project_template:3147"},{"RTWName":"<S2>/Auto Steering","SIDString":"Final_project_template:2806"},{"RTWName":"<S2>/Inputs","SIDString":"Final_project_template:15"},{"RTWName":"<S26>/Select Speed (GPI 122-129)","SIDString":"Final_project_template:38"},{"RTWName":"<S26>/Throttle (Potentiometer)","SIDString":"Final_project_template:63"},{"RTWName":"<S26>/get wheel position","SIDString":"Final_project_template:461"},{"RTWName":"<S38>/Subsystem","SIDString":"Final_project_template:2884"},{"RTWName":"<S2>/Outputs","SIDString":"Final_project_template:24"},{"RTWName":"<S27>/Extract x,y,psi","SIDString":"Final_project_template:498"},{"RTWName":"<S40>/s,n to x,y","SIDString":"Final_project_template:1016"},{"RTWName":"<S27>/Extract x,y,psi (Cars 1 - 6)","SIDString":"Final_project_template:505"},{"RTWName":"<S41>/Extract x,y,psi","SIDString":"Final_project_template:508"},{"RTWName":"<S45>/s,n to x,y","SIDString":"Final_project_template:977"},{"RTWName":"<S41>/Extract x,y,psi1","SIDString":"Final_project_template:978"},{"RTWName":"<S46>/s,n to x,y","SIDString":"Final_project_template:983"},{"RTWName":"<S41>/Extract x,y,psi2","SIDString":"Final_project_template:985"},{"RTWName":"<S47>/s,n to x,y","SIDString":"Final_project_template:990"},{"RTWName":"<S41>/Extract x,y,psi3","SIDString":"Final_project_template:992"},{"RTWName":"<S48>/s,n to x,y","SIDString":"Final_project_template:997"},{"RTWName":"<S41>/Extract x,y,psi4","SIDString":"Final_project_template:999"},{"RTWName":"<S49>/s,n to x,y","SIDString":"Final_project_template:1004"},{"RTWName":"<S41>/Extract x,y,psi5","SIDString":"Final_project_template:1006"},{"RTWName":"<S50>/s,n to x,y","SIDString":"Final_project_template:1011"},{"RTWName":"<S27>/Tx CAN","SIDString":"Final_project_template:553"},{"RTWName":"<S27>/write torque","SIDString":"Final_project_template:483"},{"RTWName":"<S43>/Write_Reaction_Torque","SIDString":"Final_project_template:2905"},{"RTWName":"<S2>/Vehicle Dynamics","SIDString":"Final_project_template:2798"},{"RTWName":"<S28>/Vehicle Dynamics","SIDString":"Final_project_template:3029"},{"RTWName":"<S58>/Subsystem","SIDString":"Final_project_template:3033"},{"RTWName":"<S58>/Subsystem1","SIDString":"Final_project_template:3040"},{"RTWName":"<S58>/Subsystem2","SIDString":"Final_project_template:3048"},{"RTWName":"<S28>/outputs","SIDString":"Final_project_template:3087"},{"RTWName":"<S59>/coordinate transform","SIDString":"Final_project_template:3080"},{"RTWName":"<S63>/Look up Forward Vector","SIDString":"Final_project_template:3063"},{"RTWName":"<S63>/x,y to s,n","SIDString":"Final_project_template:3062"},{"RTWName":"<S66>/Data Type\nConversion\nInherited","SIDString":"Final_project_template:3062:27"},{"RTWName":"<S66>/Look up the Forward Vector","SIDString":"Final_project_template:3062:30"},{"RTWName":"<S66>/My Discrete Integrator","SIDString":"Final_project_template:3062:40"},{"RTWName":"<S66>/My Dot Product1","SIDString":"Final_project_template:3062:46"},{"RTWName":"<S66>/My Dot Product2","SIDString":"Final_project_template:3062:53"},{"RTWName":"<S59>/projected velocity","SIDString":"Final_project_template:3072"},{"RTWName":"<Root>/SC Filter","SIDString":"Final_project_template:2812"},{"RTWName":"<Root>/Serial Sim Out to Virtual Sim","SIDString":"Final_project_template:2747"},{"RTWName":"<S4>/Serial","SIDString":"Final_project_template:2753"},{"RTWName":"<S4>/UART Iteration","SIDString":"Final_project_template:2764"},{"RTWName":"<S73>/Resettable\nSubsystem","SIDString":"Final_project_template:2770"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};